(function(ns){
// Enqueue class
var enqueue = function(fn) {
	var queue = [], locked = 1, working = 0, fn = fn,
		instance = function(){
			queue.push([this, arguments]);
			if (!locked) instance.execute();
		};
		instance.execute = function(){
			if (working) return;
			working = 1; locked = 0;
			var q; while(q = queue.shift()) { fn.apply(q[0], q[1]) };
			working = 0;
		};
		instance.lock = function(){
			locked = 0;
		};
	return instance;
};

// Private variables
var $, options, components = {}, initialized = 0, installers = [];

var self = window[ns] = {

	setup: function(o) {
		options = o; // Keep a copy of the options
		self.init(); // Try to initialize.
	},

	jquery: function(jquery) {
		if ($) return; // If jquery is already available, stop.
		$ = jquery; // Set self.$ to jquery object
		self.init(); // Try to initialize.
	},

	init: function() {
		if (initialized) {
			return; // If initialized, stop.
		}

		if ($ && options) { // If options & jquery is available,
			self.$ = $.initialize(options); // Initialize jquery
			self.plugin.execute(); // Execute any pending plugins
			initialized = 1;
		}
	},

	plugin: enqueue(function(name, factory) {
		factory.apply(self, [$]);
	}),

	module: enqueue(function(name, factory) {
		$.module(name, factory);
	}),

	installer: function(recipient, name, factory) {
		if (!installers[recipient]) installers[recipient] = []; // Create package array if this is the first time
		if (!name) return installers[recipient];
		var component = components[recipient]; // Get component
		if (component.registered) return component.install(name, factory); // If component exist, install straight away
		installers[recipient].push([name, factory]); // Keep the package to install later
	},

	component: function(name, options) {

		// Getter
		if (!name) {
			return components; // return list of components
		}

		if (!options) {
			return components[name]; // return component
		}

		// Registering
		if (typeof options === "function") {
			var component = options;
			component.registered = true;
			return components[name] = component;
		}

		// Setter
		var queue = [];

		var abstractQueue = function(method, context, args) {
			return {method: method, context: this, args: args};
		};

		var abstractMethod = function(method, parent, chain) {
			return function(){
				(chain || queue).push(abstractQueue(method, this, arguments));
				return parent;
			};
		};

		var abstractInstance = function(instance, methods, chain) {
			var i = 0;
			for (; i < methods.length; i++) {
				var method = methods[i];
				instance[method] = abstractMethod(method, instance, chain);
			};
			return instance;
		};

		var abstractChain = function(name, methods) {
			return function(){
				var chain = [abstractQueue(name, this, arguments)];
					queue.push(chain);
				return abstractInstance({}, methods, chain);
			};
		};

		queue.execute = function(){
			var component = components[name], i = 0;
			for (; i < queue.length; i++) {
				var fn = queue[i];
				if (Object.prototype.toString.call(fn)==='[object Array]') {
					var chain = fn, context = component, j = 0;
					for (; j < chain.length; j++) {
						context = context[chain[j].method].apply(context, chain[j].args);
					}
				} else {
					component[fn.method].apply(component, fn.args)
				}
			}
		};

		// Create abstract component
		var component = abstractInstance(
				function(){component.run.apply(this.arguments)},
				["run","ready","template","dialog"]
			);

			// Set reference to options & queue
			component.className = name;
			component.options = options;
			component.queue = queue;

			// Create abstract module method
			component.module = abstractChain(
				"module",
				["done","always","fail","progress"]
			);

			// Create abstract require method
			component.require = abstractChain(
				"require",
				["library","script","stylesheet","language","template","app","view","done","always","fail","progress"]
			);

		// Register component in global namespace
		window[name] = components[name] = component;

		if (initialized) {
			$.Component.register(component);
		}

		return component;
	}
};

})("FD40");

// Setup foundry
FD40.setup({
	"environment": window.es.environment,
	"source": "local",
	"mode": window.es.environment == "production" ? "compressed" : "uncompressed",
	"path": window.es.rootUrl + "/media/com_easysocial/scripts/vendors",
	"cdn": "",
	"extension":".js",
	"cdnPath": "",
	"rootPath": window.es.rootUrl,
	"basePath": window.es.rootUrl,
	"indexUrl": window.es.rootUrl + '/index.php',
	"token": window.es.token,
	"joomla":{
		"appendTitle": window.es.appendTitle,
		"sitename": window.es.siteName
	},
	"locale":{
		"lang": window.es.locale
	}
});

FD40.component("EasySocial", {
	"environment": window.es.environment,
	"source":"local",
	"mode": window.es.environment == "production" ? "compressed" : "uncompressed",
	"mode": "compressed",
	"baseUrl": window.es.baseUrl,
	"version":"2.0",
	"momentLang": window.es.momentLang,
	"ajaxUrl": window.es.ajaxUrl
});

!function(a){var x,b=" ",c="width",d="height",e="replace",f="classList",g="className",h="parentNode",i="fit-width",j="fit-height",k="fit-both",l="fit-small",m=i+b+j+b+k+b+l,n=function(a,b){return a.getAttribute("data-"+b)},o=function(a,b){return a["natural"+b[0].toUpperCase()+b.slice(1)]},p=function(a,b){return parseInt(n(a,b)||o(a,b)||a[b])},q=function(a,c){a[f]?a[f].add(c):a[g]+=b+c},r=function(a,c){a[g]=a[g][e](new RegExp("\\b("+c[e](/\s+/g,"|")+")\\b","g"),b)[e](/\s+/g,b)[e](/^\s+|\s+$/g,"")},s=function(a,b,c){a.style[b]=c+"px"},u=function(a,b,e,f,g,t,v,x,y,z){return!n(a,c)&&0===o(a,c)&&(a._retry||(a._retry=0))<=25?setTimeout(function(){a._retry++,u(a)},200):(b=a[h],e=b[h],f=e[h],g=n(b,"mode"),t=n(b,"threshold"),v=p(a,c),x=p(a,d),y=b.offsetWidth,z=b.offsetHeight,r(f,m),q(f,t>v&&t>x?function(){return s(a,c,v),s(a,d,x),l}():"cover"==g?function(b,c,d){return 1>y||1>z?(w.push(a),k):(b=y/z,c=y/v,d=z/x,1>b?z>x*c?j:i:b>1?y>v*d?i:j:1==b?1>=v/x?i:j:void 0)}():function(){return w.push(a),a.style.maxHeight="none",s(a,"maxHeight",b.offsetHeight),k}()),a.removeAttribute("onload"),void 0)},v=function(a,b){for(b=w,w=[];a=b.shift();)a[h]&&u(a)},w=[],y=function(){clearTimeout(x),x=setTimeout(v,500)},z=a.ESImageList||[];for(a.ESImage=u,a.ESImageRefresh=v,a.addEventListener?a.addEventListener("resize",y,!1):a.attachEvent("resize",y);z.length;)u(z.shift())}(window);
/*!
 * jQuery JavaScript Library v1.11.1pre
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2015-09-04T08:47Z
 */

(function( global, factory ) {

    if ( typeof module === "object" && typeof module.exports === "object" ) {
        // For CommonJS and CommonJS-like environments where a proper window is present,
        // execute the factory and get jQuery
        // For environments that do not inherently posses a window with a document
        // (such as Node.js), expose a jQuery-making factory as module.exports
        // This accentuates the need for the creation of a real window
        // e.g. var jQuery = require("jquery")(window);
        // See ticket #14549 for more info
        module.exports = global.document ?
            factory( global, true ) :
            function( w ) {
                if ( !w.document ) {
                    throw new Error( "jQuery requires a window with a document" );
                }
                return factory( w );
            };
    } else {
        factory( global );
    }

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Can't do this because several apps including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
// Support: Firefox 18+
//

var deletedIds = [];

var slice = deletedIds.slice;

var concat = deletedIds.concat;

var push = deletedIds.push;

var indexOf = deletedIds.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var trim = "".trim;

var support = {};



var
    version = "1.11.1pre",

    // Define a local copy of jQuery
    jQuery = function( selector, context ) {
        // The jQuery object is actually just the init constructor 'enhanced'
        // Need init if jQuery is called (just allow error to be thrown if not included)
        return new jQuery.fn.init( selector, context );
    },

    // Make sure we trim BOM and NBSP (here's looking at you, Safari 5.0 and IE)
    rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

    // Matches dashed string for camelizing
    rmsPrefix = /^-ms-/,
    rdashAlpha = /-([\da-z])/gi,

    // Used by jQuery.camelCase as callback to replace()
    fcamelCase = function( all, letter ) {
        return letter.toUpperCase();
    };

jQuery.fn = jQuery.prototype = {
    // The current version of jQuery being used
    jquery: version,

    constructor: jQuery,

    // Start with an empty selector
    selector: "",

    // The default length of a jQuery object is 0
    length: 0,

    toArray: function() {
        return slice.call( this );
    },

    // Get the Nth element in the matched element set OR
    // Get the whole matched element set as a clean array
    get: function( num ) {
        return num != null ?

            // Return a 'clean' array
            ( num < 0 ? this[ num + this.length ] : this[ num ] ) :

            // Return just the object
            slice.call( this );
    },

    // Take an array of elements and push it onto the stack
    // (returning the new matched element set)
    pushStack: function( elems ) {

        // Build a new jQuery matched element set
        var ret = jQuery.merge( this.constructor(), elems );

        // Add the old object onto the stack (as a reference)
        ret.prevObject = this;
        ret.context = this.context;

        // Return the newly-formed element set
        return ret;
    },

    // Execute a callback for every element in the matched set.
    // (You can seed the arguments with an array of args, but this is
    // only used internally.)
    each: function( callback, args ) {
        return jQuery.each( this, callback, args );
    },

    map: function( callback ) {
        return this.pushStack( jQuery.map(this, function( elem, i ) {
            return callback.call( elem, i, elem );
        }));
    },

    slice: function() {
        return this.pushStack( slice.apply( this, arguments ) );
    },

    first: function() {
        return this.eq( 0 );
    },

    last: function() {
        return this.eq( -1 );
    },

    eq: function( i ) {
        var len = this.length,
            j = +i + ( i < 0 ? len : 0 );
        return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
    },

    end: function() {
        return this.prevObject || this.constructor(null);
    },

    // For internal use only.
    // Behaves like an Array's method, not like a jQuery method.
    push: push,
    sort: deletedIds.sort,
    splice: deletedIds.splice
};

jQuery.extend = jQuery.fn.extend = function() {
    var src, copyIsArray, copy, name, options, clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false;

    // Handle a deep copy situation
    if ( typeof target === "boolean" ) {
        deep = target;

        // skip the boolean and the target
        target = arguments[ i ] || {};
        i++;
    }

    // Handle case when target is a string or something (possible in deep copy)
    if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
        target = {};
    }

    // extend jQuery itself if only one argument is passed
    if ( i === length ) {
        target = this;
        i--;
    }

    for ( ; i < length; i++ ) {
        // Only deal with non-null/undefined values
        if ( (options = arguments[ i ]) != null ) {
            // Extend the base object
            for ( name in options ) {
                src = target[ name ];
                copy = options[ name ];

                // Prevent never-ending loop
                if ( target === copy ) {
                    continue;
                }

                // Recurse if we're merging plain objects or arrays
                if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
                    if ( copyIsArray ) {
                        copyIsArray = false;
                        clone = src && jQuery.isArray(src) ? src : [];

                    } else {
                        clone = src && jQuery.isPlainObject(src) ? src : {};
                    }

                    // Never move original objects, clone them
                    target[ name ] = jQuery.extend( deep, clone, copy );

                // Don't bring in undefined values
                } else if ( copy !== undefined ) {
                    target[ name ] = copy;
                }
            }
        }
    }

    // Return the modified object
    return target;
};

jQuery.extend({
    // Unique for each copy of jQuery on the page
    expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

    // Assume jQuery is ready without the ready module
    isReady: true,

    error: function( msg ) {
        throw new Error( msg );
    },

    noop: function() {},

    // See test/unit/core.js for details concerning isFunction.
    // Since version 1.3, DOM methods and functions like alert
    // aren't supported. They return false on IE (#2968).
    isFunction: function( obj ) {
        return jQuery.type(obj) === "function";
    },

    isArray: Array.isArray || function( obj ) {
        return jQuery.type(obj) === "array";
    },

    isWindow: function( obj ) {
        /* jshint eqeqeq: false */
        return obj != null && obj == obj.window;
    },

    isNumeric: function( obj ) {
        // parseFloat NaNs numeric-cast false positives (null|true|false|"")
        // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
        // subtraction forces infinities to NaN
        return obj - parseFloat( obj ) >= 0;
    },

    isEmptyObject: function( obj ) {
        var name;
        for ( name in obj ) {
            return false;
        }
        return true;
    },

    isPlainObject: function( obj ) {
        var key;

        // Must be an Object.
        // Because of IE, we also have to check the presence of the constructor property.
        // Make sure that DOM nodes and window objects don't pass through, as well
        if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
            return false;
        }

        try {
            // Not own constructor property must be Object
            if ( obj.constructor &&
                !hasOwn.call(obj, "constructor") &&
                !hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
                return false;
            }
        } catch ( e ) {
            // IE8,9 Will throw exceptions on certain host objects #9897
            return false;
        }

        // Support: IE<9
        // Handle iteration over inherited properties before own properties.
        if ( support.ownLast ) {
            for ( key in obj ) {
                return hasOwn.call( obj, key );
            }
        }

        // Own properties are enumerated firstly, so to speed up,
        // if last one is own, then all properties are own.
        for ( key in obj ) {}

        return key === undefined || hasOwn.call( obj, key );
    },

    type: function( obj ) {
        if ( obj == null ) {
            return obj + "";
        }
        return typeof obj === "object" || typeof obj === "function" ?
            class2type[ toString.call(obj) ] || "object" :
            typeof obj;
    },

    // Evaluates a script in a global context
    // Workarounds based on findings by Jim Driscoll
    // http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
    globalEval: function( data ) {
        if ( data && jQuery.trim( data ) ) {
            // We use execScript on Internet Explorer
            // We use an anonymous function so that context is window
            // rather than jQuery in Firefox
            ( window.execScript || function( data ) {
                window[ "eval" ].call( window, data );
            } )( data );
        }
    },

    // Convert dashed to camelCase; used by the css and data modules
    // Microsoft forgot to hump their vendor prefix (#9572)
    camelCase: function( string ) {
        return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
    },

    nodeName: function( elem, name ) {
        return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
    },

    // args is for internal usage only
    each: function( obj, callback, args ) {
        var value,
            i = 0,
            length = obj.length,
            isArray = isArraylike( obj );

        if ( args ) {
            if ( isArray ) {
                for ( ; i < length; i++ ) {
                    value = callback.apply( obj[ i ], args );

                    if ( value === false ) {
                        break;
                    }
                }
            } else {
                for ( i in obj ) {
                    value = callback.apply( obj[ i ], args );

                    if ( value === false ) {
                        break;
                    }
                }
            }

        // A special, fast, case for the most common use of each
        } else {
            if ( isArray ) {
                for ( ; i < length; i++ ) {
                    value = callback.call( obj[ i ], i, obj[ i ] );

                    if ( value === false ) {
                        break;
                    }
                }
            } else {
                for ( i in obj ) {
                    value = callback.call( obj[ i ], i, obj[ i ] );

                    if ( value === false ) {
                        break;
                    }
                }
            }
        }

        return obj;
    },

    // Use native String.trim function wherever possible
    trim: trim && !trim.call("\uFEFF\xA0") ?
        function( text ) {
            return text == null ?
                "" :
                trim.call( text );
        } :

        // Otherwise use our own trimming functionality
        function( text ) {
            return text == null ?
                "" :
                ( text + "" ).replace( rtrim, "" );
        },

    // results is for internal usage only
    makeArray: function( arr, results ) {
        var ret = results || [];

        if ( arr != null ) {
            if ( isArraylike( Object(arr) ) ) {
                jQuery.merge( ret,
                    typeof arr === "string" ?
                    [ arr ] : arr
                );
            } else {
                push.call( ret, arr );
            }
        }

        return ret;
    },

    inArray: function( elem, arr, i ) {
        var len;

        if ( arr ) {
            if ( indexOf ) {
                return indexOf.call( arr, elem, i );
            }

            len = arr.length;
            i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

            for ( ; i < len; i++ ) {
                // Skip accessing in sparse arrays
                if ( i in arr && arr[ i ] === elem ) {
                    return i;
                }
            }
        }

        return -1;
    },

    merge: function( first, second ) {
        var len = +second.length,
            j = 0,
            i = first.length;

        while ( j < len ) {
            first[ i++ ] = second[ j++ ];
        }

        // Support: IE<9
        // Workaround casting of .length to NaN on otherwise arraylike objects (e.g., NodeLists)
        if ( len !== len ) {
            while ( second[j] !== undefined ) {
                first[ i++ ] = second[ j++ ];
            }
        }

        first.length = i;

        return first;
    },

    grep: function( elems, callback, invert ) {
        var callbackInverse,
            matches = [],
            i = 0,
            length = elems.length,
            callbackExpect = !invert;

        // Go through the array, only saving the items
        // that pass the validator function
        for ( ; i < length; i++ ) {
            callbackInverse = !callback( elems[ i ], i );
            if ( callbackInverse !== callbackExpect ) {
                matches.push( elems[ i ] );
            }
        }

        return matches;
    },

    // arg is for internal usage only
    map: function( elems, callback, arg ) {
        var value,
            i = 0,
            length = elems.length,
            isArray = isArraylike( elems ),
            ret = [];

        // Go through the array, translating each of the items to their new values
        if ( isArray ) {
            for ( ; i < length; i++ ) {
                value = callback( elems[ i ], i, arg );

                if ( value != null ) {
                    ret.push( value );
                }
            }

        // Go through every key on the object,
        } else {
            for ( i in elems ) {
                value = callback( elems[ i ], i, arg );

                if ( value != null ) {
                    ret.push( value );
                }
            }
        }

        // Flatten any nested arrays
        return concat.apply( [], ret );
    },

    // A global GUID counter for objects
    guid: 1,

    // Bind a function to a context, optionally partially applying any
    // arguments.
    proxy: function( fn, context ) {
        var args, proxy, tmp;

        if ( typeof context === "string" ) {
            tmp = fn[ context ];
            context = fn;
            fn = tmp;
        }

        // Quick check to determine if target is callable, in the spec
        // this throws a TypeError, but we will just return undefined.
        if ( !jQuery.isFunction( fn ) ) {
            return undefined;
        }

        // Simulated bind
        args = slice.call( arguments, 2 );
        proxy = function() {
            return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
        };

        // Set the guid of unique handler to the same of original handler, so it can be removed
        proxy.guid = fn.guid = fn.guid || jQuery.guid++;

        return proxy;
    },

    now: function() {
        return +( new Date() );
    },

    // jQuery.support is not used in Core but other projects attach their
    // properties to it so it needs to exist.
    support: support
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
    class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

function isArraylike( obj ) {
    var length = obj.length,
        type = jQuery.type( obj );

    if ( type === "function" || jQuery.isWindow( obj ) ) {
        return false;
    }

    if ( obj.nodeType === 1 && length ) {
        return true;
    }

    return type === "array" || length === 0 ||
        typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v1.10.18
 * http://sizzlejs.com/
 *
 * Copyright 2013 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-02-05
 */
(function( window ) {

var i,
    support,
    Expr,
    getText,
    isXML,
    compile,
    select,
    outermostContext,
    sortInput,
    hasDuplicate,

    // Local document vars
    setDocument,
    document,
    docElem,
    documentIsHTML,
    rbuggyQSA,
    rbuggyMatches,
    matches,
    contains,

    // Instance-specific data
    expando = "sizzle" + -(new Date()),
    preferredDoc = window.document,
    dirruns = 0,
    done = 0,
    classCache = createCache(),
    tokenCache = createCache(),
    compilerCache = createCache(),
    sortOrder = function( a, b ) {
        if ( a === b ) {
            hasDuplicate = true;
        }
        return 0;
    },

    // General-purpose constants
    strundefined = typeof undefined,
    MAX_NEGATIVE = 1 << 31,

    // Instance methods
    hasOwn = ({}).hasOwnProperty,
    arr = [],
    pop = arr.pop,
    push_native = arr.push,
    push = arr.push,
    slice = arr.slice,
    // Use a stripped-down indexOf if we can't use a native one
    indexOf = arr.indexOf || function( elem ) {
        var i = 0,
            len = this.length;
        for ( ; i < len; i++ ) {
            if ( this[i] === elem ) {
                return i;
            }
        }
        return -1;
    },

    booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

    // Regular expressions

    // Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
    whitespace = "[\\x20\\t\\r\\n\\f]",
    // http://www.w3.org/TR/css3-syntax/#characters
    characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

    // Loosely modeled on CSS identifier characters
    // An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
    // Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
    identifier = characterEncoding.replace( "w", "w#" ),

    // Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors
    attributes = "\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace +
        "*(?:([*^$|!~]?=)" + whitespace + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + identifier + ")|)|)" + whitespace + "*\\]",

    // Prefer arguments quoted,
    //   then not containing pseudos/brackets,
    //   then attribute selectors/non-parenthetical expressions,
    //   then anything else
    // These preferences are here to reduce the number of selectors
    //   needing tokenize in the PSEUDO preFilter
    pseudos = ":(" + characterEncoding + ")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|" + attributes.replace( 3, 8 ) + ")*)|.*)\\)|)",

    // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
    rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

    rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
    rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

    rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

    rpseudo = new RegExp( pseudos ),
    ridentifier = new RegExp( "^" + identifier + "$" ),

    matchExpr = {
        "ID": new RegExp( "^#(" + characterEncoding + ")" ),
        "CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
        "TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
        "ATTR": new RegExp( "^" + attributes ),
        "PSEUDO": new RegExp( "^" + pseudos ),
        "CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
            "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
            "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
        "bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
        // For use in libraries implementing .is()
        // We use this for POS matching in `select`
        "needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
            whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
    },

    rinputs = /^(?:input|select|textarea|button)$/i,
    rheader = /^h\d$/i,

    rnative = /^[^{]+\{\s*\[native \w/,

    // Easily-parseable/retrievable ID or TAG or CLASS selectors
    rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

    rsibling = /[+~]/,
    rescape = /'|\\/g,

    // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
    runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
    funescape = function( _, escaped, escapedWhitespace ) {
        var high = "0x" + escaped - 0x10000;
        // NaN means non-codepoint
        // Support: Firefox<24
        // Workaround erroneous numeric interpretation of +"0x"
        return high !== high || escapedWhitespace ?
            escaped :
            high < 0 ?
                // BMP codepoint
                String.fromCharCode( high + 0x10000 ) :
                // Supplemental Plane codepoint (surrogate pair)
                String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
    };

// Optimize for push.apply( _, NodeList )
try {
    push.apply(
        (arr = slice.call( preferredDoc.childNodes )),
        preferredDoc.childNodes
    );
    // Support: Android<4.0
    // Detect silently failing push.apply
    arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
    push = { apply: arr.length ?

        // Leverage slice if possible
        function( target, els ) {
            push_native.apply( target, slice.call(els) );
        } :

        // Support: IE<9
        // Otherwise append directly
        function( target, els ) {
            var j = target.length,
                i = 0;
            // Can't trust NodeList.length
            while ( (target[j++] = els[i++]) ) {}
            target.length = j - 1;
        }
    };
}

function Sizzle( selector, context, results, seed ) {
    var match, elem, m, nodeType,
        // QSA vars
        i, groups, old, nid, newContext, newSelector;

    if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
        setDocument( context );
    }

    context = context || document;
    results = results || [];

    if ( !selector || typeof selector !== "string" ) {
        return results;
    }

    if ( (nodeType = context.nodeType) !== 1 && nodeType !== 9 ) {
        return [];
    }

    if ( documentIsHTML && !seed ) {

        // Shortcuts
        if ( (match = rquickExpr.exec( selector )) ) {
            // Speed-up: Sizzle("#ID")
            if ( (m = match[1]) ) {
                if ( nodeType === 9 ) {
                    elem = context.getElementById( m );
                    // Check parentNode to catch when Blackberry 4.6 returns
                    // nodes that are no longer in the document (jQuery #6963)
                    if ( elem && elem.parentNode ) {
                        // Handle the case where IE, Opera, and Webkit return items
                        // by name instead of ID
                        if ( elem.id === m ) {
                            results.push( elem );
                            return results;
                        }
                    } else {
                        return results;
                    }
                } else {
                    // Context is not a document
                    if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
                        contains( context, elem ) && elem.id === m ) {
                        results.push( elem );
                        return results;
                    }
                }

            // Speed-up: Sizzle("TAG")
            } else if ( match[2] ) {
                push.apply( results, context.getElementsByTagName( selector ) );
                return results;

            // Speed-up: Sizzle(".CLASS")
            } else if ( (m = match[3]) && support.getElementsByClassName && context.getElementsByClassName ) {
                push.apply( results, context.getElementsByClassName( m ) );
                return results;
            }
        }

        // QSA path
        if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
            nid = old = expando;
            newContext = context;
            newSelector = nodeType === 9 && selector;

            // qSA works strangely on Element-rooted queries
            // We can work around this by specifying an extra ID on the root
            // and working up from there (Thanks to Andrew Dupont for the technique)
            // IE 8 doesn't work on object elements
            if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
                groups = tokenize( selector );

                if ( (old = context.getAttribute("id")) ) {
                    nid = old.replace( rescape, "\\$&" );
                } else {
                    context.setAttribute( "id", nid );
                }
                nid = "[id='" + nid + "'] ";

                i = groups.length;
                while ( i-- ) {
                    groups[i] = nid + toSelector( groups[i] );
                }
                newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
                newSelector = groups.join(",");
            }

            if ( newSelector ) {
                try {
                    push.apply( results,
                        newContext.querySelectorAll( newSelector )
                    );
                    return results;
                } catch(qsaError) {
                } finally {
                    if ( !old ) {
                        context.removeAttribute("id");
                    }
                }
            }
        }
    }

    // All others
    return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
 *  property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *  deleting the oldest entry
 */
function createCache() {
    var keys = [];

    function cache( key, value ) {
        // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
        if ( keys.push( key + " " ) > Expr.cacheLength ) {
            // Only keep the most recent entries
            delete cache[ keys.shift() ];
        }
        return (cache[ key + " " ] = value);
    }
    return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
    fn[ expando ] = true;
    return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
    var div = document.createElement("div");

    try {
        return !!fn( div );
    } catch (e) {
        return false;
    } finally {
        // Remove from its parent by default
        if ( div.parentNode ) {
            div.parentNode.removeChild( div );
        }
        // release memory in IE
        div = null;
    }
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
    var arr = attrs.split("|"),
        i = attrs.length;

    while ( i-- ) {
        Expr.attrHandle[ arr[i] ] = handler;
    }
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
    var cur = b && a,
        diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
            ( ~b.sourceIndex || MAX_NEGATIVE ) -
            ( ~a.sourceIndex || MAX_NEGATIVE );

    // Use IE sourceIndex if available on both nodes
    if ( diff ) {
        return diff;
    }

    // Check if b follows a
    if ( cur ) {
        while ( (cur = cur.nextSibling) ) {
            if ( cur === b ) {
                return -1;
            }
        }
    }

    return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
    return function( elem ) {
        var name = elem.nodeName.toLowerCase();
        return name === "input" && elem.type === type;
    };
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
    return function( elem ) {
        var name = elem.nodeName.toLowerCase();
        return (name === "input" || name === "button") && elem.type === type;
    };
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
    return markFunction(function( argument ) {
        argument = +argument;
        return markFunction(function( seed, matches ) {
            var j,
                matchIndexes = fn( [], seed.length, argument ),
                i = matchIndexes.length;

            // Match elements found at the specified indexes
            while ( i-- ) {
                if ( seed[ (j = matchIndexes[i]) ] ) {
                    seed[j] = !(matches[j] = seed[j]);
                }
            }
        });
    });
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
    return context && typeof context.getElementsByTagName !== strundefined && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
    // documentElement is verified for cases where it doesn't yet exist
    // (such as loading iframes in IE - #4833)
    var documentElement = elem && (elem.ownerDocument || elem).documentElement;
    return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
    var hasCompare,
        doc = node ? node.ownerDocument || node : preferredDoc,
        parent = doc.defaultView;

    // If no document and documentElement is available, return
    if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
        return document;
    }

    // Set our document
    document = doc;
    docElem = doc.documentElement;

    // Support tests
    documentIsHTML = !isXML( doc );

    // Support: IE>8
    // If iframe document is assigned to "document" variable and if iframe has been reloaded,
    // IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
    // IE6-8 do not support the defaultView property so parent will be undefined
    if ( parent && parent !== parent.top ) {
        // IE11 does not have attachEvent, so all must suffer
        if ( parent.addEventListener ) {
            parent.addEventListener( "unload", function() {
                setDocument();
            }, false );
        } else if ( parent.attachEvent ) {
            parent.attachEvent( "onunload", function() {
                setDocument();
            });
        }
    }

    /* Attributes
    ---------------------------------------------------------------------- */

    // Support: IE<8
    // Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)
    support.attributes = assert(function( div ) {
        div.className = "i";
        return !div.getAttribute("className");
    });

    /* getElement(s)By*
    ---------------------------------------------------------------------- */

    // Check if getElementsByTagName("*") returns only elements
    support.getElementsByTagName = assert(function( div ) {
        div.appendChild( doc.createComment("") );
        return !div.getElementsByTagName("*").length;
    });

    // Check if getElementsByClassName can be trusted
    support.getElementsByClassName = rnative.test( doc.getElementsByClassName ) && assert(function( div ) {
        div.innerHTML = "<div class='a'></div><div class='a i'></div>";

        // Support: Safari<4
        // Catch class over-caching
        div.firstChild.className = "i";
        // Support: Opera<10
        // Catch gEBCN failure to find non-leading classes
        return div.getElementsByClassName("i").length === 2;
    });

    // Support: IE<10
    // Check if getElementById returns elements by name
    // The broken getElementById methods don't pick up programatically-set names,
    // so use a roundabout getElementsByName test
    support.getById = assert(function( div ) {
        docElem.appendChild( div ).id = expando;
        return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
    });

    // ID find and filter
    if ( support.getById ) {
        Expr.find["ID"] = function( id, context ) {
            if ( typeof context.getElementById !== strundefined && documentIsHTML ) {
                var m = context.getElementById( id );
                // Check parentNode to catch when Blackberry 4.6 returns
                // nodes that are no longer in the document #6963
                return m && m.parentNode ? [m] : [];
            }
        };
        Expr.filter["ID"] = function( id ) {
            var attrId = id.replace( runescape, funescape );
            return function( elem ) {
                return elem.getAttribute("id") === attrId;
            };
        };
    } else {
        // Support: IE6/7
        // getElementById is not reliable as a find shortcut
        delete Expr.find["ID"];

        Expr.filter["ID"] =  function( id ) {
            var attrId = id.replace( runescape, funescape );
            return function( elem ) {
                var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
                return node && node.value === attrId;
            };
        };
    }

    // Tag
    Expr.find["TAG"] = support.getElementsByTagName ?
        function( tag, context ) {
            if ( typeof context.getElementsByTagName !== strundefined ) {
                return context.getElementsByTagName( tag );
            }
        } :
        function( tag, context ) {
            var elem,
                tmp = [],
                i = 0,
                results = context.getElementsByTagName( tag );

            // Filter out possible comments
            if ( tag === "*" ) {
                while ( (elem = results[i++]) ) {
                    if ( elem.nodeType === 1 ) {
                        tmp.push( elem );
                    }
                }

                return tmp;
            }
            return results;
        };

    // Class
    Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
        if ( typeof context.getElementsByClassName !== strundefined && documentIsHTML ) {
            return context.getElementsByClassName( className );
        }
    };

    /* QSA/matchesSelector
    ---------------------------------------------------------------------- */

    // QSA and matchesSelector support

    // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
    rbuggyMatches = [];

    // qSa(:focus) reports false when true (Chrome 21)
    // We allow this because of a bug in IE8/9 that throws an error
    // whenever `document.activeElement` is accessed on an iframe
    // So, we allow :focus to pass through QSA all the time to avoid the IE error
    // See http://bugs.jquery.com/ticket/13378
    rbuggyQSA = [];

    if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
        // Build QSA regex
        // Regex strategy adopted from Diego Perini
        assert(function( div ) {
            // Select is set to empty string on purpose
            // This is to test IE's treatment of not explicitly
            // setting a boolean content attribute,
            // since its presence should be enough
            // http://bugs.jquery.com/ticket/12359
            div.innerHTML = "<select t=''><option selected=''></option></select>";

            // Support: IE8, Opera 10-12
            // Nothing should be selected when empty strings follow ^= or $= or *=
            if ( div.querySelectorAll("[t^='']").length ) {
                rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
            }

            // Support: IE8
            // Boolean attributes and "value" are not treated correctly
            if ( !div.querySelectorAll("[selected]").length ) {
                rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
            }

            // Webkit/Opera - :checked should return selected option elements
            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
            // IE8 throws error here and will not see later tests
            if ( !div.querySelectorAll(":checked").length ) {
                rbuggyQSA.push(":checked");
            }
        });

        assert(function( div ) {
            // Support: Windows 8 Native Apps
            // The type and name attributes are restricted during .innerHTML assignment
            var input = doc.createElement("input");
            input.setAttribute( "type", "hidden" );
            div.appendChild( input ).setAttribute( "name", "D" );

            // Support: IE8
            // Enforce case-sensitivity of name attribute
            if ( div.querySelectorAll("[name=d]").length ) {
                rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
            }

            // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
            // IE8 throws error here and will not see later tests
            if ( !div.querySelectorAll(":enabled").length ) {
                rbuggyQSA.push( ":enabled", ":disabled" );
            }

            // Opera 10-11 does not throw on post-comma invalid pseudos
            div.querySelectorAll("*,:x");
            rbuggyQSA.push(",.*:");
        });
    }

    if ( (support.matchesSelector = rnative.test( (matches = docElem.webkitMatchesSelector ||
        docElem.mozMatchesSelector ||
        docElem.oMatchesSelector ||
        docElem.msMatchesSelector) )) ) {

        assert(function( div ) {
            // Check to see if it's possible to do matchesSelector
            // on a disconnected node (IE 9)
            support.disconnectedMatch = matches.call( div, "div" );

            // This should fail with an exception
            // Gecko does not error, returns false instead
            matches.call( div, "[s!='']:x" );
            rbuggyMatches.push( "!=", pseudos );
        });
    }

    rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
    rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

    /* Contains
    ---------------------------------------------------------------------- */
    hasCompare = rnative.test( docElem.compareDocumentPosition );

    // Element contains another
    // Purposefully does not implement inclusive descendent
    // As in, an element does not contain itself
    contains = hasCompare || rnative.test( docElem.contains ) ?
        function( a, b ) {
            var adown = a.nodeType === 9 ? a.documentElement : a,
                bup = b && b.parentNode;
            return a === bup || !!( bup && bup.nodeType === 1 && (
                adown.contains ?
                    adown.contains( bup ) :
                    a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
            ));
        } :
        function( a, b ) {
            if ( b ) {
                while ( (b = b.parentNode) ) {
                    if ( b === a ) {
                        return true;
                    }
                }
            }
            return false;
        };

    /* Sorting
    ---------------------------------------------------------------------- */

    // Document order sorting
    sortOrder = hasCompare ?
    function( a, b ) {

        // Flag for duplicate removal
        if ( a === b ) {
            hasDuplicate = true;
            return 0;
        }

        // Sort on method existence if only one input has compareDocumentPosition
        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
        if ( compare ) {
            return compare;
        }

        // Calculate position if both inputs belong to the same document
        compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
            a.compareDocumentPosition( b ) :

            // Otherwise we know they are disconnected
            1;

        // Disconnected nodes
        if ( compare & 1 ||
            (!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

            // Choose the first element that is related to our preferred document
            if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
                return -1;
            }
            if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
                return 1;
            }

            // Maintain original order
            return sortInput ?
                ( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
                0;
        }

        return compare & 4 ? -1 : 1;
    } :
    function( a, b ) {
        // Exit early if the nodes are identical
        if ( a === b ) {
            hasDuplicate = true;
            return 0;
        }

        var cur,
            i = 0,
            aup = a.parentNode,
            bup = b.parentNode,
            ap = [ a ],
            bp = [ b ];

        // Parentless nodes are either documents or disconnected
        if ( !aup || !bup ) {
            return a === doc ? -1 :
                b === doc ? 1 :
                aup ? -1 :
                bup ? 1 :
                sortInput ?
                ( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
                0;

        // If the nodes are siblings, we can do a quick check
        } else if ( aup === bup ) {
            return siblingCheck( a, b );
        }

        // Otherwise we need full lists of their ancestors for comparison
        cur = a;
        while ( (cur = cur.parentNode) ) {
            ap.unshift( cur );
        }
        cur = b;
        while ( (cur = cur.parentNode) ) {
            bp.unshift( cur );
        }

        // Walk down the tree looking for a discrepancy
        while ( ap[i] === bp[i] ) {
            i++;
        }

        return i ?
            // Do a sibling check if the nodes have a common ancestor
            siblingCheck( ap[i], bp[i] ) :

            // Otherwise nodes in our document sort first
            ap[i] === preferredDoc ? -1 :
            bp[i] === preferredDoc ? 1 :
            0;
    };

    return doc;
};

Sizzle.matches = function( expr, elements ) {
    return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
    // Set document vars if needed
    if ( ( elem.ownerDocument || elem ) !== document ) {
        setDocument( elem );
    }

    // Make sure that attribute selectors are quoted
    expr = expr.replace( rattributeQuotes, "='$1']" );

    if ( support.matchesSelector && documentIsHTML &&
        ( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
        ( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

        try {
            var ret = matches.call( elem, expr );

            // IE 9's matchesSelector returns false on disconnected nodes
            if ( ret || support.disconnectedMatch ||
                    // As well, disconnected nodes are said to be in a document
                    // fragment in IE 9
                    elem.document && elem.document.nodeType !== 11 ) {
                return ret;
            }
        } catch(e) {}
    }

    return Sizzle( expr, document, null, [elem] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
    // Set document vars if needed
    if ( ( context.ownerDocument || context ) !== document ) {
        setDocument( context );
    }
    return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
    // Set document vars if needed
    if ( ( elem.ownerDocument || elem ) !== document ) {
        setDocument( elem );
    }

    var fn = Expr.attrHandle[ name.toLowerCase() ],
        // Don't get fooled by Object.prototype properties (jQuery #13807)
        val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
            fn( elem, name, !documentIsHTML ) :
            undefined;

    return val !== undefined ?
        val :
        support.attributes || !documentIsHTML ?
            elem.getAttribute( name ) :
            (val = elem.getAttributeNode(name)) && val.specified ?
                val.value :
                null;
};

Sizzle.error = function( msg ) {
    throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
    var elem,
        duplicates = [],
        j = 0,
        i = 0;

    // Unless we *know* we can detect duplicates, assume their presence
    hasDuplicate = !support.detectDuplicates;
    sortInput = !support.sortStable && results.slice( 0 );
    results.sort( sortOrder );

    if ( hasDuplicate ) {
        while ( (elem = results[i++]) ) {
            if ( elem === results[ i ] ) {
                j = duplicates.push( i );
            }
        }
        while ( j-- ) {
            results.splice( duplicates[ j ], 1 );
        }
    }

    // Clear input after sorting to release objects
    // See https://github.com/jquery/sizzle/pull/225
    sortInput = null;

    return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
    var node,
        ret = "",
        i = 0,
        nodeType = elem.nodeType;

    if ( !nodeType ) {
        // If no nodeType, this is expected to be an array
        while ( (node = elem[i++]) ) {
            // Do not traverse comment nodes
            ret += getText( node );
        }
    } else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
        // Use textContent for elements
        // innerText usage removed for consistency of new lines (jQuery #11153)
        if ( typeof elem.textContent === "string" ) {
            return elem.textContent;
        } else {
            // Traverse its children
            for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
                ret += getText( elem );
            }
        }
    } else if ( nodeType === 3 || nodeType === 4 ) {
        return elem.nodeValue;
    }
    // Do not include comment or processing instruction nodes

    return ret;
};

Expr = Sizzle.selectors = {

    // Can be adjusted by the user
    cacheLength: 50,

    createPseudo: markFunction,

    match: matchExpr,

    attrHandle: {},

    find: {},

    relative: {
        ">": { dir: "parentNode", first: true },
        " ": { dir: "parentNode" },
        "+": { dir: "previousSibling", first: true },
        "~": { dir: "previousSibling" }
    },

    preFilter: {
        "ATTR": function( match ) {
            match[1] = match[1].replace( runescape, funescape );

            // Move the given value to match[3] whether quoted or unquoted
            match[3] = ( match[4] || match[5] || "" ).replace( runescape, funescape );

            if ( match[2] === "~=" ) {
                match[3] = " " + match[3] + " ";
            }

            return match.slice( 0, 4 );
        },

        "CHILD": function( match ) {
            /* matches from matchExpr["CHILD"]
                1 type (only|nth|...)
                2 what (child|of-type)
                3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
                4 xn-component of xn+y argument ([+-]?\d*n|)
                5 sign of xn-component
                6 x of xn-component
                7 sign of y-component
                8 y of y-component
            */
            match[1] = match[1].toLowerCase();

            if ( match[1].slice( 0, 3 ) === "nth" ) {
                // nth-* requires argument
                if ( !match[3] ) {
                    Sizzle.error( match[0] );
                }

                // numeric x and y parameters for Expr.filter.CHILD
                // remember that false/true cast respectively to 0/1
                match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
                match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

            // other types prohibit arguments
            } else if ( match[3] ) {
                Sizzle.error( match[0] );
            }

            return match;
        },

        "PSEUDO": function( match ) {
            var excess,
                unquoted = !match[5] && match[2];

            if ( matchExpr["CHILD"].test( match[0] ) ) {
                return null;
            }

            // Accept quoted arguments as-is
            if ( match[3] && match[4] !== undefined ) {
                match[2] = match[4];

            // Strip excess characters from unquoted arguments
            } else if ( unquoted && rpseudo.test( unquoted ) &&
                // Get excess from tokenize (recursively)
                (excess = tokenize( unquoted, true )) &&
                // advance to the next closing parenthesis
                (excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

                // excess is a negative index
                match[0] = match[0].slice( 0, excess );
                match[2] = unquoted.slice( 0, excess );
            }

            // Return only captures needed by the pseudo filter method (type and argument)
            return match.slice( 0, 3 );
        }
    },

    filter: {

        "TAG": function( nodeNameSelector ) {
            var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
            return nodeNameSelector === "*" ?
                function() { return true; } :
                function( elem ) {
                    return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                };
        },

        "CLASS": function( className ) {
            var pattern = classCache[ className + " " ];

            return pattern ||
                (pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
                classCache( className, function( elem ) {
                    return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "" );
                });
        },

        "ATTR": function( name, operator, check ) {
            return function( elem ) {
                var result = Sizzle.attr( elem, name );

                if ( result == null ) {
                    return operator === "!=";
                }
                if ( !operator ) {
                    return true;
                }

                result += "";

                return operator === "=" ? result === check :
                    operator === "!=" ? result !== check :
                    operator === "^=" ? check && result.indexOf( check ) === 0 :
                    operator === "*=" ? check && result.indexOf( check ) > -1 :
                    operator === "$=" ? check && result.slice( -check.length ) === check :
                    operator === "~=" ? ( " " + result + " " ).indexOf( check ) > -1 :
                    operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
                    false;
            };
        },

        "CHILD": function( type, what, argument, first, last ) {
            var simple = type.slice( 0, 3 ) !== "nth",
                forward = type.slice( -4 ) !== "last",
                ofType = what === "of-type";

            return first === 1 && last === 0 ?

                // Shortcut for :nth-*(n)
                function( elem ) {
                    return !!elem.parentNode;
                } :

                function( elem, context, xml ) {
                    var cache, outerCache, node, diff, nodeIndex, start,
                        dir = simple !== forward ? "nextSibling" : "previousSibling",
                        parent = elem.parentNode,
                        name = ofType && elem.nodeName.toLowerCase(),
                        useCache = !xml && !ofType;

                    if ( parent ) {

                        // :(first|last|only)-(child|of-type)
                        if ( simple ) {
                            while ( dir ) {
                                node = elem;
                                while ( (node = node[ dir ]) ) {
                                    if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
                                        return false;
                                    }
                                }
                                // Reverse direction for :only-* (if we haven't yet done so)
                                start = dir = type === "only" && !start && "nextSibling";
                            }
                            return true;
                        }

                        start = [ forward ? parent.firstChild : parent.lastChild ];

                        // non-xml :nth-child(...) stores cache data on `parent`
                        if ( forward && useCache ) {
                            // Seek `elem` from a previously-cached index
                            outerCache = parent[ expando ] || (parent[ expando ] = {});
                            cache = outerCache[ type ] || [];
                            nodeIndex = cache[0] === dirruns && cache[1];
                            diff = cache[0] === dirruns && cache[2];
                            node = nodeIndex && parent.childNodes[ nodeIndex ];

                            while ( (node = ++nodeIndex && node && node[ dir ] ||

                                // Fallback to seeking `elem` from the start
                                (diff = nodeIndex = 0) || start.pop()) ) {

                                // When found, cache indexes on `parent` and break
                                if ( node.nodeType === 1 && ++diff && node === elem ) {
                                    outerCache[ type ] = [ dirruns, nodeIndex, diff ];
                                    break;
                                }
                            }

                        // Use previously-cached element index if available
                        } else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
                            diff = cache[1];

                        // xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
                        } else {
                            // Use the same loop as above to seek `elem` from the start
                            while ( (node = ++nodeIndex && node && node[ dir ] ||
                                (diff = nodeIndex = 0) || start.pop()) ) {

                                if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
                                    // Cache the index of each encountered element
                                    if ( useCache ) {
                                        (node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
                                    }

                                    if ( node === elem ) {
                                        break;
                                    }
                                }
                            }
                        }

                        // Incorporate the offset, then check against cycle size
                        diff -= last;
                        return diff === first || ( diff % first === 0 && diff / first >= 0 );
                    }
                };
        },

        "PSEUDO": function( pseudo, argument ) {
            // pseudo-class names are case-insensitive
            // http://www.w3.org/TR/selectors/#pseudo-classes
            // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
            // Remember that setFilters inherits from pseudos
            var args,
                fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
                    Sizzle.error( "unsupported pseudo: " + pseudo );

            // The user may use createPseudo to indicate that
            // arguments are needed to create the filter function
            // just as Sizzle does
            if ( fn[ expando ] ) {
                return fn( argument );
            }

            // But maintain support for old signatures
            if ( fn.length > 1 ) {
                args = [ pseudo, pseudo, "", argument ];
                return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
                    markFunction(function( seed, matches ) {
                        var idx,
                            matched = fn( seed, argument ),
                            i = matched.length;
                        while ( i-- ) {
                            idx = indexOf.call( seed, matched[i] );
                            seed[ idx ] = !( matches[ idx ] = matched[i] );
                        }
                    }) :
                    function( elem ) {
                        return fn( elem, 0, args );
                    };
            }

            return fn;
        }
    },

    pseudos: {
        // Potentially complex pseudos
        "not": markFunction(function( selector ) {
            // Trim the selector passed to compile
            // to avoid treating leading and trailing
            // spaces as combinators
            var input = [],
                results = [],
                matcher = compile( selector.replace( rtrim, "$1" ) );

            return matcher[ expando ] ?
                markFunction(function( seed, matches, context, xml ) {
                    var elem,
                        unmatched = matcher( seed, null, xml, [] ),
                        i = seed.length;

                    // Match elements unmatched by `matcher`
                    while ( i-- ) {
                        if ( (elem = unmatched[i]) ) {
                            seed[i] = !(matches[i] = elem);
                        }
                    }
                }) :
                function( elem, context, xml ) {
                    input[0] = elem;
                    matcher( input, null, xml, results );
                    return !results.pop();
                };
        }),

        "has": markFunction(function( selector ) {
            return function( elem ) {
                return Sizzle( selector, elem ).length > 0;
            };
        }),

        "contains": markFunction(function( text ) {
            return function( elem ) {
                return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
            };
        }),

        // "Whether an element is represented by a :lang() selector
        // is based solely on the element's language value
        // being equal to the identifier C,
        // or beginning with the identifier C immediately followed by "-".
        // The matching of C against the element's language value is performed case-insensitively.
        // The identifier C does not have to be a valid language name."
        // http://www.w3.org/TR/selectors/#lang-pseudo
        "lang": markFunction( function( lang ) {
            // lang value must be a valid identifier
            if ( !ridentifier.test(lang || "") ) {
                Sizzle.error( "unsupported lang: " + lang );
            }
            lang = lang.replace( runescape, funescape ).toLowerCase();
            return function( elem ) {
                var elemLang;
                do {
                    if ( (elemLang = documentIsHTML ?
                        elem.lang :
                        elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

                        elemLang = elemLang.toLowerCase();
                        return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
                    }
                } while ( (elem = elem.parentNode) && elem.nodeType === 1 );
                return false;
            };
        }),

        // Miscellaneous
        "target": function( elem ) {
            var hash = window.location && window.location.hash;
            return hash && hash.slice( 1 ) === elem.id;
        },

        "root": function( elem ) {
            return elem === docElem;
        },

        "focus": function( elem ) {
            return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
        },

        // Boolean properties
        "enabled": function( elem ) {
            return elem.disabled === false;
        },

        "disabled": function( elem ) {
            return elem.disabled === true;
        },

        "checked": function( elem ) {
            // In CSS3, :checked should return both checked and selected elements
            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
            var nodeName = elem.nodeName.toLowerCase();
            return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
        },

        "selected": function( elem ) {
            // Accessing this property makes selected-by-default
            // options in Safari work properly
            if ( elem.parentNode ) {
                elem.parentNode.selectedIndex;
            }

            return elem.selected === true;
        },

        // Contents
        "empty": function( elem ) {
            // http://www.w3.org/TR/selectors/#empty-pseudo
            // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
            //   but not by others (comment: 8; processing instruction: 7; etc.)
            // nodeType < 6 works because attributes (2) do not appear as children
            for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
                if ( elem.nodeType < 6 ) {
                    return false;
                }
            }
            return true;
        },

        "parent": function( elem ) {
            return !Expr.pseudos["empty"]( elem );
        },

        // Element/input types
        "header": function( elem ) {
            return rheader.test( elem.nodeName );
        },

        "input": function( elem ) {
            return rinputs.test( elem.nodeName );
        },

        "button": function( elem ) {
            var name = elem.nodeName.toLowerCase();
            return name === "input" && elem.type === "button" || name === "button";
        },

        "text": function( elem ) {
            var attr;
            return elem.nodeName.toLowerCase() === "input" &&
                elem.type === "text" &&

                // Support: IE<8
                // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
                ( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
        },

        // Position-in-collection
        "first": createPositionalPseudo(function() {
            return [ 0 ];
        }),

        "last": createPositionalPseudo(function( matchIndexes, length ) {
            return [ length - 1 ];
        }),

        "eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
            return [ argument < 0 ? argument + length : argument ];
        }),

        "even": createPositionalPseudo(function( matchIndexes, length ) {
            var i = 0;
            for ( ; i < length; i += 2 ) {
                matchIndexes.push( i );
            }
            return matchIndexes;
        }),

        "odd": createPositionalPseudo(function( matchIndexes, length ) {
            var i = 1;
            for ( ; i < length; i += 2 ) {
                matchIndexes.push( i );
            }
            return matchIndexes;
        }),

        "lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
            var i = argument < 0 ? argument + length : argument;
            for ( ; --i >= 0; ) {
                matchIndexes.push( i );
            }
            return matchIndexes;
        }),

        "gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
            var i = argument < 0 ? argument + length : argument;
            for ( ; ++i < length; ) {
                matchIndexes.push( i );
            }
            return matchIndexes;
        })
    }
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
    Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
    Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

function tokenize( selector, parseOnly ) {
    var matched, match, tokens, type,
        soFar, groups, preFilters,
        cached = tokenCache[ selector + " " ];

    if ( cached ) {
        return parseOnly ? 0 : cached.slice( 0 );
    }

    soFar = selector;
    groups = [];
    preFilters = Expr.preFilter;

    while ( soFar ) {

        // Comma and first run
        if ( !matched || (match = rcomma.exec( soFar )) ) {
            if ( match ) {
                // Don't consume trailing commas as valid
                soFar = soFar.slice( match[0].length ) || soFar;
            }
            groups.push( (tokens = []) );
        }

        matched = false;

        // Combinators
        if ( (match = rcombinators.exec( soFar )) ) {
            matched = match.shift();
            tokens.push({
                value: matched,
                // Cast descendant combinators to space
                type: match[0].replace( rtrim, " " )
            });
            soFar = soFar.slice( matched.length );
        }

        // Filters
        for ( type in Expr.filter ) {
            if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
                (match = preFilters[ type ]( match ))) ) {
                matched = match.shift();
                tokens.push({
                    value: matched,
                    type: type,
                    matches: match
                });
                soFar = soFar.slice( matched.length );
            }
        }

        if ( !matched ) {
            break;
        }
    }

    // Return the length of the invalid excess
    // if we're just parsing
    // Otherwise, throw an error or return tokens
    return parseOnly ?
        soFar.length :
        soFar ?
            Sizzle.error( selector ) :
            // Cache the tokens
            tokenCache( selector, groups ).slice( 0 );
}

function toSelector( tokens ) {
    var i = 0,
        len = tokens.length,
        selector = "";
    for ( ; i < len; i++ ) {
        selector += tokens[i].value;
    }
    return selector;
}

function addCombinator( matcher, combinator, base ) {
    var dir = combinator.dir,
        checkNonElements = base && dir === "parentNode",
        doneName = done++;

    return combinator.first ?
        // Check against closest ancestor/preceding element
        function( elem, context, xml ) {
            while ( (elem = elem[ dir ]) ) {
                if ( elem.nodeType === 1 || checkNonElements ) {
                    return matcher( elem, context, xml );
                }
            }
        } :

        // Check against all ancestor/preceding elements
        function( elem, context, xml ) {
            var oldCache, outerCache,
                newCache = [ dirruns, doneName ];

            // We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
            if ( xml ) {
                while ( (elem = elem[ dir ]) ) {
                    if ( elem.nodeType === 1 || checkNonElements ) {
                        if ( matcher( elem, context, xml ) ) {
                            return true;
                        }
                    }
                }
            } else {
                while ( (elem = elem[ dir ]) ) {
                    if ( elem.nodeType === 1 || checkNonElements ) {
                        outerCache = elem[ expando ] || (elem[ expando ] = {});
                        if ( (oldCache = outerCache[ dir ]) &&
                            oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

                            // Assign to newCache so results back-propagate to previous elements
                            return (newCache[ 2 ] = oldCache[ 2 ]);
                        } else {
                            // Reuse newcache so results back-propagate to previous elements
                            outerCache[ dir ] = newCache;

                            // A match means we're done; a fail means we have to keep checking
                            if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
                                return true;
                            }
                        }
                    }
                }
            }
        };
}

function elementMatcher( matchers ) {
    return matchers.length > 1 ?
        function( elem, context, xml ) {
            var i = matchers.length;
            while ( i-- ) {
                if ( !matchers[i]( elem, context, xml ) ) {
                    return false;
                }
            }
            return true;
        } :
        matchers[0];
}

function multipleContexts( selector, contexts, results ) {
    var i = 0,
        len = contexts.length;
    for ( ; i < len; i++ ) {
        Sizzle( selector, contexts[i], results );
    }
    return results;
}

function condense( unmatched, map, filter, context, xml ) {
    var elem,
        newUnmatched = [],
        i = 0,
        len = unmatched.length,
        mapped = map != null;

    for ( ; i < len; i++ ) {
        if ( (elem = unmatched[i]) ) {
            if ( !filter || filter( elem, context, xml ) ) {
                newUnmatched.push( elem );
                if ( mapped ) {
                    map.push( i );
                }
            }
        }
    }

    return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
    if ( postFilter && !postFilter[ expando ] ) {
        postFilter = setMatcher( postFilter );
    }
    if ( postFinder && !postFinder[ expando ] ) {
        postFinder = setMatcher( postFinder, postSelector );
    }
    return markFunction(function( seed, results, context, xml ) {
        var temp, i, elem,
            preMap = [],
            postMap = [],
            preexisting = results.length,

            // Get initial elements from seed or context
            elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

            // Prefilter to get matcher input, preserving a map for seed-results synchronization
            matcherIn = preFilter && ( seed || !selector ) ?
                condense( elems, preMap, preFilter, context, xml ) :
                elems,

            matcherOut = matcher ?
                // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

                    // ...intermediate processing is necessary
                    [] :

                    // ...otherwise use results directly
                    results :
                matcherIn;

        // Find primary matches
        if ( matcher ) {
            matcher( matcherIn, matcherOut, context, xml );
        }

        // Apply postFilter
        if ( postFilter ) {
            temp = condense( matcherOut, postMap );
            postFilter( temp, [], context, xml );

            // Un-match failing elements by moving them back to matcherIn
            i = temp.length;
            while ( i-- ) {
                if ( (elem = temp[i]) ) {
                    matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
                }
            }
        }

        if ( seed ) {
            if ( postFinder || preFilter ) {
                if ( postFinder ) {
                    // Get the final matcherOut by condensing this intermediate into postFinder contexts
                    temp = [];
                    i = matcherOut.length;
                    while ( i-- ) {
                        if ( (elem = matcherOut[i]) ) {
                            // Restore matcherIn since elem is not yet a final match
                            temp.push( (matcherIn[i] = elem) );
                        }
                    }
                    postFinder( null, (matcherOut = []), temp, xml );
                }

                // Move matched elements from seed to results to keep them synchronized
                i = matcherOut.length;
                while ( i-- ) {
                    if ( (elem = matcherOut[i]) &&
                        (temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {

                        seed[temp] = !(results[temp] = elem);
                    }
                }
            }

        // Add elements to results, through postFinder if defined
        } else {
            matcherOut = condense(
                matcherOut === results ?
                    matcherOut.splice( preexisting, matcherOut.length ) :
                    matcherOut
            );
            if ( postFinder ) {
                postFinder( null, results, matcherOut, xml );
            } else {
                push.apply( results, matcherOut );
            }
        }
    });
}

function matcherFromTokens( tokens ) {
    var checkContext, matcher, j,
        len = tokens.length,
        leadingRelative = Expr.relative[ tokens[0].type ],
        implicitRelative = leadingRelative || Expr.relative[" "],
        i = leadingRelative ? 1 : 0,

        // The foundational matcher ensures that elements are reachable from top-level context(s)
        matchContext = addCombinator( function( elem ) {
            return elem === checkContext;
        }, implicitRelative, true ),
        matchAnyContext = addCombinator( function( elem ) {
            return indexOf.call( checkContext, elem ) > -1;
        }, implicitRelative, true ),
        matchers = [ function( elem, context, xml ) {
            return ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
                (checkContext = context).nodeType ?
                    matchContext( elem, context, xml ) :
                    matchAnyContext( elem, context, xml ) );
        } ];

    for ( ; i < len; i++ ) {
        if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
            matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
        } else {
            matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

            // Return special upon seeing a positional matcher
            if ( matcher[ expando ] ) {
                // Find the next relative operator (if any) for proper handling
                j = ++i;
                for ( ; j < len; j++ ) {
                    if ( Expr.relative[ tokens[j].type ] ) {
                        break;
                    }
                }
                return setMatcher(
                    i > 1 && elementMatcher( matchers ),
                    i > 1 && toSelector(
                        // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                        tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
                    ).replace( rtrim, "$1" ),
                    matcher,
                    i < j && matcherFromTokens( tokens.slice( i, j ) ),
                    j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
                    j < len && toSelector( tokens )
                );
            }
            matchers.push( matcher );
        }
    }

    return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
    var bySet = setMatchers.length > 0,
        byElement = elementMatchers.length > 0,
        superMatcher = function( seed, context, xml, results, outermost ) {
            var elem, j, matcher,
                matchedCount = 0,
                i = "0",
                unmatched = seed && [],
                setMatched = [],
                contextBackup = outermostContext,
                // We must always have either seed elements or outermost context
                elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
                // Use integer dirruns iff this is the outermost matcher
                dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
                len = elems.length;

            if ( outermost ) {
                outermostContext = context !== document && context;
            }

            // Add elements passing elementMatchers directly to results
            // Keep `i` a string if there are no elements so `matchedCount` will be "00" below
            // Support: IE<9, Safari
            // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
            for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
                if ( byElement && elem ) {
                    j = 0;
                    while ( (matcher = elementMatchers[j++]) ) {
                        if ( matcher( elem, context, xml ) ) {
                            results.push( elem );
                            break;
                        }
                    }
                    if ( outermost ) {
                        dirruns = dirrunsUnique;
                    }
                }

                // Track unmatched elements for set filters
                if ( bySet ) {
                    // They will have gone through all possible matchers
                    if ( (elem = !matcher && elem) ) {
                        matchedCount--;
                    }

                    // Lengthen the array for every element, matched or not
                    if ( seed ) {
                        unmatched.push( elem );
                    }
                }
            }

            // Apply set filters to unmatched elements
            matchedCount += i;
            if ( bySet && i !== matchedCount ) {
                j = 0;
                while ( (matcher = setMatchers[j++]) ) {
                    matcher( unmatched, setMatched, context, xml );
                }

                if ( seed ) {
                    // Reintegrate element matches to eliminate the need for sorting
                    if ( matchedCount > 0 ) {
                        while ( i-- ) {
                            if ( !(unmatched[i] || setMatched[i]) ) {
                                setMatched[i] = pop.call( results );
                            }
                        }
                    }

                    // Discard index placeholder values to get only actual matches
                    setMatched = condense( setMatched );
                }

                // Add matches to results
                push.apply( results, setMatched );

                // Seedless set matches succeeding multiple successful matchers stipulate sorting
                if ( outermost && !seed && setMatched.length > 0 &&
                    ( matchedCount + setMatchers.length ) > 1 ) {

                    Sizzle.uniqueSort( results );
                }
            }

            // Override manipulation of globals by nested matchers
            if ( outermost ) {
                dirruns = dirrunsUnique;
                outermostContext = contextBackup;
            }

            return unmatched;
        };

    return bySet ?
        markFunction( superMatcher ) :
        superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
    var i,
        setMatchers = [],
        elementMatchers = [],
        cached = compilerCache[ selector + " " ];

    if ( !cached ) {
        // Generate a function of recursive functions that can be used to check each element
        if ( !match ) {
            match = tokenize( selector );
        }
        i = match.length;
        while ( i-- ) {
            cached = matcherFromTokens( match[i] );
            if ( cached[ expando ] ) {
                setMatchers.push( cached );
            } else {
                elementMatchers.push( cached );
            }
        }

        // Cache the compiled function
        cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

        // Save selector and tokenization
        cached.selector = selector;
    }
    return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
    var i, tokens, token, type, find,
        compiled = typeof selector === "function" && selector,
        match = !seed && tokenize( (selector = compiled.selector || selector) );

    results = results || [];

    // Try to minimize operations if there is no seed and only one group
    if ( match.length === 1 ) {

        // Take a shortcut and set the context if the root selector is an ID
        tokens = match[0] = match[0].slice( 0 );
        if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
                support.getById && context.nodeType === 9 && documentIsHTML &&
                Expr.relative[ tokens[1].type ] ) {

            context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
            if ( !context ) {
                return results;

            // Precompiled matchers will still verify ancestry, so step up a level
            } else if ( compiled ) {
                context = context.parentNode;
            }

            selector = selector.slice( tokens.shift().value.length );
        }

        // Fetch a seed set for right-to-left matching
        i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
        while ( i-- ) {
            token = tokens[i];

            // Abort if we hit a combinator
            if ( Expr.relative[ (type = token.type) ] ) {
                break;
            }
            if ( (find = Expr.find[ type ]) ) {
                // Search, expanding context for leading sibling combinators
                if ( (seed = find(
                    token.matches[0].replace( runescape, funescape ),
                    rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
                )) ) {

                    // If seed is empty or no tokens remain, we can return early
                    tokens.splice( i, 1 );
                    selector = seed.length && toSelector( tokens );
                    if ( !selector ) {
                        push.apply( results, seed );
                        return results;
                    }

                    break;
                }
            }
        }
    }

    // Compile and execute a filtering function if one is not provided
    // Provide `match` to avoid retokenization if we modified the selector above
    ( compiled || compile( selector, match ) )(
        seed,
        context,
        !documentIsHTML,
        results,
        rsibling.test( selector ) && testContext( context.parentNode ) || context
    );
    return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome<14
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
    // Should return 1, but returns 4 (following)
    return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
    div.innerHTML = "<a href='#'></a>";
    return div.firstChild.getAttribute("href") === "#" ;
}) ) {
    addHandle( "type|href|height|width", function( elem, name, isXML ) {
        if ( !isXML ) {
            return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
        }
    });
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( div ) {
    div.innerHTML = "<input/>";
    div.firstChild.setAttribute( "value", "" );
    return div.firstChild.getAttribute( "value" ) === "";
}) ) {
    addHandle( "value", function( elem, name, isXML ) {
        if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
            return elem.defaultValue;
        }
    });
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
    return div.getAttribute("disabled") == null;
}) ) {
    addHandle( booleans, function( elem, name, isXML ) {
        var val;
        if ( !isXML ) {
            return elem[ name ] === true ? name.toLowerCase() :
                    (val = elem.getAttributeNode( name )) && val.specified ?
                    val.value :
                null;
        }
    });
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;



var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
    if ( jQuery.isFunction( qualifier ) ) {
        return jQuery.grep( elements, function( elem, i ) {
            /* jshint -W018 */
            return !!qualifier.call( elem, i, elem ) !== not;
        });

    }

    if ( qualifier.nodeType ) {
        return jQuery.grep( elements, function( elem ) {
            return ( elem === qualifier ) !== not;
        });

    }

    if ( typeof qualifier === "string" ) {
        if ( risSimple.test( qualifier ) ) {
            return jQuery.filter( qualifier, elements, not );
        }

        qualifier = jQuery.filter( qualifier, elements );
    }

    return jQuery.grep( elements, function( elem ) {
        return ( jQuery.inArray( elem, qualifier ) >= 0 ) !== not;
    });
}

jQuery.filter = function( expr, elems, not ) {
    var elem = elems[ 0 ];

    if ( not ) {
        expr = ":not(" + expr + ")";
    }

    return elems.length === 1 && elem.nodeType === 1 ?
        jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
        jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
            return elem.nodeType === 1;
        }));
};

jQuery.fn.extend({
    find: function( selector ) {
        var i,
            ret = [],
            self = this,
            len = self.length;

        if ( typeof selector !== "string" ) {
            return this.pushStack( jQuery( selector ).filter(function() {
                for ( i = 0; i < len; i++ ) {
                    if ( jQuery.contains( self[ i ], this ) ) {
                        return true;
                    }
                }
            }) );
        }

        for ( i = 0; i < len; i++ ) {
            jQuery.find( selector, self[ i ], ret );
        }

        // Needed because $( selector, context ) becomes $( context ).find( selector )
        ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
        ret.selector = this.selector ? this.selector + " " + selector : selector;
        return ret;
    },
    filter: function( selector ) {
        return this.pushStack( winnow(this, selector || [], false) );
    },
    not: function( selector ) {
        return this.pushStack( winnow(this, selector || [], true) );
    },
    is: function( selector ) {
        return !!winnow(
            this,

            // If this is a positional/relative selector, check membership in the returned set
            // so $("p:first").is("p:last") won't return true for a doc with two "p".
            typeof selector === "string" && rneedsContext.test( selector ) ?
                jQuery( selector ) :
                selector || [],
            false
        ).length;
    }
});


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

    // Use the correct document accordingly with window argument (sandbox)
    document = window.document,

    // A simple way to check for HTML strings
    // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
    // Strict HTML recognition (#11290: must start with <)
    rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

    init = jQuery.fn.init = function( selector, context ) {
        var match, elem;

        // HANDLE: $(""), $(null), $(undefined), $(false)
        if ( !selector ) {
            return this;
        }

        // Handle HTML strings
        if ( typeof selector === "string" ) {
            if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
                // Assume that strings that start and end with <> are HTML and skip the regex check
                match = [ null, selector, null ];

            } else {
                match = rquickExpr.exec( selector );
            }

            // Match html or make sure no context is specified for #id
            if ( match && (match[1] || !context) ) {

                // HANDLE: $(html) -> $(array)
                if ( match[1] ) {
                    context = context instanceof jQuery ? context[0] : context;

                    // scripts is true for back-compat
                    // Intentionally let the error be thrown if parseHTML is not present
                    jQuery.merge( this, jQuery.parseHTML(
                        match[1],
                        context && context.nodeType ? context.ownerDocument || context : document,
                        true
                    ) );

                    // HANDLE: $(html, props)
                    if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
                        for ( match in context ) {
                            // Properties of context are called as methods if possible
                            if ( jQuery.isFunction( this[ match ] ) ) {
                                this[ match ]( context[ match ] );

                            // ...and otherwise set as attributes
                            } else {
                                this.attr( match, context[ match ] );
                            }
                        }
                    }

                    return this;

                // HANDLE: $(#id)
                } else {
                    elem = document.getElementById( match[2] );

                    // Check parentNode to catch when Blackberry 4.6 returns
                    // nodes that are no longer in the document #6963
                    if ( elem && elem.parentNode ) {
                        // Handle the case where IE and Opera return items
                        // by name instead of ID
                        if ( elem.id !== match[2] ) {
                            return rootjQuery.find( selector );
                        }

                        // Otherwise, we inject the element directly into the jQuery object
                        this.length = 1;
                        this[0] = elem;
                    }

                    this.context = document;
                    this.selector = selector;
                    return this;
                }

            // HANDLE: $(expr, $(...))
            } else if ( !context || context.jquery ) {
                return ( context || rootjQuery ).find( selector );

            // HANDLE: $(expr, context)
            // (which is just equivalent to: $(context).find(expr)
            } else {
                return this.constructor( context ).find( selector );
            }

        // HANDLE: $(DOMElement)
        } else if ( selector.nodeType ) {
            this.context = this[0] = selector;
            this.length = 1;
            return this;

        // HANDLE: $(function)
        // Shortcut for document ready
        } else if ( jQuery.isFunction( selector ) ) {
            return typeof rootjQuery.ready !== "undefined" ?
                rootjQuery.ready( selector ) :
                // Execute immediately if ready is not present
                selector( jQuery );
        }

        if ( selector.selector !== undefined ) {
            this.selector = selector.selector;
            this.context = selector.context;
        }

        return jQuery.makeArray( selector, this );
    };

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,
    // methods guaranteed to produce a unique set when starting from a unique set
    guaranteedUnique = {
        children: true,
        contents: true,
        next: true,
        prev: true
    };

jQuery.extend({
    dir: function( elem, dir, until ) {
        var matched = [],
            cur = elem[ dir ];

        while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
            if ( cur.nodeType === 1 ) {
                matched.push( cur );
            }
            cur = cur[dir];
        }
        return matched;
    },

    sibling: function( n, elem ) {
        var r = [];

        for ( ; n; n = n.nextSibling ) {
            if ( n.nodeType === 1 && n !== elem ) {
                r.push( n );
            }
        }

        return r;
    }
});

jQuery.fn.extend({
    has: function( target ) {
        var i,
            targets = jQuery( target, this ),
            len = targets.length;

        return this.filter(function() {
            for ( i = 0; i < len; i++ ) {
                if ( jQuery.contains( this, targets[i] ) ) {
                    return true;
                }
            }
        });
    },

    closest: function( selectors, context ) {
        var cur,
            i = 0,
            l = this.length,
            matched = [],
            pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
                jQuery( selectors, context || this.context ) :
                0;

        for ( ; i < l; i++ ) {
            for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
                // Always skip document fragments
                if ( cur.nodeType < 11 && (pos ?
                    pos.index(cur) > -1 :

                    // Don't pass non-elements to Sizzle
                    cur.nodeType === 1 &&
                        jQuery.find.matchesSelector(cur, selectors)) ) {

                    matched.push( cur );
                    break;
                }
            }
        }

        return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
    },

    // Determine the position of an element within
    // the matched set of elements
    index: function( elem ) {

        // No argument, return index in parent
        if ( !elem ) {
            return ( this[0] && this[0].parentNode ) ? this.first().prevAll().length : -1;
        }

        // index in selector
        if ( typeof elem === "string" ) {
            return jQuery.inArray( this[0], jQuery( elem ) );
        }

        // Locate the position of the desired element
        return jQuery.inArray(
            // If it receives a jQuery object, the first element is used
            elem.jquery ? elem[0] : elem, this );
    },

    add: function( selector, context ) {
        return this.pushStack(
            jQuery.unique(
                jQuery.merge( this.get(), jQuery( selector, context ) )
            )
        );
    },

    addBack: function( selector ) {
        return this.add( selector == null ?
            this.prevObject : this.prevObject.filter(selector)
        );
    }
});

function sibling( cur, dir ) {
    do {
        cur = cur[ dir ];
    } while ( cur && cur.nodeType !== 1 );

    return cur;
}

jQuery.each({
    parent: function( elem ) {
        var parent = elem.parentNode;
        return parent && parent.nodeType !== 11 ? parent : null;
    },
    parents: function( elem ) {
        return jQuery.dir( elem, "parentNode" );
    },
    parentsUntil: function( elem, i, until ) {
        return jQuery.dir( elem, "parentNode", until );
    },
    next: function( elem ) {
        return sibling( elem, "nextSibling" );
    },
    prev: function( elem ) {
        return sibling( elem, "previousSibling" );
    },
    nextAll: function( elem ) {
        return jQuery.dir( elem, "nextSibling" );
    },
    prevAll: function( elem ) {
        return jQuery.dir( elem, "previousSibling" );
    },
    nextUntil: function( elem, i, until ) {
        return jQuery.dir( elem, "nextSibling", until );
    },
    prevUntil: function( elem, i, until ) {
        return jQuery.dir( elem, "previousSibling", until );
    },
    siblings: function( elem ) {
        return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
    },
    children: function( elem ) {
        return jQuery.sibling( elem.firstChild );
    },
    contents: function( elem ) {
        return jQuery.nodeName( elem, "iframe" ) ?
            elem.contentDocument || elem.contentWindow.document :
            jQuery.merge( [], elem.childNodes );
    }
}, function( name, fn ) {
    jQuery.fn[ name ] = function( until, selector ) {
        var ret = jQuery.map( this, fn, until );

        if ( name.slice( -5 ) !== "Until" ) {
            selector = until;
        }

        if ( selector && typeof selector === "string" ) {
            ret = jQuery.filter( selector, ret );
        }

        if ( this.length > 1 ) {
            // Remove duplicates
            if ( !guaranteedUnique[ name ] ) {
                ret = jQuery.unique( ret );
            }

            // Reverse order for parents* and prev-derivatives
            if ( rparentsprev.test( name ) ) {
                ret = ret.reverse();
            }
        }

        return this.pushStack( ret );
    };
});
var rnotwhite = (/\S+/g);



// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
    var object = optionsCache[ options ] = {};
    jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
        object[ flag ] = true;
    });
    return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *  options: an optional list of space-separated options that will change how
 *          the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *  once:           will ensure the callback list can only be fired once (like a Deferred)
 *
 *  memory:         will keep track of previous values and will call any callback added
 *                  after the list has been fired right away with the latest "memorized"
 *                  values (like a Deferred)
 *
 *  unique:         will ensure a callback can only be added once (no duplicate in the list)
 *
 *  stopOnFalse:    interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

    // Convert options from String-formatted to Object-formatted if needed
    // (we check in cache first)
    options = typeof options === "string" ?
        ( optionsCache[ options ] || createOptions( options ) ) :
        jQuery.extend( {}, options );

    var // Flag to know if list is currently firing
        firing,
        // Last fire value (for non-forgettable lists)
        memory,
        // Flag to know if list was already fired
        fired,
        // End of the loop when firing
        firingLength,
        // Index of currently firing callback (modified by remove if needed)
        firingIndex,
        // First callback to fire (used internally by add and fireWith)
        firingStart,
        // Actual callback list
        list = [],
        // Stack of fire calls for repeatable lists
        stack = !options.once && [],
        // Fire callbacks
        fire = function( data ) {
            memory = options.memory && data;
            fired = true;
            firingIndex = firingStart || 0;
            firingStart = 0;
            firingLength = list.length;
            firing = true;
            for ( ; list && firingIndex < firingLength; firingIndex++ ) {
                if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
                    memory = false; // To prevent further calls using add
                    break;
                }
            }
            firing = false;
            if ( list ) {
                if ( stack ) {
                    if ( stack.length ) {
                        fire( stack.shift() );
                    }
                } else if ( memory ) {
                    list = [];
                } else {
                    self.disable();
                }
            }
        },
        // Actual Callbacks object
        self = {
            // Add a callback or a collection of callbacks to the list
            add: function() {
                if ( list ) {
                    // First, we save the current length
                    var start = list.length;
                    (function add( args ) {
                        jQuery.each( args, function( _, arg ) {
                            var type = jQuery.type( arg );
                            if ( type === "function" ) {
                                if ( !options.unique || !self.has( arg ) ) {
                                    list.push( arg );
                                }
                            } else if ( arg && arg.length && type !== "string" ) {
                                // Inspect recursively
                                add( arg );
                            }
                        });
                    })( arguments );
                    // Do we need to add the callbacks to the
                    // current firing batch?
                    if ( firing ) {
                        firingLength = list.length;
                    // With memory, if we're not firing then
                    // we should call right away
                    } else if ( memory ) {
                        firingStart = start;
                        fire( memory );
                    }
                }
                return this;
            },
            // Remove a callback from the list
            remove: function() {
                if ( list ) {
                    jQuery.each( arguments, function( _, arg ) {
                        var index;
                        while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
                            list.splice( index, 1 );
                            // Handle firing indexes
                            if ( firing ) {
                                if ( index <= firingLength ) {
                                    firingLength--;
                                }
                                if ( index <= firingIndex ) {
                                    firingIndex--;
                                }
                            }
                        }
                    });
                }
                return this;
            },
            // Check if a given callback is in the list.
            // If no argument is given, return whether or not list has callbacks attached.
            has: function( fn ) {
                return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
            },
            // Remove all callbacks from the list
            empty: function() {
                list = [];
                firingLength = 0;
                return this;
            },
            // Have the list do nothing anymore
            disable: function() {
                list = stack = memory = undefined;
                return this;
            },
            // Is it disabled?
            disabled: function() {
                return !list;
            },
            // Lock the list in its current state
            lock: function() {
                stack = undefined;
                if ( !memory ) {
                    self.disable();
                }
                return this;
            },
            // Is it locked?
            locked: function() {
                return !stack;
            },
            // Call all callbacks with the given context and arguments
            fireWith: function( context, args ) {
                if ( list && ( !fired || stack ) ) {
                    args = args || [];
                    args = [ context, args.slice ? args.slice() : args ];
                    if ( firing ) {
                        stack.push( args );
                    } else {
                        fire( args );
                    }
                }
                return this;
            },
            // Call all the callbacks with the given arguments
            fire: function() {
                self.fireWith( this, arguments );
                return this;
            },
            // To know if the callbacks have already been called at least once
            fired: function() {
                return !!fired;
            }
        };

    return self;
};


jQuery.extend({

    Deferred: function( func ) {
        var tuples = [
                // action, add listener, listener list, final state
                [ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
                [ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
                [ "notify", "progress", jQuery.Callbacks("memory") ]
            ],
            state = "pending",
            promise = {
                state: function() {
                    return state;
                },
                always: function() {
                    deferred.done( arguments ).fail( arguments );
                    return this;
                },
                then: function( /* fnDone, fnFail, fnProgress */ ) {
                    var fns = arguments;
                    return jQuery.Deferred(function( newDefer ) {
                        jQuery.each( tuples, function( i, tuple ) {
                            var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
                            // deferred[ done | fail | progress ] for forwarding actions to newDefer
                            deferred[ tuple[1] ](function() {
                                var returned = fn && fn.apply( this, arguments );
                                if ( returned && jQuery.isFunction( returned.promise ) ) {
                                    returned.promise()
                                        .done( newDefer.resolve )
                                        .fail( newDefer.reject )
                                        .progress( newDefer.notify );
                                } else {
                                    newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
                                }
                            });
                        });
                        fns = null;
                    }).promise();
                },
                // Get a promise for this deferred
                // If obj is provided, the promise aspect is added to the object
                promise: function( obj ) {
                    return obj != null ? jQuery.extend( obj, promise ) : promise;
                }
            },
            deferred = {};

        // Keep pipe for back-compat
        promise.pipe = promise.then;

        // Add list-specific methods
        jQuery.each( tuples, function( i, tuple ) {
            var list = tuple[ 2 ],
                stateString = tuple[ 3 ];

            // promise[ done | fail | progress ] = list.add
            promise[ tuple[1] ] = list.add;

            // Handle state
            if ( stateString ) {
                list.add(function() {
                    // state = [ resolved | rejected ]
                    state = stateString;

                // [ reject_list | resolve_list ].disable; progress_list.lock
                }, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
            }

            // deferred[ resolve | reject | notify ]
            deferred[ tuple[0] ] = function() {
                deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
                return this;
            };
            deferred[ tuple[0] + "With" ] = list.fireWith;
        });

        // Make the deferred a promise
        promise.promise( deferred );

        // Call given func if any
        if ( func ) {
            func.call( deferred, deferred );
        }

        // All done!
        return deferred;
    },

    // Deferred helper
    when: function( subordinate /* , ..., subordinateN */ ) {
        var i = 0,
            resolveValues = slice.call( arguments ),
            length = resolveValues.length,

            // the count of uncompleted subordinates
            remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

            // the master Deferred. If resolveValues consist of only a single Deferred, just use that.
            deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

            // Update function for both resolve and progress values
            updateFunc = function( i, contexts, values ) {
                return function( value ) {
                    contexts[ i ] = this;
                    values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
                    if ( values === progressValues ) {
                        deferred.notifyWith( contexts, values );

                    } else if ( !(--remaining) ) {
                        deferred.resolveWith( contexts, values );
                    }
                };
            },

            progressValues, progressContexts, resolveContexts;

        // add listeners to Deferred subordinates; treat others as resolved
        if ( length > 1 ) {
            progressValues = new Array( length );
            progressContexts = new Array( length );
            resolveContexts = new Array( length );
            for ( ; i < length; i++ ) {
                if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
                    resolveValues[ i ].promise()
                        .done( updateFunc( i, resolveContexts, resolveValues ) )
                        .fail( deferred.reject )
                        .progress( updateFunc( i, progressContexts, progressValues ) );
                } else {
                    --remaining;
                }
            }
        }

        // if we're not waiting on anything, resolve the master
        if ( !remaining ) {
            deferred.resolveWith( resolveContexts, resolveValues );
        }

        return deferred.promise();
    }
});


// The deferred used on DOM ready
var readyList;

jQuery.fn.ready = function( fn ) {
    // Add the callback
    jQuery.ready.promise().done( fn );

    return this;
};

jQuery.extend({
    // Is the DOM ready to be used? Set to true once it occurs.
    isReady: false,

    // A counter to track how many items to wait for before
    // the ready event fires. See #6781
    readyWait: 1,

    // Hold (or release) the ready event
    holdReady: function( hold ) {
        if ( hold ) {
            jQuery.readyWait++;
        } else {
            jQuery.ready( true );
        }
    },

    // Handle when the DOM is ready
    ready: function( wait ) {

        // Abort if there are pending holds or we're already ready
        if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
            return;
        }

        // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
        if ( !document.body ) {
            return setTimeout( jQuery.ready );
        }

        // Remember that the DOM is ready
        jQuery.isReady = true;

        // If a normal DOM Ready event fired, decrement, and wait if need be
        if ( wait !== true && --jQuery.readyWait > 0 ) {
            return;
        }

        // If there are functions bound, to execute
        readyList.resolveWith( document, [ jQuery ] );

        // Trigger any bound ready events
        if ( jQuery.fn.trigger ) {
            jQuery( document ).trigger("ready").off("ready");
        }
    }
});

/**
 * Clean-up method for dom ready events
 */
function detach() {
    if ( document.addEventListener ) {
        document.removeEventListener( "DOMContentLoaded", completed, false );
        window.removeEventListener( "load", completed, false );

    } else {
        document.detachEvent( "onreadystatechange", completed );
        window.detachEvent( "onload", completed );
    }
}

/**
 * The ready event handler and self cleanup method
 */
function completed() {
    // readyState === "complete" is good enough for us to call the dom ready in oldIE
    if ( document.addEventListener || event.type === "load" || document.readyState === "complete" ) {
        detach();
        jQuery.ready();
    }
}

jQuery.ready.promise = function( obj ) {
    if ( !readyList ) {

        readyList = jQuery.Deferred();

        // Catch cases where $(document).ready() is called after the browser event has already occurred.
        // we once tried to use readyState "interactive" here, but it caused issues like the one
        // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
        if ( document.readyState === "complete" ) {
            // Handle it asynchronously to allow scripts the opportunity to delay ready
            setTimeout( jQuery.ready );

        // Standards-based browsers support DOMContentLoaded
        } else if ( document.addEventListener ) {
            // Use the handy event callback
            document.addEventListener( "DOMContentLoaded", completed, false );

            // A fallback to window.onload, that will always work
            window.addEventListener( "load", completed, false );

        // If IE event model is used
        } else {
            // Ensure firing before onload, maybe late but safe also for iframes
            document.attachEvent( "onreadystatechange", completed );

            // A fallback to window.onload, that will always work
            window.attachEvent( "onload", completed );

            // If IE and not a frame
            // continually check to see if the document is ready
            var top = false;

            try {
                top = window.frameElement == null && document.documentElement;
            } catch(e) {}

            if ( top && top.doScroll ) {
                (function doScrollCheck() {
                    if ( !jQuery.isReady ) {

                        try {
                            // Use the trick by Diego Perini
                            // http://javascript.nwbox.com/IEContentLoaded/
                            top.doScroll("left");
                        } catch(e) {
                            return setTimeout( doScrollCheck, 50 );
                        }

                        // detach all dom ready events
                        detach();

                        // and execute any waiting functions
                        jQuery.ready();
                    }
                })();
            }
        }
    }
    return readyList.promise( obj );
};


var strundefined = typeof undefined;



// Support: IE<9
// Iteration over object's inherited properties before its own
var i;
for ( i in jQuery( support ) ) {
    break;
}
support.ownLast = i !== "0";

// Note: most support tests are defined in their respective modules.
// false until the test is run
support.inlineBlockNeedsLayout = false;

jQuery(function() {
    // We need to execute this one support test ASAP because we need to know
    // if body.style.zoom needs to be set.

    var container, div,
        body = document.getElementsByTagName("body")[0];

    if ( !body ) {
        // Return for frameset docs that don't have a body
        return;
    }

    // Setup
    container = document.createElement( "div" );
    container.style.cssText = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px";

    div = document.createElement( "div" );
    body.appendChild( container ).appendChild( div );

    if ( typeof div.style.zoom !== strundefined ) {
        // Support: IE<8
        // Check if natively block-level elements act like inline-block
        // elements when setting their display to 'inline' and giving
        // them layout
        div.style.cssText = "border:0;margin:0;width:1px;padding:1px;display:inline;zoom:1";

        if ( (support.inlineBlockNeedsLayout = ( div.offsetWidth === 3 )) ) {
            // Prevent IE 6 from affecting layout for positioned elements #11048
            // Prevent IE from shrinking the body in IE 7 mode #12869
            // Support: IE<8
            body.style.zoom = 1;
        }
    }

    body.removeChild( container );

    // Null elements to avoid leaks in IE
    container = div = null;
});




(function() {
    var div = document.createElement( "div" );

    // Execute the test only if not already executed in another module.
    if (support.deleteExpando == null) {
        // Support: IE<9
        support.deleteExpando = true;
        try {
            delete div.test;
        } catch( e ) {
            support.deleteExpando = false;
        }
    }

    // Null elements to avoid leaks in IE.
    div = null;
})();


/**
 * Determines whether an object can have data
 */
jQuery.acceptData = function( elem ) {
    var noData = jQuery.noData[ (elem.nodeName + " ").toLowerCase() ],
        nodeType = +elem.nodeType || 1;

    // Do not set data on non-element DOM nodes because it will not be cleared (#8335).
    return nodeType !== 1 && nodeType !== 9 ?
        false :

        // Nodes accept data unless otherwise specified; rejection can be conditional
        !noData || noData !== true && elem.getAttribute("classid") === noData;
};


var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
    rmultiDash = /([A-Z])/g;

function dataAttr( elem, key, data ) {
    // If nothing was found internally, try to fetch any
    // data from the HTML5 data-* attribute
    if ( data === undefined && elem.nodeType === 1 ) {

        var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

        data = elem.getAttribute( name );

        if ( typeof data === "string" ) {
            try {
                data = data === "true" ? true :
                    data === "false" ? false :
                    data === "null" ? null :
                    // Only convert to a number if it doesn't change the string
                    +data + "" === data ? +data :
                    rbrace.test( data ) ? jQuery.parseJSON( data ) :
                    data;
            } catch( e ) {}

            // Make sure we set the data so it isn't changed later
            jQuery.data( elem, key, data );

        } else {
            data = undefined;
        }
    }

    return data;
}

// checks a cache object for emptiness
function isEmptyDataObject( obj ) {
    var name;
    for ( name in obj ) {

        // if the public data object is empty, the private is still empty
        if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
            continue;
        }
        if ( name !== "toJSON" ) {
            return false;
        }
    }

    return true;
}

function internalData( elem, name, data, pvt /* Internal Use Only */ ) {
    if ( !jQuery.acceptData( elem ) ) {
        return;
    }

    var ret, thisCache,
        internalKey = jQuery.expando,

        // We have to handle DOM nodes and JS objects differently because IE6-7
        // can't GC object references properly across the DOM-JS boundary
        isNode = elem.nodeType,

        // Only DOM nodes need the global jQuery cache; JS object data is
        // attached directly to the object so GC can occur automatically
        cache = isNode ? jQuery.cache : elem,

        // Only defining an ID for JS objects if its cache already exists allows
        // the code to shortcut on the same path as a DOM node with no cache
        id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;

    // Avoid doing any more work than we need to when trying to get data on an
    // object that has no data at all
    if ( (!id || !cache[id] || (!pvt && !cache[id].data)) && data === undefined && typeof name === "string" ) {
        return;
    }

    if ( !id ) {
        // Only DOM nodes need a new unique ID for each element since their data
        // ends up in the global cache
        if ( isNode ) {
            id = elem[ internalKey ] = deletedIds.pop() || jQuery.guid++;
        } else {
            id = internalKey;
        }
    }

    if ( !cache[ id ] ) {
        // Avoid exposing jQuery metadata on plain JS objects when the object
        // is serialized using JSON.stringify
        cache[ id ] = isNode ? {} : { toJSON: jQuery.noop };
    }

    // An object can be passed to jQuery.data instead of a key/value pair; this gets
    // shallow copied over onto the existing cache
    if ( typeof name === "object" || typeof name === "function" ) {
        if ( pvt ) {
            cache[ id ] = jQuery.extend( cache[ id ], name );
        } else {
            cache[ id ].data = jQuery.extend( cache[ id ].data, name );
        }
    }

    thisCache = cache[ id ];

    // jQuery data() is stored in a separate object inside the object's internal data
    // cache in order to avoid key collisions between internal data and user-defined
    // data.
    if ( !pvt ) {
        if ( !thisCache.data ) {
            thisCache.data = {};
        }

        thisCache = thisCache.data;
    }

    if ( data !== undefined ) {
        thisCache[ jQuery.camelCase( name ) ] = data;
    }

    // Check for both converted-to-camel and non-converted data property names
    // If a data property was specified
    if ( typeof name === "string" ) {

        // First Try to find as-is property data
        ret = thisCache[ name ];

        // Test for null|undefined property data
        if ( ret == null ) {

            // Try to find the camelCased property
            ret = thisCache[ jQuery.camelCase( name ) ];
        }
    } else {
        ret = thisCache;
    }

    return ret;
}

function internalRemoveData( elem, name, pvt ) {
    if ( !jQuery.acceptData( elem ) ) {
        return;
    }

    var thisCache, i,
        isNode = elem.nodeType,

        // See jQuery.data for more information
        cache = isNode ? jQuery.cache : elem,
        id = isNode ? elem[ jQuery.expando ] : jQuery.expando;

    // If there is already no cache entry for this object, there is no
    // purpose in continuing
    if ( !cache[ id ] ) {
        return;
    }

    if ( name ) {

        thisCache = pvt ? cache[ id ] : cache[ id ].data;

        if ( thisCache ) {

            // Support array or space separated string names for data keys
            if ( !jQuery.isArray( name ) ) {

                // try the string as a key before any manipulation
                if ( name in thisCache ) {
                    name = [ name ];
                } else {

                    // split the camel cased version by spaces unless a key with the spaces exists
                    name = jQuery.camelCase( name );
                    if ( name in thisCache ) {
                        name = [ name ];
                    } else {
                        name = name.split(" ");
                    }
                }
            } else {
                // If "name" is an array of keys...
                // When data is initially created, via ("key", "val") signature,
                // keys will be converted to camelCase.
                // Since there is no way to tell _how_ a key was added, remove
                // both plain key and camelCase key. #12786
                // This will only penalize the array argument path.
                name = name.concat( jQuery.map( name, jQuery.camelCase ) );
            }

            i = name.length;
            while ( i-- ) {
                delete thisCache[ name[i] ];
            }

            // If there is no data left in the cache, we want to continue
            // and let the cache object itself get destroyed
            if ( pvt ? !isEmptyDataObject(thisCache) : !jQuery.isEmptyObject(thisCache) ) {
                return;
            }
        }
    }

    // See jQuery.data for more information
    if ( !pvt ) {
        delete cache[ id ].data;

        // Don't destroy the parent cache unless the internal data object
        // had been the only thing left in it
        if ( !isEmptyDataObject( cache[ id ] ) ) {
            return;
        }
    }

    // Destroy the cache
    if ( isNode ) {
        jQuery.cleanData( [ elem ], true );

    // Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
    /* jshint eqeqeq: false */
    } else if ( support.deleteExpando || cache != cache.window ) {
        /* jshint eqeqeq: true */
        delete cache[ id ];

    // When all else fails, null
    } else {
        cache[ id ] = null;
    }
}

jQuery.extend({
    cache: {},

    // The following elements (space-suffixed to avoid Object.prototype collisions)
    // throw uncatchable exceptions if you attempt to set expando properties
    noData: {
        "applet ": true,
        "embed ": true,
        // ...but Flash objects (which have this classid) *can* handle expandos
        "object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
    },

    hasData: function( elem ) {
        elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
        return !!elem && !isEmptyDataObject( elem );
    },

    data: function( elem, name, data ) {
        return internalData( elem, name, data );
    },

    removeData: function( elem, name ) {
        return internalRemoveData( elem, name );
    },

    // For internal use only.
    _data: function( elem, name, data ) {
        return internalData( elem, name, data, true );
    },

    _removeData: function( elem, name ) {
        return internalRemoveData( elem, name, true );
    }
});

jQuery.fn.extend({
    data: function( key, value ) {
        var i, name, data,
            elem = this[0],
            attrs = elem && elem.attributes;

        // Special expections of .data basically thwart jQuery.access,
        // so implement the relevant behavior ourselves

        // Gets all values
        if ( key === undefined ) {
            if ( this.length ) {
                data = jQuery.data( elem );

                if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
                    i = attrs.length;
                    while ( i-- ) {
                        name = attrs[i].name;

                        if ( name.indexOf("data-") === 0 ) {
                            name = jQuery.camelCase( name.slice(5) );

                            dataAttr( elem, name, data[ name ] );
                        }
                    }
                    jQuery._data( elem, "parsedAttrs", true );
                }
            }

            return data;
        }

        // Sets multiple values
        if ( typeof key === "object" ) {
            return this.each(function() {
                jQuery.data( this, key );
            });
        }

        return arguments.length > 1 ?

            // Sets one value
            this.each(function() {
                jQuery.data( this, key, value );
            }) :

            // Gets one value
            // Try to fetch any internally stored data first
            elem ? dataAttr( elem, key, jQuery.data( elem, key ) ) : undefined;
    },

    removeData: function( key ) {
        return this.each(function() {
            jQuery.removeData( this, key );
        });
    }
});


jQuery.extend({
    queue: function( elem, type, data ) {
        var queue;

        if ( elem ) {
            type = ( type || "fx" ) + "queue";
            queue = jQuery._data( elem, type );

            // Speed up dequeue by getting out quickly if this is just a lookup
            if ( data ) {
                if ( !queue || jQuery.isArray(data) ) {
                    queue = jQuery._data( elem, type, jQuery.makeArray(data) );
                } else {
                    queue.push( data );
                }
            }
            return queue || [];
        }
    },

    dequeue: function( elem, type ) {
        type = type || "fx";

        var queue = jQuery.queue( elem, type ),
            startLength = queue.length,
            fn = queue.shift(),
            hooks = jQuery._queueHooks( elem, type ),
            next = function() {
                jQuery.dequeue( elem, type );
            };

        // If the fx queue is dequeued, always remove the progress sentinel
        if ( fn === "inprogress" ) {
            fn = queue.shift();
            startLength--;
        }

        if ( fn ) {

            // Add a progress sentinel to prevent the fx queue from being
            // automatically dequeued
            if ( type === "fx" ) {
                queue.unshift( "inprogress" );
            }

            // clear up the last queue stop function
            delete hooks.stop;
            fn.call( elem, next, hooks );
        }

        if ( !startLength && hooks ) {
            hooks.empty.fire();
        }
    },

    // not intended for public consumption - generates a queueHooks object, or returns the current one
    _queueHooks: function( elem, type ) {
        var key = type + "queueHooks";
        return jQuery._data( elem, key ) || jQuery._data( elem, key, {
            empty: jQuery.Callbacks("once memory").add(function() {
                jQuery._removeData( elem, type + "queue" );
                jQuery._removeData( elem, key );
            })
        });
    }
});

jQuery.fn.extend({
    queue: function( type, data ) {
        var setter = 2;

        if ( typeof type !== "string" ) {
            data = type;
            type = "fx";
            setter--;
        }

        if ( arguments.length < setter ) {
            return jQuery.queue( this[0], type );
        }

        return data === undefined ?
            this :
            this.each(function() {
                var queue = jQuery.queue( this, type, data );

                // ensure a hooks for this queue
                jQuery._queueHooks( this, type );

                if ( type === "fx" && queue[0] !== "inprogress" ) {
                    jQuery.dequeue( this, type );
                }
            });
    },
    dequeue: function( type ) {
        return this.each(function() {
            jQuery.dequeue( this, type );
        });
    },
    clearQueue: function( type ) {
        return this.queue( type || "fx", [] );
    },
    // Get a promise resolved when queues of a certain type
    // are emptied (fx is the type by default)
    promise: function( type, obj ) {
        var tmp,
            count = 1,
            defer = jQuery.Deferred(),
            elements = this,
            i = this.length,
            resolve = function() {
                if ( !( --count ) ) {
                    defer.resolveWith( elements, [ elements ] );
                }
            };

        if ( typeof type !== "string" ) {
            obj = type;
            type = undefined;
        }
        type = type || "fx";

        while ( i-- ) {
            tmp = jQuery._data( elements[ i ], type + "queueHooks" );
            if ( tmp && tmp.empty ) {
                count++;
                tmp.empty.add( resolve );
            }
        }
        resolve();
        return defer.promise( obj );
    }
});
var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHidden = function( elem, el ) {
        // isHidden might be called from jQuery#filter function;
        // in that case, element will be second argument
        elem = el || elem;
        return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
    };



// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
    var i = 0,
        length = elems.length,
        bulk = key == null;

    // Sets many values
    if ( jQuery.type( key ) === "object" ) {
        chainable = true;
        for ( i in key ) {
            jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
        }

    // Sets one value
    } else if ( value !== undefined ) {
        chainable = true;

        if ( !jQuery.isFunction( value ) ) {
            raw = true;
        }

        if ( bulk ) {
            // Bulk operations run against the entire set
            if ( raw ) {
                fn.call( elems, value );
                fn = null;

            // ...except when executing function values
            } else {
                bulk = fn;
                fn = function( elem, key, value ) {
                    return bulk.call( jQuery( elem ), value );
                };
            }
        }

        if ( fn ) {
            for ( ; i < length; i++ ) {
                fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
            }
        }
    }

    return chainable ?
        elems :

        // Gets
        bulk ?
            fn.call( elems ) :
            length ? fn( elems[0], key ) : emptyGet;
};
var rcheckableType = (/^(?:checkbox|radio)$/i);



(function() {
    var fragment = document.createDocumentFragment(),
        div = document.createElement("div"),
        input = document.createElement("input");

    // Setup
    div.setAttribute( "className", "t" );
    div.innerHTML = "  <link/><table></table><a href='/a'>a</a>";

    // IE strips leading whitespace when .innerHTML is used
    support.leadingWhitespace = div.firstChild.nodeType === 3;

    // Make sure that tbody elements aren't automatically inserted
    // IE will insert them into empty tables
    support.tbody = !div.getElementsByTagName( "tbody" ).length;

    // Make sure that link elements get serialized correctly by innerHTML
    // This requires a wrapper element in IE
    support.htmlSerialize = !!div.getElementsByTagName( "link" ).length;

    // Makes sure cloning an html5 element does not cause problems
    // Where outerHTML is undefined, this still works
    support.html5Clone =
        document.createElement( "nav" ).cloneNode( true ).outerHTML !== "<:nav></:nav>";

    // Check if a disconnected checkbox will retain its checked
    // value of true after appended to the DOM (IE6/7)
    input.type = "checkbox";
    input.checked = true;
    fragment.appendChild( input );
    support.appendChecked = input.checked;

    // Make sure textarea (and checkbox) defaultValue is properly cloned
    // Support: IE6-IE11+
    div.innerHTML = "<textarea>x</textarea>";
    support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

    // #11217 - WebKit loses check when the name is after the checked attribute
    fragment.appendChild( div );
    div.innerHTML = "<input type='radio' checked='checked' name='t'/>";

    // Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3
    // old WebKit doesn't clone checked state correctly in fragments
    support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

    // Support: IE<9
    // Opera does not clone events (and typeof div.attachEvent === undefined).
    // IE9-10 clones events bound via attachEvent, but they don't trigger with .click()
    support.noCloneEvent = true;
    if ( div.attachEvent ) {
        div.attachEvent( "onclick", function() {
            support.noCloneEvent = false;
        });

        div.cloneNode( true ).click();
    }

    // Execute the test only if not already executed in another module.
    if (support.deleteExpando == null) {
        // Support: IE<9
        support.deleteExpando = true;
        try {
            delete div.test;
        } catch( e ) {
            support.deleteExpando = false;
        }
    }

    // Null elements to avoid leaks in IE.
    fragment = div = input = null;
})();


(function() {
    var i, eventName,
        div = document.createElement( "div" );

    // Support: IE<9 (lack submit/change bubble), Firefox 23+ (lack focusin event)
    for ( i in { submit: true, change: true, focusin: true }) {
        eventName = "on" + i;

        if ( !(support[ i + "Bubbles" ] = eventName in window) ) {
            // Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)
            div.setAttribute( eventName, "t" );
            support[ i + "Bubbles" ] = div.attributes[ eventName ].expando === false;
        }
    }

    // Null elements to avoid leaks in IE.
    div = null;
})();


var rformElems = /^(?:input|select|textarea)$/i,
    rkeyEvent = /^key/,
    rmouseEvent = /^(?:mouse|contextmenu)|click/,
    rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
    rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

function returnTrue() {
    return true;
}

function returnFalse() {
    return false;
}

function safeActiveElement() {
    try {
        return document.activeElement;
    } catch ( err ) { }
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

    global: {},

    add: function( elem, types, handler, data, selector ) {
        var tmp, events, t, handleObjIn,
            special, eventHandle, handleObj,
            handlers, type, namespaces, origType,
            elemData = jQuery._data( elem );

        // Don't attach events to noData or text/comment nodes (but allow plain objects)
        if ( !elemData ) {
            return;
        }

        // Caller can pass in an object of custom data in lieu of the handler
        if ( handler.handler ) {
            handleObjIn = handler;
            handler = handleObjIn.handler;
            selector = handleObjIn.selector;
        }

        // Make sure that the handler has a unique ID, used to find/remove it later
        if ( !handler.guid ) {
            handler.guid = jQuery.guid++;
        }

        // Init the element's event structure and main handler, if this is the first
        if ( !(events = elemData.events) ) {
            events = elemData.events = {};
        }
        if ( !(eventHandle = elemData.handle) ) {
            eventHandle = elemData.handle = function( e ) {
                // Discard the second event of a jQuery.event.trigger() and
                // when an event is called after a page has unloaded
                return typeof jQuery !== strundefined && (!e || jQuery.event.triggered !== e.type) ?
                    jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
                    undefined;
            };
            // Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
            eventHandle.elem = elem;
        }

        // Handle multiple events separated by a space
        types = ( types || "" ).match( rnotwhite ) || [ "" ];
        t = types.length;
        while ( t-- ) {
            tmp = rtypenamespace.exec( types[t] ) || [];
            type = origType = tmp[1];
            namespaces = ( tmp[2] || "" ).split( "." ).sort();

            // There *must* be a type, no attaching namespace-only handlers
            if ( !type ) {
                continue;
            }

            // If event changes its type, use the special event handlers for the changed type
            special = jQuery.event.special[ type ] || {};

            // If selector defined, determine special event api type, otherwise given type
            type = ( selector ? special.delegateType : special.bindType ) || type;

            // Update special based on newly reset type
            special = jQuery.event.special[ type ] || {};

            // handleObj is passed to all event handlers
            handleObj = jQuery.extend({
                type: type,
                origType: origType,
                data: data,
                handler: handler,
                guid: handler.guid,
                selector: selector,
                needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
                namespace: namespaces.join(".")
            }, handleObjIn );

            // Init the event handler queue if we're the first
            if ( !(handlers = events[ type ]) ) {
                handlers = events[ type ] = [];
                handlers.delegateCount = 0;

                // Only use addEventListener/attachEvent if the special events handler returns false
                if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
                    // Bind the global event handler to the element
                    if ( elem.addEventListener ) {
                        elem.addEventListener( type, eventHandle, false );

                    } else if ( elem.attachEvent ) {
                        elem.attachEvent( "on" + type, eventHandle );
                    }
                }
            }

            if ( special.add ) {
                special.add.call( elem, handleObj );

                if ( !handleObj.handler.guid ) {
                    handleObj.handler.guid = handler.guid;
                }
            }

            // Add to the element's handler list, delegates in front
            if ( selector ) {
                handlers.splice( handlers.delegateCount++, 0, handleObj );
            } else {
                handlers.push( handleObj );
            }

            // Keep track of which events have ever been used, for event optimization
            jQuery.event.global[ type ] = true;
        }

        // Nullify elem to prevent memory leaks in IE
        elem = null;
    },

    // Detach an event or set of events from an element
    remove: function( elem, types, handler, selector, mappedTypes ) {
        var j, handleObj, tmp,
            origCount, t, events,
            special, handlers, type,
            namespaces, origType,
            elemData = jQuery.hasData( elem ) && jQuery._data( elem );

        if ( !elemData || !(events = elemData.events) ) {
            return;
        }

        // Once for each type.namespace in types; type may be omitted
        types = ( types || "" ).match( rnotwhite ) || [ "" ];
        t = types.length;
        while ( t-- ) {
            tmp = rtypenamespace.exec( types[t] ) || [];
            type = origType = tmp[1];
            namespaces = ( tmp[2] || "" ).split( "." ).sort();

            // Unbind all events (on this namespace, if provided) for the element
            if ( !type ) {
                for ( type in events ) {
                    jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
                }
                continue;
            }

            special = jQuery.event.special[ type ] || {};
            type = ( selector ? special.delegateType : special.bindType ) || type;
            handlers = events[ type ] || [];
            tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

            // Remove matching events
            origCount = j = handlers.length;
            while ( j-- ) {
                handleObj = handlers[ j ];

                if ( ( mappedTypes || origType === handleObj.origType ) &&
                    ( !handler || handler.guid === handleObj.guid ) &&
                    ( !tmp || tmp.test( handleObj.namespace ) ) &&
                    ( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
                    handlers.splice( j, 1 );

                    if ( handleObj.selector ) {
                        handlers.delegateCount--;
                    }
                    if ( special.remove ) {
                        special.remove.call( elem, handleObj );
                    }
                }
            }

            // Remove generic event handler if we removed something and no more handlers exist
            // (avoids potential for endless recursion during removal of special event handlers)
            if ( origCount && !handlers.length ) {
                if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
                    jQuery.removeEvent( elem, type, elemData.handle );
                }

                delete events[ type ];
            }
        }

        // Remove the expando if it's no longer used
        if ( jQuery.isEmptyObject( events ) ) {
            delete elemData.handle;

            // removeData also checks for emptiness and clears the expando if empty
            // so use it instead of delete
            jQuery._removeData( elem, "events" );
        }
    },

    trigger: function( event, data, elem, onlyHandlers ) {
        var handle, ontype, cur,
            bubbleType, special, tmp, i,
            eventPath = [ elem || document ],
            type = hasOwn.call( event, "type" ) ? event.type : event,
            namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

        cur = tmp = elem = elem || document;

        // Don't do events on text and comment nodes
        if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
            return;
        }

        // focus/blur morphs to focusin/out; ensure we're not firing them right now
        if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
            return;
        }

        if ( type.indexOf(".") >= 0 ) {
            // Namespaced trigger; create a regexp to match event type in handle()
            namespaces = type.split(".");
            type = namespaces.shift();
            namespaces.sort();
        }
        ontype = type.indexOf(":") < 0 && "on" + type;

        // Caller can pass in a jQuery.Event object, Object, or just an event type string
        event = event[ jQuery.expando ] ?
            event :
            new jQuery.Event( type, typeof event === "object" && event );

        // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
        event.isTrigger = onlyHandlers ? 2 : 3;
        event.namespace = namespaces.join(".");
        event.namespace_re = event.namespace ?
            new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
            null;

        // Clean up the event in case it is being reused
        event.result = undefined;
        if ( !event.target ) {
            event.target = elem;
        }

        // Clone any incoming data and prepend the event, creating the handler arg list
        data = data == null ?
            [ event ] :
            jQuery.makeArray( data, [ event ] );

        // Allow special events to draw outside the lines
        special = jQuery.event.special[ type ] || {};
        if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
            return;
        }

        // Determine event propagation path in advance, per W3C events spec (#9951)
        // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
        if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

            bubbleType = special.delegateType || type;
            if ( !rfocusMorph.test( bubbleType + type ) ) {
                cur = cur.parentNode;
            }
            for ( ; cur; cur = cur.parentNode ) {
                eventPath.push( cur );
                tmp = cur;
            }

            // Only add window if we got to document (e.g., not plain obj or detached DOM)
            if ( tmp === (elem.ownerDocument || document) ) {
                eventPath.push( tmp.defaultView || tmp.parentWindow || window );
            }
        }

        // Fire handlers on the event path
        i = 0;
        while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

            event.type = i > 1 ?
                bubbleType :
                special.bindType || type;

            // jQuery handler
            handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
            if ( handle ) {
                handle.apply( cur, data );
            }

            // Native handler
            handle = ontype && cur[ ontype ];
            if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
                event.result = handle.apply( cur, data );
                if ( event.result === false ) {
                    event.preventDefault();
                }
            }
        }
        event.type = type;

        // If nobody prevented the default action, do it now
        if ( !onlyHandlers && !event.isDefaultPrevented() ) {

            if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
                jQuery.acceptData( elem ) ) {

                // Call a native DOM method on the target with the same name name as the event.
                // Can't use an .isFunction() check here because IE6/7 fails that test.
                // Don't do default actions on window, that's where global variables be (#6170)
                if ( ontype && elem[ type ] && !jQuery.isWindow( elem ) ) {

                    // Don't re-trigger an onFOO event when we call its FOO() method
                    tmp = elem[ ontype ];

                    if ( tmp ) {
                        elem[ ontype ] = null;
                    }

                    // Prevent re-triggering of the same event, since we already bubbled it above
                    jQuery.event.triggered = type;
                    try {
                        elem[ type ]();
                    } catch ( e ) {
                        // IE<9 dies on focus/blur to hidden element (#1486,#12518)
                        // only reproducible on winXP IE8 native, not IE9 in IE8 mode
                    }
                    jQuery.event.triggered = undefined;

                    if ( tmp ) {
                        elem[ ontype ] = tmp;
                    }
                }
            }
        }

        return event.result;
    },

    dispatch: function( event ) {

        // Make a writable jQuery.Event from the native event object
        event = jQuery.event.fix( event );

        var i, ret, handleObj, matched, j,
            handlerQueue = [],
            args = slice.call( arguments ),
            handlers = ( jQuery._data( this, "events" ) || {} )[ event.type ] || [],
            special = jQuery.event.special[ event.type ] || {};

        // Use the fix-ed jQuery.Event rather than the (read-only) native event
        args[0] = event;
        event.delegateTarget = this;

        // Call the preDispatch hook for the mapped type, and let it bail if desired
        if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
            return;
        }

        // Determine handlers
        handlerQueue = jQuery.event.handlers.call( this, event, handlers );

        // Run delegates first; they may want to stop propagation beneath us
        i = 0;
        while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
            event.currentTarget = matched.elem;

            j = 0;
            while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

                // Triggered event must either 1) have no namespace, or
                // 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
                if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

                    event.handleObj = handleObj;
                    event.data = handleObj.data;

                    ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
                            .apply( matched.elem, args );

                    if ( ret !== undefined ) {
                        if ( (event.result = ret) === false ) {
                            event.preventDefault();
                            event.stopPropagation();
                        }
                    }
                }
            }
        }

        // Call the postDispatch hook for the mapped type
        if ( special.postDispatch ) {
            special.postDispatch.call( this, event );
        }

        return event.result;
    },

    handlers: function( event, handlers ) {
        var sel, handleObj, matches, i,
            handlerQueue = [],
            delegateCount = handlers.delegateCount,
            cur = event.target;

        // Find delegate handlers
        // Black-hole SVG <use> instance trees (#13180)
        // Avoid non-left-click bubbling in Firefox (#3861)
        if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

            /* jshint eqeqeq: false */
            for ( ; cur != this; cur = cur.parentNode || this ) {
                /* jshint eqeqeq: true */

                // Don't check non-elements (#13208)
                // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
                if ( cur.nodeType === 1 && (cur.disabled !== true || event.type !== "click") ) {
                    matches = [];
                    for ( i = 0; i < delegateCount; i++ ) {
                        handleObj = handlers[ i ];

                        // Don't conflict with Object.prototype properties (#13203)
                        sel = handleObj.selector + " ";

                        if ( matches[ sel ] === undefined ) {
                            matches[ sel ] = handleObj.needsContext ?
                                jQuery( sel, this ).index( cur ) >= 0 :
                                jQuery.find( sel, this, null, [ cur ] ).length;
                        }
                        if ( matches[ sel ] ) {
                            matches.push( handleObj );
                        }
                    }
                    if ( matches.length ) {
                        handlerQueue.push({ elem: cur, handlers: matches });
                    }
                }
            }
        }

        // Add the remaining (directly-bound) handlers
        if ( delegateCount < handlers.length ) {
            handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
        }

        return handlerQueue;
    },

    fix: function( event ) {
        if ( event[ jQuery.expando ] ) {
            return event;
        }

        // Create a writable copy of the event object and normalize some properties
        var i, prop, copy,
            type = event.type,
            originalEvent = event,
            fixHook = this.fixHooks[ type ];

        if ( !fixHook ) {
            this.fixHooks[ type ] = fixHook =
                rmouseEvent.test( type ) ? this.mouseHooks :
                rkeyEvent.test( type ) ? this.keyHooks :
                {};
        }
        copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

        event = new jQuery.Event( originalEvent );

        i = copy.length;
        while ( i-- ) {
            prop = copy[ i ];
            event[ prop ] = originalEvent[ prop ];
        }

        // Support: IE<9
        // Fix target property (#1925)
        if ( !event.target ) {
            event.target = originalEvent.srcElement || document;
        }

        // Support: Chrome 23+, Safari?
        // Target should not be a text node (#504, #13143)
        if ( event.target.nodeType === 3 ) {
            event.target = event.target.parentNode;
        }

        // Support: IE<9
        // For mouse/key events, metaKey==false if it's undefined (#3368, #11328)
        event.metaKey = !!event.metaKey;

        return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
    },

    // Includes some event props shared by KeyEvent and MouseEvent
    props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

    fixHooks: {},

    keyHooks: {
        props: "char charCode key keyCode".split(" "),
        filter: function( event, original ) {

            // Add which for key events
            if ( event.which == null ) {
                event.which = original.charCode != null ? original.charCode : original.keyCode;
            }

            return event;
        }
    },

    mouseHooks: {
        props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
        filter: function( event, original ) {
            var body, eventDoc, doc,
                button = original.button,
                fromElement = original.fromElement;

            // Calculate pageX/Y if missing and clientX/Y available
            if ( event.pageX == null && original.clientX != null ) {
                eventDoc = event.target.ownerDocument || document;
                doc = eventDoc.documentElement;
                body = eventDoc.body;

                event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
                event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
            }

            // Add relatedTarget, if necessary
            if ( !event.relatedTarget && fromElement ) {
                event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
            }

            // Add which for click: 1 === left; 2 === middle; 3 === right
            // Note: button is not normalized, so don't use it
            if ( !event.which && button !== undefined ) {
                event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
            }

            return event;
        }
    },

    special: {
        load: {
            // Prevent triggered image.load events from bubbling to window.load
            noBubble: true
        },
        focus: {
            // Fire native event if possible so blur/focus sequence is correct
            trigger: function() {
                if ( this !== safeActiveElement() && this.focus ) {
                    try {
                        this.focus();
                        return false;
                    } catch ( e ) {
                        // Support: IE<9
                        // If we error on focus to hidden element (#1486, #12518),
                        // let .trigger() run the handlers
                    }
                }
            },
            delegateType: "focusin"
        },
        blur: {
            trigger: function() {
                if ( this === safeActiveElement() && this.blur ) {
                    this.blur();
                    return false;
                }
            },
            delegateType: "focusout"
        },
        click: {
            // For checkbox, fire native event so checked state will be right
            trigger: function() {
                if ( jQuery.nodeName( this, "input" ) && this.type === "checkbox" && this.click ) {
                    this.click();
                    return false;
                }
            },

            // For cross-browser consistency, don't fire native .click() on links
            _default: function( event ) {
                return jQuery.nodeName( event.target, "a" );
            }
        },

        beforeunload: {
            postDispatch: function( event ) {

                // Even when returnValue equals to undefined Firefox will still show alert
                if ( event.result !== undefined ) {
                    event.originalEvent.returnValue = event.result;
                }
            }
        }
    },

    simulate: function( type, elem, event, bubble ) {
        // Piggyback on a donor event to simulate a different one.
        // Fake originalEvent to avoid donor's stopPropagation, but if the
        // simulated event prevents default then we do the same on the donor.
        var e = jQuery.extend(
            new jQuery.Event(),
            event,
            {
                type: type,
                isSimulated: true,
                originalEvent: {}
            }
        );
        if ( bubble ) {
            jQuery.event.trigger( e, null, elem );
        } else {
            jQuery.event.dispatch.call( elem, e );
        }
        if ( e.isDefaultPrevented() ) {
            event.preventDefault();
        }
    }
};

jQuery.removeEvent = document.removeEventListener ?
    function( elem, type, handle ) {
        if ( elem.removeEventListener ) {
            elem.removeEventListener( type, handle, false );
        }
    } :
    function( elem, type, handle ) {
        var name = "on" + type;

        if ( elem.detachEvent ) {

            // #8545, #7054, preventing memory leaks for custom events in IE6-8
            // detachEvent needed property on element, by name of that event, to properly expose it to GC
            if ( typeof elem[ name ] === strundefined ) {
                elem[ name ] = null;
            }

            elem.detachEvent( name, handle );
        }
    };

jQuery.Event = function( src, props ) {
    // Allow instantiation without the 'new' keyword
    if ( !(this instanceof jQuery.Event) ) {
        return new jQuery.Event( src, props );
    }

    // Event object
    if ( src && src.type ) {
        this.originalEvent = src;
        this.type = src.type;

        // Events bubbling up the document may have been marked as prevented
        // by a handler lower down the tree; reflect the correct value.
        this.isDefaultPrevented = src.defaultPrevented ||
                src.defaultPrevented === undefined && (
                // Support: IE < 9
                src.returnValue === false ||
                // Support: Android < 4.0
                src.getPreventDefault && src.getPreventDefault() ) ?
            returnTrue :
            returnFalse;

    // Event type
    } else {
        this.type = src;
    }

    // Put explicitly provided properties onto the event object
    if ( props ) {
        jQuery.extend( this, props );
    }

    // Create a timestamp if incoming event doesn't have one
    this.timeStamp = src && src.timeStamp || jQuery.now();

    // Mark it as fixed
    this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse,

    preventDefault: function() {
        var e = this.originalEvent;

        this.isDefaultPrevented = returnTrue;
        if ( !e ) {
            return;
        }

        // If preventDefault exists, run it on the original event
        if ( e.preventDefault ) {
            e.preventDefault();

        // Support: IE
        // Otherwise set the returnValue property of the original event to false
        } else {
            e.returnValue = false;
        }
    },
    stopPropagation: function() {
        var e = this.originalEvent;

        this.isPropagationStopped = returnTrue;
        if ( !e ) {
            return;
        }
        // If stopPropagation exists, run it on the original event
        if ( e.stopPropagation ) {
            e.stopPropagation();
        }

        // Support: IE
        // Set the cancelBubble property of the original event to true
        e.cancelBubble = true;
    },
    stopImmediatePropagation: function() {
        this.isImmediatePropagationStopped = returnTrue;
        this.stopPropagation();
    }
};

// Create mouseenter/leave events using mouseover/out and event-time checks
jQuery.each({
    mouseenter: "mouseover",
    mouseleave: "mouseout"
}, function( orig, fix ) {
    jQuery.event.special[ orig ] = {
        delegateType: fix,
        bindType: fix,

        handle: function( event ) {
            var ret,
                target = this,
                related = event.relatedTarget,
                handleObj = event.handleObj;

            // For mousenter/leave call the handler if related is outside the target.
            // NB: No relatedTarget if the mouse left/entered the browser window
            if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
                event.type = handleObj.origType;
                ret = handleObj.handler.apply( this, arguments );
                event.type = fix;
            }
            return ret;
        }
    };
});

// IE submit delegation
if ( !support.submitBubbles ) {

    jQuery.event.special.submit = {
        setup: function() {
            // Only need this for delegated form submit events
            if ( jQuery.nodeName( this, "form" ) ) {
                return false;
            }

            // Lazy-add a submit handler when a descendant form may potentially be submitted
            jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
                // Node name check avoids a VML-related crash in IE (#9807)
                var elem = e.target,
                    form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
                if ( form && !jQuery._data( form, "submitBubbles" ) ) {
                    jQuery.event.add( form, "submit._submit", function( event ) {
                        event._submit_bubble = true;
                    });
                    jQuery._data( form, "submitBubbles", true );
                }
            });
            // return undefined since we don't need an event listener
        },

        postDispatch: function( event ) {
            // If form was submitted by the user, bubble the event up the tree
            if ( event._submit_bubble ) {
                delete event._submit_bubble;
                if ( this.parentNode && !event.isTrigger ) {
                    jQuery.event.simulate( "submit", this.parentNode, event, true );
                }
            }
        },

        teardown: function() {
            // Only need this for delegated form submit events
            if ( jQuery.nodeName( this, "form" ) ) {
                return false;
            }

            // Remove delegated handlers; cleanData eventually reaps submit handlers attached above
            jQuery.event.remove( this, "._submit" );
        }
    };
}

// IE change delegation and checkbox/radio fix
if ( !support.changeBubbles ) {

    jQuery.event.special.change = {

        setup: function() {

            if ( rformElems.test( this.nodeName ) ) {
                // IE doesn't fire change on a check/radio until blur; trigger it on click
                // after a propertychange. Eat the blur-change in special.change.handle.
                // This still fires onchange a second time for check/radio after blur.
                if ( this.type === "checkbox" || this.type === "radio" ) {
                    jQuery.event.add( this, "propertychange._change", function( event ) {
                        if ( event.originalEvent.propertyName === "checked" ) {
                            this._just_changed = true;
                        }
                    });
                    jQuery.event.add( this, "click._change", function( event ) {
                        if ( this._just_changed && !event.isTrigger ) {
                            this._just_changed = false;
                        }
                        // Allow triggered, simulated change events (#11500)
                        jQuery.event.simulate( "change", this, event, true );
                    });
                }
                return false;
            }
            // Delegated event; lazy-add a change handler on descendant inputs
            jQuery.event.add( this, "beforeactivate._change", function( e ) {
                var elem = e.target;

                if ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, "changeBubbles" ) ) {
                    jQuery.event.add( elem, "change._change", function( event ) {
                        if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
                            jQuery.event.simulate( "change", this.parentNode, event, true );
                        }
                    });
                    jQuery._data( elem, "changeBubbles", true );
                }
            });
        },

        handle: function( event ) {
            var elem = event.target;

            // Swallow native change events from checkbox/radio, we already triggered them above
            if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
                return event.handleObj.handler.apply( this, arguments );
            }
        },

        teardown: function() {
            jQuery.event.remove( this, "._change" );

            return !rformElems.test( this.nodeName );
        }
    };
}

// Create "bubbling" focus and blur events
if ( !support.focusinBubbles ) {
    jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

        // Attach a single capturing handler on the document while someone wants focusin/focusout
        var handler = function( event ) {
                jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
            };

        jQuery.event.special[ fix ] = {
            setup: function() {
                var doc = this.ownerDocument || this,
                    attaches = jQuery._data( doc, fix );

                if ( !attaches ) {
                    doc.addEventListener( orig, handler, true );
                }
                jQuery._data( doc, fix, ( attaches || 0 ) + 1 );
            },
            teardown: function() {
                var doc = this.ownerDocument || this,
                    attaches = jQuery._data( doc, fix ) - 1;

                if ( !attaches ) {
                    doc.removeEventListener( orig, handler, true );
                    jQuery._removeData( doc, fix );
                } else {
                    jQuery._data( doc, fix, attaches );
                }
            }
        };
    });
}

jQuery.fn.extend({

    on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
        var type, origFn;

        // Types can be a map of types/handlers
        if ( typeof types === "object" ) {
            // ( types-Object, selector, data )
            if ( typeof selector !== "string" ) {
                // ( types-Object, data )
                data = data || selector;
                selector = undefined;
            }
            for ( type in types ) {
                this.on( type, selector, data, types[ type ], one );
            }
            return this;
        }

        if ( data == null && fn == null ) {
            // ( types, fn )
            fn = selector;
            data = selector = undefined;
        } else if ( fn == null ) {
            if ( typeof selector === "string" ) {
                // ( types, selector, fn )
                fn = data;
                data = undefined;
            } else {
                // ( types, data, fn )
                fn = data;
                data = selector;
                selector = undefined;
            }
        }
        if ( fn === false ) {
            fn = returnFalse;
        } else if ( !fn ) {
            return this;
        }

        if ( one === 1 ) {
            origFn = fn;
            fn = function( event ) {
                // Can use an empty set, since event contains the info
                jQuery().off( event );
                return origFn.apply( this, arguments );
            };
            // Use same guid so caller can remove using origFn
            fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
        }
        return this.each( function() {
            jQuery.event.add( this, types, fn, data, selector );
        });
    },
    one: function( types, selector, data, fn ) {
        return this.on( types, selector, data, fn, 1 );
    },
    off: function( types, selector, fn ) {
        var handleObj, type;
        if ( types && types.preventDefault && types.handleObj ) {
            // ( event )  dispatched jQuery.Event
            handleObj = types.handleObj;
            jQuery( types.delegateTarget ).off(
                handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
                handleObj.selector,
                handleObj.handler
            );
            return this;
        }
        if ( typeof types === "object" ) {
            // ( types-object [, selector] )
            for ( type in types ) {
                this.off( type, selector, types[ type ] );
            }
            return this;
        }
        if ( selector === false || typeof selector === "function" ) {
            // ( types [, fn] )
            fn = selector;
            selector = undefined;
        }
        if ( fn === false ) {
            fn = returnFalse;
        }
        return this.each(function() {
            jQuery.event.remove( this, types, fn, selector );
        });
    },

    trigger: function( type, data ) {
        return this.each(function() {
            jQuery.event.trigger( type, data, this );
        });
    },
    triggerHandler: function( type, data ) {
        var elem = this[0];
        if ( elem ) {
            return jQuery.event.trigger( type, data, elem, true );
        }
    }
});


function createSafeFragment( document ) {
    var list = nodeNames.split( "|" ),
        safeFrag = document.createDocumentFragment();

    if ( safeFrag.createElement ) {
        while ( list.length ) {
            safeFrag.createElement(
                list.pop()
            );
        }
    }
    return safeFrag;
}

var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
        "header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
    rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
    rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
    rleadingWhitespace = /^\s+/,
    rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
    rtagName = /<([\w:]+)/,
    rtbody = /<tbody/i,
    rhtml = /<|&#?\w+;/,
    rnoInnerhtml = /<(?:script|style|link)/i,
    // checked="checked" or checked
    rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
    rscriptType = /^$|\/(?:java|ecma)script/i,
    rscriptTypeMasked = /^true\/(.*)/,
    rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

    // We have to close these tags to support XHTML (#13200)
    wrapMap = {
        option: [ 1, "<select multiple='multiple'>", "</select>" ],
        legend: [ 1, "<fieldset>", "</fieldset>" ],
        area: [ 1, "<map>", "</map>" ],
        param: [ 1, "<object>", "</object>" ],
        thead: [ 1, "<table>", "</table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

        // IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
        // unless wrapped in a div with non-breaking characters in front of it.
        _default: support.htmlSerialize ? [ 0, "", "" ] : [ 1, "X<div>", "</div>"  ]
    },
    safeFragment = createSafeFragment( document ),
    fragmentDiv = safeFragment.appendChild( document.createElement("div") );

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

function getAll( context, tag ) {
    var elems, elem,
        i = 0,
        found = typeof context.getElementsByTagName !== strundefined ? context.getElementsByTagName( tag || "*" ) :
            typeof context.querySelectorAll !== strundefined ? context.querySelectorAll( tag || "*" ) :
            undefined;

    if ( !found ) {
        for ( found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++ ) {
            if ( !tag || jQuery.nodeName( elem, tag ) ) {
                found.push( elem );
            } else {
                jQuery.merge( found, getAll( elem, tag ) );
            }
        }
    }

    return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
        jQuery.merge( [ context ], found ) :
        found;
}

// Used in buildFragment, fixes the defaultChecked property
function fixDefaultChecked( elem ) {
    if ( rcheckableType.test( elem.type ) ) {
        elem.defaultChecked = elem.checked;
    }
}

// Support: IE<8
// Manipulating tables requires a tbody
function manipulationTarget( elem, content ) {
    return jQuery.nodeName( elem, "table" ) &&
        jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

        elem.getElementsByTagName("tbody")[0] ||
            elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
        elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
    elem.type = (jQuery.find.attr( elem, "type" ) !== null) + "/" + elem.type;
    return elem;
}
function restoreScript( elem ) {
    var match = rscriptTypeMasked.exec( elem.type );
    if ( match ) {
        elem.type = match[1];
    } else {
        elem.removeAttribute("type");
    }
    return elem;
}

// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
    var elem,
        i = 0;
    for ( ; (elem = elems[i]) != null; i++ ) {
        jQuery._data( elem, "globalEval", !refElements || jQuery._data( refElements[i], "globalEval" ) );
    }
}

function cloneCopyEvent( src, dest ) {

    if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
        return;
    }

    var type, i, l,
        oldData = jQuery._data( src ),
        curData = jQuery._data( dest, oldData ),
        events = oldData.events;

    if ( events ) {
        delete curData.handle;
        curData.events = {};

        for ( type in events ) {
            for ( i = 0, l = events[ type ].length; i < l; i++ ) {
                jQuery.event.add( dest, type, events[ type ][ i ] );
            }
        }
    }

    // make the cloned public data object a copy from the original
    if ( curData.data ) {
        curData.data = jQuery.extend( {}, curData.data );
    }
}

function fixCloneNodeIssues( src, dest ) {
    var nodeName, e, data;

    // We do not need to do anything for non-Elements
    if ( dest.nodeType !== 1 ) {
        return;
    }

    nodeName = dest.nodeName.toLowerCase();

    // IE6-8 copies events bound via attachEvent when using cloneNode.
    if ( !support.noCloneEvent && dest[ jQuery.expando ] ) {
        data = jQuery._data( dest );

        for ( e in data.events ) {
            jQuery.removeEvent( dest, e, data.handle );
        }

        // Event data gets referenced instead of copied if the expando gets copied too
        dest.removeAttribute( jQuery.expando );
    }

    // IE blanks contents when cloning scripts, and tries to evaluate newly-set text
    if ( nodeName === "script" && dest.text !== src.text ) {
        disableScript( dest ).text = src.text;
        restoreScript( dest );

    // IE6-10 improperly clones children of object elements using classid.
    // IE10 throws NoModificationAllowedError if parent is null, #12132.
    } else if ( nodeName === "object" ) {
        if ( dest.parentNode ) {
            dest.outerHTML = src.outerHTML;
        }

        // This path appears unavoidable for IE9. When cloning an object
        // element in IE9, the outerHTML strategy above is not sufficient.
        // If the src has innerHTML and the destination does not,
        // copy the src.innerHTML into the dest.innerHTML. #10324
        if ( support.html5Clone && ( src.innerHTML && !jQuery.trim(dest.innerHTML) ) ) {
            dest.innerHTML = src.innerHTML;
        }

    } else if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
        // IE6-8 fails to persist the checked state of a cloned checkbox
        // or radio button. Worse, IE6-7 fail to give the cloned element
        // a checked appearance if the defaultChecked value isn't also set

        dest.defaultChecked = dest.checked = src.checked;

        // IE6-7 get confused and end up setting the value of a cloned
        // checkbox/radio button to an empty string instead of "on"
        if ( dest.value !== src.value ) {
            dest.value = src.value;
        }

    // IE6-8 fails to return the selected option to the default selected
    // state when cloning options
    } else if ( nodeName === "option" ) {
        dest.defaultSelected = dest.selected = src.defaultSelected;

    // IE6-8 fails to set the defaultValue to the correct value when
    // cloning other types of input fields
    } else if ( nodeName === "input" || nodeName === "textarea" ) {
        dest.defaultValue = src.defaultValue;
    }
}

jQuery.extend({
    clone: function( elem, dataAndEvents, deepDataAndEvents ) {
        var destElements, node, clone, i, srcElements,
            inPage = jQuery.contains( elem.ownerDocument, elem );

        if ( support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( "<" + elem.nodeName + ">" ) ) {
            clone = elem.cloneNode( true );

        // IE<=8 does not properly clone detached, unknown element nodes
        } else {
            fragmentDiv.innerHTML = elem.outerHTML;
            fragmentDiv.removeChild( clone = fragmentDiv.firstChild );
        }

        if ( (!support.noCloneEvent || !support.noCloneChecked) &&
                (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {

            // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
            destElements = getAll( clone );
            srcElements = getAll( elem );

            // Fix all IE cloning issues
            for ( i = 0; (node = srcElements[i]) != null; ++i ) {
                // Ensure that the destination node is not null; Fixes #9587
                if ( destElements[i] ) {
                    fixCloneNodeIssues( node, destElements[i] );
                }
            }
        }

        // Copy the events from the original to the clone
        if ( dataAndEvents ) {
            if ( deepDataAndEvents ) {
                srcElements = srcElements || getAll( elem );
                destElements = destElements || getAll( clone );

                for ( i = 0; (node = srcElements[i]) != null; i++ ) {
                    cloneCopyEvent( node, destElements[i] );
                }
            } else {
                cloneCopyEvent( elem, clone );
            }
        }

        // Preserve script evaluation history
        destElements = getAll( clone, "script" );
        if ( destElements.length > 0 ) {
            setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
        }

        destElements = srcElements = node = null;

        // Return the cloned set
        return clone;
    },

    buildFragment: function( elems, context, scripts, selection ) {
        var j, elem, contains,
            tmp, tag, tbody, wrap,
            l = elems.length,

            // Ensure a safe fragment
            safe = createSafeFragment( context ),

            nodes = [],
            i = 0;

        for ( ; i < l; i++ ) {
            elem = elems[ i ];

            if ( elem || elem === 0 ) {

                // Add nodes directly
                if ( jQuery.type( elem ) === "object" ) {
                    jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

                // Convert non-html into a text node
                } else if ( !rhtml.test( elem ) ) {
                    nodes.push( context.createTextNode( elem ) );

                // Convert html into DOM nodes
                } else {
                    tmp = tmp || safe.appendChild( context.createElement("div") );

                    // Deserialize a standard representation
                    tag = (rtagName.exec( elem ) || [ "", "" ])[ 1 ].toLowerCase();
                    wrap = wrapMap[ tag ] || wrapMap._default;

                    tmp.innerHTML = wrap[1] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[2];

                    // Descend through wrappers to the right content
                    j = wrap[0];
                    while ( j-- ) {
                        tmp = tmp.lastChild;
                    }

                    // Manually add leading whitespace removed by IE
                    if ( !support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
                        nodes.push( context.createTextNode( rleadingWhitespace.exec( elem )[0] ) );
                    }

                    // Remove IE's autoinserted <tbody> from table fragments
                    if ( !support.tbody ) {

                        // String was a <table>, *may* have spurious <tbody>
                        elem = tag === "table" && !rtbody.test( elem ) ?
                            tmp.firstChild :

                            // String was a bare <thead> or <tfoot>
                            wrap[1] === "<table>" && !rtbody.test( elem ) ?
                                tmp :
                                0;

                        j = elem && elem.childNodes.length;
                        while ( j-- ) {
                            if ( jQuery.nodeName( (tbody = elem.childNodes[j]), "tbody" ) && !tbody.childNodes.length ) {
                                elem.removeChild( tbody );
                            }
                        }
                    }

                    jQuery.merge( nodes, tmp.childNodes );

                    // Fix #12392 for WebKit and IE > 9
                    tmp.textContent = "";

                    // Fix #12392 for oldIE
                    while ( tmp.firstChild ) {
                        tmp.removeChild( tmp.firstChild );
                    }

                    // Remember the top-level container for proper cleanup
                    tmp = safe.lastChild;
                }
            }
        }

        // Fix #11356: Clear elements from fragment
        if ( tmp ) {
            safe.removeChild( tmp );
        }

        // Reset defaultChecked for any radios and checkboxes
        // about to be appended to the DOM in IE 6/7 (#8060)
        if ( !support.appendChecked ) {
            jQuery.grep( getAll( nodes, "input" ), fixDefaultChecked );
        }

        i = 0;
        while ( (elem = nodes[ i++ ]) ) {

            // #4087 - If origin and destination elements are the same, and this is
            // that element, do not do anything
            if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
                continue;
            }

            contains = jQuery.contains( elem.ownerDocument, elem );

            // Append to fragment
            tmp = getAll( safe.appendChild( elem ), "script" );

            // Preserve script evaluation history
            if ( contains ) {
                setGlobalEval( tmp );
            }

            // Capture executables
            if ( scripts ) {
                j = 0;
                while ( (elem = tmp[ j++ ]) ) {
                    if ( rscriptType.test( elem.type || "" ) ) {
                        scripts.push( elem );
                    }
                }
            }
        }

        tmp = null;

        return safe;
    },

    cleanData: function( elems, /* internal */ acceptData ) {
        var elem, type, id, data,
            i = 0,
            internalKey = jQuery.expando,
            cache = jQuery.cache,
            deleteExpando = support.deleteExpando,
            special = jQuery.event.special;

        for ( ; (elem = elems[i]) != null; i++ ) {
            if ( acceptData || jQuery.acceptData( elem ) ) {

                id = elem[ internalKey ];
                data = id && cache[ id ];

                if ( data ) {
                    if ( data.events ) {
                        for ( type in data.events ) {
                            if ( special[ type ] ) {
                                jQuery.event.remove( elem, type );

                            // This is a shortcut to avoid jQuery.event.remove's overhead
                            } else {
                                jQuery.removeEvent( elem, type, data.handle );
                            }
                        }
                    }

                    // Remove cache only if it was not already removed by jQuery.event.remove
                    if ( cache[ id ] ) {

                        delete cache[ id ];

                        // IE does not allow us to delete expando properties from nodes,
                        // nor does it have a removeAttribute function on Document nodes;
                        // we must handle all of these cases
                        if ( deleteExpando ) {
                            delete elem[ internalKey ];

                        } else if ( typeof elem.removeAttribute !== strundefined ) {
                            elem.removeAttribute( internalKey );

                        } else {
                            elem[ internalKey ] = null;
                        }

                        deletedIds.push( id );
                    }
                }
            }
        }
    }
});

jQuery.fn.extend({
    text: function( value ) {
        return access( this, function( value ) {
            return value === undefined ?
                jQuery.text( this ) :
                this.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );
        }, null, value, arguments.length );
    },

    append: function() {
        return this.domManip( arguments, function( elem ) {
            if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
                var target = manipulationTarget( this, elem );
                target.appendChild( elem );
            }
        });
    },

    prepend: function() {
        return this.domManip( arguments, function( elem ) {
            if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
                var target = manipulationTarget( this, elem );
                target.insertBefore( elem, target.firstChild );
            }
        });
    },

    before: function() {
        return this.domManip( arguments, function( elem ) {
            if ( this.parentNode ) {
                this.parentNode.insertBefore( elem, this );
            }
        });
    },

    after: function() {
        return this.domManip( arguments, function( elem ) {
            if ( this.parentNode ) {
                this.parentNode.insertBefore( elem, this.nextSibling );
            }
        });
    },

    remove: function( selector, keepData /* Internal Use Only */ ) {
        var elem,
            elems = selector ? jQuery.filter( selector, this ) : this,
            i = 0;

        for ( ; (elem = elems[i]) != null; i++ ) {

            if ( !keepData && elem.nodeType === 1 ) {
                jQuery.cleanData( getAll( elem ) );
            }

            if ( elem.parentNode ) {
                if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
                    setGlobalEval( getAll( elem, "script" ) );
                }
                elem.parentNode.removeChild( elem );
            }
        }

        return this;
    },

    empty: function() {
        var elem,
            i = 0;

        for ( ; (elem = this[i]) != null; i++ ) {
            // Remove element nodes and prevent memory leaks
            if ( elem.nodeType === 1 ) {
                jQuery.cleanData( getAll( elem, false ) );
            }

            // Remove any remaining nodes
            while ( elem.firstChild ) {
                elem.removeChild( elem.firstChild );
            }

            // If this is a select, ensure that it displays empty (#12336)
            // Support: IE<9
            if ( elem.options && jQuery.nodeName( elem, "select" ) ) {
                elem.options.length = 0;
            }
        }

        return this;
    },

    clone: function( dataAndEvents, deepDataAndEvents ) {
        dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
        deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

        return this.map(function() {
            return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
        });
    },

    html: function( value ) {
        return access( this, function( value ) {
            var elem = this[ 0 ] || {},
                i = 0,
                l = this.length;

            if ( value === undefined ) {
                return elem.nodeType === 1 ?
                    elem.innerHTML.replace( rinlinejQuery, "" ) :
                    undefined;
            }

            // See if we can take a shortcut and just use innerHTML
            if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
                ( support.htmlSerialize || !rnoshimcache.test( value )  ) &&
                ( support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&
                !wrapMap[ (rtagName.exec( value ) || [ "", "" ])[ 1 ].toLowerCase() ] ) {

                value = value.replace( rxhtmlTag, "<$1></$2>" );

                try {
                    for (; i < l; i++ ) {
                        // Remove element nodes and prevent memory leaks
                        elem = this[i] || {};
                        if ( elem.nodeType === 1 ) {
                            jQuery.cleanData( getAll( elem, false ) );
                            elem.innerHTML = value;
                        }
                    }

                    elem = 0;

                // If using innerHTML throws an exception, use the fallback method
                } catch(e) {}
            }

            if ( elem ) {
                this.empty().append( value );
            }
        }, null, value, arguments.length );
    },

    replaceWith: function() {
        var arg = arguments[ 0 ];

        // Make the changes, replacing each context element with the new content
        this.domManip( arguments, function( elem ) {
            arg = this.parentNode;

            jQuery.cleanData( getAll( this ) );

            if ( arg ) {
                arg.replaceChild( elem, this );
            }
        });

        // Force removal if there was no new content (e.g., from empty arguments)
        return arg && (arg.length || arg.nodeType) ? this : this.remove();
    },

    detach: function( selector ) {
        return this.remove( selector, true );
    },

    domManip: function( args, callback ) {

        // Flatten any nested arrays
        args = concat.apply( [], args );

        var first, node, hasScripts,
            scripts, doc, fragment,
            i = 0,
            l = this.length,
            set = this,
            iNoClone = l - 1,
            value = args[0],
            isFunction = jQuery.isFunction( value );

        // We can't cloneNode fragments that contain checked, in WebKit
        if ( isFunction ||
                ( l > 1 && typeof value === "string" &&
                    !support.checkClone && rchecked.test( value ) ) ) {
            return this.each(function( index ) {
                var self = set.eq( index );
                if ( isFunction ) {
                    args[0] = value.call( this, index, self.html() );
                }
                self.domManip( args, callback );
            });
        }

        if ( l ) {
            fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
            first = fragment.firstChild;

            if ( fragment.childNodes.length === 1 ) {
                fragment = first;
            }

            if ( first ) {
                scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
                hasScripts = scripts.length;

                // Use the original fragment for the last item instead of the first because it can end up
                // being emptied incorrectly in certain situations (#8070).
                for ( ; i < l; i++ ) {
                    node = fragment;

                    if ( i !== iNoClone ) {
                        node = jQuery.clone( node, true, true );

                        // Keep references to cloned scripts for later restoration
                        if ( hasScripts ) {
                            jQuery.merge( scripts, getAll( node, "script" ) );
                        }
                    }

                    callback.call( this[i], node, i );
                }

                if ( hasScripts ) {
                    doc = scripts[ scripts.length - 1 ].ownerDocument;

                    // Reenable scripts
                    jQuery.map( scripts, restoreScript );

                    // Evaluate executable scripts on first document insertion
                    for ( i = 0; i < hasScripts; i++ ) {
                        node = scripts[ i ];
                        if ( rscriptType.test( node.type || "" ) &&
                            !jQuery._data( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

                            if ( node.src ) {
                                // Optional AJAX dependency, but won't run scripts if not present
                                if ( jQuery._evalUrl ) {
                                    jQuery._evalUrl( node.src );
                                }
                            } else {
                                jQuery.globalEval( ( node.text || node.textContent || node.innerHTML || "" ).replace( rcleanScript, "" ) );
                            }
                        }
                    }
                }

                // Fix #11809: Avoid leaking memory
                fragment = first = null;
            }
        }

        return this;
    }
});

jQuery.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
}, function( name, original ) {
    jQuery.fn[ name ] = function( selector ) {
        var elems,
            i = 0,
            ret = [],
            insert = jQuery( selector ),
            last = insert.length - 1;

        for ( ; i <= last; i++ ) {
            elems = i === last ? this : this.clone(true);
            jQuery( insert[i] )[ original ]( elems );

            // Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()
            push.apply( ret, elems.get() );
        }

        return this.pushStack( ret );
    };
});


var iframe,
    elemdisplay = {};

/**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */
// Called only from within defaultDisplay
function actualDisplay( name, doc ) {
    var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

        // getDefaultComputedStyle might be reliably used only on attached element
        display = window.getDefaultComputedStyle ?

            // Use of this method is a temporary fix (more like optmization) until something better comes along,
            // since it was removed from specification and supported only in FF
            window.getDefaultComputedStyle( elem[ 0 ] ).display : jQuery.css( elem[ 0 ], "display" );

    // We don't have any data stored on the element,
    // so use "detach" method as fast way to get rid of the element
    elem.detach();

    return display;
}

/**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
function defaultDisplay( nodeName ) {
    var doc = document,
        display = elemdisplay[ nodeName ];

    if ( !display ) {
        display = actualDisplay( nodeName, doc );

        // If the simple way fails, read from inside an iframe
        if ( display === "none" || !display ) {

            // Use the already-created iframe if possible
            iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );

            // Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
            doc = ( iframe[ 0 ].contentWindow || iframe[ 0 ].contentDocument ).document;

            // Support: IE
            doc.write();
            doc.close();

            display = actualDisplay( nodeName, doc );
            iframe.detach();
        }

        // Store the correct default display
        elemdisplay[ nodeName ] = display;
    }

    return display;
}


(function() {
    var a, shrinkWrapBlocksVal,
        div = document.createElement( "div" ),
        // Support: Firefox<29, Android 2.3 (Prefixed box-sizing versions).
        divReset =
            "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;" +
            "display:block;padding:0;margin:0;border:0";

    // Setup
    div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
    a = div.getElementsByTagName( "a" )[ 0 ];

    a.style.cssText = "float:left;opacity:.5";

    // Make sure that element opacity exists
    // (IE uses filter instead)
    // Use a regex to work around a WebKit issue. See #5145
    support.opacity = /^0.5/.test( a.style.opacity );

    // Verify style float existence
    // (IE uses styleFloat instead of cssFloat)
    support.cssFloat = !!a.style.cssFloat;

    div.style.backgroundClip = "content-box";
    div.cloneNode( true ).style.backgroundClip = "";
    support.clearCloneStyle = div.style.backgroundClip === "content-box";

    // Null elements to avoid leaks in IE.
    a = div = null;

    support.shrinkWrapBlocks = function() {
        var body, container, div, containerStyles;

        if ( shrinkWrapBlocksVal == null ) {
            body = document.getElementsByTagName( "body" )[ 0 ];
            if ( !body ) {
                // Test fired too early or in an unsupported environment, exit.
                return;
            }

            containerStyles = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px";
            container = document.createElement( "div" );
            div = document.createElement( "div" );

            body.appendChild( container ).appendChild( div );

            // Will be changed later if needed.
            shrinkWrapBlocksVal = false;

            if ( typeof div.style.zoom !== strundefined ) {
                // Support: IE6
                // Check if elements with layout shrink-wrap their children
                div.style.cssText = divReset + ";width:1px;padding:1px;zoom:1";
                div.innerHTML = "<div></div>";
                div.firstChild.style.width = "5px";
                shrinkWrapBlocksVal = div.offsetWidth !== 3;
            }

            body.removeChild( container );

            // Null elements to avoid leaks in IE.
            body = container = div = null;
        }

        return shrinkWrapBlocksVal;
    };

})();
var rmargin = (/^margin/);

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );



var getStyles, curCSS,
    rposition = /^(top|right|bottom|left)$/;

if ( window.getComputedStyle ) {
    getStyles = function( elem ) {
        return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
    };

    curCSS = function( elem, name, computed ) {
        var width, minWidth, maxWidth, ret,
            style = elem.style;

        computed = computed || getStyles( elem );

        // getPropertyValue is only needed for .css('filter') in IE9, see #12537
        ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined;

        if ( computed ) {

            if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
                ret = jQuery.style( elem, name );
            }

            // A tribute to the "awesome hack by Dean Edwards"
            // Chrome < 17 and Safari 5.0 uses "computed value" instead of "used value" for margin-right
            // Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
            // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
            if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

                // Remember the original values
                width = style.width;
                minWidth = style.minWidth;
                maxWidth = style.maxWidth;

                // Put in the new values to get a computed value out
                style.minWidth = style.maxWidth = style.width = ret;
                ret = computed.width;

                // Revert the changed values
                style.width = width;
                style.minWidth = minWidth;
                style.maxWidth = maxWidth;
            }
        }

        // Support: IE
        // IE returns zIndex value as an integer.
        return ret === undefined ?
            ret :
            ret + "";
    };
} else if ( document.documentElement.currentStyle ) {
    getStyles = function( elem ) {
        return elem.currentStyle;
    };

    curCSS = function( elem, name, computed ) {
        var left, rs, rsLeft, ret,
            style = elem.style;

        computed = computed || getStyles( elem );
        ret = computed ? computed[ name ] : undefined;

        // Avoid setting ret to empty string here
        // so we don't default to auto
        if ( ret == null && style && style[ name ] ) {
            ret = style[ name ];
        }

        // From the awesome hack by Dean Edwards
        // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

        // If we're not dealing with a regular pixel number
        // but a number that has a weird ending, we need to convert it to pixels
        // but not position css attributes, as those are proportional to the parent element instead
        // and we can't measure the parent instead because it might trigger a "stacking dolls" problem
        if ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {

            // Remember the original values
            left = style.left;
            rs = elem.runtimeStyle;
            rsLeft = rs && rs.left;

            // Put in the new values to get a computed value out
            if ( rsLeft ) {
                rs.left = elem.currentStyle.left;
            }
            style.left = name === "fontSize" ? "1em" : ret;
            ret = style.pixelLeft + "px";

            // Revert the changed values
            style.left = left;
            if ( rsLeft ) {
                rs.left = rsLeft;
            }
        }

        // Support: IE
        // IE returns zIndex value as an integer.
        return ret === undefined ?
            ret :
            ret + "" || "auto";
    };
}




function addGetHookIf( conditionFn, hookFn ) {
    // Define the hook, we'll check on the first run if it's really needed.
    return {
        get: function() {
            var condition = conditionFn();

            if ( condition == null ) {
                // The test was not ready at this point; screw the hook this time
                // but check again when needed next time.
                return;
            }

            if ( condition ) {
                // Hook not needed (or it's not possible to use it due to missing dependency),
                // remove it.
                // Since there are no other hooks for marginRight, remove the whole object.
                delete this.get;
                return;
            }

            // Hook needed; redefine it so that the support test is not executed again.

            return (this.get = hookFn).apply( this, arguments );
        }
    };
}


(function() {
    var a, reliableHiddenOffsetsVal, boxSizingVal, boxSizingReliableVal,
        pixelPositionVal,
        div = document.createElement( "div" ),
        containerStyles = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px",
        // Support: Firefox<29, Android 2.3 (Prefixed box-sizing versions).
        divReset =
            "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;" +
            "display:block;padding:0;margin:0;border:0";

    // Setup
    div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
    a = div.getElementsByTagName( "a" )[ 0 ];

    a.style.cssText = "float:left;opacity:.5";

    // Make sure that element opacity exists
    // (IE uses filter instead)
    // Use a regex to work around a WebKit issue. See #5145
    support.opacity = /^0.5/.test( a.style.opacity );

    // Verify style float existence
    // (IE uses styleFloat instead of cssFloat)
    support.cssFloat = !!a.style.cssFloat;

    div.style.backgroundClip = "content-box";
    div.cloneNode( true ).style.backgroundClip = "";
    support.clearCloneStyle = div.style.backgroundClip === "content-box";

    // Null elements to avoid leaks in IE.
    a = div = null;

    jQuery.extend(support, {
        reliableHiddenOffsets: function() {
            if ( reliableHiddenOffsetsVal != null ) {
                return reliableHiddenOffsetsVal;
            }

            var container, tds, isSupported,
                div = document.createElement( "div" ),
                body = document.getElementsByTagName( "body" )[ 0 ];

            if ( !body ) {
                // Return for frameset docs that don't have a body
                return;
            }

            // Setup
            div.setAttribute( "className", "t" );
            div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";

            container = document.createElement( "div" );
            container.style.cssText = containerStyles;

            body.appendChild( container ).appendChild( div );

            // Support: IE8
            // Check if table cells still have offsetWidth/Height when they are set
            // to display:none and there are still other visible table cells in a
            // table row; if so, offsetWidth/Height are not reliable for use when
            // determining if an element has been hidden directly using
            // display:none (it is still safe to use offsets if a parent element is
            // hidden; don safety goggles and see bug #4512 for more information).
            div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
            tds = div.getElementsByTagName( "td" );
            tds[ 0 ].style.cssText = "padding:0;margin:0;border:0;display:none";
            isSupported = ( tds[ 0 ].offsetHeight === 0 );

            tds[ 0 ].style.display = "";
            tds[ 1 ].style.display = "none";

            // Support: IE8
            // Check if empty table cells still have offsetWidth/Height
            reliableHiddenOffsetsVal = isSupported && ( tds[ 0 ].offsetHeight === 0 );

            body.removeChild( container );

            // Null elements to avoid leaks in IE.
            div = body = null;

            return reliableHiddenOffsetsVal;
        },

        boxSizing: function() {
            if ( boxSizingVal == null ) {
                computeStyleTests();
            }
            return boxSizingVal;
        },

        boxSizingReliable: function() {
            if ( boxSizingReliableVal == null ) {
                computeStyleTests();
            }
            return boxSizingReliableVal;
        },

        pixelPosition: function() {
            if ( pixelPositionVal == null ) {
                computeStyleTests();
            }
            return pixelPositionVal;
        },

        // Support: Android 2.3
        reliableMarginRight: function() {
            var body, container, div, marginDiv,
                // Support: IE<9.
                // IE should pass the test but we're using getComputedStyle
                // to compute it so just return true if the method is not present.
                reliableMarginRightVal = true;

            // Use window.getComputedStyle because jsdom on node.js will break without it.
            if ( window.getComputedStyle ) {
                body = document.getElementsByTagName( "body" )[ 0 ];
                if ( !body ) {
                    // Test fired too early or in an unsupported environment, exit.
                    return;
                }

                container = document.createElement( "div" );
                div = document.createElement( "div" );
                container.style.cssText = containerStyles;

                body.appendChild( container ).appendChild( div );

                // Check if div with explicit width and no margin-right incorrectly
                // gets computed margin-right based on width of container. (#3333)
                // Fails in WebKit before Feb 2011 nightlies
                // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                marginDiv = div.appendChild( document.createElement( "div" ) );
                marginDiv.style.cssText = div.style.cssText = divReset;
                marginDiv.style.marginRight = marginDiv.style.width = "0";
                div.style.width = "1px";

                reliableMarginRightVal =
                    !parseFloat( ( window.getComputedStyle( marginDiv, null ) || {} ).marginRight );

                body.removeChild( container );
            }

            return reliableMarginRightVal;
        }
    });

    function computeStyleTests() {
        var container, div,
            body = document.getElementsByTagName( "body" )[ 0 ];

        if ( !body ) {
            // Test fired too early or in an unsupported environment, exit.
            return;
        }

        container = document.createElement( "div" );
        div = document.createElement( "div" );
        container.style.cssText = containerStyles;

        body.appendChild( container ).appendChild( div );

        // Support: Firefox<29, Android 2.3 (Prefixed box-sizing versions).
        div.style.cssText =
            "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;" +
                "position:absolute;display:block;padding:1px;border:1px;width:4px;" +
                "margin-top:1%;top:1%";

        // Workaround failing boxSizing test due to offsetWidth returning wrong value
        // with some non-1 values of body zoom, ticket #13543
        jQuery.swap( body, body.style.zoom != null ? { zoom: 1 } : {}, function() {
            boxSizingVal = div.offsetWidth === 4;
        });

        // Will be changed later if needed.
        boxSizingReliableVal = true;
        pixelPositionVal = false;

        // Use window.getComputedStyle because jsdom on node.js will break without it.
        if ( window.getComputedStyle ) {
            pixelPositionVal = ( window.getComputedStyle( div, null ) || {} ).top !== "1%";
            boxSizingReliableVal =
                ( window.getComputedStyle( div, null ) || { width: "4px" } ).width === "4px";
        }

        body.removeChild( container );

        // Null elements to avoid leaks in IE.
        div = body = null;
    }

})();


// A method for quickly swapping in/out CSS properties to get correct calculations.
jQuery.swap = function( elem, options, callback, args ) {
    var ret, name,
        old = {};

    // Remember the old values, and insert the new ones
    for ( name in options ) {
        old[ name ] = elem.style[ name ];
        elem.style[ name ] = options[ name ];
    }

    ret = callback.apply( elem, args || [] );

    // Revert the old values
    for ( name in options ) {
        elem.style[ name ] = old[ name ];
    }

    return ret;
};


var
        ralpha = /alpha\([^)]*\)/i,
    ropacity = /opacity\s*=\s*([^)]*)/,

    // swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
    // see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
    rdisplayswap = /^(none|table(?!-c[ea]).+)/,
    rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
    rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),

    cssShow = { position: "absolute", visibility: "hidden", display: "block" },
    cssNormalTransform = {
        letterSpacing: 0,
        fontWeight: 400
    },

    cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];


// return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

    // shortcut for names that are not vendor prefixed
    if ( name in style ) {
        return name;
    }

    // check for vendor prefixed names
    var capName = name.charAt(0).toUpperCase() + name.slice(1),
        origName = name,
        i = cssPrefixes.length;

    while ( i-- ) {
        name = cssPrefixes[ i ] + capName;
        if ( name in style ) {
            return name;
        }
    }

    return origName;
}

function showHide( elements, show ) {
    var display, elem, hidden,
        values = [],
        index = 0,
        length = elements.length;

    for ( ; index < length; index++ ) {
        elem = elements[ index ];
        if ( !elem.style ) {
            continue;
        }

        values[ index ] = jQuery._data( elem, "olddisplay" );
        display = elem.style.display;
        if ( show ) {
            // Reset the inline display of this element to learn if it is
            // being hidden by cascaded rules or not
            if ( !values[ index ] && display === "none" ) {
                elem.style.display = "";
            }

            // Set elements which have been overridden with display: none
            // in a stylesheet to whatever the default browser style is
            // for such an element
            if ( elem.style.display === "" && isHidden( elem ) ) {
                values[ index ] = jQuery._data( elem, "olddisplay", defaultDisplay(elem.nodeName) );
            }
        } else {

            if ( !values[ index ] ) {
                hidden = isHidden( elem );

                if ( display && display !== "none" || !hidden ) {
                    jQuery._data( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
                }
            }
        }
    }

    // Set the display of most of the elements in a second loop
    // to avoid the constant reflow
    for ( index = 0; index < length; index++ ) {
        elem = elements[ index ];
        if ( !elem.style ) {
            continue;
        }
        if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
            elem.style.display = show ? values[ index ] || "" : "none";
        }
    }

    return elements;
}

function setPositiveNumber( elem, value, subtract ) {
    var matches = rnumsplit.exec( value );
    return matches ?
        // Guard against undefined "subtract", e.g., when used as in cssHooks
        Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
        value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
    var i = extra === ( isBorderBox ? "border" : "content" ) ?
        // If we already have the right measurement, avoid augmentation
        4 :
        // Otherwise initialize for horizontal or vertical properties
        name === "width" ? 1 : 0,

        val = 0;

    for ( ; i < 4; i += 2 ) {
        // both box models exclude margin, so add it if we want it
        if ( extra === "margin" ) {
            val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
        }

        if ( isBorderBox ) {
            // border-box includes padding, so remove it if we want content
            if ( extra === "content" ) {
                val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
            }

            // at this point, extra isn't border nor margin, so remove border
            if ( extra !== "margin" ) {
                val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
            }
        } else {
            // at this point, extra isn't content, so add padding
            val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

            // at this point, extra isn't content nor padding, so add border
            if ( extra !== "padding" ) {
                val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
            }
        }
    }

    return val;
}

function getWidthOrHeight( elem, name, extra ) {

    // Start with offset property, which is equivalent to the border-box value
    var valueIsBorderBox = true,
        val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
        styles = getStyles( elem ),
        isBorderBox = support.boxSizing() && jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

    // some non-html elements return undefined for offsetWidth, so check for null/undefined
    // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
    // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
    if ( val <= 0 || val == null ) {
        // Fall back to computed then uncomputed css if necessary
        val = curCSS( elem, name, styles );
        if ( val < 0 || val == null ) {
            val = elem.style[ name ];
        }

        // Computed unit is not pixels. Stop here and return.
        if ( rnumnonpx.test(val) ) {
            return val;
        }

        // we need the check for style in case a browser which returns unreliable values
        // for getComputedStyle silently falls back to the reliable elem.style
        valueIsBorderBox = isBorderBox && ( support.boxSizingReliable() || val === elem.style[ name ] );

        // Normalize "", auto, and prepare for extra
        val = parseFloat( val ) || 0;
    }

    // use the active box-sizing model to add/subtract irrelevant styles
    return ( val +
        augmentWidthOrHeight(
            elem,
            name,
            extra || ( isBorderBox ? "border" : "content" ),
            valueIsBorderBox,
            styles
        )
    ) + "px";
}

jQuery.extend({
    // Add in style property hooks for overriding the default
    // behavior of getting and setting a style property
    cssHooks: {
        opacity: {
            get: function( elem, computed ) {
                if ( computed ) {
                    // We should always get a number back from opacity
                    var ret = curCSS( elem, "opacity" );
                    return ret === "" ? "1" : ret;
                }
            }
        }
    },

    // Don't automatically add "px" to these possibly-unitless properties
    cssNumber: {
        "columnCount": true,
        "fillOpacity": true,
        "fontWeight": true,
        "lineHeight": true,
        "opacity": true,
        "order": true,
        "orphans": true,
        "widows": true,
        "zIndex": true,
        "zoom": true
    },

    // Add in properties whose names you wish to fix before
    // setting or getting the value
    cssProps: {
        // normalize float css property
        "float": support.cssFloat ? "cssFloat" : "styleFloat"
    },

    // Get and set the style property on a DOM Node
    style: function( elem, name, value, extra ) {
        // Don't set styles on text and comment nodes
        if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
            return;
        }

        // Make sure that we're working with the right name
        var ret, type, hooks,
            origName = jQuery.camelCase( name ),
            style = elem.style;

        name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

        // gets hook for the prefixed version
        // followed by the unprefixed version
        hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

        // Check if we're setting a value
        if ( value !== undefined ) {
            type = typeof value;

            // convert relative number strings (+= or -=) to relative numbers. #7345
            if ( type === "string" && (ret = rrelNum.exec( value )) ) {
                value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
                // Fixes bug #9237
                type = "number";
            }

            // Make sure that null and NaN values aren't set. See: #7116
            if ( value == null || value !== value ) {
                return;
            }

            // If a number was passed in, add 'px' to the (except for certain CSS properties)
            if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
                value += "px";
            }

            // Fixes #8908, it can be done more correctly by specifing setters in cssHooks,
            // but it would mean to define eight (for every problematic property) identical functions
            if ( !support.clearCloneStyle && value === "" && name.indexOf("background") === 0 ) {
                style[ name ] = "inherit";
            }

            // If a hook was provided, use that value, otherwise just set the specified value
            if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {

                // Support: IE
                // Swallow errors from 'invalid' CSS values (#5509)
                try {
                    // Support: Chrome, Safari
                    // Setting style to blank string required to delete "style: x !important;"
                    style[ name ] = "";
                    style[ name ] = value;
                } catch(e) {}
            }

        } else {
            // If a hook was provided get the non-computed value from there
            if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
                return ret;
            }

            // Otherwise just get the value from the style object
            return style[ name ];
        }
    },

    css: function( elem, name, extra, styles ) {
        var num, val, hooks,
            origName = jQuery.camelCase( name );

        // Make sure that we're working with the right name
        name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

        // gets hook for the prefixed version
        // followed by the unprefixed version
        hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

        // If a hook was provided get the computed value from there
        if ( hooks && "get" in hooks ) {
            val = hooks.get( elem, true, extra );
        }

        // Otherwise, if a way to get the computed value exists, use that
        if ( val === undefined ) {
            val = curCSS( elem, name, styles );
        }

        //convert "normal" to computed value
        if ( val === "normal" && name in cssNormalTransform ) {
            val = cssNormalTransform[ name ];
        }

        // Return, converting to number if forced or a qualifier was provided and val looks numeric
        if ( extra === "" || extra ) {
            num = parseFloat( val );
            return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
        }
        return val;
    }
});

jQuery.each([ "height", "width" ], function( i, name ) {
    jQuery.cssHooks[ name ] = {
        get: function( elem, computed, extra ) {
            if ( computed ) {
                // certain elements can have dimension info if we invisibly show them
                // however, it must have a current display style that would benefit from this
                return elem.offsetWidth === 0 && rdisplayswap.test( jQuery.css( elem, "display" ) ) ?
                    jQuery.swap( elem, cssShow, function() {
                        return getWidthOrHeight( elem, name, extra );
                    }) :
                    getWidthOrHeight( elem, name, extra );
            }
        },

        set: function( elem, value, extra ) {
            var styles = extra && getStyles( elem );
            return setPositiveNumber( elem, value, extra ?
                augmentWidthOrHeight(
                    elem,
                    name,
                    extra,
                    support.boxSizing() && jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
                    styles
                ) : 0
            );
        }
    };
});

if ( !support.opacity ) {
    jQuery.cssHooks.opacity = {
        get: function( elem, computed ) {
            // IE uses filters for opacity
            return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
                ( 0.01 * parseFloat( RegExp.$1 ) ) + "" :
                computed ? "1" : "";
        },

        set: function( elem, value ) {
            var style = elem.style,
                currentStyle = elem.currentStyle,
                opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
                filter = currentStyle && currentStyle.filter || style.filter || "";

            // IE has trouble with opacity if it does not have layout
            // Force it by setting the zoom level
            style.zoom = 1;

            // if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
            // if value === "", then remove inline opacity #12685
            if ( ( value >= 1 || value === "" ) &&
                    jQuery.trim( filter.replace( ralpha, "" ) ) === "" &&
                    style.removeAttribute ) {

                // Setting style.filter to null, "" & " " still leave "filter:" in the cssText
                // if "filter:" is present at all, clearType is disabled, we want to avoid this
                // style.removeAttribute is IE Only, but so apparently is this code path...
                style.removeAttribute( "filter" );

                // if there is no filter style applied in a css rule or unset inline opacity, we are done
                if ( value === "" || currentStyle && !currentStyle.filter ) {
                    return;
                }
            }

            // otherwise, set new filter values
            style.filter = ralpha.test( filter ) ?
                filter.replace( ralpha, opacity ) :
                filter + " " + opacity;
        }
    };
}

jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
    function( elem, computed ) {
        if ( computed ) {
            // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
            // Work around by temporarily setting element display to inline-block
            return jQuery.swap( elem, { "display": "inline-block" },
                curCSS, [ elem, "marginRight" ] );
        }
    }
);

// These hooks are used by animate to expand properties
jQuery.each({
    margin: "",
    padding: "",
    border: "Width"
}, function( prefix, suffix ) {
    jQuery.cssHooks[ prefix + suffix ] = {
        expand: function( value ) {
            var i = 0,
                expanded = {},

                // assumes a single number if not a string
                parts = typeof value === "string" ? value.split(" ") : [ value ];

            for ( ; i < 4; i++ ) {
                expanded[ prefix + cssExpand[ i ] + suffix ] =
                    parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
            }

            return expanded;
        }
    };

    if ( !rmargin.test( prefix ) ) {
        jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
    }
});

jQuery.fn.extend({
    css: function( name, value ) {
        return access( this, function( elem, name, value ) {
            var styles, len,
                map = {},
                i = 0;

            if ( jQuery.isArray( name ) ) {
                styles = getStyles( elem );
                len = name.length;

                for ( ; i < len; i++ ) {
                    map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
                }

                return map;
            }

            return value !== undefined ?
                jQuery.style( elem, name, value ) :
                jQuery.css( elem, name );
        }, name, value, arguments.length > 1 );
    },
    show: function() {
        return showHide( this, true );
    },
    hide: function() {
        return showHide( this );
    },
    toggle: function( state ) {
        if ( typeof state === "boolean" ) {
            return state ? this.show() : this.hide();
        }

        return this.each(function() {
            if ( isHidden( this ) ) {
                jQuery( this ).show();
            } else {
                jQuery( this ).hide();
            }
        });
    }
});


function Tween( elem, options, prop, end, easing ) {
    return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
    constructor: Tween,
    init: function( elem, options, prop, end, easing, unit ) {
        this.elem = elem;
        this.prop = prop;
        this.easing = easing || "swing";
        this.options = options;
        this.start = this.now = this.cur();
        this.end = end;
        this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
    },
    cur: function() {
        var hooks = Tween.propHooks[ this.prop ];

        return hooks && hooks.get ?
            hooks.get( this ) :
            Tween.propHooks._default.get( this );
    },
    run: function( percent ) {
        var eased,
            hooks = Tween.propHooks[ this.prop ];

        if ( this.options.duration ) {
            this.pos = eased = jQuery.easing[ this.easing ](
                percent, this.options.duration * percent, 0, 1, this.options.duration
            );
        } else {
            this.pos = eased = percent;
        }
        this.now = ( this.end - this.start ) * eased + this.start;

        if ( this.options.step ) {
            this.options.step.call( this.elem, this.now, this );
        }

        if ( hooks && hooks.set ) {
            hooks.set( this );
        } else {
            Tween.propHooks._default.set( this );
        }
        return this;
    }
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
    _default: {
        get: function( tween ) {
            var result;

            if ( tween.elem[ tween.prop ] != null &&
                (!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
                return tween.elem[ tween.prop ];
            }

            // passing an empty string as a 3rd parameter to .css will automatically
            // attempt a parseFloat and fallback to a string if the parse fails
            // so, simple values such as "10px" are parsed to Float.
            // complex values such as "rotate(1rad)" are returned as is.
            result = jQuery.css( tween.elem, tween.prop, "" );
            // Empty strings, null, undefined and "auto" are converted to 0.
            return !result || result === "auto" ? 0 : result;
        },
        set: function( tween ) {
            // use step hook for back compat - use cssHook if its there - use .style if its
            // available and use plain properties where available
            if ( jQuery.fx.step[ tween.prop ] ) {
                jQuery.fx.step[ tween.prop ]( tween );
            } else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
                jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
            } else {
                tween.elem[ tween.prop ] = tween.now;
            }
        }
    }
};

// Support: IE <=9
// Panic based approach to setting things on disconnected nodes

Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
    set: function( tween ) {
        if ( tween.elem.nodeType && tween.elem.parentNode ) {
            tween.elem[ tween.prop ] = tween.now;
        }
    }
};

jQuery.easing = {
    linear: function( p ) {
        return p;
    },
    swing: function( p ) {
        return 0.5 - Math.cos( p * Math.PI ) / 2;
    }
};

jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
jQuery.fx.step = {};




var
    fxNow, timerId,
    rfxtypes = /^(?:toggle|show|hide)$/,
    rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
    rrun = /queueHooks$/,
    animationPrefilters = [ defaultPrefilter ],
    tweeners = {
        "*": [ function( prop, value ) {
            var tween = this.createTween( prop, value ),
                target = tween.cur(),
                parts = rfxnum.exec( value ),
                unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

                // Starting value computation is required for potential unit mismatches
                start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
                    rfxnum.exec( jQuery.css( tween.elem, prop ) ),
                scale = 1,
                maxIterations = 20;

            if ( start && start[ 3 ] !== unit ) {
                // Trust units reported by jQuery.css
                unit = unit || start[ 3 ];

                // Make sure we update the tween properties later on
                parts = parts || [];

                // Iteratively approximate from a nonzero starting point
                start = +target || 1;

                do {
                    // If previous iteration zeroed out, double until we get *something*
                    // Use a string for doubling factor so we don't accidentally see scale as unchanged below
                    scale = scale || ".5";

                    // Adjust and apply
                    start = start / scale;
                    jQuery.style( tween.elem, prop, start + unit );

                // Update scale, tolerating zero or NaN from tween.cur()
                // And breaking the loop if scale is unchanged or perfect, or if we've just had enough
                } while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
            }

            // Update tween properties
            if ( parts ) {
                start = tween.start = +start || +target || 0;
                tween.unit = unit;
                // If a +=/-= token was provided, we're doing a relative animation
                tween.end = parts[ 1 ] ?
                    start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
                    +parts[ 2 ];
            }

            return tween;
        } ]
    };

// Animations created synchronously will run synchronously
function createFxNow() {
    setTimeout(function() {
        fxNow = undefined;
    });
    return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
    var which,
        attrs = { height: type },
        i = 0;

    // if we include width, step value is 1 to do all cssExpand values,
    // if we don't include width, step value is 2 to skip over Left and Right
    includeWidth = includeWidth ? 1 : 0;
    for ( ; i < 4 ; i += 2 - includeWidth ) {
        which = cssExpand[ i ];
        attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
    }

    if ( includeWidth ) {
        attrs.opacity = attrs.width = type;
    }

    return attrs;
}

function createTween( value, prop, animation ) {
    var tween,
        collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
        index = 0,
        length = collection.length;
    for ( ; index < length; index++ ) {
        if ( (tween = collection[ index ].call( animation, prop, value )) ) {

            // we're done with this property
            return tween;
        }
    }
}

function defaultPrefilter( elem, props, opts ) {
    /* jshint validthis: true */
    var prop, value, toggle, tween, hooks, oldfire, display, dDisplay,
        anim = this,
        orig = {},
        style = elem.style,
        hidden = elem.nodeType && isHidden( elem ),
        dataShow = jQuery._data( elem, "fxshow" );

    // handle queue: false promises
    if ( !opts.queue ) {
        hooks = jQuery._queueHooks( elem, "fx" );
        if ( hooks.unqueued == null ) {
            hooks.unqueued = 0;
            oldfire = hooks.empty.fire;
            hooks.empty.fire = function() {
                if ( !hooks.unqueued ) {
                    oldfire();
                }
            };
        }
        hooks.unqueued++;

        anim.always(function() {
            // doing this makes sure that the complete handler will be called
            // before this completes
            anim.always(function() {
                hooks.unqueued--;
                if ( !jQuery.queue( elem, "fx" ).length ) {
                    hooks.empty.fire();
                }
            });
        });
    }

    // height/width overflow pass
    if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
        // Make sure that nothing sneaks out
        // Record all 3 overflow attributes because IE does not
        // change the overflow attribute when overflowX and
        // overflowY are set to the same value
        opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

        // Set display property to inline-block for height/width
        // animations on inline elements that are having width/height animated
        display = jQuery.css( elem, "display" );
        dDisplay = defaultDisplay( elem.nodeName );
        if ( display === "none" ) {
            display = dDisplay;
        }
        if ( display === "inline" &&
                jQuery.css( elem, "float" ) === "none" ) {

            // inline-level elements accept inline-block;
            // block-level elements need to be inline with layout
            if ( !support.inlineBlockNeedsLayout || dDisplay === "inline" ) {
                style.display = "inline-block";
            } else {
                style.zoom = 1;
            }
        }
    }

    if ( opts.overflow ) {
        style.overflow = "hidden";
        if ( !support.shrinkWrapBlocks() ) {
            anim.always(function() {
                style.overflow = opts.overflow[ 0 ];
                style.overflowX = opts.overflow[ 1 ];
                style.overflowY = opts.overflow[ 2 ];
            });
        }
    }

    // show/hide pass
    for ( prop in props ) {
        value = props[ prop ];
        if ( rfxtypes.exec( value ) ) {
            delete props[ prop ];
            toggle = toggle || value === "toggle";
            if ( value === ( hidden ? "hide" : "show" ) ) {

                // If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
                if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
                    hidden = true;
                } else {
                    continue;
                }
            }
            orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
        }
    }

    if ( !jQuery.isEmptyObject( orig ) ) {
        if ( dataShow ) {
            if ( "hidden" in dataShow ) {
                hidden = dataShow.hidden;
            }
        } else {
            dataShow = jQuery._data( elem, "fxshow", {} );
        }

        // store state if its toggle - enables .stop().toggle() to "reverse"
        if ( toggle ) {
            dataShow.hidden = !hidden;
        }
        if ( hidden ) {
            jQuery( elem ).show();
        } else {
            anim.done(function() {
                jQuery( elem ).hide();
            });
        }
        anim.done(function() {
            var prop;
            jQuery._removeData( elem, "fxshow" );
            for ( prop in orig ) {
                jQuery.style( elem, prop, orig[ prop ] );
            }
        });
        for ( prop in orig ) {
            tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

            if ( !( prop in dataShow ) ) {
                dataShow[ prop ] = tween.start;
                if ( hidden ) {
                    tween.end = tween.start;
                    tween.start = prop === "width" || prop === "height" ? 1 : 0;
                }
            }
        }
    }
}

function propFilter( props, specialEasing ) {
    var index, name, easing, value, hooks;

    // camelCase, specialEasing and expand cssHook pass
    for ( index in props ) {
        name = jQuery.camelCase( index );
        easing = specialEasing[ name ];
        value = props[ index ];
        if ( jQuery.isArray( value ) ) {
            easing = value[ 1 ];
            value = props[ index ] = value[ 0 ];
        }

        if ( index !== name ) {
            props[ name ] = value;
            delete props[ index ];
        }

        hooks = jQuery.cssHooks[ name ];
        if ( hooks && "expand" in hooks ) {
            value = hooks.expand( value );
            delete props[ name ];

            // not quite $.extend, this wont overwrite keys already present.
            // also - reusing 'index' from above because we have the correct "name"
            for ( index in value ) {
                if ( !( index in props ) ) {
                    props[ index ] = value[ index ];
                    specialEasing[ index ] = easing;
                }
            }
        } else {
            specialEasing[ name ] = easing;
        }
    }
}

function Animation( elem, properties, options ) {
    var result,
        stopped,
        index = 0,
        length = animationPrefilters.length,
        deferred = jQuery.Deferred().always( function() {
            // don't match elem in the :animated selector
            delete tick.elem;
        }),
        tick = function() {
            if ( stopped ) {
                return false;
            }
            var currentTime = fxNow || createFxNow(),
                remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
                // archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
                temp = remaining / animation.duration || 0,
                percent = 1 - temp,
                index = 0,
                length = animation.tweens.length;

            for ( ; index < length ; index++ ) {
                animation.tweens[ index ].run( percent );
            }

            deferred.notifyWith( elem, [ animation, percent, remaining ]);

            if ( percent < 1 && length ) {
                return remaining;
            } else {
                deferred.resolveWith( elem, [ animation ] );
                return false;
            }
        },
        animation = deferred.promise({
            elem: elem,
            props: jQuery.extend( {}, properties ),
            opts: jQuery.extend( true, { specialEasing: {} }, options ),
            originalProperties: properties,
            originalOptions: options,
            startTime: fxNow || createFxNow(),
            duration: options.duration,
            tweens: [],
            createTween: function( prop, end ) {
                var tween = jQuery.Tween( elem, animation.opts, prop, end,
                        animation.opts.specialEasing[ prop ] || animation.opts.easing );
                animation.tweens.push( tween );
                return tween;
            },
            stop: function( gotoEnd ) {
                var index = 0,
                    // if we are going to the end, we want to run all the tweens
                    // otherwise we skip this part
                    length = gotoEnd ? animation.tweens.length : 0;
                if ( stopped ) {
                    return this;
                }
                stopped = true;
                for ( ; index < length ; index++ ) {
                    animation.tweens[ index ].run( 1 );
                }

                // resolve when we played the last frame
                // otherwise, reject
                if ( gotoEnd ) {
                    deferred.resolveWith( elem, [ animation, gotoEnd ] );
                } else {
                    deferred.rejectWith( elem, [ animation, gotoEnd ] );
                }
                return this;
            }
        }),
        props = animation.props;

    propFilter( props, animation.opts.specialEasing );

    for ( ; index < length ; index++ ) {
        result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
        if ( result ) {
            return result;
        }
    }

    jQuery.map( props, createTween, animation );

    if ( jQuery.isFunction( animation.opts.start ) ) {
        animation.opts.start.call( elem, animation );
    }

    jQuery.fx.timer(
        jQuery.extend( tick, {
            elem: elem,
            anim: animation,
            queue: animation.opts.queue
        })
    );

    // attach callbacks from options
    return animation.progress( animation.opts.progress )
        .done( animation.opts.done, animation.opts.complete )
        .fail( animation.opts.fail )
        .always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {
    tweener: function( props, callback ) {
        if ( jQuery.isFunction( props ) ) {
            callback = props;
            props = [ "*" ];
        } else {
            props = props.split(" ");
        }

        var prop,
            index = 0,
            length = props.length;

        for ( ; index < length ; index++ ) {
            prop = props[ index ];
            tweeners[ prop ] = tweeners[ prop ] || [];
            tweeners[ prop ].unshift( callback );
        }
    },

    prefilter: function( callback, prepend ) {
        if ( prepend ) {
            animationPrefilters.unshift( callback );
        } else {
            animationPrefilters.push( callback );
        }
    }
});

jQuery.speed = function( speed, easing, fn ) {
    var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
        complete: fn || !fn && easing ||
            jQuery.isFunction( speed ) && speed,
        duration: speed,
        easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
    };

    opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
        opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

    // normalize opt.queue - true/undefined/null -> "fx"
    if ( opt.queue == null || opt.queue === true ) {
        opt.queue = "fx";
    }

    // Queueing
    opt.old = opt.complete;

    opt.complete = function() {
        if ( jQuery.isFunction( opt.old ) ) {
            opt.old.call( this );
        }

        if ( opt.queue ) {
            jQuery.dequeue( this, opt.queue );
        }
    };

    return opt;
};

jQuery.fn.extend({
    fadeTo: function( speed, to, easing, callback ) {

        // show any hidden elements after setting opacity to 0
        return this.filter( isHidden ).css( "opacity", 0 ).show()

            // animate to the value specified
            .end().animate({ opacity: to }, speed, easing, callback );
    },
    animate: function( prop, speed, easing, callback ) {
        var empty = jQuery.isEmptyObject( prop ),
            optall = jQuery.speed( speed, easing, callback ),
            doAnimation = function() {
                // Operate on a copy of prop so per-property easing won't be lost
                var anim = Animation( this, jQuery.extend( {}, prop ), optall );

                // Empty animations, or finishing resolves immediately
                if ( empty || jQuery._data( this, "finish" ) ) {
                    anim.stop( true );
                }
            };
            doAnimation.finish = doAnimation;

        return empty || optall.queue === false ?
            this.each( doAnimation ) :
            this.queue( optall.queue, doAnimation );
    },
    stop: function( type, clearQueue, gotoEnd ) {
        var stopQueue = function( hooks ) {
            var stop = hooks.stop;
            delete hooks.stop;
            stop( gotoEnd );
        };

        if ( typeof type !== "string" ) {
            gotoEnd = clearQueue;
            clearQueue = type;
            type = undefined;
        }
        if ( clearQueue && type !== false ) {
            this.queue( type || "fx", [] );
        }

        return this.each(function() {
            var dequeue = true,
                index = type != null && type + "queueHooks",
                timers = jQuery.timers,
                data = jQuery._data( this );

            if ( index ) {
                if ( data[ index ] && data[ index ].stop ) {
                    stopQueue( data[ index ] );
                }
            } else {
                for ( index in data ) {
                    if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
                        stopQueue( data[ index ] );
                    }
                }
            }

            for ( index = timers.length; index--; ) {
                if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
                    timers[ index ].anim.stop( gotoEnd );
                    dequeue = false;
                    timers.splice( index, 1 );
                }
            }

            // start the next in the queue if the last step wasn't forced
            // timers currently will call their complete callbacks, which will dequeue
            // but only if they were gotoEnd
            if ( dequeue || !gotoEnd ) {
                jQuery.dequeue( this, type );
            }
        });
    },
    finish: function( type ) {
        if ( type !== false ) {
            type = type || "fx";
        }
        return this.each(function() {
            var index,
                data = jQuery._data( this ),
                queue = data[ type + "queue" ],
                hooks = data[ type + "queueHooks" ],
                timers = jQuery.timers,
                length = queue ? queue.length : 0;

            // enable finishing flag on private data
            data.finish = true;

            // empty the queue first
            jQuery.queue( this, type, [] );

            if ( hooks && hooks.stop ) {
                hooks.stop.call( this, true );
            }

            // look for any active animations, and finish them
            for ( index = timers.length; index--; ) {
                if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
                    timers[ index ].anim.stop( true );
                    timers.splice( index, 1 );
                }
            }

            // look for any animations in the old queue and finish them
            for ( index = 0; index < length; index++ ) {
                if ( queue[ index ] && queue[ index ].finish ) {
                    queue[ index ].finish.call( this );
                }
            }

            // turn off finishing flag
            delete data.finish;
        });
    }
});

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
    var cssFn = jQuery.fn[ name ];
    jQuery.fn[ name ] = function( speed, easing, callback ) {
        return speed == null || typeof speed === "boolean" ?
            cssFn.apply( this, arguments ) :
            this.animate( genFx( name, true ), speed, easing, callback );
    };
});

// Generate shortcuts for custom animations
jQuery.each({
    slideDown: genFx("show"),
    slideUp: genFx("hide"),
    slideToggle: genFx("toggle"),
    fadeIn: { opacity: "show" },
    fadeOut: { opacity: "hide" },
    fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
    jQuery.fn[ name ] = function( speed, easing, callback ) {
        return this.animate( props, speed, easing, callback );
    };
});

jQuery.timers = [];
jQuery.fx.tick = function() {
    var timer,
        timers = jQuery.timers,
        i = 0;

    fxNow = jQuery.now();

    for ( ; i < timers.length; i++ ) {
        timer = timers[ i ];
        // Checks the timer has not already been removed
        if ( !timer() && timers[ i ] === timer ) {
            timers.splice( i--, 1 );
        }
    }

    if ( !timers.length ) {
        jQuery.fx.stop();
    }
    fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
    jQuery.timers.push( timer );
    if ( timer() ) {
        jQuery.fx.start();
    } else {
        jQuery.timers.pop();
    }
};

jQuery.fx.interval = 13;

jQuery.fx.start = function() {
    if ( !timerId ) {
        timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
    }
};

jQuery.fx.stop = function() {
    clearInterval( timerId );
    timerId = null;
};

jQuery.fx.speeds = {
    slow: 600,
    fast: 200,
    // Default speed
    _default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
    time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
    type = type || "fx";

    return this.queue( type, function( next, hooks ) {
        var timeout = setTimeout( next, time );
        hooks.stop = function() {
            clearTimeout( timeout );
        };
    });
};


(function() {
    var a, input, select, opt,
        div = document.createElement("div" );

    // Setup
    div.setAttribute( "className", "t" );
    div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
    a = div.getElementsByTagName("a")[ 0 ];

    // First batch of tests.
    select = document.createElement("select");
    opt = select.appendChild( document.createElement("option") );
    input = div.getElementsByTagName("input")[ 0 ];

    a.style.cssText = "top:1px";

    // Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
    support.getSetAttribute = div.className !== "t";

    // Get the style information from getAttribute
    // (IE uses .cssText instead)
    support.style = /top/.test( a.getAttribute("style") );

    // Make sure that URLs aren't manipulated
    // (IE normalizes it by default)
    support.hrefNormalized = a.getAttribute("href") === "/a";

    // Check the default checkbox/radio value ("" on WebKit; "on" elsewhere)
    support.checkOn = !!input.value;

    // Make sure that a selected-by-default option has a working selected property.
    // (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
    support.optSelected = opt.selected;

    // Tests for enctype support on a form (#6743)
    support.enctype = !!document.createElement("form").enctype;

    // Make sure that the options inside disabled selects aren't marked as disabled
    // (WebKit marks them as disabled)
    select.disabled = true;
    support.optDisabled = !opt.disabled;

    // Support: IE8 only
    // Check if we can trust getAttribute("value")
    input = document.createElement( "input" );
    input.setAttribute( "value", "" );
    support.input = input.getAttribute( "value" ) === "";

    // Check if an input maintains its value after becoming a radio
    input.value = "t";
    input.setAttribute( "type", "radio" );
    support.radioValue = input.value === "t";

    // Null elements to avoid leaks in IE.
    a = input = select = opt = div = null;
})();


var rreturn = /\r/g;

jQuery.fn.extend({
    val: function( value ) {
        var hooks, ret, isFunction,
            elem = this[0];

        if ( !arguments.length ) {
            if ( elem ) {
                hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

                if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
                    return ret;
                }

                ret = elem.value;

                return typeof ret === "string" ?
                    // handle most common string cases
                    ret.replace(rreturn, "") :
                    // handle cases where value is null/undef or number
                    ret == null ? "" : ret;
            }

            return;
        }

        isFunction = jQuery.isFunction( value );

        return this.each(function( i ) {
            var val;

            if ( this.nodeType !== 1 ) {
                return;
            }

            if ( isFunction ) {
                val = value.call( this, i, jQuery( this ).val() );
            } else {
                val = value;
            }

            // Treat null/undefined as ""; convert numbers to string
            if ( val == null ) {
                val = "";
            } else if ( typeof val === "number" ) {
                val += "";
            } else if ( jQuery.isArray( val ) ) {
                val = jQuery.map( val, function( value ) {
                    return value == null ? "" : value + "";
                });
            }

            hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

            // If set returns undefined, fall back to normal setting
            if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
                this.value = val;
            }
        });
    }
});

jQuery.extend({
    valHooks: {
        option: {
            get: function( elem ) {
                var val = jQuery.find.attr( elem, "value" );
                return val != null ?
                    val :
                    jQuery.text( elem );
            }
        },
        select: {
            get: function( elem ) {
                var value, option,
                    options = elem.options,
                    index = elem.selectedIndex,
                    one = elem.type === "select-one" || index < 0,
                    values = one ? null : [],
                    max = one ? index + 1 : options.length,
                    i = index < 0 ?
                        max :
                        one ? index : 0;

                // Loop through all the selected options
                for ( ; i < max; i++ ) {
                    option = options[ i ];

                    // oldIE doesn't update selected after form reset (#2551)
                    if ( ( option.selected || i === index ) &&
                            // Don't return options that are disabled or in a disabled optgroup
                            ( support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null ) &&
                            ( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

                        // Get the specific value for the option
                        value = jQuery( option ).val();

                        // We don't need an array for one selects
                        if ( one ) {
                            return value;
                        }

                        // Multi-Selects return an array
                        values.push( value );
                    }
                }

                return values;
            },

            set: function( elem, value ) {
                var optionSet, option,
                    options = elem.options,
                    values = jQuery.makeArray( value ),
                    i = options.length;

                while ( i-- ) {
                    option = options[ i ];

                    if ( jQuery.inArray( jQuery.valHooks.option.get( option ), values ) >= 0 ) {

                        // Support: IE6
                        // When new option element is added to select box we need to
                        // force reflow of newly added node in order to workaround delay
                        // of initialization properties
                        try {
                            option.selected = optionSet = true;

                        } catch ( _ ) {

                            // Will be executed only in IE6
                            option.scrollHeight;
                        }

                    } else {
                        option.selected = false;
                    }
                }

                // Force browsers to behave consistently when non-matching value is set
                if ( !optionSet ) {
                    elem.selectedIndex = -1;
                }

                return options;
            }
        }
    }
});

// Radios and checkboxes getter/setter
jQuery.each([ "radio", "checkbox" ], function() {
    jQuery.valHooks[ this ] = {
        set: function( elem, value ) {
            if ( jQuery.isArray( value ) ) {
                return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
            }
        }
    };
    if ( !support.checkOn ) {
        jQuery.valHooks[ this ].get = function( elem ) {
            // Support: Webkit
            // "" is returned instead of "on" if a value isn't specified
            return elem.getAttribute("value") === null ? "on" : elem.value;
        };
    }
});




var nodeHook, boolHook,
    attrHandle = jQuery.expr.attrHandle,
    ruseDefault = /^(?:checked|selected)$/i,
    getSetAttribute = support.getSetAttribute,
    getSetInput = support.input;

jQuery.fn.extend({
    attr: function( name, value ) {
        return access( this, jQuery.attr, name, value, arguments.length > 1 );
    },

    removeAttr: function( name ) {
        return this.each(function() {
            jQuery.removeAttr( this, name );
        });
    }
});

jQuery.extend({
    attr: function( elem, name, value ) {
        var hooks, ret,
            nType = elem.nodeType;

        // don't get/set attributes on text, comment and attribute nodes
        if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
            return;
        }

        // Fallback to prop when attributes are not supported
        if ( typeof elem.getAttribute === strundefined ) {
            return jQuery.prop( elem, name, value );
        }

        // All attributes are lowercase
        // Grab necessary hook if one is defined
        if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
            name = name.toLowerCase();
            hooks = jQuery.attrHooks[ name ] ||
                ( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
        }

        if ( value !== undefined ) {

            if ( value === null ) {
                jQuery.removeAttr( elem, name );

            } else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
                return ret;

            } else {
                elem.setAttribute( name, value + "" );
                return value;
            }

        } else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
            return ret;

        } else {
            ret = jQuery.find.attr( elem, name );

            // Non-existent attributes return null, we normalize to undefined
            return ret == null ?
                undefined :
                ret;
        }
    },

    removeAttr: function( elem, value ) {
        var name, propName,
            i = 0,
            attrNames = value && value.match( rnotwhite );

        if ( attrNames && elem.nodeType === 1 ) {
            while ( (name = attrNames[i++]) ) {
                propName = jQuery.propFix[ name ] || name;

                // Boolean attributes get special treatment (#10870)
                if ( jQuery.expr.match.bool.test( name ) ) {
                    // Set corresponding property to false
                    if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
                        elem[ propName ] = false;
                    // Support: IE<9
                    // Also clear defaultChecked/defaultSelected (if appropriate)
                    } else {
                        elem[ jQuery.camelCase( "default-" + name ) ] =
                            elem[ propName ] = false;
                    }

                // See #9699 for explanation of this approach (setting first, then removal)
                } else {
                    jQuery.attr( elem, name, "" );
                }

                elem.removeAttribute( getSetAttribute ? name : propName );
            }
        }
    },

    attrHooks: {
        type: {
            set: function( elem, value ) {
                if ( !support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
                    // Setting the type on a radio button after the value resets the value in IE6-9
                    // Reset value to default in case type is set after value during creation
                    var val = elem.value;
                    elem.setAttribute( "type", value );
                    if ( val ) {
                        elem.value = val;
                    }
                    return value;
                }
            }
        }
    }
});

// Hook for boolean attributes
boolHook = {
    set: function( elem, value, name ) {
        if ( value === false ) {
            // Remove boolean attributes when set to false
            jQuery.removeAttr( elem, name );
        } else if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
            // IE<8 needs the *property* name
            elem.setAttribute( !getSetAttribute && jQuery.propFix[ name ] || name, name );

        // Use defaultChecked and defaultSelected for oldIE
        } else {
            elem[ jQuery.camelCase( "default-" + name ) ] = elem[ name ] = true;
        }

        return name;
    }
};

// Retrieve booleans specially
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {

    var getter = attrHandle[ name ] || jQuery.find.attr;

    attrHandle[ name ] = getSetInput && getSetAttribute || !ruseDefault.test( name ) ?
        function( elem, name, isXML ) {
            var ret, handle;
            if ( !isXML ) {
                // Avoid an infinite loop by temporarily removing this function from the getter
                handle = attrHandle[ name ];
                attrHandle[ name ] = ret;
                ret = getter( elem, name, isXML ) != null ?
                    name.toLowerCase() :
                    null;
                attrHandle[ name ] = handle;
            }
            return ret;
        } :
        function( elem, name, isXML ) {
            if ( !isXML ) {
                return elem[ jQuery.camelCase( "default-" + name ) ] ?
                    name.toLowerCase() :
                    null;
            }
        };
});

// fix oldIE attroperties
if ( !getSetInput || !getSetAttribute ) {
    jQuery.attrHooks.value = {
        set: function( elem, value, name ) {
            if ( jQuery.nodeName( elem, "input" ) ) {
                // Does not return so that setAttribute is also used
                elem.defaultValue = value;
            } else {
                // Use nodeHook if defined (#1954); otherwise setAttribute is fine
                return nodeHook && nodeHook.set( elem, value, name );
            }
        }
    };
}

// IE6/7 do not support getting/setting some attributes with get/setAttribute
if ( !getSetAttribute ) {

    // Use this for any attribute in IE6/7
    // This fixes almost every IE6/7 issue
    nodeHook = {
        set: function( elem, value, name ) {
            // Set the existing or create a new attribute node
            var ret = elem.getAttributeNode( name );
            if ( !ret ) {
                elem.setAttributeNode(
                    (ret = elem.ownerDocument.createAttribute( name ))
                );
            }

            ret.value = value += "";

            // Break association with cloned elements by also using setAttribute (#9646)
            if ( name === "value" || value === elem.getAttribute( name ) ) {
                return value;
            }
        }
    };

    // Some attributes are constructed with empty-string values when not defined
    attrHandle.id = attrHandle.name = attrHandle.coords =
        function( elem, name, isXML ) {
            var ret;
            if ( !isXML ) {
                return (ret = elem.getAttributeNode( name )) && ret.value !== "" ?
                    ret.value :
                    null;
            }
        };

    // Fixing value retrieval on a button requires this module
    jQuery.valHooks.button = {
        get: function( elem, name ) {
            var ret = elem.getAttributeNode( name );
            if ( ret && ret.specified ) {
                return ret.value;
            }
        },
        set: nodeHook.set
    };

    // Set contenteditable to false on removals(#10429)
    // Setting to empty string throws an error as an invalid value
    jQuery.attrHooks.contenteditable = {
        set: function( elem, value, name ) {
            nodeHook.set( elem, value === "" ? false : value, name );
        }
    };

    // Set width and height to auto instead of 0 on empty string( Bug #8150 )
    // This is for removals
    jQuery.each([ "width", "height" ], function( i, name ) {
        jQuery.attrHooks[ name ] = {
            set: function( elem, value ) {
                if ( value === "" ) {
                    elem.setAttribute( name, "auto" );
                    return value;
                }
            }
        };
    });
}

if ( !support.style ) {
    jQuery.attrHooks.style = {
        get: function( elem ) {
            // Return undefined in the case of empty string
            // Note: IE uppercases css property names, but if we were to .toLowerCase()
            // .cssText, that would destroy case senstitivity in URL's, like in "background"
            return elem.style.cssText || undefined;
        },
        set: function( elem, value ) {
            return ( elem.style.cssText = value + "" );
        }
    };
}




var rfocusable = /^(?:input|select|textarea|button|object)$/i,
    rclickable = /^(?:a|area)$/i;

jQuery.fn.extend({
    prop: function( name, value ) {
        return access( this, jQuery.prop, name, value, arguments.length > 1 );
    },

    removeProp: function( name ) {
        name = jQuery.propFix[ name ] || name;
        return this.each(function() {
            // try/catch handles cases where IE balks (such as removing a property on window)
            try {
                this[ name ] = undefined;
                delete this[ name ];
            } catch( e ) {}
        });
    }
});

jQuery.extend({
    propFix: {
        "for": "htmlFor",
        "class": "className"
    },

    prop: function( elem, name, value ) {
        var ret, hooks, notxml,
            nType = elem.nodeType;

        // don't get/set properties on text, comment and attribute nodes
        if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
            return;
        }

        notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

        if ( notxml ) {
            // Fix name and attach hooks
            name = jQuery.propFix[ name ] || name;
            hooks = jQuery.propHooks[ name ];
        }

        if ( value !== undefined ) {
            return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
                ret :
                ( elem[ name ] = value );

        } else {
            return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
                ret :
                elem[ name ];
        }
    },

    propHooks: {
        tabIndex: {
            get: function( elem ) {
                // elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
                // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                // Use proper attribute retrieval(#12072)
                var tabindex = jQuery.find.attr( elem, "tabindex" );

                return tabindex ?
                    parseInt( tabindex, 10 ) :
                    rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
                        0 :
                        -1;
            }
        }
    }
});

// Some attributes require a special call on IE
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !support.hrefNormalized ) {
    // href/src property should get the full normalized URL (#10299/#12915)
    jQuery.each([ "href", "src" ], function( i, name ) {
        jQuery.propHooks[ name ] = {
            get: function( elem ) {
                return elem.getAttribute( name, 4 );
            }
        };
    });
}

// Support: Safari, IE9+
// mis-reports the default selected property of an option
// Accessing the parent's selectedIndex property fixes it
if ( !support.optSelected ) {
    jQuery.propHooks.selected = {
        get: function( elem ) {
            var parent = elem.parentNode;

            if ( parent ) {
                parent.selectedIndex;

                // Make sure that it also works with optgroups, see #5701
                if ( parent.parentNode ) {
                    parent.parentNode.selectedIndex;
                }
            }
            return null;
        }
    };
}

jQuery.each([
    "tabIndex",
    "readOnly",
    "maxLength",
    "cellSpacing",
    "cellPadding",
    "rowSpan",
    "colSpan",
    "useMap",
    "frameBorder",
    "contentEditable"
], function() {
    jQuery.propFix[ this.toLowerCase() ] = this;
});

// IE6/7 call enctype encoding
if ( !support.enctype ) {
    jQuery.propFix.enctype = "encoding";
}




var rclass = /[\t\r\n\f]/g;

jQuery.fn.extend({
    addClass: function( value ) {
        var classes, elem, cur, clazz, j, finalValue,
            i = 0,
            len = this.length,
            proceed = typeof value === "string" && value;

        if ( jQuery.isFunction( value ) ) {
            return this.each(function( j ) {
                jQuery( this ).addClass( value.call( this, j, this.className ) );
            });
        }

        if ( proceed ) {
            // The disjunction here is for better compressibility (see removeClass)
            classes = ( value || "" ).match( rnotwhite ) || [];

            for ( ; i < len; i++ ) {
                elem = this[ i ];
                cur = elem.nodeType === 1 && ( elem.className ?
                    ( " " + elem.className + " " ).replace( rclass, " " ) :
                    " "
                );

                if ( cur ) {
                    j = 0;
                    while ( (clazz = classes[j++]) ) {
                        if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
                            cur += clazz + " ";
                        }
                    }

                    // only assign if different to avoid unneeded rendering.
                    finalValue = jQuery.trim( cur );
                    if ( elem.className !== finalValue ) {
                        elem.className = finalValue;
                    }
                }
            }
        }

        return this;
    },

    removeClass: function( value ) {
        var classes, elem, cur, clazz, j, finalValue,
            i = 0,
            len = this.length,
            proceed = arguments.length === 0 || typeof value === "string" && value;

        if ( jQuery.isFunction( value ) ) {
            return this.each(function( j ) {
                jQuery( this ).removeClass( value.call( this, j, this.className ) );
            });
        }
        if ( proceed ) {
            classes = ( value || "" ).match( rnotwhite ) || [];

            for ( ; i < len; i++ ) {
                elem = this[ i ];
                // This expression is here for better compressibility (see addClass)
                cur = elem.nodeType === 1 && ( elem.className ?
                    ( " " + elem.className + " " ).replace( rclass, " " ) :
                    ""
                );

                if ( cur ) {
                    j = 0;
                    while ( (clazz = classes[j++]) ) {
                        // Remove *all* instances
                        while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
                            cur = cur.replace( " " + clazz + " ", " " );
                        }
                    }

                    // only assign if different to avoid unneeded rendering.
                    finalValue = value ? jQuery.trim( cur ) : "";
                    if ( elem.className !== finalValue ) {
                        elem.className = finalValue;
                    }
                }
            }
        }

        return this;
    },

    toggleClass: function( value, stateVal ) {
        var type = typeof value;

        if ( typeof stateVal === "boolean" && type === "string" ) {
            return stateVal ? this.addClass( value ) : this.removeClass( value );
        }

        if ( jQuery.isFunction( value ) ) {
            return this.each(function( i ) {
                jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
            });
        }

        return this.each(function() {
            if ( type === "string" ) {
                // toggle individual class names
                var className,
                    i = 0,
                    self = jQuery( this ),
                    classNames = value.match( rnotwhite ) || [];

                while ( (className = classNames[ i++ ]) ) {
                    // check each className given, space separated list
                    if ( self.hasClass( className ) ) {
                        self.removeClass( className );
                    } else {
                        self.addClass( className );
                    }
                }

            // Toggle whole class name
            } else if ( type === strundefined || type === "boolean" ) {
                if ( this.className ) {
                    // store className if set
                    jQuery._data( this, "__className__", this.className );
                }

                // If the element has a class name or if we're passed "false",
                // then remove the whole classname (if there was one, the above saved it).
                // Otherwise bring back whatever was previously saved (if anything),
                // falling back to the empty string if nothing was stored.
                this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
            }
        });
    },

    hasClass: function( selector ) {
        var className = " " + selector + " ",
            i = 0,
            l = this.length;
        for ( ; i < l; i++ ) {
            if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
                return true;
            }
        }

        return false;
    }
});




// Return jQuery for attributes-only inclusion


jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
    "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
    "change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

    // Handle event binding
    jQuery.fn[ name ] = function( data, fn ) {
        return arguments.length > 0 ?
            this.on( name, null, data, fn ) :
            this.trigger( name );
    };
});

jQuery.fn.extend({
    hover: function( fnOver, fnOut ) {
        return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
    },

    bind: function( types, data, fn ) {
        return this.on( types, null, data, fn );
    },
    unbind: function( types, fn ) {
        return this.off( types, null, fn );
    },

    delegate: function( selector, types, data, fn ) {
        return this.on( types, selector, data, fn );
    },
    undelegate: function( selector, types, fn ) {
        // ( namespace ) or ( selector, types [, fn] )
        return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
    }
});


var nonce = jQuery.now();

var rquery = (/\?/);



var rvalidtokens = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;

jQuery.parseJSON = function( data ) {
    // Attempt to parse using the native JSON parser first
    if ( window.JSON && window.JSON.parse ) {
        // Support: Android 2.3
        // Workaround failure to string-cast null input
        return window.JSON.parse( data + "" );
    }

    var requireNonComma,
        depth = null,
        str = jQuery.trim( data + "" );

    // Guard against invalid (and possibly dangerous) input by ensuring that nothing remains
    // after removing valid tokens
    return str && !jQuery.trim( str.replace( rvalidtokens, function( token, comma, open, close ) {

        // Force termination if we see a misplaced comma
        if ( requireNonComma && comma ) {
            depth = 0;
        }

        // Perform no more replacements after returning to outermost depth
        if ( depth === 0 ) {
            return token;
        }

        // Commas must not follow "[", "{", or ","
        requireNonComma = open || comma;

        // Determine new depth
        // array/object open ("[" or "{"): depth += true - false (increment)
        // array/object close ("]" or "}"): depth += false - true (decrement)
        // other cases ("," or primitive): depth += true - true (numeric cast)
        depth += !close - !open;

        // Remove this token
        return "";
    }) ) ?
        ( Function( "return " + str ) )() :
        jQuery.error( "Invalid JSON: " + data );
};


// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
    var xml, tmp;
    if ( !data || typeof data !== "string" ) {
        return null;
    }
    try {
        if ( window.DOMParser ) { // Standard
            tmp = new DOMParser();
            xml = tmp.parseFromString( data, "text/xml" );
        } else { // IE
            xml = new ActiveXObject( "Microsoft.XMLDOM" );
            xml.async = "false";
            xml.loadXML( data );
        }
    } catch( e ) {
        xml = undefined;
    }
    if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
        jQuery.error( "Invalid XML: " + data );
    }
    return xml;
};


var
    // Document location
    ajaxLocParts,
    ajaxLocation,

    rhash = /#.*$/,
    rts = /([?&])_=[^&]*/,
    rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
    // #7653, #8125, #8152: local protocol detection
    rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
    rnoContent = /^(?:GET|HEAD)$/,
    rprotocol = /^\/\//,
    rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

    /* Prefilters
     * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
     * 2) These are called:
     *    - BEFORE asking for a transport
     *    - AFTER param serialization (s.data is a string if s.processData is true)
     * 3) key is the dataType
     * 4) the catchall symbol "*" can be used
     * 5) execution will start with transport dataType and THEN continue down to "*" if needed
     */
    prefilters = {},

    /* Transports bindings
     * 1) key is the dataType
     * 2) the catchall symbol "*" can be used
     * 3) selection will start with transport dataType and THEN go to "*" if needed
     */
    transports = {},

    // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
    allTypes = "*/".concat("*");

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
    ajaxLocation = location.href;
} catch( e ) {
    // Use the href attribute of an A element
    // since IE will modify it given document.location
    ajaxLocation = document.createElement( "a" );
    ajaxLocation.href = "";
    ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

    // dataTypeExpression is optional and defaults to "*"
    return function( dataTypeExpression, func ) {

        if ( typeof dataTypeExpression !== "string" ) {
            func = dataTypeExpression;
            dataTypeExpression = "*";
        }

        var dataType,
            i = 0,
            dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

        if ( jQuery.isFunction( func ) ) {
            // For each dataType in the dataTypeExpression
            while ( (dataType = dataTypes[i++]) ) {
                // Prepend if requested
                if ( dataType.charAt( 0 ) === "+" ) {
                    dataType = dataType.slice( 1 ) || "*";
                    (structure[ dataType ] = structure[ dataType ] || []).unshift( func );

                // Otherwise append
                } else {
                    (structure[ dataType ] = structure[ dataType ] || []).push( func );
                }
            }
        }
    };
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

    var inspected = {},
        seekingTransport = ( structure === transports );

    function inspect( dataType ) {
        var selected;
        inspected[ dataType ] = true;
        jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
            var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
            if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
                options.dataTypes.unshift( dataTypeOrTransport );
                inspect( dataTypeOrTransport );
                return false;
            } else if ( seekingTransport ) {
                return !( selected = dataTypeOrTransport );
            }
        });
        return selected;
    }

    return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
    var deep, key,
        flatOptions = jQuery.ajaxSettings.flatOptions || {};

    for ( key in src ) {
        if ( src[ key ] !== undefined ) {
            ( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
        }
    }
    if ( deep ) {
        jQuery.extend( true, target, deep );
    }

    return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {
    var firstDataType, ct, finalDataType, type,
        contents = s.contents,
        dataTypes = s.dataTypes;

    // Remove auto dataType and get content-type in the process
    while ( dataTypes[ 0 ] === "*" ) {
        dataTypes.shift();
        if ( ct === undefined ) {
            ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
        }
    }

    // Check if we're dealing with a known content-type
    if ( ct ) {
        for ( type in contents ) {
            if ( contents[ type ] && contents[ type ].test( ct ) ) {
                dataTypes.unshift( type );
                break;
            }
        }
    }

    // Check to see if we have a response for the expected dataType
    if ( dataTypes[ 0 ] in responses ) {
        finalDataType = dataTypes[ 0 ];
    } else {
        // Try convertible dataTypes
        for ( type in responses ) {
            if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
                finalDataType = type;
                break;
            }
            if ( !firstDataType ) {
                firstDataType = type;
            }
        }
        // Or just use first one
        finalDataType = finalDataType || firstDataType;
    }

    // If we found a dataType
    // We add the dataType to the list if needed
    // and return the corresponding response
    if ( finalDataType ) {
        if ( finalDataType !== dataTypes[ 0 ] ) {
            dataTypes.unshift( finalDataType );
        }
        return responses[ finalDataType ];
    }
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
    var conv2, current, conv, tmp, prev,
        converters = {},
        // Work with a copy of dataTypes in case we need to modify it for conversion
        dataTypes = s.dataTypes.slice();

    // Create converters map with lowercased keys
    if ( dataTypes[ 1 ] ) {
        for ( conv in s.converters ) {
            converters[ conv.toLowerCase() ] = s.converters[ conv ];
        }
    }

    current = dataTypes.shift();

    // Convert to each sequential dataType
    while ( current ) {

        if ( s.responseFields[ current ] ) {
            jqXHR[ s.responseFields[ current ] ] = response;
        }

        // Apply the dataFilter if provided
        if ( !prev && isSuccess && s.dataFilter ) {
            response = s.dataFilter( response, s.dataType );
        }

        prev = current;
        current = dataTypes.shift();

        if ( current ) {

            // There's only work to do if current dataType is non-auto
            if ( current === "*" ) {

                current = prev;

            // Convert response if prev dataType is non-auto and differs from current
            } else if ( prev !== "*" && prev !== current ) {

                // Seek a direct converter
                conv = converters[ prev + " " + current ] || converters[ "* " + current ];

                // If none found, seek a pair
                if ( !conv ) {
                    for ( conv2 in converters ) {

                        // If conv2 outputs current
                        tmp = conv2.split( " " );
                        if ( tmp[ 1 ] === current ) {

                            // If prev can be converted to accepted input
                            conv = converters[ prev + " " + tmp[ 0 ] ] ||
                                converters[ "* " + tmp[ 0 ] ];
                            if ( conv ) {
                                // Condense equivalence converters
                                if ( conv === true ) {
                                    conv = converters[ conv2 ];

                                // Otherwise, insert the intermediate dataType
                                } else if ( converters[ conv2 ] !== true ) {
                                    current = tmp[ 0 ];
                                    dataTypes.unshift( tmp[ 1 ] );
                                }
                                break;
                            }
                        }
                    }
                }

                // Apply converter (if not an equivalence)
                if ( conv !== true ) {

                    // Unless errors are allowed to bubble, catch and return them
                    if ( conv && s[ "throws" ] ) {
                        response = conv( response );
                    } else {
                        try {
                            response = conv( response );
                        } catch ( e ) {
                            return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
                        }
                    }
                }
            }
        }
    }

    return { state: "success", data: response };
}

jQuery.extend({

    // Counter for holding the number of active queries
    active: 0,

    // Last-Modified header cache for next request
    lastModified: {},
    etag: {},

    ajaxSettings: {
        url: ajaxLocation,
        type: "GET",
        isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
        global: true,
        processData: true,
        async: true,
        contentType: "application/x-www-form-urlencoded; charset=UTF-8",
        /*
        timeout: 0,
        data: null,
        dataType: null,
        username: null,
        password: null,
        cache: null,
        throws: false,
        traditional: false,
        headers: {},
        */

        accepts: {
            "*": allTypes,
            text: "text/plain",
            html: "text/html",
            xml: "application/xml, text/xml",
            json: "application/json, text/javascript"
        },

        contents: {
            xml: /xml/,
            html: /html/,
            json: /json/
        },

        responseFields: {
            xml: "responseXML",
            text: "responseText",
            json: "responseJSON"
        },

        // Data converters
        // Keys separate source (or catchall "*") and destination types with a single space
        converters: {

            // Convert anything to text
            "* text": String,

            // Text to html (true = no transformation)
            "text html": true,

            // Evaluate text as a json expression
            "text json": jQuery.parseJSON,

            // Parse text as xml
            "text xml": jQuery.parseXML
        },

        // For options that shouldn't be deep extended:
        // you can add your own custom options here if
        // and when you create one that shouldn't be
        // deep extended (see ajaxExtend)
        flatOptions: {
            url: true,
            context: true
        }
    },

    // Creates a full fledged settings object into target
    // with both ajaxSettings and settings fields.
    // If target is omitted, writes into ajaxSettings.
    ajaxSetup: function( target, settings ) {
        return settings ?

            // Building a settings object
            ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

            // Extending ajaxSettings
            ajaxExtend( jQuery.ajaxSettings, target );
    },

    ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
    ajaxTransport: addToPrefiltersOrTransports( transports ),

    // Main method
    ajax: function( url, options ) {

        // If url is an object, simulate pre-1.5 signature
        if ( typeof url === "object" ) {
            options = url;
            url = undefined;
        }

        // Force options to be an object
        options = options || {};

        var // Cross-domain detection vars
            parts,
            // Loop variable
            i,
            // URL without anti-cache param
            cacheURL,
            // Response headers as string
            responseHeadersString,
            // timeout handle
            timeoutTimer,

            // To know if global events are to be dispatched
            fireGlobals,

            transport,
            // Response headers
            responseHeaders,
            // Create the final options object
            s = jQuery.ajaxSetup( {}, options ),
            // Callbacks context
            callbackContext = s.context || s,
            // Context for global events is callbackContext if it is a DOM node or jQuery collection
            globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
                jQuery( callbackContext ) :
                jQuery.event,
            // Deferreds
            deferred = jQuery.Deferred(),
            completeDeferred = jQuery.Callbacks("once memory"),
            // Status-dependent callbacks
            statusCode = s.statusCode || {},
            // Headers (they are sent all at once)
            requestHeaders = {},
            requestHeadersNames = {},
            // The jqXHR state
            state = 0,
            // Default abort message
            strAbort = "canceled",
            // Fake xhr
            jqXHR = {
                readyState: 0,

                // Builds headers hashtable if needed
                getResponseHeader: function( key ) {
                    var match;
                    if ( state === 2 ) {
                        if ( !responseHeaders ) {
                            responseHeaders = {};
                            while ( (match = rheaders.exec( responseHeadersString )) ) {
                                responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
                            }
                        }
                        match = responseHeaders[ key.toLowerCase() ];
                    }
                    return match == null ? null : match;
                },

                // Raw string
                getAllResponseHeaders: function() {
                    return state === 2 ? responseHeadersString : null;
                },

                // Caches the header
                setRequestHeader: function( name, value ) {
                    var lname = name.toLowerCase();
                    if ( !state ) {
                        name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
                        requestHeaders[ name ] = value;
                    }
                    return this;
                },

                // Overrides response content-type header
                overrideMimeType: function( type ) {
                    if ( !state ) {
                        s.mimeType = type;
                    }
                    return this;
                },

                // Status-dependent callbacks
                statusCode: function( map ) {
                    var code;
                    if ( map ) {
                        if ( state < 2 ) {
                            for ( code in map ) {
                                // Lazy-add the new callback in a way that preserves old ones
                                statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
                            }
                        } else {
                            // Execute the appropriate callbacks
                            jqXHR.always( map[ jqXHR.status ] );
                        }
                    }
                    return this;
                },

                // Cancel the request
                abort: function( statusText ) {
                    var finalText = statusText || strAbort;
                    if ( transport ) {
                        transport.abort( finalText );
                    }
                    done( 0, finalText );
                    return this;
                }
            };

        // Attach deferreds
        deferred.promise( jqXHR ).complete = completeDeferred.add;
        jqXHR.success = jqXHR.done;
        jqXHR.error = jqXHR.fail;

        // Remove hash character (#7531: and string promotion)
        // Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
        // Handle falsy url in the settings object (#10093: consistency with old signature)
        // We also use the url parameter if available
        s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

        // Alias method option to type as per ticket #12004
        s.type = options.method || options.type || s.method || s.type;

        // Extract dataTypes list
        s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

        // A cross-domain request is in order when we have a protocol:host:port mismatch
        if ( s.crossDomain == null ) {
            parts = rurl.exec( s.url.toLowerCase() );
            s.crossDomain = !!( parts &&
                ( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
                    ( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
                        ( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
            );
        }

        // Convert data if not already a string
        if ( s.data && s.processData && typeof s.data !== "string" ) {
            s.data = jQuery.param( s.data, s.traditional );
        }

        // Apply prefilters
        inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

        // If request was aborted inside a prefilter, stop there
        if ( state === 2 ) {
            return jqXHR;
        }

        // We can fire global events as of now if asked to
        fireGlobals = s.global;

        // Watch for a new set of requests
        if ( fireGlobals && jQuery.active++ === 0 ) {
            jQuery.event.trigger("ajaxStart");
        }

        // Uppercase the type
        s.type = s.type.toUpperCase();

        // Determine if request has content
        s.hasContent = !rnoContent.test( s.type );

        // Save the URL in case we're toying with the If-Modified-Since
        // and/or If-None-Match header later on
        cacheURL = s.url;

        // More options handling for requests with no content
        if ( !s.hasContent ) {

            // If data is available, append data to url
            if ( s.data ) {
                cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
                // #9682: remove data so that it's not used in an eventual retry
                delete s.data;
            }

            // Add anti-cache in url if needed
            if ( s.cache === false ) {
                s.url = rts.test( cacheURL ) ?

                    // If there is already a '_' parameter, set its value
                    cacheURL.replace( rts, "$1_=" + nonce++ ) :

                    // Otherwise add one to the end
                    cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
            }
        }

        // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
        if ( s.ifModified ) {
            if ( jQuery.lastModified[ cacheURL ] ) {
                jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
            }
            if ( jQuery.etag[ cacheURL ] ) {
                jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
            }
        }

        // Set the correct header, if data is being sent
        if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
            jqXHR.setRequestHeader( "Content-Type", s.contentType );
        }

        // Set the Accepts header for the server, depending on the dataType
        jqXHR.setRequestHeader(
            "Accept",
            s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
                s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
                s.accepts[ "*" ]
        );

        // Check for headers option
        for ( i in s.headers ) {
            jqXHR.setRequestHeader( i, s.headers[ i ] );
        }

        // Allow custom headers/mimetypes and early abort
        if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
            // Abort if not done already and return
            return jqXHR.abort();
        }

        // aborting is no longer a cancellation
        strAbort = "abort";

        // Install callbacks on deferreds
        for ( i in { success: 1, error: 1, complete: 1 } ) {
            jqXHR[ i ]( s[ i ] );
        }

        // Get transport
        transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

        // FOUNDRY_HACK
        // Method to trigger ajax send
        jqXHR.send = function() {

            jqXHR.readyState = 1;

            // Send global event
            if ( fireGlobals ) {
                globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
            }
            // Timeout
            if ( s.async && s.timeout > 0 ) {
                timeoutTimer = setTimeout(function() {
                    jqXHR.abort("timeout");
                }, s.timeout );
            }

            try {
                state = 1;
                transport.send( requestHeaders, done );
            } catch ( e ) {
                // Propagate exception as error if not done
                if ( state < 2 ) {
                    done( -1, e );
                // Simply rethrow otherwise
                } else {
                    throw e;
                }
            }
        }

        // If no transport, we auto-abort
        if ( !transport ) {
            done( -1, "No Transport" );
        } else {

            // FOUNDRY_HACK
            // Autostart option. If autostart is false,
            // ajax will not begin until send() is manually called.
            options.autostart!==false && jqXHR.send();
        }

        // Callback for when everything is done
        function done( status, nativeStatusText, responses, headers ) {
            var isSuccess, success, error, response, modified,
                statusText = nativeStatusText;

            // Called once
            if ( state === 2 ) {
                return;
            }

            // State is "done" now
            state = 2;

            // Clear timeout if it exists
            if ( timeoutTimer ) {
                clearTimeout( timeoutTimer );
            }

            // Dereference transport for early garbage collection
            // (no matter how long the jqXHR object will be used)
            transport = undefined;

            // Cache response headers
            responseHeadersString = headers || "";

            // Set readyState
            jqXHR.readyState = status > 0 ? 4 : 0;

            // Determine if successful
            isSuccess = status >= 200 && status < 300 || status === 304;

            // Get response data
            if ( responses ) {
                response = ajaxHandleResponses( s, jqXHR, responses );
            }

            // Convert no matter what (that way responseXXX fields are always set)
            response = ajaxConvert( s, response, jqXHR, isSuccess );

            // If successful, handle type chaining
            if ( isSuccess ) {

                // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                if ( s.ifModified ) {
                    modified = jqXHR.getResponseHeader("Last-Modified");
                    if ( modified ) {
                        jQuery.lastModified[ cacheURL ] = modified;
                    }
                    modified = jqXHR.getResponseHeader("etag");
                    if ( modified ) {
                        jQuery.etag[ cacheURL ] = modified;
                    }
                }

                // if no content
                if ( status === 204 || s.type === "HEAD" ) {
                    statusText = "nocontent";

                // if not modified
                } else if ( status === 304 ) {
                    statusText = "notmodified";

                // If we have data, let's convert it
                } else {
                    statusText = response.state;
                    success = response.data;
                    error = response.error;
                    isSuccess = !error;
                }
            } else {
                // We extract error from statusText
                // then normalize statusText and status for non-aborts
                error = statusText;
                if ( status || !statusText ) {
                    statusText = "error";
                    if ( status < 0 ) {
                        status = 0;
                    }
                }
            }

            // Set data for the fake xhr object
            jqXHR.status = status;
            jqXHR.statusText = ( nativeStatusText || statusText ) + "";

            // Success/Error
            if ( isSuccess ) {
                deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
            } else {
                deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
            }

            // Status-dependent callbacks
            jqXHR.statusCode( statusCode );
            statusCode = undefined;

            if ( fireGlobals ) {
                globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
                    [ jqXHR, s, isSuccess ? success : error ] );
            }

            // Complete
            completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

            if ( fireGlobals ) {
                globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
                // Handle the global AJAX counter
                if ( !( --jQuery.active ) ) {
                    jQuery.event.trigger("ajaxStop");
                }
            }
        }

        return jqXHR;
    },

    getJSON: function( url, data, callback ) {
        return jQuery.get( url, data, callback, "json" );
    },

    getScript: function( url, callback ) {
        return jQuery.get( url, undefined, callback, "script" );
    }
});

jQuery.each( [ "get", "post" ], function( i, method ) {
    jQuery[ method ] = function( url, data, callback, type ) {
        // shift arguments if data argument was omitted
        if ( jQuery.isFunction( data ) ) {
            type = type || callback;
            callback = data;
            data = undefined;
        }

        return jQuery.ajax({
            url: url,
            type: method,
            dataType: type,
            data: data,
            success: callback
        });
    };
});

// Attach a bunch of functions for handling common AJAX events
jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
    jQuery.fn[ type ] = function( fn ) {
        return this.on( type, fn );
    };
});


jQuery._evalUrl = function( url ) {
    return jQuery.ajax({
        url: url,
        type: "GET",
        dataType: "script",
        async: false,
        global: false,
        "throws": true
    });
};


jQuery.fn.extend({
    wrapAll: function( html ) {
        if ( jQuery.isFunction( html ) ) {
            return this.each(function(i) {
                jQuery(this).wrapAll( html.call(this, i) );
            });
        }

        if ( this[0] ) {
            // The elements to wrap the target around
            var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

            if ( this[0].parentNode ) {
                wrap.insertBefore( this[0] );
            }

            wrap.map(function() {
                var elem = this;

                while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
                    elem = elem.firstChild;
                }

                return elem;
            }).append( this );
        }

        return this;
    },

    wrapInner: function( html ) {
        if ( jQuery.isFunction( html ) ) {
            return this.each(function(i) {
                jQuery(this).wrapInner( html.call(this, i) );
            });
        }

        return this.each(function() {
            var self = jQuery( this ),
                contents = self.contents();

            if ( contents.length ) {
                contents.wrapAll( html );

            } else {
                self.append( html );
            }
        });
    },

    wrap: function( html ) {
        var isFunction = jQuery.isFunction( html );

        return this.each(function(i) {
            jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
        });
    },

    unwrap: function() {
        return this.parent().each(function() {
            if ( !jQuery.nodeName( this, "body" ) ) {
                jQuery( this ).replaceWith( this.childNodes );
            }
        }).end();
    }
});


jQuery.expr.filters.hidden = function( elem ) {
    // Support: Opera <= 12.12
    // Opera reports offsetWidths and offsetHeights less than zero on some elements
    return elem.offsetWidth <= 0 && elem.offsetHeight <= 0 ||
        (!support.reliableHiddenOffsets() &&
            ((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");
};

jQuery.expr.filters.visible = function( elem ) {
    return !jQuery.expr.filters.hidden( elem );
};




var r20 = /%20/g,
    rbracket = /\[\]$/,
    rCRLF = /\r?\n/g,
    rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
    rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
    var name;

    if ( jQuery.isArray( obj ) ) {
        // Serialize array item.
        jQuery.each( obj, function( i, v ) {
            if ( traditional || rbracket.test( prefix ) ) {
                // Treat each array item as a scalar.
                add( prefix, v );

            } else {
                // Item is non-scalar (array or object), encode its numeric index.
                buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
            }
        });

    } else if ( !traditional && jQuery.type( obj ) === "object" ) {
        // Serialize object item.
        for ( name in obj ) {
            buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
        }

    } else {
        // Serialize scalar item.
        add( prefix, obj );
    }
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
    var prefix,
        s = [],
        add = function( key, value ) {
            // If value is a function, invoke it and return its value
            value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
            s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
        };

    // Set traditional to true for jQuery <= 1.3.2 behavior.
    if ( traditional === undefined ) {
        traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
    }

    // If an array was passed in, assume that it is an array of form elements.
    if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
        // Serialize the form elements
        jQuery.each( a, function() {
            add( this.name, this.value );
        });

    } else {
        // If traditional, encode the "old" way (the way 1.3.2 or older
        // did it), otherwise encode params recursively.
        for ( prefix in a ) {
            buildParams( prefix, a[ prefix ], traditional, add );
        }
    }

    // Return the resulting serialization
    return s.join( "&" ).replace( r20, "+" );
};

jQuery.fn.extend({
    serialize: function() {
        return jQuery.param( this.serializeArray() );
    },
    serializeArray: function() {
        return this.map(function() {
            // Can add propHook for "elements" to filter or add form elements
            var elements = jQuery.prop( this, "elements" );
            return elements ? jQuery.makeArray( elements ) : this;
        })
        .filter(function() {
            var type = this.type;
            // Use .is(":disabled") so that fieldset[disabled] works
            return this.name && !jQuery( this ).is( ":disabled" ) &&
                rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
                ( this.checked || !rcheckableType.test( type ) );
        })
        .map(function( i, elem ) {
            var val = jQuery( this ).val();

            return val == null ?
                null :
                jQuery.isArray( val ) ?
                    jQuery.map( val, function( val ) {
                        return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
                    }) :
                    { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
        }).get();
    }
});


// Create the request object
// (This is still attached to ajaxSettings for backward compatibility)
jQuery.ajaxSettings.xhr = window.ActiveXObject !== undefined ?
    // Support: IE6+
    function() {

        // XHR cannot access local files, always use ActiveX for that case
        return !this.isLocal &&

            // Support: IE7-8
            // oldIE XHR does not support non-RFC2616 methods (#13240)
            // See http://msdn.microsoft.com/en-us/library/ie/ms536648(v=vs.85).aspx
            // and http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9
            // Although this check for six methods instead of eight
            // since IE also does not support "trace" and "connect"
            /^(get|post|head|put|delete|options)$/i.test( this.type ) &&

            createStandardXHR() || createActiveXHR();
    } :
    // For all other browsers, use the standard XMLHttpRequest object
    createStandardXHR;

var xhrId = 0,
    xhrCallbacks = {},
    xhrSupported = jQuery.ajaxSettings.xhr();

// Support: IE<10
// Open requests must be manually aborted on unload (#5280)
if ( window.ActiveXObject ) {
    jQuery( window ).on( "unload", function() {
        for ( var key in xhrCallbacks ) {
            xhrCallbacks[ key ]( undefined, true );
        }
    });
}

// Determine support properties
support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
xhrSupported = support.ajax = !!xhrSupported;

// Create transport if the browser can provide an xhr
if ( xhrSupported ) {

    jQuery.ajaxTransport(function( options ) {
        // Cross domain only allowed if supported through XMLHttpRequest
        if ( !options.crossDomain || support.cors ) {

            var callback;

            return {
                send: function( headers, complete ) {
                    var i,
                        xhr = options.xhr(),
                        id = ++xhrId;

                    // Open the socket
                    xhr.open( options.type, options.url, options.async, options.username, options.password );

                    // Apply custom fields if provided
                    if ( options.xhrFields ) {
                        for ( i in options.xhrFields ) {
                            xhr[ i ] = options.xhrFields[ i ];
                        }
                    }

                    // Override mime type if needed
                    if ( options.mimeType && xhr.overrideMimeType ) {
                        xhr.overrideMimeType( options.mimeType );
                    }

                    // X-Requested-With header
                    // For cross-domain requests, seeing as conditions for a preflight are
                    // akin to a jigsaw puzzle, we simply never set it to be sure.
                    // (it can always be set on a per-request basis or even using ajaxSetup)
                    // For same-domain requests, won't change header if already provided.
                    if ( !options.crossDomain && !headers["X-Requested-With"] ) {
                        headers["X-Requested-With"] = "XMLHttpRequest";
                    }

                    // Set headers
                    for ( i in headers ) {
                        // Support: IE<9
                        // IE's ActiveXObject throws a 'Type Mismatch' exception when setting
                        // request header to a null-value.
                        //
                        // To keep consistent with other XHR implementations, cast the value
                        // to string and ignore `undefined`.
                        if ( headers[ i ] !== undefined ) {
                            xhr.setRequestHeader( i, headers[ i ] + "" );
                        }
                    }

                    // Do send the request
                    // This may raise an exception which is actually
                    // handled in jQuery.ajax (so no try/catch here)
                    xhr.send( ( options.hasContent && options.data ) || null );

                    // Listener
                    callback = function( _, isAbort ) {
                        var status, statusText, responses;

                        // Was never called and is aborted or complete
                        if ( callback && ( isAbort || xhr.readyState === 4 ) ) {
                            // Clean up
                            delete xhrCallbacks[ id ];
                            callback = undefined;
                            xhr.onreadystatechange = jQuery.noop;

                            // Abort manually if needed
                            if ( isAbort ) {
                                if ( xhr.readyState !== 4 ) {
                                    xhr.abort();
                                }
                            } else {
                                responses = {};
                                status = xhr.status;

                                // Support: IE<10
                                // Accessing binary-data responseText throws an exception
                                // (#11426)
                                if ( typeof xhr.responseText === "string" ) {
                                    responses.text = xhr.responseText;
                                }

                                // Firefox throws an exception when accessing
                                // statusText for faulty cross-domain requests
                                try {
                                    statusText = xhr.statusText;
                                } catch( e ) {
                                    // We normalize with Webkit giving an empty statusText
                                    statusText = "";
                                }

                                // Filter status for non standard behaviors

                                // If the request is local and we have data: assume a success
                                // (success with no data won't get notified, that's the best we
                                // can do given current implementations)
                                if ( !status && options.isLocal && !options.crossDomain ) {
                                    status = responses.text ? 200 : 404;
                                // IE - #1450: sometimes returns 1223 when it should be 204
                                } else if ( status === 1223 ) {
                                    status = 204;
                                }
                            }
                        }

                        // Call complete if needed
                        if ( responses ) {
                            complete( status, statusText, responses, xhr.getAllResponseHeaders() );
                        }
                    };

                    if ( !options.async ) {
                        // if we're in sync mode we fire the callback
                        callback();
                    } else if ( xhr.readyState === 4 ) {
                        // (IE6 & IE7) if it's in cache and has been
                        // retrieved directly we need to fire the callback
                        setTimeout( callback );
                    } else {
                        // Add to the list of active xhr callbacks
                        xhr.onreadystatechange = xhrCallbacks[ id ] = callback;
                    }
                },

                abort: function() {
                    if ( callback ) {
                        callback( undefined, true );
                    }
                }
            };
        }
    });
}

// Functions to create xhrs
function createStandardXHR() {
    try {
        return new window.XMLHttpRequest();
    } catch( e ) {}
}

function createActiveXHR() {
    try {
        return new window.ActiveXObject( "Microsoft.XMLHTTP" );
    } catch( e ) {}
}




// Install script dataType
jQuery.ajaxSetup({
    accepts: {
        script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
    },
    contents: {
        script: /(?:java|ecma)script/
    },
    converters: {
        "text script": function( text ) {
            jQuery.globalEval( text );
            return text;
        }
    }
});

// Handle cache's special case and global
jQuery.ajaxPrefilter( "script", function( s ) {
    if ( s.cache === undefined ) {
        s.cache = false;
    }
    if ( s.crossDomain ) {
        s.type = "GET";
        s.global = false;
    }
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function(s) {

    // This transport only deals with cross domain requests
    if ( s.crossDomain ) {

        var script,
            head = document.head || jQuery("head")[0] || document.documentElement;

        return {

            send: function( _, callback ) {

                script = document.createElement("script");

                script.async = true;

                if ( s.scriptCharset ) {
                    script.charset = s.scriptCharset;
                }

                script.src = s.url;

                // Attach handlers for all browsers
                script.onload = script.onreadystatechange = function( _, isAbort ) {

                    if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

                        // Handle memory leak in IE
                        script.onload = script.onreadystatechange = null;

                        // Remove the script
                        if ( script.parentNode ) {
                            script.parentNode.removeChild( script );
                        }

                        // Dereference the script
                        script = null;

                        // Callback if not abort
                        if ( !isAbort ) {
                            callback( 200, "success" );
                        }
                    }
                };

                // Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending
                // Use native DOM manipulation to avoid our domManip AJAX trickery
                head.insertBefore( script, head.firstChild );
            },

            abort: function() {
                if ( script ) {
                    script.onload( undefined, true );
                }
            }
        };
    }
});




var oldCallbacks = [],
    rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function() {
        var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
        this[ callback ] = true;
        return callback;
    }
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

    var callbackName, overwritten, responseContainer,
        jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
            "url" :
            typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
        );

    // Handle iff the expected data type is "jsonp" or we have a parameter to set
    if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

        // Get callback name, remembering preexisting value associated with it
        callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
            s.jsonpCallback() :
            s.jsonpCallback;

        // Insert callback into url or form data
        if ( jsonProp ) {
            s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
        } else if ( s.jsonp !== false ) {
            s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
        }

        // Use data converter to retrieve json after script execution
        s.converters["script json"] = function() {
            if ( !responseContainer ) {
                jQuery.error( callbackName + " was not called" );
            }
            return responseContainer[ 0 ];
        };

        // force json dataType
        s.dataTypes[ 0 ] = "json";

        // Install callback
        overwritten = window[ callbackName ];
        window[ callbackName ] = function() {
            responseContainer = arguments;
        };

        // Clean-up function (fires after converters)
        jqXHR.always(function() {
            // Restore preexisting value
            window[ callbackName ] = overwritten;

            // Save back as free
            if ( s[ callbackName ] ) {
                // make sure that re-using the options doesn't screw things around
                s.jsonpCallback = originalSettings.jsonpCallback;

                // save the callback name for future use
                oldCallbacks.push( callbackName );
            }

            // Call if it was a function and we have a response
            if ( responseContainer && jQuery.isFunction( overwritten ) ) {
                overwritten( responseContainer[ 0 ] );
            }

            responseContainer = overwritten = undefined;
        });

        // Delegate to script
        return "script";
    }
});




// data: string of html
// context (optional): If specified, the fragment will be created in this context, defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
    if ( !data || typeof data !== "string" ) {
        return null;
    }
    if ( typeof context === "boolean" ) {
        keepScripts = context;
        context = false;
    }
    context = context || document;

    var parsed = rsingleTag.exec( data ),
        scripts = !keepScripts && [];

    // Single tag
    if ( parsed ) {
        return [ context.createElement( parsed[1] ) ];
    }

    parsed = jQuery.buildFragment( [ data ], context, scripts );

    if ( scripts && scripts.length ) {
        jQuery( scripts ).remove();
    }

    return jQuery.merge( [], parsed.childNodes );
};


// Keep a copy of the old load method
var _load = jQuery.fn.load;

/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
    if ( typeof url !== "string" && _load ) {
        return _load.apply( this, arguments );
    }

    var selector, response, type,
        self = this,
        off = url.indexOf(" ");

    if ( off >= 0 ) {
        selector = url.slice( off, url.length );
        url = url.slice( 0, off );
    }

    // If it's a function
    if ( jQuery.isFunction( params ) ) {

        // We assume that it's the callback
        callback = params;
        params = undefined;

    // Otherwise, build a param string
    } else if ( params && typeof params === "object" ) {
        type = "POST";
    }

    // If we have elements to modify, make the request
    if ( self.length > 0 ) {
        jQuery.ajax({
            url: url,

            // if "type" variable is undefined, then "GET" method will be used
            type: type,
            dataType: "html",
            data: params
        }).done(function( responseText ) {

            // Save response for use in complete callback
            response = arguments;

            self.html( selector ?

                // If a selector was specified, locate the right elements in a dummy div
                // Exclude scripts to avoid IE 'Permission Denied' errors
                jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

                // Otherwise use the full result
                responseText );

        }).complete( callback && function( jqXHR, status ) {
            self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
        });
    }

    return this;
};




jQuery.expr.filters.animated = function( elem ) {
    return jQuery.grep(jQuery.timers, function( fn ) {
        return elem === fn.elem;
    }).length;
};





var docElem = window.document.documentElement;

/**
 * Gets a window from an element
 */
function getWindow( elem ) {
    return jQuery.isWindow( elem ) ?
        elem :
        elem.nodeType === 9 ?
            elem.defaultView || elem.parentWindow :
            false;
}

jQuery.offset = {
    setOffset: function( elem, options, i ) {
        var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
            position = jQuery.css( elem, "position" ),
            curElem = jQuery( elem ),
            props = {};

        // set position first, in-case top/left are set even on static elem
        if ( position === "static" ) {
            elem.style.position = "relative";
        }

        curOffset = curElem.offset();
        curCSSTop = jQuery.css( elem, "top" );
        curCSSLeft = jQuery.css( elem, "left" );
        calculatePosition = ( position === "absolute" || position === "fixed" ) &&
            jQuery.inArray("auto", [ curCSSTop, curCSSLeft ] ) > -1;

        // need to be able to calculate position if either top or left is auto and position is either absolute or fixed
        if ( calculatePosition ) {
            curPosition = curElem.position();
            curTop = curPosition.top;
            curLeft = curPosition.left;
        } else {
            curTop = parseFloat( curCSSTop ) || 0;
            curLeft = parseFloat( curCSSLeft ) || 0;
        }

        if ( jQuery.isFunction( options ) ) {
            options = options.call( elem, i, curOffset );
        }

        if ( options.top != null ) {
            props.top = ( options.top - curOffset.top ) + curTop;
        }
        if ( options.left != null ) {
            props.left = ( options.left - curOffset.left ) + curLeft;
        }

        if ( "using" in options ) {
            options.using.call( elem, props );
        } else {
            curElem.css( props );
        }
    }
};

jQuery.fn.extend({
    offset: function( options ) {
        if ( arguments.length ) {
            return options === undefined ?
                this :
                this.each(function( i ) {
                    jQuery.offset.setOffset( this, options, i );
                });
        }

        var docElem, win,
            box = { top: 0, left: 0 },
            elem = this[ 0 ],
            doc = elem && elem.ownerDocument;

        if ( !doc ) {
            return;
        }

        docElem = doc.documentElement;

        // Make sure it's not a disconnected DOM node
        if ( !jQuery.contains( docElem, elem ) ) {
            return box;
        }

        // If we don't have gBCR, just use 0,0 rather than error
        // BlackBerry 5, iOS 3 (original iPhone)
        if ( typeof elem.getBoundingClientRect !== strundefined ) {
            box = elem.getBoundingClientRect();
        }
        win = getWindow( doc );
        return {
            top: box.top  + ( win.pageYOffset || docElem.scrollTop )  - ( docElem.clientTop  || 0 ),
            left: box.left + ( win.pageXOffset || docElem.scrollLeft ) - ( docElem.clientLeft || 0 )
        };
    },

    position: function() {
        if ( !this[ 0 ] ) {
            return;
        }

        var offsetParent, offset,
            parentOffset = { top: 0, left: 0 },
            elem = this[ 0 ];

        // fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
        if ( jQuery.css( elem, "position" ) === "fixed" ) {
            // we assume that getBoundingClientRect is available when computed position is fixed
            offset = elem.getBoundingClientRect();
        } else {
            // Get *real* offsetParent
            offsetParent = this.offsetParent();

            // Get correct offsets
            offset = this.offset();
            if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
                parentOffset = offsetParent.offset();
            }

            // Add offsetParent borders
            parentOffset.top  += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
            parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
        }

        // Subtract parent offsets and element margins
        // note: when an element has margin: auto the offsetLeft and marginLeft
        // are the same in Safari causing offset.left to incorrectly be 0
        return {
            top:  offset.top  - parentOffset.top - jQuery.css( elem, "marginTop", true ),
            left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true)
        };
    },

    offsetParent: function() {
        return this.map(function() {
            var offsetParent = this.offsetParent || docElem;

            while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
                offsetParent = offsetParent.offsetParent;
            }
            return offsetParent || docElem;
        });
    }
});

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
    var top = /Y/.test( prop );

    jQuery.fn[ method ] = function( val ) {
        return access( this, function( elem, method, val ) {
            var win = getWindow( elem );

            if ( val === undefined ) {
                return win ? (prop in win) ? win[ prop ] :
                    win.document.documentElement[ method ] :
                    elem[ method ];
            }

            if ( win ) {
                win.scrollTo(
                    !top ? val : jQuery( win ).scrollLeft(),
                    top ? val : jQuery( win ).scrollTop()
                );

            } else {
                elem[ method ] = val;
            }
        }, method, val, arguments.length, null );
    };
});

// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// getComputedStyle returns percent when specified for top/left/bottom/right
// rather than make the css module depend on the offset module, we just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
    jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
        function( elem, computed ) {
            if ( computed ) {
                computed = curCSS( elem, prop );
                // if curCSS returns percentage, fallback to offset
                return rnumnonpx.test( computed ) ?
                    jQuery( elem ).position()[ prop ] + "px" :
                    computed;
            }
        }
    );
});


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
    jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
        // margin is only for outerHeight, outerWidth
        jQuery.fn[ funcName ] = function( margin, value ) {
            var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
                extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

            return access( this, function( elem, type, value ) {
                var doc;

                if ( jQuery.isWindow( elem ) ) {
                    // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
                    // isn't a whole lot we can do. See pull request at this URL for discussion:
                    // https://github.com/jquery/jquery/pull/764
                    return elem.document.documentElement[ "client" + name ];
                }

                // Get document width or height
                if ( elem.nodeType === 9 ) {
                    doc = elem.documentElement;

                    // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest
                    // unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.
                    return Math.max(
                        elem.body[ "scroll" + name ], doc[ "scroll" + name ],
                        elem.body[ "offset" + name ], doc[ "offset" + name ],
                        doc[ "client" + name ]
                    );
                }

                return value === undefined ?
                    // Get width or height on the element, requesting but not forcing parseFloat
                    jQuery.css( elem, type, extra ) :

                    // Set width or height on the element
                    jQuery.style( elem, type, value, extra );
            }, type, chainable ? margin : undefined, chainable, null );
        };
    });
});


// The number of elements contained in the matched element set
jQuery.fn.size = function() {
    return this.length;
};

jQuery.fn.andSelf = jQuery.fn.addBack;

// Limit scope pollution from any deprecated API
(function() {

var matched, browser;

// Use of jQuery.browser is frowned upon.
// More details: http://api.jquery.com/jQuery.browser
// jQuery.uaMatch maintained for back-compat
jQuery.uaMatch = function( ua ) {
    ua = ua.toLowerCase();

    var match = /(chrome)[ \/]([\w.]+)/.exec( ua ) ||
        /(webkit)[ \/]([\w.]+)/.exec( ua ) ||
        /(opera)(?:.*version|)[ \/]([\w.]+)/.exec( ua ) ||
        /(msie) ([\w.]+)/.exec( ua ) ||
        ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec( ua ) ||
        [];

    return {
        browser: match[ 1 ] || "",
        version: match[ 2 ] || "0"
    };
};

matched = jQuery.uaMatch( navigator.userAgent );
browser = {};

if ( matched.browser ) {
    browser[ matched.browser ] = true;
    browser.version = matched.version;
}

// Chrome is Webkit, but Webkit is also Safari.
if ( browser.chrome ) {
    browser.webkit = true;
} else if ( browser.webkit ) {
    browser.safari = true;
}

jQuery.browser = browser;

})();




jQuery.version = "4.0";
jQuery.long_version = "4.0.37";

jQuery.uid = function(p,s) {
    return ((p) ? p : "") + Math.random().toString().replace(".","") + ((s) ? s : "");
};

jQuery.globalNamespace = jQuery.uid("Foundry");

window[jQuery.globalNamespace] = jQuery;

jQuery.run = function(command) {
    return (jQuery.isFunction(command)) ? command(jQuery) : null;
};

jQuery.initialize = function(options) {

    if (jQuery.initialized) return;

    jQuery.extend(jQuery, options);

    if (jQuery.environment=="development") {
        window.F = jQuery;
    }

    jQuery.initialized = true;

    // Execute any pending modules
    FD40.module.execute();
}

// Register jquery into bootloader
FD40.jquery(jQuery);

// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.
if ( typeof define === "function" && define.amd ) {
    define( "jquery", [], function() {
        return jQuery;
    });
}




return jQuery;

}));
FD40.plugin("lodash", function($) {

/**
 * @license
 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
 * Build: `lodash modern -o ./dist/lodash.js`
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <http://lodash.com/license>
 */

  /** Used as a safe reference for `undefined` in pre ES5 environments */
  var undefined;

  /** Used to pool arrays and objects used internally */
  var arrayPool = [],
      objectPool = [];

  /** Used to generate unique IDs */
  var idCounter = 0;

  /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */
  var keyPrefix = +new Date + '';

  /** Used as the size when optimizations are enabled for large arrays */
  var largeArraySize = 75;

  /** Used as the max size of the `arrayPool` and `objectPool` */
  var maxPoolSize = 40;

  /** Used to detect and test whitespace */
  var whitespace = (
    // whitespace
    ' \t\x0B\f\xA0\ufeff' +

    // line terminators
    '\n\r\u2028\u2029' +

    // unicode category "Zs" space separators
    '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
  );

  /** Used to match empty string literals in compiled template source */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /**
   * Used to match ES6 template delimiters
   * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-literals-string-literals
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match regexp flags from their coerced string values */
  var reFlags = /\w*$/;

  /** Used to detected named functions */
  var reFuncName = /^\s*function[ \n\r\t]+\w/;

  /** Used to match "interpolate" template delimiters */
  var reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match leading whitespace and zeros to be removed */
  var reLeadingSpacesAndZeros = RegExp('^[' + whitespace + ']*0+(?=.$)');

  /** Used to ensure capturing order of template delimiters */
  var reNoMatch = /($^)/;

  /** Used to detect functions containing a `this` reference */
  var reThis = /\bthis\b/;

  /** Used to match unescaped characters in compiled string literals */
  var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;

  /** Used to assign default `context` object properties */
  var contextProps = [
    'Array', 'Boolean', 'Date', 'Function', 'Math', 'Number', 'Object',
    'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN',
    'parseInt', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify */
  var templateCounter = 0;

  /** `Object#toString` result shortcuts */
  var argsClass = '[object Arguments]',
      arrayClass = '[object Array]',
      boolClass = '[object Boolean]',
      dateClass = '[object Date]',
      funcClass = '[object Function]',
      numberClass = '[object Number]',
      objectClass = '[object Object]',
      regexpClass = '[object RegExp]',
      stringClass = '[object String]';

  /** Used to identify object classifications that `_.clone` supports */
  var cloneableClasses = {};
  cloneableClasses[funcClass] = false;
  cloneableClasses[argsClass] = cloneableClasses[arrayClass] =
  cloneableClasses[boolClass] = cloneableClasses[dateClass] =
  cloneableClasses[numberClass] = cloneableClasses[objectClass] =
  cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;

  /** Used as an internal `_.debounce` options object */
  var debounceOptions = {
    'leading': false,
    'maxWait': 0,
    'trailing': false
  };

  /** Used as the property descriptor for `__bindData__` */
  var descriptor = {
    'configurable': false,
    'enumerable': false,
    'value': null,
    'writable': false
  };

  /** Used to determine if values are of the language type Object */
  var objectTypes = {
    'boolean': false,
    'function': true,
    'object': true,
    'number': false,
    'string': false,
    'undefined': false
  };

  /** Used to escape characters for inclusion in compiled string literals */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\t': 't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Used as a reference to the global object */
  var root = (objectTypes[typeof window] && window) || this;

  /** Detect free variable `exports` */
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  /** Detect free variable `module` */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports` */
  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
  var freeGlobal = objectTypes[typeof global] && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
    root = freeGlobal;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `_.indexOf` without support for binary searches
   * or `fromIndex` constraints.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the matched value or `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    var index = (fromIndex || 0) - 1,
        length = array ? array.length : 0;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * An implementation of `_.contains` for cache objects that mimics the return
   * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.
   *
   * @private
   * @param {Object} cache The cache object to inspect.
   * @param {*} value The value to search for.
   * @returns {number} Returns `0` if `value` is found, else `-1`.
   */
  function cacheIndexOf(cache, value) {
    var type = typeof value;
    cache = cache.cache;

    if (type == 'boolean' || value == null) {
      return cache[value] ? 0 : -1;
    }
    if (type != 'number' && type != 'string') {
      type = 'object';
    }
    var key = type == 'number' ? value : keyPrefix + value;
    cache = (cache = cache[type]) && cache[key];

    return type == 'object'
      ? (cache && baseIndexOf(cache, value) > -1 ? 0 : -1)
      : (cache ? 0 : -1);
  }

  /**
   * Adds a given value to the corresponding cache object.
   *
   * @private
   * @param {*} value The value to add to the cache.
   */
  function cachePush(value) {
    var cache = this.cache,
        type = typeof value;

    if (type == 'boolean' || value == null) {
      cache[value] = true;
    } else {
      if (type != 'number' && type != 'string') {
        type = 'object';
      }
      var key = type == 'number' ? value : keyPrefix + value,
          typeCache = cache[type] || (cache[type] = {});

      if (type == 'object') {
        (typeCache[key] || (typeCache[key] = [])).push(value);
      } else {
        typeCache[key] = true;
      }
    }
  }

  /**
   * Used by `_.max` and `_.min` as the default callback when a given
   * collection is a string value.
   *
   * @private
   * @param {string} value The character to inspect.
   * @returns {number} Returns the code unit of given character.
   */
  function charAtCallback(value) {
    return value.charCodeAt(0);
  }

  /**
   * Used by `sortBy` to compare transformed `collection` elements, stable sorting
   * them in ascending order.
   *
   * @private
   * @param {Object} a The object to compare to `b`.
   * @param {Object} b The object to compare to `a`.
   * @returns {number} Returns the sort order indicator of `1` or `-1`.
   */
  function compareAscending(a, b) {
    var ac = a.criteria,
        bc = b.criteria,
        index = -1,
        length = ac.length;

    while (++index < length) {
      var value = ac[index],
          other = bc[index];

      if (value !== other) {
        if (value > other || typeof value == 'undefined') {
          return 1;
        }
        if (value < other || typeof other == 'undefined') {
          return -1;
        }
      }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to return the same value for
    // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247
    //
    // This also ensures a stable sort in V8 and other engines.
    // See http://code.google.com/p/v8/issues/detail?id=90
    return a.index - b.index;
  }

  /**
   * Creates a cache object to optimize linear searches of large arrays.
   *
   * @private
   * @param {Array} [array=[]] The array to search.
   * @returns {null|Object} Returns the cache object or `null` if caching should not be used.
   */
  function createCache(array) {
    var index = -1,
        length = array.length,
        first = array[0],
        mid = array[(length / 2) | 0],
        last = array[length - 1];

    if (first && typeof first == 'object' &&
        mid && typeof mid == 'object' && last && typeof last == 'object') {
      return false;
    }
    var cache = getObject();
    cache['false'] = cache['null'] = cache['true'] = cache['undefined'] = false;

    var result = getObject();
    result.array = array;
    result.cache = cache;
    result.push = cachePush;

    while (++index < length) {
      result.push(array[index]);
    }
    return result;
  }

  /**
   * Used by `template` to escape characters for inclusion in compiled
   * string literals.
   *
   * @private
   * @param {string} match The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(match) {
    return '\\' + stringEscapes[match];
  }

  /**
   * Gets an array from the array pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Array} The array from the pool.
   */
  function getArray() {
    return arrayPool.pop() || [];
  }

  /**
   * Gets an object from the object pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Object} The object from the pool.
   */
  function getObject() {
    return objectPool.pop() || {
      'array': null,
      'cache': null,
      'criteria': null,
      'false': false,
      'index': 0,
      'null': false,
      'number': null,
      'object': null,
      'push': null,
      'string': null,
      'true': false,
      'undefined': false,
      'value': null
    };
  }

  /**
   * Releases the given array back to the array pool.
   *
   * @private
   * @param {Array} [array] The array to release.
   */
  function releaseArray(array) {
    array.length = 0;
    if (arrayPool.length < maxPoolSize) {
      arrayPool.push(array);
    }
  }

  /**
   * Releases the given object back to the object pool.
   *
   * @private
   * @param {Object} [object] The object to release.
   */
  function releaseObject(object) {
    var cache = object.cache;
    if (cache) {
      releaseObject(cache);
    }
    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
    if (objectPool.length < maxPoolSize) {
      objectPool.push(object);
    }
  }

  /**
   * Slices the `collection` from the `start` index up to, but not including,
   * the `end` index.
   *
   * Note: This function is used instead of `Array#slice` to support node lists
   * in IE < 9 and to ensure dense arrays are returned.
   *
   * @private
   * @param {Array|Object|string} collection The collection to slice.
   * @param {number} start The start index.
   * @param {number} end The end index.
   * @returns {Array} Returns the new array.
   */
  function slice(array, start, end) {
    start || (start = 0);
    if (typeof end == 'undefined') {
      end = array ? array.length : 0;
    }
    var index = -1,
        length = end - start || 0,
        result = Array(length < 0 ? 0 : length);

    while (++index < length) {
      result[index] = array[start + index];
    }
    return result;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new `lodash` function using the given context object.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns the `lodash` function.
   */
  function runInContext(context) {
    // Avoid issues with some ES3 environments that attempt to use values, named
    // after built-in constructors like `Object`, for the creation of literals.
    // ES5 clears this up by stating that literals must use built-in constructors.
    // See http://es5.github.io/#x11.1.5.
    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

    /** Native constructor references */
    var Array = context.Array,
        Boolean = context.Boolean,
        Date = context.Date,
        Function = context.Function,
        Math = context.Math,
        Number = context.Number,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /**
     * Used for `Array` method references.
     *
     * Normally `Array.prototype` would suffice, however, using an array literal
     * avoids issues in Narwhal.
     */
    var arrayRef = [];

    /** Used for native method references */
    var objectProto = Object.prototype;

    /** Used to restore the original `_` reference in `noConflict` */
    var oldDash = context._;

    /** Used to resolve the internal [[Class]] of values */
    var toString = objectProto.toString;

    /** Used to detect if a method is native */
    var reNative = RegExp('^' +
      String(toString)
        .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
        .replace(/toString| for [^\]]+/g, '.*?') + '$'
    );

    /** Native method shortcuts */
    var ceil = Math.ceil,
        clearTimeout = context.clearTimeout,
        floor = Math.floor,
        fnToString = Function.prototype.toString,
        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
        hasOwnProperty = objectProto.hasOwnProperty,
        push = arrayRef.push,
        setTimeout = context.setTimeout,
        splice = arrayRef.splice,
        unshift = arrayRef.unshift;

    /** Used to set meta data on functions */
    var defineProperty = (function() {
      // IE 8 only accepts DOM elements
      try {
        var o = {},
            func = isNative(func = Object.defineProperty) && func,
            result = func(o, o, o) && func;
      } catch(e) { }
      return result;
    }());

    /* Native method shortcuts for methods with the same name as other `lodash` methods */
    var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
        nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
        nativeIsFinite = context.isFinite,
        nativeIsNaN = context.isNaN,
        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random;

    /** Used to lookup a built-in constructor by [[Class]] */
    var ctorByClass = {};
    ctorByClass[arrayClass] = Array;
    ctorByClass[boolClass] = Boolean;
    ctorByClass[dateClass] = Date;
    ctorByClass[funcClass] = Function;
    ctorByClass[objectClass] = Object;
    ctorByClass[numberClass] = Number;
    ctorByClass[regexpClass] = RegExp;
    ctorByClass[stringClass] = String;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps the given value to enable intuitive
     * method chaining.
     *
     * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
     * and `unshift`
     *
     * Chaining is supported in custom builds as long as the `value` method is
     * implicitly or explicitly included in the build.
     *
     * The chainable wrapper functions are:
     * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
     * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,
     * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,
     * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
     * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
     * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
     * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,
     * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,
     * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,
     * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,
     * and `zip`
     *
     * The non-chainable wrapper functions are:
     * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,
     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,
     * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
     * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,
     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,
     * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,
     * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,
     * `template`, `unescape`, `uniqueId`, and `value`
     *
     * The wrapper functions `first` and `last` return wrapped values when `n` is
     * provided, otherwise they return unwrapped values.
     *
     * Explicit chaining can be enabled by using the `_.chain` method.
     *
     * @name _
     * @constructor
     * @category Chaining
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns a `lodash` instance.
     * @example
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // returns an unwrapped value
     * wrapped.reduce(function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * // returns a wrapped value
     * var squares = wrapped.map(function(num) {
     *   return num * num;
     * });
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor
      return (value && typeof value == 'object' && !isArray(value) && hasOwnProperty.call(value, '__wrapped__'))
       ? value
       : new lodashWrapper(value);
    }

    /**
     * A fast path for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap in a `lodash` instance.
     * @param {boolean} chainAll A flag to enable chaining for all methods
     * @returns {Object} Returns a `lodash` instance.
     */
    function lodashWrapper(value, chainAll) {
      this.__chain__ = !!chainAll;
      this.__wrapped__ = value;
    }
    // ensure `new lodashWrapper` is an instance of `lodash`
    lodashWrapper.prototype = lodash.prototype;

    /**
     * An object used to flag environments features.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    var support = lodash.support = {};

    /**
     * Detect if functions can be decompiled by `Function#toString`
     * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);

    /**
     * Detect if `Function#name` is supported (all but IE).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcNames = typeof Function.name == 'string';

    /**
     * By default, the template delimiters used by Lo-Dash are similar to those in
     * embedded Ruby (ERB). Change the following template settings to use alternative
     * delimiters.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'escape': /<%-([\s\S]+?)%>/g,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'evaluate': /<%([\s\S]+?)%>/g,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type string
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type Object
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type Function
         */
        '_': lodash
      }
    };

    /*--------------------------------------------------------------------------*/

    /**
     * The base implementation of `_.bind` that creates the bound function and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new bound function.
     */
    function baseBind(bindData) {
      var func = bindData[0],
          partialArgs = bindData[2],
          thisArg = bindData[4];

      function bound() {
        // `Function#bind` spec
        // http://es5.github.io/#x15.3.4.5
        if (partialArgs) {
          // avoid `arguments` object deoptimizations by using `slice` instead
          // of `Array.prototype.slice.call` and not assigning `arguments` to a
          // variable as a ternary expression
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        // mimic the constructor's `return` behavior
        // http://es5.github.io/#x13.2.2
        if (this instanceof bound) {
          // ensure `new bound` is an instance of `func`
          var thisBinding = baseCreate(func.prototype),
              result = func.apply(thisBinding, args || arguments);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisArg, args || arguments);
      }
      setBindData(bound, bindData);
      return bound;
    }

    /**
     * The base implementation of `_.clone` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates clones with source counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, isDeep, callback, stackA, stackB) {
      if (callback) {
        var result = callback(value);
        if (typeof result != 'undefined') {
          return result;
        }
      }
      // inspect [[Class]]
      var isObj = isObject(value);
      if (isObj) {
        var className = toString.call(value);
        if (!cloneableClasses[className]) {
          return value;
        }
        var ctor = ctorByClass[className];
        switch (className) {
          case boolClass:
          case dateClass:
            return new ctor(+value);

          case numberClass:
          case stringClass:
            return new ctor(value);

          case regexpClass:
            result = ctor(value.source, reFlags.exec(value));
            result.lastIndex = value.lastIndex;
            return result;
        }
      } else {
        return value;
      }
      var isArr = isArray(value);
      if (isDeep) {
        // check for circular references and return corresponding clone
        var initedStack = !stackA;
        stackA || (stackA = getArray());
        stackB || (stackB = getArray());

        var length = stackA.length;
        while (length--) {
          if (stackA[length] == value) {
            return stackB[length];
          }
        }
        result = isArr ? ctor(value.length) : {};
      }
      else {
        result = isArr ? slice(value) : assign({}, value);
      }
      // add array properties assigned by `RegExp#exec`
      if (isArr) {
        if (hasOwnProperty.call(value, 'index')) {
          result.index = value.index;
        }
        if (hasOwnProperty.call(value, 'input')) {
          result.input = value.input;
        }
      }
      // exit for shallow clone
      if (!isDeep) {
        return result;
      }
      // add the source value to the stack of traversed objects
      // and associate it with its clone
      stackA.push(value);
      stackB.push(result);

      // recursively populate clone (susceptible to call stack limits)
      (isArr ? forEach : forOwn)(value, function(objValue, key) {
        result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
      });

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    function baseCreate(prototype, properties) {
      return isObject(prototype) ? nativeCreate(prototype) : {};
    }
    // fallback for browsers without `Object.create`
    if (!nativeCreate) {
      baseCreate = (function() {
        function Object() {}
        return function(prototype) {
          if (isObject(prototype)) {
            Object.prototype = prototype;
            var result = new Object;
            Object.prototype = null;
          }
          return result || context.Object();
        };
      }());
    }

    /**
     * The base implementation of `_.createCallback` without support for creating
     * "_.pluck" or "_.where" style callbacks.
     *
     * @private
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     */
    function baseCreateCallback(func, thisArg, argCount) {
      if (typeof func != 'function') {
        return identity;
      }
      // exit early for no `thisArg` or already bound by `Function#bind`
      if (typeof thisArg == 'undefined' || !('prototype' in func)) {
        return func;
      }
      var bindData = func.__bindData__;
      if (typeof bindData == 'undefined') {
        if (support.funcNames) {
          bindData = !func.name;
        }
        bindData = bindData || !support.funcDecomp;
        if (!bindData) {
          var source = fnToString.call(func);
          if (!support.funcNames) {
            bindData = !reFuncName.test(source);
          }
          if (!bindData) {
            // checks if `func` references the `this` keyword and stores the result
            bindData = reThis.test(source);
            setBindData(func, bindData);
          }
        }
      }
      // exit early if there are no `this` references or `func` is bound
      if (bindData === false || (bindData !== true && bindData[1] & 1)) {
        return func;
      }
      switch (argCount) {
        case 1: return function(value) {
          return func.call(thisArg, value);
        };
        case 2: return function(a, b) {
          return func.call(thisArg, a, b);
        };
        case 3: return function(value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
        case 4: return function(accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
      }
      return bind(func, thisArg);
    }

    /**
     * The base implementation of `createWrapper` that creates the wrapper and
     * sets its meta data.
     *
     * @private
     * @param {Array} bindData The bind data array.
     * @returns {Function} Returns the new function.
     */
    function baseCreateWrapper(bindData) {
      var func = bindData[0],
          bitmask = bindData[1],
          partialArgs = bindData[2],
          partialRightArgs = bindData[3],
          thisArg = bindData[4],
          arity = bindData[5];

      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          key = func;

      function bound() {
        var thisBinding = isBind ? thisArg : this;
        if (partialArgs) {
          var args = slice(partialArgs);
          push.apply(args, arguments);
        }
        if (partialRightArgs || isCurry) {
          args || (args = slice(arguments));
          if (partialRightArgs) {
            push.apply(args, partialRightArgs);
          }
          if (isCurry && args.length < arity) {
            bitmask |= 16 & ~32;
            return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask & ~3), args, null, thisArg, arity]);
          }
        }
        args || (args = arguments);
        if (isBindKey) {
          func = thisBinding[key];
        }
        if (this instanceof bound) {
          thisBinding = baseCreate(func.prototype);
          var result = func.apply(thisBinding, args);
          return isObject(result) ? result : thisBinding;
        }
        return func.apply(thisBinding, args);
      }
      setBindData(bound, bindData);
      return bound;
    }

    /**
     * The base implementation of `_.difference` that accepts a single array
     * of values to exclude.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {Array} [values] The array of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     */
    function baseDifference(array, values) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          isLarge = length >= largeArraySize && indexOf === baseIndexOf,
          result = [];

      if (isLarge) {
        var cache = createCache(values);
        if (cache) {
          indexOf = cacheIndexOf;
          values = cache;
        } else {
          isLarge = false;
        }
      }
      while (++index < length) {
        var value = array[index];
        if (indexOf(values, value) < 0) {
          result.push(value);
        }
      }
      if (isLarge) {
        releaseObject(values);
      }
      return result;
    }

    /**
     * The base implementation of `_.flatten` without support for callback
     * shorthands or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.
     * @param {number} [fromIndex=0] The index to start from.
     * @returns {Array} Returns a new flattened array.
     */
    function baseFlatten(array, isShallow, isStrict, fromIndex) {
      var index = (fromIndex || 0) - 1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];

        if (value && typeof value == 'object' && typeof value.length == 'number'
            && (isArray(value) || isArguments(value))) {
          // recursively flatten arrays (susceptible to call stack limits)
          if (!isShallow) {
            value = baseFlatten(value, isShallow, isStrict);
          }
          var valIndex = -1,
              valLength = value.length,
              resIndex = result.length;

          result.length += valLength;
          while (++valIndex < valLength) {
            result[resIndex++] = value[valIndex];
          }
        } else if (!isStrict) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.isEqual`, without support for `thisArg` binding,
     * that allows partial "_.where" style comparisons.
     *
     * @private
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.
     * @param {Array} [stackA=[]] Tracks traversed `a` objects.
     * @param {Array} [stackB=[]] Tracks traversed `b` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
      // used to indicate that when comparing objects, `a` has at least the properties of `b`
      if (callback) {
        var result = callback(a, b);
        if (typeof result != 'undefined') {
          return !!result;
        }
      }
      // exit early for identical values
      if (a === b) {
        // treat `+0` vs. `-0` as not equal
        return a !== 0 || (1 / a == 1 / b);
      }
      var type = typeof a,
          otherType = typeof b;

      // exit early for unlike primitive values
      if (a === a &&
          !(a && objectTypes[type]) &&
          !(b && objectTypes[otherType])) {
        return false;
      }
      // exit early for `null` and `undefined` avoiding ES3's Function#call behavior
      // http://es5.github.io/#x15.3.4.4
      if (a == null || b == null) {
        return a === b;
      }
      // compare [[Class]] names
      var className = toString.call(a),
          otherClass = toString.call(b);

      if (className == argsClass) {
        className = objectClass;
      }
      if (otherClass == argsClass) {
        otherClass = objectClass;
      }
      if (className != otherClass) {
        return false;
      }
      switch (className) {
        case boolClass:
        case dateClass:
          // coerce dates and booleans to numbers, dates to milliseconds and booleans
          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal
          return +a == +b;

        case numberClass:
          // treat `NaN` vs. `NaN` as equal
          return (a != +a)
            ? b != +b
            // but treat `+0` vs. `-0` as not equal
            : (a == 0 ? (1 / a == 1 / b) : a == +b);

        case regexpClass:
        case stringClass:
          // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)
          // treat string primitives and their corresponding object instances as equal
          return a == String(b);
      }
      var isArr = className == arrayClass;
      if (!isArr) {
        // unwrap any `lodash` wrapped values
        var aWrapped = hasOwnProperty.call(a, '__wrapped__'),
            bWrapped = hasOwnProperty.call(b, '__wrapped__');

        if (aWrapped || bWrapped) {
          return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
        }
        // exit for functions and DOM nodes
        if (className != objectClass) {
          return false;
        }
        // in older versions of Opera, `arguments` objects have `Array` constructors
        var ctorA = a.constructor,
            ctorB = b.constructor;

        // non `Object` object instances with different constructors are not equal
        if (ctorA != ctorB &&
              !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) &&
              ('constructor' in a && 'constructor' in b)
            ) {
          return false;
        }
      }
      // assume cyclic structures are equal
      // the algorithm for detecting cyclic structures is adapted from ES 5.1
      // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)
      var initedStack = !stackA;
      stackA || (stackA = getArray());
      stackB || (stackB = getArray());

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == a) {
          return stackB[length] == b;
        }
      }
      var size = 0;
      result = true;

      // add `a` and `b` to the stack of traversed objects
      stackA.push(a);
      stackB.push(b);

      // recursively compare objects and arrays (susceptible to call stack limits)
      if (isArr) {
        // compare lengths to determine if a deep comparison is necessary
        length = a.length;
        size = b.length;
        result = size == length;

        if (result || isWhere) {
          // deep compare the contents, ignoring non-numeric properties
          while (size--) {
            var index = length,
                value = b[size];

            if (isWhere) {
              while (index--) {
                if ((result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB))) {
                  break;
                }
              }
            } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
              break;
            }
          }
        }
      }
      else {
        // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
        // which, in this case, is more costly
        forIn(b, function(value, key, b) {
          if (hasOwnProperty.call(b, key)) {
            // count the number of properties.
            size++;
            // deep compare each property value.
            return (result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB));
          }
        });

        if (result && !isWhere) {
          // ensure both objects have the same number of properties
          forIn(a, function(value, key, a) {
            if (hasOwnProperty.call(a, key)) {
              // `size` will be `-1` if `a` has more properties than `b`
              return (result = --size > -1);
            }
          });
        }
      }
      stackA.pop();
      stackB.pop();

      if (initedStack) {
        releaseArray(stackA);
        releaseArray(stackB);
      }
      return result;
    }

    /**
     * The base implementation of `_.merge` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     */
    function baseMerge(object, source, callback, stackA, stackB) {
      (isArray(source) ? forEach : forOwn)(source, function(source, key) {
        var found,
            isArr,
            result = source,
            value = object[key];

        if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
          // avoid merging previously merged cyclic sources
          var stackLength = stackA.length;
          while (stackLength--) {
            if ((found = stackA[stackLength] == source)) {
              value = stackB[stackLength];
              break;
            }
          }
          if (!found) {
            var isShallow;
            if (callback) {
              result = callback(value, source);
              if ((isShallow = typeof result != 'undefined')) {
                value = result;
              }
            }
            if (!isShallow) {
              value = isArr
                ? (isArray(value) ? value : [])
                : (isPlainObject(value) ? value : {});
            }
            // add `source` and associated `value` to the stack of traversed objects
            stackA.push(source);
            stackB.push(value);

            // recursively merge objects and arrays (susceptible to call stack limits)
            if (!isShallow) {
              baseMerge(value, source, callback, stackA, stackB);
            }
          }
        }
        else {
          if (callback) {
            result = callback(value, source);
            if (typeof result == 'undefined') {
              result = source;
            }
          }
          if (typeof result != 'undefined') {
            value = result;
          }
        }
        object[key] = value;
      });
    }

    /**
     * The base implementation of `_.random` without argument juggling or support
     * for returning floating-point numbers.
     *
     * @private
     * @param {number} min The minimum possible value.
     * @param {number} max The maximum possible value.
     * @returns {number} Returns a random number.
     */
    function baseRandom(min, max) {
      return min + floor(nativeRandom() * (max - min + 1));
    }

    /**
     * The base implementation of `_.uniq` without support for callback shorthands
     * or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function} [callback] The function called per iteration.
     * @returns {Array} Returns a duplicate-value-free array.
     */
    function baseUniq(array, isSorted, callback) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array ? array.length : 0,
          result = [];

      var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,
          seen = (callback || isLarge) ? getArray() : result;

      if (isLarge) {
        var cache = createCache(seen);
        indexOf = cacheIndexOf;
        seen = cache;
      }
      while (++index < length) {
        var value = array[index],
            computed = callback ? callback(value, index, array) : value;

        if (isSorted
              ? !index || seen[seen.length - 1] !== computed
              : indexOf(seen, computed) < 0
            ) {
          if (callback || isLarge) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      if (isLarge) {
        releaseArray(seen.array);
        releaseObject(seen);
      } else if (callback) {
        releaseArray(seen);
      }
      return result;
    }

    /**
     * Creates a function that aggregates a collection, creating an object composed
     * of keys generated from the results of running each element of the collection
     * through a callback. The given `setter` function sets the keys and values
     * of the composed object.
     *
     * @private
     * @param {Function} setter The setter function.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter) {
      return function(collection, callback, thisArg) {
        var result = {};
        callback = lodash.createCallback(callback, thisArg, 3);

        var index = -1,
            length = collection ? collection.length : 0;

        if (typeof length == 'number') {
          while (++index < length) {
            var value = collection[index];
            setter(result, value, callback(value, index, collection), collection);
          }
        } else {
          forOwn(collection, function(value, key, collection) {
            setter(result, value, callback(value, key, collection), collection);
          });
        }
        return result;
      };
    }

    /**
     * Creates a function that, when called, either curries or invokes `func`
     * with an optional `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of method flags to compose.
     *  The bitmask may be composed of the following flags:
     *  1 - `_.bind`
     *  2 - `_.bindKey`
     *  4 - `_.curry`
     *  8 - `_.curry` (bound)
     *  16 - `_.partial`
     *  32 - `_.partialRight`
     * @param {Array} [partialArgs] An array of arguments to prepend to those
     *  provided to the new function.
     * @param {Array} [partialRightArgs] An array of arguments to append to those
     *  provided to the new function.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new function.
     */
    function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
      var isBind = bitmask & 1,
          isBindKey = bitmask & 2,
          isCurry = bitmask & 4,
          isCurryBound = bitmask & 8,
          isPartial = bitmask & 16,
          isPartialRight = bitmask & 32;

      if (!isBindKey && !isFunction(func)) {
        throw new TypeError;
      }
      if (isPartial && !partialArgs.length) {
        bitmask &= ~16;
        isPartial = partialArgs = false;
      }
      if (isPartialRight && !partialRightArgs.length) {
        bitmask &= ~32;
        isPartialRight = partialRightArgs = false;
      }
      var bindData = func && func.__bindData__;
      if (bindData && bindData !== true) {
        // clone `bindData`
        bindData = slice(bindData);
        if (bindData[2]) {
          bindData[2] = slice(bindData[2]);
        }
        if (bindData[3]) {
          bindData[3] = slice(bindData[3]);
        }
        // set `thisBinding` is not previously bound
        if (isBind && !(bindData[1] & 1)) {
          bindData[4] = thisArg;
        }
        // set if previously bound but not currently (subsequent curried functions)
        if (!isBind && bindData[1] & 1) {
          bitmask |= 8;
        }
        // set curried arity if not yet set
        if (isCurry && !(bindData[1] & 4)) {
          bindData[5] = arity;
        }
        // append partial left arguments
        if (isPartial) {
          push.apply(bindData[2] || (bindData[2] = []), partialArgs);
        }
        // append partial right arguments
        if (isPartialRight) {
          unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
        }
        // merge flags
        bindData[1] |= bitmask;
        return createWrapper.apply(null, bindData);
      }
      // fast path for `_.bind`
      var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;
      return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
    }

    /**
     * Used by `escape` to convert characters to HTML entities.
     *
     * @private
     * @param {string} match The matched character to escape.
     * @returns {string} Returns the escaped character.
     */
    function escapeHtmlChar(match) {
      return htmlEscapes[match];
    }

    /**
     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
     * customized, this method returns the custom method, otherwise it returns
     * the `baseIndexOf` function.
     *
     * @private
     * @returns {Function} Returns the "indexOf" function.
     */
    function getIndexOf() {
      var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
      return result;
    }

    /**
     * Checks if `value` is a native function.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.
     */
    function isNative(value) {
      return typeof value == 'function' && reNative.test(value);
    }

    /**
     * Sets `this` binding data on a given function.
     *
     * @private
     * @param {Function} func The function to set data on.
     * @param {Array} value The data array to set.
     */
    var setBindData = !defineProperty ? noop : function(func, value) {
      descriptor.value = value;
      defineProperty(func, '__bindData__', descriptor);
    };

    /**
     * A fallback implementation of `isPlainObject` which checks if a given value
     * is an object created by the `Object` constructor, assuming objects created
     * by the `Object` constructor have no inherited enumerable properties and that
     * there are no `Object.prototype` extensions.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     */
    function shimIsPlainObject(value) {
      var ctor,
          result;

      // avoid non Object objects, `arguments` objects, and DOM elements
      if (!(value && toString.call(value) == objectClass) ||
          (ctor = value.constructor, isFunction(ctor) && !(ctor instanceof ctor))) {
        return false;
      }
      // In most environments an object's own properties are iterated before
      // its inherited properties. If the last iterated property is an object's
      // own property then there are no inherited enumerable properties.
      forIn(value, function(value, key) {
        result = key;
      });
      return typeof result == 'undefined' || hasOwnProperty.call(value, result);
    }

    /**
     * Used by `unescape` to convert HTML entities to characters.
     *
     * @private
     * @param {string} match The matched character to unescape.
     * @returns {string} Returns the unescaped character.
     */
    function unescapeHtmlChar(match) {
      return htmlUnescapes[match];
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Checks if `value` is an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
     * @example
     *
     * (function() { return _.isArguments(arguments); })(1, 2, 3);
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == argsClass || false;
    }

    /**
     * Checks if `value` is an array.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an array, else `false`.
     * @example
     *
     * (function() { return _.isArray(arguments); })();
     * // => false
     *
     * _.isArray([1, 2, 3]);
     * // => true
     */
    var isArray = nativeIsArray || function(value) {
      return value && typeof value == 'object' && typeof value.length == 'number' &&
        toString.call(value) == arrayClass || false;
    };

    /**
     * A fallback implementation of `Object.keys` which produces an array of the
     * given object's own enumerable property names.
     *
     * @private
     * @type Function
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     */
    var shimKeys = function(object) {
      var index, iterable = object, result = [];
      if (!iterable) return result;
      if (!(objectTypes[typeof object])) return result;
        for (index in iterable) {
          if (hasOwnProperty.call(iterable, index)) {
            result.push(index);
          }
        }
      return result
    };

    /**
     * Creates an array composed of the own enumerable property names of an object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names.
     * @example
     *
     * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
     * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)
     */
    var keys = !nativeKeys ? shimKeys : function(object) {
      if (!isObject(object)) {
        return [];
      }
      return nativeKeys(object);
    };

    /**
     * Used to convert characters to HTML entities:
     *
     * Though the `>` character is escaped for symmetry, characters like `>` and `/`
     * don't require escaping in HTML and have no special meaning unless they're part
     * of a tag or an unquoted attribute value.
     * http://mathiasbynens.be/notes/ambiguous-ampersands (under "semi-related fun fact")
     */
    var htmlEscapes = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };

    /** Used to convert HTML entities to characters */
    var htmlUnescapes = invert(htmlEscapes);

    /** Used to match HTML entities and HTML characters */
    var reEscapedHtml = RegExp('(' + keys(htmlUnescapes).join('|') + ')', 'g'),
        reUnescapedHtml = RegExp('[' + keys(htmlEscapes).join('') + ']', 'g');

    /*--------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object. Subsequent sources will overwrite property assignments of previous
     * sources. If a callback is provided it will be executed to produce the
     * assigned values. The callback is bound to `thisArg` and invoked with two
     * arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @type Function
     * @alias extend
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize assigning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });
     * // => { 'name': 'fred', 'employer': 'slate' }
     *
     * var defaults = _.partialRight(_.assign, function(a, b) {
     *   return typeof a == 'undefined' ? b : a;
     * });
     *
     * var object = { 'name': 'barney' };
     * defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */
    var assign = function(object, source, guard) {
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {
        var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);
      } else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {
        callback = args[--argsLength];
      }
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];
        }
        }
      }
      return result
    };

    /**
     * Creates a clone of `value`. If `isDeep` is `true` nested objects will also
     * be cloned, otherwise they will be assigned by reference. If a callback
     * is provided it will be executed to produce the cloned values. If the
     * callback returns `undefined` cloning will be handled by the method instead.
     * The callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var shallow = _.clone(characters);
     * shallow[0] === characters[0];
     * // => true
     *
     * var deep = _.clone(characters, true);
     * deep[0] === characters[0];
     * // => false
     *
     * _.mixin({
     *   'clone': _.partialRight(_.clone, function(value) {
     *     return _.isElement(value) ? value.cloneNode(false) : undefined;
     *   })
     * });
     *
     * var clone = _.clone(document.body);
     * clone.childNodes.length;
     * // => 0
     */
    function clone(value, isDeep, callback, thisArg) {
      // allows working with "Collections" methods without using their `index`
      // and `collection` arguments for `isDeep` and `callback`
      if (typeof isDeep != 'boolean' && isDeep != null) {
        thisArg = callback;
        callback = isDeep;
        isDeep = false;
      }
      return baseClone(value, isDeep, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }

    /**
     * Creates a deep clone of `value`. If a callback is provided it will be
     * executed to produce the cloned values. If the callback returns `undefined`
     * cloning will be handled by the method instead. The callback is bound to
     * `thisArg` and invoked with one argument; (value).
     *
     * Note: This method is loosely based on the structured clone algorithm. Functions
     * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and
     * objects created by constructors other than `Object` are cloned to plain `Object` objects.
     * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the deep cloned value.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * var deep = _.cloneDeep(characters);
     * deep[0] === characters[0];
     * // => false
     *
     * var view = {
     *   'label': 'docs',
     *   'node': element
     * };
     *
     * var clone = _.cloneDeep(view, function(value) {
     *   return _.isElement(value) ? value.cloneNode(true) : undefined;
     * });
     *
     * clone.node == view.node;
     * // => false
     */
    function cloneDeep(value, callback, thisArg) {
      return baseClone(value, true, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 1));
    }

    /**
     * Creates an object that inherits from the given `prototype` object. If a
     * `properties` object is provided its own enumerable properties are assigned
     * to the created object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties ? assign(result, properties) : result;
    }

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object for all destination properties that resolve to `undefined`. Once a
     * property is set, additional defaults of the same property will be ignored.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param- {Object} [guard] Allows working with `_.reduce` without using its
     *  `key` and `object` arguments as sources.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var object = { 'name': 'barney' };
     * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });
     * // => { 'name': 'barney', 'employer': 'slate' }
     */
    var defaults = function(object, source, guard) {
      var index, iterable = object, result = iterable;
      if (!iterable) return result;
      var args = arguments,
          argsIndex = 0,
          argsLength = typeof guard == 'number' ? 2 : args.length;
      while (++argsIndex < argsLength) {
        iterable = args[argsIndex];
        if (iterable && objectTypes[typeof iterable]) {
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (typeof result[index] == 'undefined') result[index] = iterable[index];
        }
        }
      }
      return result
    };

    /**
     * This method is like `_.findIndex` except that it returns the key of the
     * first element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': false },
     *   'fred': {    'age': 40, 'blocked': true },
     *   'pebbles': { 'age': 1,  'blocked': false }
     * };
     *
     * _.findKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => 'barney' (property order is not guaranteed across environments)
     *
     * // using "_.where" callback shorthand
     * _.findKey(characters, { 'age': 1 });
     * // => 'pebbles'
     *
     * // using "_.pluck" callback shorthand
     * _.findKey(characters, 'blocked');
     * // => 'fred'
     */
    function findKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwn(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * var characters = {
     *   'barney': {  'age': 36, 'blocked': true },
     *   'fred': {    'age': 40, 'blocked': false },
     *   'pebbles': { 'age': 1,  'blocked': true }
     * };
     *
     * _.findLastKey(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => returns `pebbles`, assuming `_.findKey` returns `barney`
     *
     * // using "_.where" callback shorthand
     * _.findLastKey(characters, { 'age': 40 });
     * // => 'fred'
     *
     * // using "_.pluck" callback shorthand
     * _.findLastKey(characters, 'blocked');
     * // => 'pebbles'
     */
    function findLastKey(object, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forOwnRight(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result = key;
          return false;
        }
      });
      return result;
    }

    /**
     * Iterates over own and inherited enumerable properties of an object,
     * executing the callback for each property. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, key, object). Callbacks may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forIn(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)
     */
    var forIn = function(collection, callback, thisArg) {
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
        for (index in iterable) {
          if (callback(iterable[index], index, collection) === false) return result;
        }
      return result
    };

    /**
     * This method is like `_.forIn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * Shape.prototype.move = function(x, y) {
     *   this.x += x;
     *   this.y += y;
     * };
     *
     * _.forInRight(new Shape, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'move', 'y', and 'x' assuming `_.forIn ` logs 'x', 'y', and 'move'
     */
    function forInRight(object, callback, thisArg) {
      var pairs = [];

      forIn(object, function(value, key) {
        pairs.push(key, value);
      });

      var length = pairs.length;
      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(pairs[length--], pairs[length], object) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * Iterates over own enumerable properties of an object, executing the callback
     * for each property. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, key, object). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)
     */
    var forOwn = function(collection, callback, thisArg) {
      var index, iterable = collection, result = iterable;
      if (!iterable) return result;
      if (!objectTypes[typeof iterable]) return result;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
        var ownIndex = -1,
            ownProps = objectTypes[typeof iterable] && keys(iterable),
            length = ownProps ? ownProps.length : 0;

        while (++ownIndex < length) {
          index = ownProps[ownIndex];
          if (callback(iterable[index], index, collection) === false) return result;
        }
      return result
    };

    /**
     * This method is like `_.forOwn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'
     */
    function forOwnRight(object, callback, thisArg) {
      var props = keys(object),
          length = props.length;

      callback = baseCreateCallback(callback, thisArg, 3);
      while (length--) {
        var key = props[length];
        if (callback(object[key], key, object) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * Creates a sorted array of property names of all enumerable properties,
     * own and inherited, of `object` that have function values.
     *
     * @static
     * @memberOf _
     * @alias methods
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names that have function values.
     * @example
     *
     * _.functions(_);
     * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
     */
    function functions(object) {
      var result = [];
      forIn(object, function(value, key) {
        if (isFunction(value)) {
          result.push(key);
        }
      });
      return result.sort();
    }

    /**
     * Checks if the specified property name exists as a direct property of `object`,
     * instead of an inherited property.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to check.
     * @returns {boolean} Returns `true` if key is a direct property, else `false`.
     * @example
     *
     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
     * // => true
     */
    function has(object, key) {
      return object ? hasOwnProperty.call(object, key) : false;
    }

    /**
     * Creates an object composed of the inverted keys and values of the given object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the created inverted object.
     * @example
     *
     * _.invert({ 'first': 'fred', 'second': 'barney' });
     * // => { 'fred': 'first', 'barney': 'second' }
     */
    function invert(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index];
        result[object[key]] = key;
      }
      return result;
    }

    /**
     * Checks if `value` is a boolean value.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.
     * @example
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        value && typeof value == 'object' && toString.call(value) == boolClass || false;
    }

    /**
     * Checks if `value` is a date.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a date, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     */
    function isDate(value) {
      return value && typeof value == 'object' && toString.call(value) == dateClass || false;
    }

    /**
     * Checks if `value` is a DOM element.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     */
    function isElement(value) {
      return value && value.nodeType === 1 || false;
    }

    /**
     * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
     * length of `0` and objects with no own enumerable properties are considered
     * "empty".
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object|string} value The value to inspect.
     * @returns {boolean} Returns `true` if the `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({});
     * // => true
     *
     * _.isEmpty('');
     * // => true
     */
    function isEmpty(value) {
      var result = true;
      if (!value) {
        return result;
      }
      var className = toString.call(value),
          length = value.length;

      if ((className == arrayClass || className == stringClass || className == argsClass ) ||
          (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {
        return !length;
      }
      forOwn(value, function() {
        return (result = false);
      });
      return result;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent to each other. If a callback is provided it will be executed
     * to compare values. If the callback returns `undefined` comparisons will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (a, b).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var copy = { 'name': 'fred' };
     *
     * object == copy;
     * // => false
     *
     * _.isEqual(object, copy);
     * // => true
     *
     * var words = ['hello', 'goodbye'];
     * var otherWords = ['hi', 'goodbye'];
     *
     * _.isEqual(words, otherWords, function(a, b) {
     *   var reGreet = /^(?:hello|hi)$/i,
     *       aGreet = _.isString(a) && reGreet.test(a),
     *       bGreet = _.isString(b) && reGreet.test(b);
     *
     *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;
     * });
     * // => true
     */
    function isEqual(a, b, callback, thisArg) {
      return baseIsEqual(a, b, typeof callback == 'function' && baseCreateCallback(callback, thisArg, 2));
    }

    /**
     * Checks if `value` is, or can be coerced to, a finite number.
     *
     * Note: This is not the same as native `isFinite` which will return true for
     * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is finite, else `false`.
     * @example
     *
     * _.isFinite(-101);
     * // => true
     *
     * _.isFinite('10');
     * // => true
     *
     * _.isFinite(true);
     * // => false
     *
     * _.isFinite('');
     * // => false
     *
     * _.isFinite(Infinity);
     * // => false
     */
    function isFinite(value) {
      return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
    }

    /**
     * Checks if `value` is a function.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     */
    function isFunction(value) {
      return typeof value == 'function';
    }

    /**
     * Checks if `value` is the language type of Object.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(1);
     * // => false
     */
    function isObject(value) {
      // check if the value is the ECMAScript language type of Object
      // http://es5.github.io/#x8
      // and avoid a V8 bug
      // http://code.google.com/p/v8/issues/detail?id=2291
      return !!(value && objectTypes[typeof value]);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * Note: This is not the same as native `isNaN` which will return `true` for
     * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // `NaN` as a primitive is the only value that is not equal to itself
      // (perform the [[Class]] check first to avoid errors with some host objects in IE)
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(undefined);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is a number.
     *
     * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(8.4 * 5);
     * // => true
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        value && typeof value == 'object' && toString.call(value) == numberClass || false;
    }

    /**
     * Checks if `value` is an object created by the `Object` constructor.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * _.isPlainObject(new Shape);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     */
    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
      if (!(value && toString.call(value) == objectClass)) {
        return false;
      }
      var valueOf = value.valueOf,
          objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

      return objProto
        ? (value == objProto || getPrototypeOf(value) == objProto)
        : shimIsPlainObject(value);
    };

    /**
     * Checks if `value` is a regular expression.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.
     * @example
     *
     * _.isRegExp(/fred/);
     * // => true
     */
    function isRegExp(value) {
      return value && typeof value == 'object' && toString.call(value) == regexpClass || false;
    }

    /**
     * Checks if `value` is a string.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
     * @example
     *
     * _.isString('fred');
     * // => true
     */
    function isString(value) {
      return typeof value == 'string' ||
        value && typeof value == 'object' && toString.call(value) == stringClass || false;
    }

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     */
    function isUndefined(value) {
      return typeof value == 'undefined';
    }

    /**
     * Creates an object with the same keys as `object` and values generated by
     * running each own enumerable property of `object` through the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new object with values of the results of each `callback` execution.
     * @example
     *
     * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(num) { return num * 3; });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     *
     * var characters = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // using "_.pluck" callback shorthand
     * _.mapValues(characters, 'age');
     * // => { 'fred': 40, 'pebbles': 1 }
     */
    function mapValues(object, callback, thisArg) {
      var result = {};
      callback = lodash.createCallback(callback, thisArg, 3);

      forOwn(object, function(value, key, object) {
        result[key] = callback(value, key, object);
      });
      return result;
    }

    /**
     * Recursively merges own enumerable properties of the source object(s), that
     * don't resolve to `undefined` into the destination object. Subsequent sources
     * will overwrite property assignments of previous sources. If a callback is
     * provided it will be executed to produce the merged values of the destination
     * and source properties. If the callback returns `undefined` merging will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var names = {
     *   'characters': [
     *     { 'name': 'barney' },
     *     { 'name': 'fred' }
     *   ]
     * };
     *
     * var ages = {
     *   'characters': [
     *     { 'age': 36 },
     *     { 'age': 40 }
     *   ]
     * };
     *
     * _.merge(names, ages);
     * // => { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }
     *
     * var food = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
     *
     * var otherFood = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
     *
     * _.merge(food, otherFood, function(a, b) {
     *   return _.isArray(a) ? a.concat(b) : undefined;
     * });
     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }
     */
    function merge(object) {
      var args = arguments,
          length = 2;

      if (!isObject(object)) {
        return object;
      }
      // allows working with `_.reduce` and `_.reduceRight` without using
      // their `index` and `collection` arguments
      if (typeof args[2] != 'number') {
        length = args.length;
      }
      if (length > 3 && typeof args[length - 2] == 'function') {
        var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
      } else if (length > 2 && typeof args[length - 1] == 'function') {
        callback = args[--length];
      }
      var sources = slice(arguments, 1, length),
          index = -1,
          stackA = getArray(),
          stackB = getArray();

      while (++index < length) {
        baseMerge(object, sources[index], callback, stackA, stackB);
      }
      releaseArray(stackA);
      releaseArray(stackB);
      return object;
    }

    /**
     * Creates a shallow clone of `object` excluding the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` omitting the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The properties to omit or the
     *  function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object without the omitted properties.
     * @example
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, 'age');
     * // => { 'name': 'fred' }
     *
     * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {
     *   return typeof value == 'number';
     * });
     * // => { 'name': 'fred' }
     */
    function omit(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var props = [];
        forIn(object, function(value, key) {
          props.push(key);
        });
        props = baseDifference(props, baseFlatten(arguments, true, false, 1));

        var index = -1,
            length = props.length;

        while (++index < length) {
          var key = props[index];
          result[key] = object[key];
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (!callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }

    /**
     * Creates a two dimensional array of an object's key-value pairs,
     * i.e. `[[key1, value1], [key2, value2]]`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns new array of key-value pairs.
     * @example
     *
     * _.pairs({ 'barney': 36, 'fred': 40 });
     * // => [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)
     */
    function pairs(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        var key = props[index];
        result[index] = [key, object[key]];
      }
      return result;
    }

    /**
     * Creates a shallow clone of `object` composed of the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` picking the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The function called per
     *  iteration or property names to pick, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object composed of the picked properties.
     * @example
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');
     * // => { 'name': 'fred' }
     *
     * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {
     *   return key.charAt(0) != '_';
     * });
     * // => { 'name': 'fred' }
     */
    function pick(object, callback, thisArg) {
      var result = {};
      if (typeof callback != 'function') {
        var index = -1,
            props = baseFlatten(arguments, true, false, 1),
            length = isObject(object) ? props.length : 0;

        while (++index < length) {
          var key = props[index];
          if (key in object) {
            result[key] = object[key];
          }
        }
      } else {
        callback = lodash.createCallback(callback, thisArg, 3);
        forIn(object, function(value, key, object) {
          if (callback(value, key, object)) {
            result[key] = value;
          }
        });
      }
      return result;
    }

    /**
     * An alternative to `_.reduce` this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable properties through a callback, with each callback execution
     * potentially mutating the `accumulator` object. The callback is bound to
     * `thisArg` and invoked with four arguments; (accumulator, value, key, object).
     * Callbacks may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {
     *   num *= num;
     *   if (num % 2) {
     *     return result.push(num) < 3;
     *   }
     * });
     * // => [1, 9, 25]
     *
     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     * });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function transform(object, callback, accumulator, thisArg) {
      var isArr = isArray(object);
      if (accumulator == null) {
        if (isArr) {
          accumulator = [];
        } else {
          var ctor = object && object.constructor,
              proto = ctor && ctor.prototype;

          accumulator = baseCreate(proto);
        }
      }
      if (callback) {
        callback = lodash.createCallback(callback, thisArg, 4);
        (isArr ? forEach : forOwn)(object, function(value, index, object) {
          return callback(accumulator, value, index, object);
        });
      }
      return accumulator;
    }

    /**
     * Creates an array composed of the own enumerable property values of `object`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property values.
     * @example
     *
     * _.values({ 'one': 1, 'two': 2, 'three': 3 });
     * // => [1, 2, 3] (property order is not guaranteed across environments)
     */
    function values(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        result[index] = object[props[index]];
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array of elements from the specified indexes, or keys, of the
     * `collection`. Indexes may be specified as individual arguments or as arrays
     * of indexes.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(number|number[]|string|string[])} [index] The indexes of `collection`
     *   to retrieve, specified as individual indexes or arrays of indexes.
     * @returns {Array} Returns a new array of elements corresponding to the
     *  provided indexes.
     * @example
     *
     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);
     * // => ['a', 'c', 'e']
     *
     * _.at(['fred', 'barney', 'pebbles'], 0, 2);
     * // => ['fred', 'pebbles']
     */
    function at(collection) {
      var args = arguments,
          index = -1,
          props = baseFlatten(args, true, false, 1),
          length = (args[2] && args[2][args[1]] === collection) ? 1 : props.length,
          result = Array(length);

      while(++index < length) {
        result[index] = collection[props[index]];
      }
      return result;
    }

    /**
     * Checks if a given value is present in a collection using strict equality
     * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the
     * offset from the end of the collection.
     *
     * @static
     * @memberOf _
     * @alias include
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {*} target The value to check for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {boolean} Returns `true` if the `target` element is found, else `false`.
     * @example
     *
     * _.contains([1, 2, 3], 1);
     * // => true
     *
     * _.contains([1, 2, 3], 1, 2);
     * // => false
     *
     * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');
     * // => true
     *
     * _.contains('pebbles', 'eb');
     * // => true
     */
    function contains(collection, target, fromIndex) {
      var index = -1,
          indexOf = getIndexOf(),
          length = collection ? collection.length : 0,
          result = false;

      fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
      if (isArray(collection)) {
        result = indexOf(collection, target, fromIndex) > -1;
      } else if (typeof length == 'number') {
        result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
      } else {
        forOwn(collection, function(value) {
          if (++index >= fromIndex) {
            return !(result = value === target);
          }
        });
      }
      return result;
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through the callback. The corresponding value
     * of each key is the number of times the key was returned by the callback.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);
    });

    /**
     * Checks if the given callback returns truey value for **all** elements of
     * a collection. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias all
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if all elements passed the callback check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes']);
     * // => false
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.every(characters, 'age');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.every(characters, { 'age': 36 });
     * // => false
     */
    function every(collection, callback, thisArg) {
      var result = true;
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if (!(result = !!callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return (result = !!callback(value, index, collection));
        });
      }
      return result;
    }

    /**
     * Iterates over elements of a collection, returning an array of all elements
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias select
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that passed the callback check.
     * @example
     *
     * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [2, 4, 6]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.filter(characters, 'blocked');
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     *
     * // using "_.where" callback shorthand
     * _.filter(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     */
    function filter(collection, callback, thisArg) {
      var result = [];
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            result.push(value);
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result.push(value);
          }
        });
      }
      return result;
    }

    /**
     * Iterates over elements of a collection, returning the first element that
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias detect, findWhere
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.find(characters, function(chr) {
     *   return chr.age < 40;
     * });
     * // => { 'name': 'barney', 'age': 36, 'blocked': false }
     *
     * // using "_.where" callback shorthand
     * _.find(characters, { 'age': 1 });
     * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }
     *
     * // using "_.pluck" callback shorthand
     * _.find(characters, 'blocked');
     * // => { 'name': 'fred', 'age': 40, 'blocked': true }
     */
    function find(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          var value = collection[index];
          if (callback(value, index, collection)) {
            return value;
          }
        }
      } else {
        var result;
        forOwn(collection, function(value, index, collection) {
          if (callback(value, index, collection)) {
            result = value;
            return false;
          }
        });
        return result;
      }
    }

    /**
     * This method is like `_.find` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(num) {
     *   return num % 2 == 1;
     * });
     * // => 3
     */
    function findLast(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);
      forEachRight(collection, function(value, index, collection) {
        if (callback(value, index, collection)) {
          result = value;
          return false;
        }
      });
      return result;
    }

    /**
     * Iterates over elements of a collection, executing the callback for each
     * element. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * Note: As with other "Collections" methods, objects with a `length` property
     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
     * may be used for object iteration.
     *
     * @static
     * @memberOf _
     * @alias each
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');
     * // => logs each number and returns '1,2,3'
     *
     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });
     * // => logs each number and returns the object (property order is not guaranteed across environments)
     */
    function forEach(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        while (++index < length) {
          if (callback(collection[index], index, collection) === false) {
            break;
          }
        }
      } else {
        forOwn(collection, callback);
      }
      return collection;
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias eachRight
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');
     * // => logs each number from right to left and returns '3,2,1'
     */
    function forEachRight(collection, callback, thisArg) {
      var length = collection ? collection.length : 0;
      callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        while (length--) {
          if (callback(collection[length], length, collection) === false) {
            break;
          }
        }
      } else {
        var props = keys(collection);
        length = props.length;
        forOwn(collection, function(value, key, collection) {
          key = props ? props[--length] : --length;
          return callback(collection[key], key, collection);
        });
      }
      return collection;
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of a collection through the callback. The corresponding value
     * of each key is an array of the elements responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * // using "_.pluck" callback shorthand
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of the collection through the given callback. The corresponding
     * value of each key is the last element responsible for generating the key.
     * The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var keys = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.indexBy(keys, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(characters, function(key) { this.fromCharCode(key.code); }, String);
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     */
    var indexBy = createAggregator(function(result, value, key) {
      result[key] = value;
    });

    /**
     * Invokes the method named by `methodName` on each element in the `collection`
     * returning an array of the results of each invoked method. Additional arguments
     * will be provided to each invoked method. If `methodName` is a function it
     * will be invoked for, and `this` bound to, each element in the `collection`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|string} methodName The name of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [arg] Arguments to invoke the method with.
     * @returns {Array} Returns a new array of the results of each invoked method.
     * @example
     *
     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invoke([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    function invoke(collection, methodName) {
      var args = slice(arguments, 2),
          index = -1,
          isFunc = typeof methodName == 'function',
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
      });
      return result;
    }

    /**
     * Creates an array of values by running each element in the collection
     * through the callback. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias collect
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of the results of each `callback` execution.
     * @example
     *
     * _.map([1, 2, 3], function(num) { return num * 3; });
     * // => [3, 6, 9]
     *
     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
     * // => [3, 6, 9] (property order is not guaranteed across environments)
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(characters, 'name');
     * // => ['barney', 'fred']
     */
    function map(collection, callback, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0;

      callback = lodash.createCallback(callback, thisArg, 3);
      if (typeof length == 'number') {
        var result = Array(length);
        while (++index < length) {
          result[index] = callback(collection[index], index, collection);
        }
      } else {
        result = [];
        forOwn(collection, function(value, key, collection) {
          result[++index] = callback(value, key, collection);
        });
      }
      return result;
    }

    /**
     * Retrieves the maximum value of a collection. If the collection is empty or
     * falsey `-Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.max(characters, function(chr) { return chr.age; });
     * // => { 'name': 'fred', 'age': 40 };
     *
     * // using "_.pluck" callback shorthand
     * _.max(characters, 'age');
     * // => { 'name': 'fred', 'age': 40 };
     */
    function max(collection, callback, thisArg) {
      var computed = -Infinity,
          result = computed;

      // allows working with functions like `_.map` without using
      // their `index` argument as a callback
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value > result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, 3);

        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current > computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the minimum value of a collection. If the collection is empty or
     * falsey `Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.min(characters, function(chr) { return chr.age; });
     * // => { 'name': 'barney', 'age': 36 };
     *
     * // using "_.pluck" callback shorthand
     * _.min(characters, 'age');
     * // => { 'name': 'barney', 'age': 36 };
     */
    function min(collection, callback, thisArg) {
      var computed = Infinity,
          result = computed;

      // allows working with functions like `_.map` without using
      // their `index` argument as a callback
      if (typeof callback != 'function' && thisArg && thisArg[callback] === collection) {
        callback = null;
      }
      if (callback == null && isArray(collection)) {
        var index = -1,
            length = collection.length;

        while (++index < length) {
          var value = collection[index];
          if (value < result) {
            result = value;
          }
        }
      } else {
        callback = (callback == null && isString(collection))
          ? charAtCallback
          : lodash.createCallback(callback, thisArg, 3);

        forEach(collection, function(value, index, collection) {
          var current = callback(value, index, collection);
          if (current < computed) {
            computed = current;
            result = value;
          }
        });
      }
      return result;
    }

    /**
     * Retrieves the value of a specified property from all elements in the collection.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {string} property The name of the property to pluck.
     * @returns {Array} Returns a new array of property values.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * _.pluck(characters, 'name');
     * // => ['barney', 'fred']
     */
    var pluck = map;

    /**
     * Reduces a collection to a value which is the accumulated result of running
     * each element in the collection through the callback, where each successive
     * callback execution consumes the return value of the previous execution. If
     * `accumulator` is not provided the first element of the collection will be
     * used as the initial `accumulator` value. The callback is bound to `thisArg`
     * and invoked with four arguments; (accumulator, value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @alias foldl, inject
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var sum = _.reduce([1, 2, 3], function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     *   return result;
     * }, {});
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
    function reduce(collection, callback, accumulator, thisArg) {
      if (!collection) return accumulator;
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);

      var index = -1,
          length = collection.length;

      if (typeof length == 'number') {
        if (noaccum) {
          accumulator = collection[++index];
        }
        while (++index < length) {
          accumulator = callback(accumulator, collection[index], index, collection);
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          accumulator = noaccum
            ? (noaccum = false, value)
            : callback(accumulator, value, index, collection)
        });
      }
      return accumulator;
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias foldr
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var list = [[0, 1], [2, 3], [4, 5]];
     * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, callback, accumulator, thisArg) {
      var noaccum = arguments.length < 3;
      callback = lodash.createCallback(callback, thisArg, 4);
      forEachRight(collection, function(value, index, collection) {
        accumulator = noaccum
          ? (noaccum = false, value)
          : callback(accumulator, value, index, collection);
      });
      return accumulator;
    }

    /**
     * The opposite of `_.filter` this method returns the elements of a
     * collection that the callback does **not** return truey for.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that failed the callback check.
     * @example
     *
     * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [1, 3, 5]
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.reject(characters, 'blocked');
     * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
     *
     * // using "_.where" callback shorthand
     * _.reject(characters, { 'age': 36 });
     * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
     */
    function reject(collection, callback, thisArg) {
      callback = lodash.createCallback(callback, thisArg, 3);
      return filter(collection, function(value, index, collection) {
        return !callback(value, index, collection);
      });
    }

    /**
     * Retrieves a random element or `n` random elements from a collection.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to sample.
     * @param {number} [n] The number of elements to sample.
     * @param- {Object} [guard] Allows working with functions like `_.map`
     *  without using their `index` arguments as `n`.
     * @returns {Array} Returns the random sample(s) of `collection`.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     *
     * _.sample([1, 2, 3, 4], 2);
     * // => [3, 1]
     */
    function sample(collection, n, guard) {
      if (collection && typeof collection.length != 'number') {
        collection = values(collection);
      }
      if (n == null || guard) {
        return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
      }
      var result = shuffle(collection);
      result.length = nativeMin(nativeMax(0, n), result.length);
      return result;
    }

    /**
     * Creates an array of shuffled values, using a version of the Fisher-Yates
     * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to shuffle.
     * @returns {Array} Returns a new shuffled collection.
     * @example
     *
     * _.shuffle([1, 2, 3, 4, 5, 6]);
     * // => [4, 1, 6, 3, 5, 2]
     */
    function shuffle(collection) {
      var index = -1,
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      forEach(collection, function(value) {
        var rand = baseRandom(0, ++index);
        result[index] = result[rand];
        result[rand] = value;
      });
      return result;
    }

    /**
     * Gets the size of the `collection` by returning `collection.length` for arrays
     * and array-like objects or the number of own enumerable properties for objects.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns `collection.length` or number of own enumerable properties.
     * @example
     *
     * _.size([1, 2]);
     * // => 2
     *
     * _.size({ 'one': 1, 'two': 2, 'three': 3 });
     * // => 3
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      var length = collection ? collection.length : 0;
      return typeof length == 'number' ? length : keys(collection).length;
    }

    /**
     * Checks if the callback returns a truey value for **any** element of a
     * collection. The function returns as soon as it finds a passing value and
     * does not iterate over the entire collection. The callback is bound to
     * `thisArg` and invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias any
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if any element passed the callback check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'blocked': false },
     *   { 'name': 'fred',   'age': 40, 'blocked': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.some(characters, 'blocked');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.some(characters, { 'age': 1 });
     * // => false
     */
    function some(collection, callback, thisArg) {
      var result;
      callback = lodash.createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == 'number') {
        while (++index < length) {
          if ((result = callback(collection[index], index, collection))) {
            break;
          }
        }
      } else {
        forOwn(collection, function(value, index, collection) {
          return !(result = callback(value, index, collection));
        });
      }
      return !!result;
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection through the callback. This method
     * performs a stable sort, that is, it will preserve the original sort order
     * of equal elements. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an array of property names is provided for `callback` the collection
     * will be sorted by each property value.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of sorted elements.
     * @example
     *
     * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
     * // => [3, 1, 2]
     *
     * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
     * // => [3, 1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'barney',  'age': 26 },
     *   { 'name': 'fred',    'age': 30 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(_.sortBy(characters, 'age'), _.values);
     * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]
     *
     * // sorting by multiple properties
     * _.map(_.sortBy(characters, ['name', 'age']), _.values);
     * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
     */
    function sortBy(collection, callback, thisArg) {
      var index = -1,
          isArr = isArray(callback),
          length = collection ? collection.length : 0,
          result = Array(typeof length == 'number' ? length : 0);

      if (!isArr) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      forEach(collection, function(value, key, collection) {
        var object = result[++index] = getObject();
        if (isArr) {
          object.criteria = map(callback, function(key) { return value[key]; });
        } else {
          (object.criteria = getArray())[0] = callback(value, key, collection);
        }
        object.index = index;
        object.value = value;
      });

      length = result.length;
      result.sort(compareAscending);
      while (length--) {
        var object = result[length];
        result[length] = object.value;
        if (!isArr) {
          releaseArray(object.criteria);
        }
        releaseObject(object);
      }
      return result;
    }

    /**
     * Converts the `collection` to an array.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to convert.
     * @returns {Array} Returns the new converted array.
     * @example
     *
     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
     * // => [2, 3, 4]
     */
    function toArray(collection) {
      if (collection && typeof collection.length == 'number') {
        return slice(collection);
      }
      return values(collection);
    }

    /**
     * Performs a deep comparison of each element in a `collection` to the given
     * `properties` object, returning an array of all elements that have equivalent
     * property values.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Object} props The object of property values to filter by.
     * @returns {Array} Returns a new array of elements that have the given properties.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * _.where(characters, { 'age': 36 });
     * // => [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]
     *
     * _.where(characters, { 'pets': ['dino'] });
     * // => [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]
     */
    var where = filter;

    /*--------------------------------------------------------------------------*/

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are all falsey.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to compact.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * Creates an array excluding all values of the provided arrays using strict
     * equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {...Array} [values] The arrays of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
     * // => [1, 3, 4]
     */
    function difference(array) {
      return baseDifference(array, baseFlatten(arguments, true, true, 1));
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element that passes the callback check, instead of the element itself.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': false },
     *   { 'name': 'fred',    'age': 40, 'blocked': true },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
     * ];
     *
     * _.findIndex(characters, function(chr) {
     *   return chr.age < 20;
     * });
     * // => 2
     *
     * // using "_.where" callback shorthand
     * _.findIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findIndex(characters, 'blocked');
     * // => 1
     */
    function findIndex(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0;

      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        if (callback(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36, 'blocked': true },
     *   { 'name': 'fred',    'age': 40, 'blocked': false },
     *   { 'name': 'pebbles', 'age': 1,  'blocked': true }
     * ];
     *
     * _.findLastIndex(characters, function(chr) {
     *   return chr.age > 30;
     * });
     * // => 1
     *
     * // using "_.where" callback shorthand
     * _.findLastIndex(characters, { 'age': 36 });
     * // => 0
     *
     * // using "_.pluck" callback shorthand
     * _.findLastIndex(characters, 'blocked');
     * // => 2
     */
    function findLastIndex(array, callback, thisArg) {
      var length = array ? array.length : 0;
      callback = lodash.createCallback(callback, thisArg, 3);
      while (length--) {
        if (callback(array[length], length, array)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Gets the first element or first `n` elements of an array. If a callback
     * is provided elements at the beginning of the array are returned as long
     * as the callback returns truey. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias head, take
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the first element(s) of `array`.
     * @example
     *
     * _.first([1, 2, 3]);
     * // => 1
     *
     * _.first([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.first([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [1, 2]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false, 'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.first(characters, 'blocked');
     * // => [{ 'name': 'barney', 'blocked': true, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.first(characters, { 'employer': 'slate' }), 'name');
     * // => ['barney', 'fred']
     */
    function first(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = -1;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[0] : undefined;
        }
      }
      return slice(array, 0, nativeMin(nativeMax(0, n), length));
    }

    /**
     * Flattens a nested array (the nesting can be to any depth). If `isShallow`
     * is truey, the array will only be flattened a single level. If a callback
     * is provided each element of the array is passed through the callback before
     * flattening. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new flattened array.
     * @example
     *
     * _.flatten([1, [2], [3, [[4]]]]);
     * // => [1, 2, 3, 4];
     *
     * _.flatten([1, [2], [3, [[4]]]], true);
     * // => [1, 2, 3, [[4]]];
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },
     *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.flatten(characters, 'pets');
     * // => ['hoppy', 'baby puss', 'dino']
     */
    function flatten(array, isShallow, callback, thisArg) {
      // juggle arguments
      if (typeof isShallow != 'boolean' && isShallow != null) {
        thisArg = callback;
        callback = (typeof isShallow != 'function' && thisArg && thisArg[isShallow] === array) ? null : isShallow;
        isShallow = false;
      }
      if (callback != null) {
        array = map(array, callback, thisArg);
      }
      return baseFlatten(array, isShallow);
    }

    /**
     * Gets the index at which the first occurrence of `value` is found using
     * strict equality for comparisons, i.e. `===`. If the array is already sorted
     * providing `true` for `fromIndex` will run a faster binary search.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
     *  to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 1
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 4
     *
     * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
     * // => 2
     */
    function indexOf(array, value, fromIndex) {
      if (typeof fromIndex == 'number') {
        var length = array ? array.length : 0;
        fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);
      } else if (fromIndex) {
        var index = sortedIndex(array, value);
        return array[index] === value ? index : -1;
      }
      return baseIndexOf(array, value, fromIndex);
    }

    /**
     * Gets all but the last element or last `n` elements of an array. If a
     * callback is provided elements at the end of the array are excluded from
     * the result as long as the callback returns truey. The callback is bound
     * to `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     *
     * _.initial([1, 2, 3], 2);
     * // => [1]
     *
     * _.initial([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [1]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.initial(characters, 'blocked');
     * // => [{ 'name': 'barney',  'blocked': false, 'employer': 'slate' }]
     *
     * // using "_.where" callback shorthand
     * _.pluck(_.initial(characters, { 'employer': 'na' }), 'name');
     * // => ['barney', 'fred']
     */
    function initial(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : callback || n;
      }
      return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
    }

    /**
     * Creates an array of unique values present in all provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of shared values.
     * @example
     *
     * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2]
     */
    function intersection() {
      var args = [],
          argsIndex = -1,
          argsLength = arguments.length,
          caches = getArray(),
          indexOf = getIndexOf(),
          trustIndexOf = indexOf === baseIndexOf,
          seen = getArray();

      while (++argsIndex < argsLength) {
        var value = arguments[argsIndex];
        if (isArray(value) || isArguments(value)) {
          args.push(value);
          caches.push(trustIndexOf && value.length >= largeArraySize &&
            createCache(argsIndex ? args[argsIndex] : seen));
        }
      }
      var array = args[0],
          index = -1,
          length = array ? array.length : 0,
          result = [];

      outer:
      while (++index < length) {
        var cache = caches[0];
        value = array[index];

        if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
          argsIndex = argsLength;
          (cache || seen).push(value);
          while (--argsIndex) {
            cache = caches[argsIndex];
            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
              continue outer;
            }
          }
          result.push(value);
        }
      }
      while (argsLength--) {
        cache = caches[argsLength];
        if (cache) {
          releaseObject(cache);
        }
      }
      releaseArray(caches);
      releaseArray(seen);
      return result;
    }

    /**
     * Gets the last element or last `n` elements of an array. If a callback is
     * provided elements at the end of the array are returned as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the last element(s) of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     *
     * _.last([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.last([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [2, 3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.last(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.last(characters, { 'employer': 'na' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */
    function last(array, callback, thisArg) {
      var n = 0,
          length = array ? array.length : 0;

      if (typeof callback != 'number' && callback != null) {
        var index = length;
        callback = lodash.createCallback(callback, thisArg, 3);
        while (index-- && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = callback;
        if (n == null || thisArg) {
          return array ? array[length - 1] : undefined;
        }
      }
      return slice(array, nativeMax(0, length - n));
    }

    /**
     * Gets the index at which the last occurrence of `value` is found using strict
     * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
     * as the offset from the end of the collection.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 4
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var index = array ? array.length : 0;
      if (typeof fromIndex == 'number') {
        index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
      }
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * Removes all provided values from the given array using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {...*} [value] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3, 1, 2, 3];
     * _.pull(array, 2, 3);
     * console.log(array);
     * // => [1, 1]
     */
    function pull(array) {
      var args = arguments,
          argsIndex = 0,
          argsLength = args.length,
          length = array ? array.length : 0;

      while (++argsIndex < argsLength) {
        var index = -1,
            value = args[argsIndex];
        while (++index < length) {
          if (array[index] === value) {
            splice.call(array, index--, 1);
            length--;
          }
        }
      }
      return array;
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to but not including `end`. If `start` is less than `stop` a
     * zero-length range is created unless a negative `step` is specified.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns a new range array.
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    function range(start, end, step) {
      start = +start || 0;
      step = typeof step == 'number' ? step : (+step || 1);

      if (end == null) {
        end = start;
        start = 0;
      }
      // use `Array(length)` so engines like Chakra and V8 avoid slower modes
      // http://youtu.be/XAqIpGU8ZZk#t=17m25s
      var index = -1,
          length = nativeMax(0, ceil((end - start) / (step || 1))),
          result = Array(length);

      while (++index < length) {
        result[index] = start;
        start += step;
      }
      return result;
    }

    /**
     * Removes all elements from an array that the callback returns truey for
     * and returns an array of removed elements. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4, 5, 6];
     * var evens = _.remove(array, function(num) { return num % 2 == 0; });
     *
     * console.log(array);
     * // => [1, 3, 5]
     *
     * console.log(evens);
     * // => [2, 4, 6]
     */
    function remove(array, callback, thisArg) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      callback = lodash.createCallback(callback, thisArg, 3);
      while (++index < length) {
        var value = array[index];
        if (callback(value, index, array)) {
          result.push(value);
          splice.call(array, index--, 1);
          length--;
        }
      }
      return result;
    }

    /**
     * The opposite of `_.initial` this method gets all but the first element or
     * first `n` elements of an array. If a callback function is provided elements
     * at the beginning of the array are excluded from the result as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias drop, tail
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.rest([1, 2, 3]);
     * // => [2, 3]
     *
     * _.rest([1, 2, 3], 2);
     * // => [3]
     *
     * _.rest([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [3]
     *
     * var characters = [
     *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
     *   { 'name': 'fred',    'blocked': false,  'employer': 'slate' },
     *   { 'name': 'pebbles', 'blocked': true, 'employer': 'na' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.pluck(_.rest(characters, 'blocked'), 'name');
     * // => ['fred', 'pebbles']
     *
     * // using "_.where" callback shorthand
     * _.rest(characters, { 'employer': 'slate' });
     * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
     */
    function rest(array, callback, thisArg) {
      if (typeof callback != 'number' && callback != null) {
        var n = 0,
            index = -1,
            length = array ? array.length : 0;

        callback = lodash.createCallback(callback, thisArg, 3);
        while (++index < length && callback(array[index], index, array)) {
          n++;
        }
      } else {
        n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);
      }
      return slice(array, n);
    }

    /**
     * Uses a binary search to determine the smallest index at which a value
     * should be inserted into a given sorted array in order to maintain the sort
     * order of the array. If a callback is provided it will be executed for
     * `value` and each element of `array` to compute their sort ranking. The
     * callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([20, 30, 50], 40);
     * // => 2
     *
     * // using "_.pluck" callback shorthand
     * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
     * // => 2
     *
     * var dict = {
     *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
     * };
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return dict.wordToNumber[word];
     * });
     * // => 2
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return this.wordToNumber[word];
     * }, dict);
     * // => 2
     */
    function sortedIndex(array, value, callback, thisArg) {
      var low = 0,
          high = array ? array.length : low;

      // explicitly reference `identity` for better inlining in Firefox
      callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
      value = callback(value);

      while (low < high) {
        var mid = (low + high) >>> 1;
        (callback(array[mid]) < value)
          ? low = mid + 1
          : high = mid;
      }
      return low;
    }

    /**
     * Creates an array of unique values, in order, of the provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of combined values.
     * @example
     *
     * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);
     * // => [1, 2, 3, 5, 4]
     */
    function union() {
      return baseUniq(baseFlatten(arguments, true, true));
    }

    /**
     * Creates a duplicate-value-free version of an array using strict equality
     * for comparisons, i.e. `===`. If the array is sorted, providing
     * `true` for `isSorted` will use a faster algorithm. If a callback is provided
     * each element of `array` is passed through the callback before uniqueness
     * is computed. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias unique
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a duplicate-value-free array.
     * @example
     *
     * _.uniq([1, 2, 1, 3, 1]);
     * // => [1, 2, 3]
     *
     * _.uniq([1, 1, 2, 2, 3], true);
     * // => [1, 2, 3]
     *
     * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });
     * // => ['A', 'b', 'C']
     *
     * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
     * // => [1, 2.5, 3]
     *
     * // using "_.pluck" callback shorthand
     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniq(array, isSorted, callback, thisArg) {
      // juggle arguments
      if (typeof isSorted != 'boolean' && isSorted != null) {
        thisArg = callback;
        callback = (typeof isSorted != 'function' && thisArg && thisArg[isSorted] === array) ? null : isSorted;
        isSorted = false;
      }
      if (callback != null) {
        callback = lodash.createCallback(callback, thisArg, 3);
      }
      return baseUniq(array, isSorted, callback);
    }

    /**
     * Creates an array excluding all provided values using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to filter.
     * @param {...*} [value] The values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
     * // => [2, 3, 4]
     */
    function without(array) {
      return baseDifference(array, slice(arguments, 1));
    }

    /**
     * Creates an array that is the symmetric difference of the provided arrays.
     * See http://en.wikipedia.org/wiki/Symmetric_difference.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of values.
     * @example
     *
     * _.xor([1, 2, 3], [5, 2, 1, 4]);
     * // => [3, 5, 4]
     *
     * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);
     * // => [1, 4, 5]
     */
    function xor() {
      var index = -1,
          length = arguments.length;

      while (++index < length) {
        var array = arguments[index];
        if (isArray(array) || isArguments(array)) {
          var result = result
            ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result)))
            : array;
        }
      }
      return result || [];
    }

    /**
     * Creates an array of grouped elements, the first of which contains the first
     * elements of the given arrays, the second of which contains the second
     * elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @alias unzip
     * @category Arrays
     * @param {...Array} [array] Arrays to process.
     * @returns {Array} Returns a new array of grouped elements.
     * @example
     *
     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     */
    function zip() {
      var array = arguments.length > 1 ? arguments : arguments[0],
          index = -1,
          length = array ? max(pluck(array, 'length')) : 0,
          result = Array(length < 0 ? 0 : length);

      while (++index < length) {
        result[index] = pluck(array, index);
      }
      return result;
    }

    /**
     * Creates an object composed from arrays of `keys` and `values`. Provide
     * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`
     * or two arrays, one of `keys` and one of corresponding `values`.
     *
     * @static
     * @memberOf _
     * @alias object
     * @category Arrays
     * @param {Array} keys The array of keys.
     * @param {Array} [values=[]] The array of values.
     * @returns {Object} Returns an object composed of the given keys and
     *  corresponding values.
     * @example
     *
     * _.zipObject(['fred', 'barney'], [30, 40]);
     * // => { 'fred': 30, 'barney': 40 }
     */
    function zipObject(keys, values) {
      var index = -1,
          length = keys ? keys.length : 0,
          result = {};

      if (!values && length && !isArray(keys[0])) {
        values = [];
      }
      while (++index < length) {
        var key = keys[index];
        if (values) {
          result[key] = values[index];
        } else if (key) {
          result[key[0]] = key[1];
        }
      }
      return result;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that executes `func`, with  the `this` binding and
     * arguments of the created function, only after being called `n` times.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {number} n The number of times the function must be called before
     *  `func` is executed.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('Done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => logs 'Done saving!', after all saves have completed
     */
    function after(n, func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with the `this`
     * binding of `thisArg` and prepends any additional `bind` arguments to those
     * provided to the bound function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to bind.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var func = function(greeting) {
     *   return greeting + ' ' + this.name;
     * };
     *
     * func = _.bind(func, { 'name': 'fred' }, 'hi');
     * func();
     * // => 'hi fred'
     */
    function bind(func, thisArg) {
      return arguments.length > 2
        ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)
        : createWrapper(func, 1, null, null, thisArg);
    }

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method. Method names may be specified as individual arguments or as arrays
     * of method names. If no method names are provided all the function properties
     * of `object` will be bound.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...string} [methodName] The object method names to
     *  bind, specified as individual method names or arrays of method names.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'onClick': function() { console.log('clicked ' + this.label); }
     * };
     *
     * _.bindAll(view);
     * jQuery('#docs').on('click', view.onClick);
     * // => logs 'clicked docs', when the button is clicked
     */
    function bindAll(object) {
      var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object),
          index = -1,
          length = funcs.length;

      while (++index < length) {
        var key = funcs[index];
        object[key] = createWrapper(object[key], 1, null, null, object);
      }
      return object;
    }

    /**
     * Creates a function that, when called, invokes the method at `object[key]`
     * and prepends any additional `bindKey` arguments to those provided to the bound
     * function. This method differs from `_.bind` by allowing bound functions to
     * reference methods that will be redefined or don't yet exist.
     * See http://michaux.ca/articles/lazy-function-definition-pattern.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object the method belongs to.
     * @param {string} key The key of the method.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'name': 'fred',
     *   'greet': function(greeting) {
     *     return greeting + ' ' + this.name;
     *   }
     * };
     *
     * var func = _.bindKey(object, 'greet', 'hi');
     * func();
     * // => 'hi fred'
     *
     * object.greet = function(greeting) {
     *   return greeting + 'ya ' + this.name + '!';
     * };
     *
     * func();
     * // => 'hiya fred!'
     */
    function bindKey(object, key) {
      return arguments.length > 2
        ? createWrapper(key, 19, slice(arguments, 2), null, object)
        : createWrapper(key, 3, null, null, object);
    }

    /**
     * Creates a function that is the composition of the provided functions,
     * where each function consumes the return value of the function that follows.
     * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
     * Each function is executed with the `this` binding of the composed function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {...Function} [func] Functions to compose.
     * @returns {Function} Returns the new composed function.
     * @example
     *
     * var realNameMap = {
     *   'pebbles': 'penelope'
     * };
     *
     * var format = function(name) {
     *   name = realNameMap[name.toLowerCase()] || name;
     *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
     * };
     *
     * var greet = function(formatted) {
     *   return 'Hiya ' + formatted + '!';
     * };
     *
     * var welcome = _.compose(greet, format);
     * welcome('pebbles');
     * // => 'Hiya Penelope!'
     */
    function compose() {
      var funcs = arguments,
          length = funcs.length;

      while (length--) {
        if (!isFunction(funcs[length])) {
          throw new TypeError;
        }
      }
      return function() {
        var args = arguments,
            length = funcs.length;

        while (length--) {
          args = [funcs[length].apply(this, args)];
        }
        return args[0];
      };
    }

    /**
     * Creates a function which accepts one or more arguments of `func` that when
     * invoked either executes `func` returning its result, if all `func` arguments
     * have been provided, or returns a function that accepts one or more of the
     * remaining `func` arguments, and so on. The arity of `func` can be specified
     * if `func.length` is not sufficient.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var curried = _.curry(function(a, b, c) {
     *   console.log(a + b + c);
     * });
     *
     * curried(1)(2)(3);
     * // => 6
     *
     * curried(1, 2)(3);
     * // => 6
     *
     * curried(1, 2, 3);
     * // => 6
     */
    function curry(func, arity) {
      arity = typeof arity == 'number' ? arity : (+arity || func.length);
      return createWrapper(func, 4, null, null, null, arity);
    }

    /**
     * Creates a function that will delay the execution of `func` until after
     * `wait` milliseconds have elapsed since the last time it was invoked.
     * Provide an options object to indicate that `func` should be invoked on
     * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
     * to the debounced function will return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the debounced function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to debounce.
     * @param {number} wait The number of milliseconds to delay.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
     * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // avoid costly calculations while the window size is in flux
     * var lazyLayout = _.debounce(calculateLayout, 150);
     * jQuery(window).on('resize', lazyLayout);
     *
     * // execute `sendMail` when the click event is fired, debouncing subsequent calls
     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * });
     *
     * // ensure `batchLog` is executed once after 1 second of debounced calls
     * var source = new EventSource('/stream');
     * source.addEventListener('message', _.debounce(batchLog, 250, {
     *   'maxWait': 1000
     * }, false);
     */
    function debounce(func, wait, options) {
      var args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = 0,
          maxWait = false,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      wait = nativeMax(0, wait) || 0;
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if (isObject(options)) {
        leading = options.leading;
        maxWait = 'maxWait' in options && (nativeMax(wait, options.maxWait) || 0);
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      var delayed = function() {
        var remaining = wait - (now() - stamp);
        if (remaining <= 0) {
          if (maxTimeoutId) {
            clearTimeout(maxTimeoutId);
          }
          var isCalled = trailingCall;
          maxTimeoutId = timeoutId = trailingCall = undefined;
          if (isCalled) {
            lastCalled = now();
            result = func.apply(thisArg, args);
            if (!timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
          }
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      };

      var maxDelayed = function() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (trailing || (maxWait !== wait)) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = null;
          }
        }
      };

      return function() {
        args = arguments;
        stamp = now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);

        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled),
              isCalled = remaining <= 0;

          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = null;
        }
        return result;
      };
    }

    /**
     * Defers executing the `func` function until the current call stack has cleared.
     * Additional arguments will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to defer.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) { console.log(text); }, 'deferred');
     * // logs 'deferred' after one or more milliseconds
     */
    function defer(func) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 1);
      return setTimeout(function() { func.apply(undefined, args); }, 1);
    }

    /**
     * Executes the `func` function after `wait` milliseconds. Additional arguments
     * will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay execution.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) { console.log(text); }, 1000, 'later');
     * // => logs 'later' after one second
     */
    function delay(func, wait) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var args = slice(arguments, 2);
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided it will be used to determine the cache key for storing the result
     * based on the arguments provided to the memoized function. By default, the
     * first argument provided to the memoized function is used as the cache key.
     * The `func` is executed with the `this` binding of the memoized function.
     * The result cache is exposed as the `cache` property on the memoized function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] A function used to resolve the cache key.
     * @returns {Function} Returns the new memoizing function.
     * @example
     *
     * var fibonacci = _.memoize(function(n) {
     *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
     * });
     *
     * fibonacci(9)
     * // => 34
     *
     * var data = {
     *   'fred': { 'name': 'fred', 'age': 40 },
     *   'pebbles': { 'name': 'pebbles', 'age': 1 }
     * };
     *
     * // modifying the result cache
     * var get = _.memoize(function(name) { return data[name]; }, _.identity);
     * get('pebbles');
     * // => { 'name': 'pebbles', 'age': 1 }
     *
     * get.cache.pebbles.name = 'penelope';
     * get('pebbles');
     * // => { 'name': 'penelope', 'age': 1 }
     */
    function memoize(func, resolver) {
      if (!isFunction(func)) {
        throw new TypeError;
      }
      var memoized = function() {
        var cache = memoized.cache,
            key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];

        return hasOwnProperty.call(cache, key)
          ? cache[key]
          : (cache[key] = func.apply(this, arguments));
      }
      memoized.cache = {};
      // hack: Add ability to reset memoized values
      memoized.reset = function() {
        var cache = memoized.cache,
            key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];

        if (hasOwnProperty.call(cache, key)) {
          delete cache[key];
        }
      }
      return memoized;
    }

    /**
     * Creates a function that is restricted to execute `func` once. Repeat calls to
     * the function will return the value of the first call. The `func` is executed
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // `initialize` executes `createApplication` once
     */
    function once(func) {
      var ran,
          result;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      return function() {
        if (ran) {
          return result;
        }
        ran = true;
        result = func.apply(this, arguments);

        // clear the `func` variable so the function may be garbage collected
        func = null;
        return result;
      };
    }

    /**
     * Creates a function that, when called, invokes `func` with any additional
     * `partial` arguments prepended to those provided to the new function. This
     * method is similar to `_.bind` except it does **not** alter the `this` binding.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) { return greeting + ' ' + name; };
     * var hi = _.partial(greet, 'hi');
     * hi('fred');
     * // => 'hi fred'
     */
    function partial(func) {
      return createWrapper(func, 16, slice(arguments, 1));
    }

    /**
     * This method is like `_.partial` except that `partial` arguments are
     * appended to those provided to the new function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var defaultsDeep = _.partialRight(_.merge, _.defaults);
     *
     * var options = {
     *   'variable': 'data',
     *   'imports': { 'jq': $ }
     * };
     *
     * defaultsDeep(options, _.templateSettings);
     *
     * options.variable
     * // => 'data'
     *
     * options.imports
     * // => { '_': _, 'jq': $ }
     */
    function partialRight(func) {
      return createWrapper(func, 32, null, slice(arguments, 1));
    }

    /**
     * Creates a function that, when executed, will only call the `func` function
     * at most once per every `wait` milliseconds. Provide an options object to
     * indicate that `func` should be invoked on the leading and/or trailing edge
     * of the `wait` timeout. Subsequent calls to the throttled function will
     * return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the throttled function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to throttle.
     * @param {number} wait The number of milliseconds to throttle executions to.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // avoid excessively updating the position while scrolling
     * var throttled = _.throttle(updatePosition, 100);
     * jQuery(window).on('scroll', throttled);
     *
     * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes
     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
     *   'trailing': false
     * }));
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (!isFunction(func)) {
        throw new TypeError;
      }
      if (options === false) {
        leading = false;
      } else if (isObject(options)) {
        leading = 'leading' in options ? options.leading : leading;
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      debounceOptions.leading = leading;
      debounceOptions.maxWait = wait;
      debounceOptions.trailing = trailing;

      return debounce(func, wait, debounceOptions);
    }

    /**
     * Creates a function that provides `value` to the wrapper function as its
     * first argument. Additional arguments provided to the function are appended
     * to those provided to the wrapper function. The wrapper is executed with
     * the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {*} value The value to wrap.
     * @param {Function} wrapper The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('Fred, Wilma, & Pebbles');
     * // => '<p>Fred, Wilma, &amp; Pebbles</p>'
     */
    function wrap(value, wrapper) {
      return createWrapper(wrapper, 16, [value]);
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'name': 'fred' };
     * var getter = _.constant(object);
     * getter() === object;
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * Produces a callback bound to an optional `thisArg`. If `func` is a property
     * name the created callback will return the property value for a given element.
     * If `func` is an object the created callback will return `true` for elements
     * that contain the equivalent object properties, otherwise it will return `false`.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // wrap to create custom callback shorthands
     * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);
     *   return !match ? func(callback, thisArg) : function(object) {
     *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
     *   };
     * });
     *
     * _.filter(characters, 'age__gt38');
     * // => [{ 'name': 'fred', 'age': 40 }]
     */
    function createCallback(func, thisArg, argCount) {
      var type = typeof func;
      if (func == null || type == 'function') {
        return baseCreateCallback(func, thisArg, argCount);
      }
      // handle "_.pluck" style callback shorthands
      if (type != 'object') {
        return property(func);
      }
      var props = keys(func),
          key = props[0],
          a = func[key];

      // handle "_.where" style callback shorthands
      if (props.length == 1 && a === a && !isObject(a)) {
        // fast path the common case of providing an object with a single
        // property containing a primitive value
        return function(object) {
          var b = object[key];
          return a === b && (a !== 0 || (1 / a == 1 / b));
        };
      }
      return function(object) {
        var length = props.length,
            result = false;

        while (length--) {
          if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
            break;
          }
        }
        return result;
      };
    }

    /**
     * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
     * corresponding HTML entities.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('Fred, Wilma, & Pebbles');
     * // => 'Fred, Wilma, &amp; Pebbles'
     */
    function escape(string) {
      return string == null ? '' : String(string).replace(reUnescapedHtml, escapeHtmlChar);
    }

    /**
     * This method returns the first argument provided to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.identity(object) === object;
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Adds function properties of a source object to the destination object.
     * If `object` is a function methods will be added to its prototype as well.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Function|Object} [object=lodash] object The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.
     * @example
     *
     * function capitalize(string) {
     *   return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
     * }
     *
     * _.mixin({ 'capitalize': capitalize });
     * _.capitalize('fred');
     * // => 'Fred'
     *
     * _('fred').capitalize().value();
     * // => 'Fred'
     *
     * _.mixin({ 'capitalize': capitalize }, { 'chain': false });
     * _('fred').capitalize();
     * // => 'Fred'
     */
    function mixin(object, source, options) {
      var chain = true,
          methodNames = source && functions(source);

      if (!source || (!options && !methodNames.length)) {
        if (options == null) {
          options = source;
        }
        ctor = lodashWrapper;
        source = object;
        object = lodash;
        methodNames = functions(source);
      }
      if (options === false) {
        chain = false;
      } else if (isObject(options) && 'chain' in options) {
        chain = options.chain;
      }
      var ctor = object,
          isFunc = isFunction(ctor);

      forEach(methodNames, function(methodName) {
        var func = object[methodName] = source[methodName];
        if (isFunc) {
          ctor.prototype[methodName] = function() {
            var chainAll = this.__chain__,
                value = this.__wrapped__,
                args = [value];

            push.apply(args, arguments);
            var result = func.apply(object, args);
            if (chain || chainAll) {
              if (value === result && isObject(result)) {
                return this;
              }
              result = new ctor(result);
              result.__chain__ = chainAll;
            }
            return result;
          };
        }
      });
    }

    /**
     * Reverts the '_' variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      context._ = oldDash;
      return this;
    }

    /**
     * A no-operation function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var object = { 'name': 'fred' };
     * _.noop(object) === undefined;
     * // => true
     */
    function noop() {
      // no operation performed
    }

    /**
     * Gets the number of milliseconds that have elapsed since the Unix epoch
     * (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @example
     *
     * var stamp = _.now();
     * _.defer(function() { console.log(_.now() - stamp); });
     * // => logs the number of milliseconds it took for the deferred function to be called
     */
    var now = isNative(now = Date.now) && now || function() {
      return new Date().getTime();
    };

    /**
     * Converts the given value into an integer of the specified radix.
     * If `radix` is `undefined` or `0` a `radix` of `10` is used unless the
     * `value` is a hexadecimal, in which case a `radix` of `16` is used.
     *
     * Note: This method avoids differences in native ES3 and ES5 `parseInt`
     * implementations. See http://es5.github.io/#E.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} value The value to parse.
     * @param {number} [radix] The radix used to interpret the value to parse.
     * @returns {number} Returns the new integer value.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     */
    var parseInt = nativeParseInt(whitespace + '08') == 8 ? nativeParseInt : function(value, radix) {
      // Firefox < 21 and Opera < 15 follow the ES3 specified implementation of `parseInt`
      return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, '') : value, radix || 0);
    };

    /**
     * Creates a "_.pluck" style function, which returns the `key` value of a
     * given object.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} key The name of the property to retrieve.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var characters = [
     *   { 'name': 'fred',   'age': 40 },
     *   { 'name': 'barney', 'age': 36 }
     * ];
     *
     * var getName = _.property('name');
     *
     * _.map(characters, getName);
     * // => ['barney', 'fred']
     *
     * _.sortBy(characters, getName);
     * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]
     */
    function property(key) {
      return function(object) {
        return object[key];
      };
    }

    /**
     * Produces a random number between `min` and `max` (inclusive). If only one
     * argument is provided a number between `0` and the given number will be
     * returned. If `floating` is truey or either `min` or `max` are floats a
     * floating-point number will be returned instead of an integer.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} [min=0] The minimum possible value.
     * @param {number} [max=1] The maximum possible value.
     * @param {boolean} [floating=false] Specify returning a floating-point number.
     * @returns {number} Returns a random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(min, max, floating) {
      var noMin = min == null,
          noMax = max == null;

      if (floating == null) {
        if (typeof min == 'boolean' && noMax) {
          floating = min;
          min = 1;
        }
        else if (!noMax && typeof max == 'boolean') {
          floating = max;
          noMax = true;
        }
      }
      if (noMin && noMax) {
        max = 1;
      }
      min = +min || 0;
      if (noMax) {
        max = min;
        min = 0;
      } else {
        max = +max || 0;
      }
      if (floating || min % 1 || max % 1) {
        var rand = nativeRandom();
        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand +'').length - 1)))), max);
      }
      return baseRandom(min, max);
    }

    /**
     * Resolves the value of property `key` on `object`. If `key` is a function
     * it will be invoked with the `this` binding of `object` and its result returned,
     * else the property value is returned. If `object` is falsey then `undefined`
     * is returned.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Object} object The object to inspect.
     * @param {string} key The name of the property to resolve.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = {
     *   'cheese': 'crumpets',
     *   'stuff': function() {
     *     return 'nonsense';
     *   }
     * };
     *
     * _.result(object, 'cheese');
     * // => 'crumpets'
     *
     * _.result(object, 'stuff');
     * // => 'nonsense'
     */
    function result(object, key) {
      if (object) {
        var value = object[key];
        return isFunction(value) ? object[key]() : value;
      }
    }

    /**
     * A micro-templating method that handles arbitrary delimiters, preserves
     * whitespace, and correctly escapes quotes within interpolated code.
     *
     * Note: In the development build, `_.template` utilizes sourceURLs for easier
     * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
     *
     * For more information on precompiling templates see:
     * http://lodash.com/custom-builds
     *
     * For more information on Chrome extension sandboxes see:
     * http://developer.chrome.com/stable/extensions/sandboxingEval.html
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} text The template text.
     * @param {Object} data The data object used to populate the text.
     * @param {Object} [options] The options object.
     * @param {RegExp} [options.escape] The "escape" delimiter.
     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
     * @param {Object} [options.imports] An object to import into the template as local variables.
     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
     * @param {string} [sourceURL] The sourceURL of the template's compiled source.
     * @param {string} [variable] The data object variable name.
     * @returns {Function|string} Returns a compiled function when no `data` object
     *  is given, else it returns the interpolated text.
     * @example
     *
     * // using the "interpolate" delimiter to create a compiled template
     * var compiled = _.template('hello <%= name %>');
     * compiled({ 'name': 'fred' });
     * // => 'hello fred'
     *
     * // using the "escape" delimiter to escape HTML in data property values
     * _.template('<b><%- value %></b>', { 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // using the "evaluate" delimiter to generate HTML
     * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
     * _.template('hello ${ name }', { 'name': 'pebbles' });
     * // => 'hello pebbles'
     *
     * // using the internal `print` function in "evaluate" delimiters
     * _.template('<% print("hello " + name); %>!', { 'name': 'barney' });
     * // => 'hello barney!'
     *
     * // using a custom template delimiters
     * _.templateSettings = {
     *   'interpolate': /{{([\s\S]+?)}}/g
     * };
     *
     * _.template('hello {{ name }}!', { 'name': 'mustache' });
     * // => 'hello mustache!'
     *
     * // using the `imports` option to import jQuery
     * var list = '<% jq.each(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the `sourceURL` option to specify a custom sourceURL for the template
     * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
     *
     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
     * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     *   var __t, __p = '', __e = _.escape;
     *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';
     *   return __p;
     * }
     *
     * // using the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and a stack trace
     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(text, data, options) {
      // based on John Resig's `tmpl` implementation
      // http://ejohn.org/blog/javascript-micro-templating/
      // and Laura Doktorova's doT.js
      // https://github.com/olado/doT
      var settings = lodash.templateSettings;
      text = String(text || '');

      // avoid missing dependencies when `iteratorTemplate` is not defined
      options = defaults({}, options, settings);

      var imports = defaults({}, options.imports, settings.imports),
          importsKeys = keys(imports),
          importsValues = values(imports);

      var isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // compile the regexp to match each delimiter
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // escape characters that cannot be included in string literals
        source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // replace delimiters with snippets
        if (escapeValue) {
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // the JS engine embedded in Adobe products requires returning the `match`
        // string in order to produce the correct `offset` value
        return match;
      });

      source += "';\n";

      // if `variable` is not specified, wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain
      var variable = options.variable,
          hasVariable = variable;

      if (!hasVariable) {
        variable = 'obj';
        source = 'with (' + variable + ') {\n' + source + '\n}\n';
      }
      // cleanup code by stripping empty strings
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // frame code as the function body
      source = 'function(' + variable + ') {\n' +
        (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') +
        "var __t, __p = '', __e = _.escape" +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      // Use a sourceURL for easier debugging.
      // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
      var sourceURL = '\n/*\n//# sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']') + '\n*/';

      try {
        var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
      } catch(e) {
        e.source = source;
        throw e;
      }
      if (data) {
        return result(data);
      }
      // provide the compiled function's source by its `toString` method, in
      // supported environments, or the `source` property as a convenience for
      // inlining compiled templates during the build process
      result.source = source;
      return result;
    }

    /**
     * Executes the callback `n` times, returning an array of the results
     * of each callback execution. The callback is bound to `thisArg` and invoked
     * with one argument; (index).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} n The number of times to execute the callback.
     * @param {Function} callback The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns an array of the results of each `callback` execution.
     * @example
     *
     * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
     * // => [3, 6, 4]
     *
     * _.times(3, function(n) { mage.castSpell(n); });
     * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
     *
     * _.times(3, function(n) { this.cast(n); }, mage);
     * // => also calls `mage.castSpell(n)` three times
     */
    function times(n, callback, thisArg) {
      n = (n = +n) > -1 ? n : 0;
      var index = -1,
          result = Array(n);

      callback = baseCreateCallback(callback, thisArg, 1);
      while (++index < n) {
        result[index] = callback(index);
      }
      return result;
    }

    /**
     * The inverse of `_.escape` this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their
     * corresponding characters.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('Fred, Barney &amp; Pebbles');
     * // => 'Fred, Barney & Pebbles'
     */
    function unescape(string) {
      return string == null ? '' : String(string).replace(reEscapedHtml, unescapeHtmlChar);
    }

    /**
     * Generates a unique ID. If `prefix` is provided the ID will be appended to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} [prefix] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return String(prefix == null ? '' : prefix) + id;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object that wraps the given value with explicit
     * method chaining enabled.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney',  'age': 36 },
     *   { 'name': 'fred',    'age': 40 },
     *   { 'name': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _.chain(characters)
     *     .sortBy('age')
     *     .map(function(chr) { return chr.name + ' is ' + chr.age; })
     *     .first()
     *     .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      value = new lodashWrapper(value);
      value.__chain__ = true;
      return value;
    }

    /**
     * Invokes `interceptor` with the `value` as the first argument and then
     * returns `value`. The purpose of this method is to "tap into" a method
     * chain in order to perform operations on intermediate results within
     * the chain.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3, 4])
     *  .tap(function(array) { array.pop(); })
     *  .reverse()
     *  .value();
     * // => [3, 2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * Enables explicit method chaining on the wrapper object.
     *
     * @name chain
     * @memberOf _
     * @category Chaining
     * @returns {*} Returns the wrapper object.
     * @example
     *
     * var characters = [
     *   { 'name': 'barney', 'age': 36 },
     *   { 'name': 'fred',   'age': 40 }
     * ];
     *
     * // without explicit chaining
     * _(characters).first();
     * // => { 'name': 'barney', 'age': 36 }
     *
     * // with explicit chaining
     * _(characters).chain()
     *   .first()
     *   .pick('age')
     *   .value();
     * // => { 'age': 36 }
     */
    function wrapperChain() {
      this.__chain__ = true;
      return this;
    }

    /**
     * Produces the `toString` result of the wrapped value.
     *
     * @name toString
     * @memberOf _
     * @category Chaining
     * @returns {string} Returns the string result.
     * @example
     *
     * _([1, 2, 3]).toString();
     * // => '1,2,3'
     */
    function wrapperToString() {
      return String(this.__wrapped__);
    }

    /**
     * Extracts the wrapped value.
     *
     * @name valueOf
     * @memberOf _
     * @alias value
     * @category Chaining
     * @returns {*} Returns the wrapped value.
     * @example
     *
     * _([1, 2, 3]).valueOf();
     * // => [1, 2, 3]
     */
    function wrapperValueOf() {
      return this.__wrapped__;
    }

    /*--------------------------------------------------------------------------*/

    // add functions that return wrapped values when chaining
    lodash.after = after;
    lodash.assign = assign;
    lodash.at = at;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.chain = chain;
    lodash.compact = compact;
    lodash.compose = compose;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.createCallback = createCallback;
    lodash.curry = curry;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.filter = filter;
    lodash.flatten = flatten;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.functions = functions;
    lodash.groupBy = groupBy;
    lodash.indexBy = indexBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.invert = invert;
    lodash.invoke = invoke;
    lodash.keys = keys;
    lodash.map = map;
    lodash.mapValues = mapValues;
    lodash.max = max;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.min = min;
    lodash.omit = omit;
    lodash.once = once;
    lodash.pairs = pairs;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.pick = pick;
    lodash.pluck = pluck;
    lodash.property = property;
    lodash.pull = pull;
    lodash.range = range;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.shuffle = shuffle;
    lodash.sortBy = sortBy;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.times = times;
    lodash.toArray = toArray;
    lodash.transform = transform;
    lodash.union = union;
    lodash.uniq = uniq;
    lodash.values = values;
    lodash.where = where;
    lodash.without = without;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.zip = zip;
    lodash.zipObject = zipObject;

    // add aliases
    lodash.collect = map;
    lodash.drop = rest;
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.extend = assign;
    lodash.methods = functions;
    lodash.object = zipObject;
    lodash.select = filter;
    lodash.tail = rest;
    lodash.unique = uniq;
    lodash.unzip = zip;

    // add functions to `lodash.prototype`
    mixin(lodash);

    /*--------------------------------------------------------------------------*/

    // add functions that return unwrapped values when chaining
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.contains = contains;
    lodash.escape = escape;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.has = has;
    lodash.identity = identity;
    lodash.indexOf = indexOf;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isBoolean = isBoolean;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isNaN = isNaN;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isString = isString;
    lodash.isUndefined = isUndefined;
    lodash.lastIndexOf = lastIndexOf;
    lodash.mixin = mixin;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.result = result;
    lodash.runInContext = runInContext;
    lodash.size = size;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.template = template;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;

    // add aliases
    lodash.all = every;
    lodash.any = some;
    lodash.detect = find;
    lodash.findWhere = find;
    lodash.foldl = reduce;
    lodash.foldr = reduceRight;
    lodash.include = contains;
    lodash.inject = reduce;

    mixin(function() {
      var source = {}
      forOwn(lodash, function(func, methodName) {
        if (!lodash.prototype[methodName]) {
          source[methodName] = func;
        }
      });
      return source;
    }(), false);

    /*--------------------------------------------------------------------------*/

    // add functions capable of returning wrapped and unwrapped values when chaining
    lodash.first = first;
    lodash.last = last;
    lodash.sample = sample;

    // add aliases
    lodash.take = first;
    lodash.head = first;

    forOwn(lodash, function(func, methodName) {
      var callbackable = methodName !== 'sample';
      if (!lodash.prototype[methodName]) {
        lodash.prototype[methodName]= function(n, guard) {
          var chainAll = this.__chain__,
              result = func(this.__wrapped__, n, guard);

          return !chainAll && (n == null || (guard && !(callbackable && typeof n == 'function')))
            ? result
            : new lodashWrapper(result, chainAll);
        };
      }
    });

    /*--------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type string
     */
    lodash.VERSION = '2.4.1';

    // add "Chaining" functions to the wrapper
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.toString = wrapperToString;
    lodash.prototype.value = wrapperValueOf;
    lodash.prototype.valueOf = wrapperValueOf;

    // add `Array` functions that return unwrapped values
    forEach(['join', 'pop', 'shift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        var chainAll = this.__chain__,
            result = func.apply(this.__wrapped__, arguments);

        return chainAll
          ? new lodashWrapper(result, chainAll)
          : result;
      };
    });

    // add `Array` functions that return the existing wrapped value
    forEach(['push', 'reverse', 'sort', 'unshift'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        func.apply(this.__wrapped__, arguments);
        return this;
      };
    });

    // add `Array` functions that return new wrapped values
    forEach(['concat', 'slice', 'splice'], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
      };
    });

    return lodash;
  }

  /*--------------------------------------------------------------------------*/

  // expose Lo-Dash
  var _ = $._ = runInContext();

  // expose Lo-Dash methods to jQuery
  $.each(_, function(prop, func){
    if (!Object.hasOwnProperty.call(_, prop) || /VERSION/.test(name)) return;
    if (!$[prop]) $[prop] = func;
  });

});FD40.plugin("bootstrap3", function($) {

var jQuery = $;
/*!
 * Bootstrap v3.0.3 (http://getbootstrap.com)
 * Copyright 2015 Twitter, Inc.
 * Licensed under http://www.apache.org/licenses/LICENSE-2.0s
 */

// if (window["Foundry/Bootstrap"]) { return } else { window["Foundry/Bootstrap"] = { version: "3.0.3", foundry: jQuery } }

// Since ES require this version of modified bootstrap the most, we must allow ES bootstrap to always loaded. #2606
if (window["Foundry/Bootstrap"] == undefined) {
  window["Foundry/Bootstrap"] = { version: "3.0.3", foundry: jQuery }
}

/* ========================================================================
 * Bootstrap: transition.js v3.0.3
 * http://getbootstrap.com/javascript/#transitions
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */


+function ($) { "use strict";

  // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
  // ============================================================

  function transitionEnd() {
	var el = document.createElement('bootstrap')

	var transEndEventNames = {
	  'WebkitTransition' : 'webkitTransitionEnd'
	, 'MozTransition'    : 'transitionend'
	, 'OTransition'      : 'oTransitionEnd otransitionend'
	, 'transition'       : 'transitionend'
	}

	for (var name in transEndEventNames) {
	  if (el.style[name] !== undefined) {
		return { end: transEndEventNames[name] }
	  }
	}
  }

  // http://blog.alexmaccaw.com/css-transitions
  $.fn.emulateTransitionEnd = function (duration) {
	var called = false, $el = this
	$(this).one($.support.transition.end, function () { called = true })
	var callback = function () { if (!called) $($el).trigger($.support.transition.end) }
	setTimeout(callback, duration)
	return this
  }

  $(function () {
	$.support.transition = transitionEnd()
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: alert.js v3.0.3
 * http://getbootstrap.com/javascript/#alerts
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */


+function ($) { "use strict";

  // ALERT CLASS DEFINITION
  // ======================

  var dismiss = '[data-bs-dismiss="alert"]'
  var Alert   = function (el) {
	$(el).on('click', dismiss, this.close)
  }

  Alert.prototype.close = function (e) {
	var $this    = $(this)
	var selector = $this.attr('data-target')

	if (!selector) {
	  selector = $this.attr('href')
	  selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
	}

	var $parent = $(selector)

	if (e) e.preventDefault()

	if (!$parent.length) {
	  $parent = $this.hasClass('alert') ? $this : $this.parent()
	}

	$parent.trigger(e = $.Event('close.bs.alert'))

	if (e.isDefaultPrevented()) return

	$parent.removeClass('in')

	function removeElement() {
	  $parent.trigger('closed.bs.alert').remove()
	}

	$.support.transition && $parent.hasClass('fade') ?
	  $parent
		.one($.support.transition.end, removeElement)
		.emulateTransitionEnd(150) :
	  removeElement()
  }


  // ALERT PLUGIN DEFINITION
  // =======================

  var old = $.fn.alert

  $.fn.alert = function (option) {
	return this.each(function () {
	  var $this = $(this)
	  var data  = $this.data('bs.alert')

	  if (!data) $this.data('bs.alert', (data = new Alert(this)))
	  if (typeof option == 'string') data[option].call($this)
	})
  }

  $.fn.alert.Constructor = Alert


  // ALERT NO CONFLICT
  // =================

  $.fn.alert.noConflict = function () {
	$.fn.alert = old
	return this
  }


  // ALERT DATA-API
  // ==============

  $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close)

}(jQuery);

/* ========================================================================
 * Bootstrap: button.js v3.0.3
 * http://getbootstrap.com/javascript/#buttons
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */


+function ($) { "use strict";

  // BUTTON PUBLIC CLASS DEFINITION
  // ==============================

  var Button = function (element, options) {
	this.$element = $(element)
	this.options  = $.extend({}, Button.DEFAULTS, options)
  }

  Button.DEFAULTS = {
	loadingText: 'loading...'
  }

  Button.prototype.setState = function (state) {
	var d    = 'disabled'
	var $el  = this.$element
	var val  = $el.is('input') ? 'val' : 'html'
	var data = $el.data()

	state = state + 'Text'

	if (!data.resetText) $el.data('resetText', $el[val]())

	$el[val](data[state] || this.options[state])

	// push to event loop to allow forms to submit
	setTimeout(function () {
	  state == 'loadingText' ?
		$el.addClass(d).attr(d, d) :
		$el.removeClass(d).removeAttr(d);
	}, 0)
  }

  Button.prototype.toggle = function () {
	var $parent = this.$element.closest('[data-bs-toggle="buttons"]')
	var changed = true

	if ($parent.length) {
	  var $input = this.$element.find('input')
	  if ($input.prop('type') === 'radio') {
		// see if clicking on current one
		if ($input.prop('checked') && this.$element.hasClass('active'))
		  changed = false
		else
		  $parent.find('.active').removeClass('active')
	  }
	  if (changed) $input.prop('checked', !this.$element.hasClass('active')).trigger('change')
	}

	if (changed) this.$element.toggleClass('active')
  }


  // BUTTON PLUGIN DEFINITION
  // ========================

  var old = $.fn.button

  $.fn.button = function (option) {
	return this.each(function () {
	  var $this   = $(this)
	  var data    = $this.data('bs.button')
	  var options = typeof option == 'object' && option

	  if (!data) $this.data('bs.button', (data = new Button(this, options)))

	  if (option == 'toggle') data.toggle()
	  else if (option) data.setState(option)
	})
  }

  $.fn.button.Constructor = Button


  // BUTTON NO CONFLICT
  // ==================

  $.fn.button.noConflict = function () {
	$.fn.button = old
	return this
  }


  // BUTTON DATA-API
  // ===============

  $(document).on('click.bs.button.data-api', '[data-bs-toggle^=button]', function (e) {
	var $btn = $(e.target)
	if (!$btn.hasClass('btn')) $btn = $btn.closest('.btn')
	$btn.button('toggle')
	e.preventDefault()
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: carousel.js v3.0.3
 * http://getbootstrap.com/javascript/#carousel
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */


+function ($) { "use strict";

  // CAROUSEL CLASS DEFINITION
  // =========================

  var Carousel = function (element, options) {
	this.$element    = $(element)
	this.$indicators = this.$element.find('.carousel-indicators')
	this.options     = options
	this.paused      =
	this.sliding     =
	this.interval    =
	this.$active     =
	this.$items      = null

	this.options.pause == 'hover' && this.$element
	  .on('mouseenter', $.proxy(this.pause, this))
	  .on('mouseleave', $.proxy(this.cycle, this))
  }

  Carousel.DEFAULTS = {
	interval: 5000
  , pause: 'hover'
  , wrap: true
  }

  Carousel.prototype.cycle =  function (e) {
	e || (this.paused = false)

	this.interval && clearInterval(this.interval)

	this.options.interval
	  && !this.paused
	  && (this.interval = setInterval($.proxy(this.next, this), this.options.interval))

	return this
  }

  Carousel.prototype.getActiveIndex = function () {
	this.$active = this.$element.find('.item.active')
	this.$items  = this.$active.parent().children()

	return this.$items.index(this.$active)
  }

  Carousel.prototype.to = function (pos) {
	var that        = this
	var activeIndex = this.getActiveIndex()

	if (pos > (this.$items.length - 1) || pos < 0) return

	if (this.sliding)       return this.$element.one('slid.bs.carousel', function () { that.to(pos) })
	if (activeIndex == pos) return this.pause().cycle()

	return this.slide(pos > activeIndex ? 'next' : 'prev', $(this.$items[pos]))
  }

  Carousel.prototype.pause = function (e) {
	e || (this.paused = true)

	if (this.$element.find('.next, .prev').length && $.support.transition.end) {
	  this.$element.trigger($.support.transition.end)
	  this.cycle(true)
	}

	this.interval = clearInterval(this.interval)

	return this
  }

  Carousel.prototype.next = function () {
	if (this.sliding) return
	return this.slide('next')
  }

  Carousel.prototype.prev = function () {
	if (this.sliding) return
	return this.slide('prev')
  }

  Carousel.prototype.slide = function (type, next) {
	var $active   = this.$element.find('.item.active')
	var $next     = next || $active[type]()
	var isCycling = this.interval
	var direction = type == 'next' ? 'left' : 'right'
	var fallback  = type == 'next' ? 'first' : 'last'
	var that      = this

	if (!$next.length) {
	  if (!this.options.wrap) return
	  $next = this.$element.find('.item')[fallback]()
	}

	this.sliding = true

	isCycling && this.pause()

	var e = $.Event('slide.bs.carousel', { relatedTarget: $next[0], direction: direction })

	if ($next.hasClass('active')) return

	if (this.$indicators.length) {
	  this.$indicators.find('.active').removeClass('active')
	  this.$element.one('slid.bs.carousel', function () {
		var $nextIndicator = $(that.$indicators.children()[that.getActiveIndex()])
		$nextIndicator && $nextIndicator.addClass('active')
	  })
	}

	if ($.support.transition && this.$element.hasClass('slide')) {
	  this.$element.trigger(e)
	  if (e.isDefaultPrevented()) return
	  $next.addClass(type)
	  $next[0].offsetWidth // force reflow
	  $active.addClass(direction)
	  $next.addClass(direction)
	  $active
		.one($.support.transition.end, function () {
		  $next.removeClass([type, direction].join(' ')).addClass('active')
		  $active.removeClass(['active', direction].join(' '))
		  that.sliding = false
		  setTimeout(function () { that.$element.trigger('slid.bs.carousel') }, 0)
		})
		.emulateTransitionEnd(600)
	} else {
	  this.$element.trigger(e)
	  if (e.isDefaultPrevented()) return
	  $active.removeClass('active')
	  $next.addClass('active')
	  this.sliding = false
	  this.$element.trigger('slid.bs.carousel')
	}

	isCycling && this.cycle()

	return this
  }


  // CAROUSEL PLUGIN DEFINITION
  // ==========================

  var old = $.fn.carousel

  $.fn.carousel = function (option) {
	return this.each(function () {
	  var $this   = $(this)
	  var data    = $this.data('bs.carousel')
	  var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option)
	  var action  = typeof option == 'string' ? option : options.slide

	  if (!data) $this.data('bs.carousel', (data = new Carousel(this, options)))
	  if (typeof option == 'number') data.to(option)
	  else if (action) data[action]()
	  else if (options.interval) data.pause().cycle()
	})
  }

  $.fn.carousel.Constructor = Carousel


  // CAROUSEL NO CONFLICT
  // ====================

  $.fn.carousel.noConflict = function () {
	$.fn.carousel = old
	return this
  }


  // CAROUSEL DATA-API
  // =================

  $(document).on('click.bs.carousel.data-api', '[data-bs-slide], [data-bs-slide-to]', function (e) {
	var $this   = $(this), href
	var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')) //strip for ie7
	var options = $.extend({}, $target.data(), $this.data())
	var slideIndex = $this.attr('data-bs-slide-to')
	if (slideIndex) options.interval = false

	$target.carousel(options)

	if (slideIndex = $this.attr('data-bs-slide-to')) {
	  $target.data('bs.carousel').to(slideIndex)
	}

	e.preventDefault()
  })

  $(window).on('load', function () {
	$('[data-bs-ride="carousel"]').each(function () {
	  var $carousel = $(this)
	  $carousel.carousel($carousel.data())
	})
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: collapse.js v3.0.3
 * http://getbootstrap.com/javascript/#collapse
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */


+function ($) { "use strict";

  // COLLAPSE PUBLIC CLASS DEFINITION
  // ================================

  var Collapse = function (element, options) {
	this.$element      = $(element)
	this.options       = $.extend({}, Collapse.DEFAULTS, options)
	this.transitioning = null

	if (this.options.parent) this.$parent = $(this.options.parent)
	if (this.options.toggle) this.toggle()
  }

  Collapse.DEFAULTS = {
	toggle: true
  }

  Collapse.prototype.dimension = function () {
	var hasWidth = this.$element.hasClass('width')
	return hasWidth ? 'width' : 'height'
  }

  Collapse.prototype.show = function () {
	if (this.transitioning || this.$element.hasClass('in')) return

	var startEvent = $.Event('show.bs.collapse')
	this.$element.triggerHandler(startEvent)
	if (startEvent.isDefaultPrevented()) return

	var actives = this.$parent && this.$parent.find('> .panel > .in')

	if (actives && actives.length) {
	  var hasData = actives.data('bs.collapse')
	  if (hasData && hasData.transitioning) return
	  actives.collapse('hide')
	  hasData || actives.data('bs.collapse', null)
	}

	var dimension = this.dimension()

	this.$element
	  .removeClass('collapse')
	  .addClass('collapsing')
	  [dimension](0)

	this.transitioning = 1

	var complete = function () {
	  this.$element
		.removeClass('collapsing')
		.addClass('in')
		[dimension]('auto')
	  this.transitioning = 0
	  this.$element.trigger('shown.bs.collapse')
	}

	if (!$.support.transition) return complete.call(this)

	var scrollSize = $.camelCase(['scroll', dimension].join('-'))

	this.$element
	  .one($.support.transition.end, $.proxy(complete, this))
	  .emulateTransitionEnd(350)
	  [dimension](this.$element[0][scrollSize])
  }

  Collapse.prototype.hide = function () {
	if (this.transitioning || !this.$element.hasClass('in')) return

	var startEvent = $.Event('hide.bs.collapse')
	this.$element.triggerHandler(startEvent)
	if (startEvent.isDefaultPrevented()) return

	var dimension = this.dimension()

	this.$element
	  [dimension](this.$element[dimension]())
	  [0].offsetHeight

	this.$element
	  .addClass('collapsing')
	  .removeClass('collapse')
	  .removeClass('in')

	this.transitioning = 1

	var complete = function () {
	  this.transitioning = 0
	  this.$element
		.trigger('hidden.bs.collapse')
		.removeClass('collapsing')
		.addClass('collapse')
	}

	if (!$.support.transition) return complete.call(this)

	this.$element
	  [dimension](0)
	  .one($.support.transition.end, $.proxy(complete, this))
	  .emulateTransitionEnd(350)
  }

  Collapse.prototype.toggle = function () {
	this[this.$element.hasClass('in') ? 'hide' : 'show']()
  }


  // COLLAPSE PLUGIN DEFINITION
  // ==========================

  var old = $.fn.collapse

  $.fn.collapse = function (option) {
	return this.each(function () {
	  var $this   = $(this)
	  var data    = $this.data('bs.collapse')
	  var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option)

	  if (!data) $this.data('bs.collapse', (data = new Collapse(this, options)))
	  if (typeof option == 'string') data[option]()
	})
  }

  $.fn.collapse.Constructor = Collapse


  // COLLAPSE NO CONFLICT
  // ====================

  $.fn.collapse.noConflict = function () {
	$.fn.collapse = old
	return this
  }


  // COLLAPSE DATA-API
  // =================

  $(document).on('click.bs.collapse.data-api', '[data-bs-toggle=collapse]', function (e) {
	var $this   = $(this), href
	var target  = $this.attr('data-target')
		|| e.preventDefault()
		|| (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '') //strip for ie7
	var $target = $(target)
	var data    = $target.data('bs.collapse')
	var option  = data ? 'toggle' : $this.data()
	var parent  = $this.attr('data-parent')
	var $parent = parent && $(parent)

	if (!data || !data.transitioning) {
	  if ($parent) $parent.find('[data-bs-toggle=collapse][data-parent="' + parent + '"]').not($this).addClass('collapsed')
	  $this[$target.hasClass('in') ? 'addClass' : 'removeClass']('collapsed')
	}

	$target.collapse(option)
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: dropdown.js v3.4.0
 * https://getbootstrap.com/docs/3.4/javascript/#dropdowns
 * ========================================================================
 * Copyright 2011-2018 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // DROPDOWN CLASS DEFINITION
  // =========================

  var backdrop = '.dropdown-backdrop'
  var toggle   = '[data-bs-toggle="dropdown"]'
  var Dropdown = function (element) {
	$(element).on('click.bs.dropdown', this.toggle)
  }

  Dropdown.VERSION = '3.4.0'

  function getParent($this) {
	var selector = $this.attr('data-target')

	if (!selector) {
	  selector = $this.attr('href')
	  selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
	}

	var $parent = selector && $(document).find(selector)

	return $parent && $parent.length ? $parent : $this.parent()
  }

  function clearMenus(e) {
	if (e && e.which === 3) return
	$(backdrop).remove()
	$(toggle).each(function () {
	  var $this         = $(this)
	  var $parent       = getParent($this)
	  var relatedTarget = { relatedTarget: this }

	  if (!$parent.hasClass('open')) return

	  if (e && e.type == 'click' && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target)) return

	  $parent.triggerHandler(e = $.Event('hide.bs.dropdown'))

	  if (e.isDefaultPrevented()) return

	  $this.attr('aria-expanded', 'false')
	  $parent.removeClass('open').trigger('hidden.bs.dropdown')
	})
  }

  Dropdown.prototype.toggle = function (e) {
	var $this = $(this)

	if ($this.is('.disabled, :disabled')) return

	var $parent  = getParent($this)
	var isActive = $parent.hasClass('open')

	// Clear out any dropdown menu that already open
	clearMenus()

	if (!isActive) {
		if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {

			var backdropTarget = $(this);

			// if mobile we use a backdrop because click events don't delegate
			setTimeout(function() {
				$(document.createElement('div'))
				.addClass('dropdown-backdrop')
				.insertAfter(backdropTarget)
				.on('click', clearMenus)
			}, 4);
		}

		var relatedTarget = { relatedTarget: this }
		$parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget))

		if (e.isDefaultPrevented()) return

		setTimeout(function() {
			$this
			.trigger('focus')
			.attr('aria-expanded', 'true')

			$parent
			.toggleClass('open')
			.trigger($.Event('shown.bs.dropdown', relatedTarget))
		}, 4);
	}

	// Returning false will somehow causing other trigger to not working correctly. #2967
	// return false
  }

  Dropdown.prototype.keydown = function (e) {
	if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return

	var $this = $(this)

	e.preventDefault()
	e.stopPropagation()

	if ($this.is('.disabled, :disabled')) return

	var $parent  = getParent($this)
	var isActive = $parent.hasClass('open')

	if (!isActive && e.which != 27 || isActive && e.which == 27) {
	  if (e.which == 27) $parent.find(toggle).trigger('focus')
	  return $this.trigger('click')
	}

	var desc = ' li:not(.disabled):visible a'
	var $items = $parent.find('.dropdown-menu' + desc)

	if (!$items.length) return

	var index = $items.index(e.target)

	if (e.which == 38 && index > 0)                 index--         // up
	if (e.which == 40 && index < $items.length - 1) index++         // down
	if (!~index)                                    index = 0

	$items.eq(index).trigger('focus')
  }


  // DROPDOWN PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
	return this.each(function () {
	  var $this = $(this)
	  var data  = $this.data('bs.dropdown')

	  if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)))
	  if (typeof option == 'string') data[option].call($this)
	})
  }

  var old = $.fn.dropdown

  $.fn.dropdown             = Plugin
  $.fn.dropdown.Constructor = Dropdown


  // DROPDOWN NO CONFLICT
  // ====================

  $.fn.dropdown.noConflict = function () {
	$.fn.dropdown = old
	return this
  }


  // APPLY TO STANDARD DROPDOWN ELEMENTS
  // ===================================

  $(document)
	.on('click.bs.dropdown.data-api', clearMenus)
	.on('click.bs.dropdown.data-api', '.dropdown_ form, .dropdown-static', function (e) { e.stopPropagation() })
	.on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle)
	.on('keydown.bs.dropdown.data-api', toggle + ', [role=menu]', Dropdown.prototype.keydown)
	.on('keydown.bs.dropdown.data-api', '.dropdown-menu', Dropdown.prototype.keydown)

}(jQuery);

/* ========================================================================
 * Bootstrap: modal.js v3.0.3
 * http://getbootstrap.com/javascript/#modals
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */


+function ($) { "use strict";

  // MODAL CLASS DEFINITION
  // ======================

  var Modal = function (element, options) {
	this.options   = options
	this.$element  = $(element)
	this.$backdrop =
	this.isShown   = null

	if (this.options.remote) this.$element.load(this.options.remote)
  }

  Modal.DEFAULTS = {
	  backdrop: true
	, keyboard: true
	, show: true
  }

  Modal.prototype.toggle = function (_relatedTarget) {
	return this[!this.isShown ? 'show' : 'hide'](_relatedTarget)
  }

  Modal.prototype.show = function (_relatedTarget) {
	var that = this
	var e    = $.Event('show.bs.modal', { relatedTarget: _relatedTarget })

	this.$element.triggerHandler(e)

	if (this.isShown || e.isDefaultPrevented()) return

	this.isShown = true

	this.escape()

	this.$element.on('click.dismiss.modal', '[data-bs-dismiss="modal"]', $.proxy(this.hide, this))

	this.backdrop(function () {
	  var transition = $.support.transition && that.$element.hasClass('fade')

	  if (!that.$element.parent().length) {
		that.$element.appendTo(document.body) // don't move modals dom position
	  }

	  that.$element.show()

	  if (transition) {
		that.$element[0].offsetWidth // force reflow
	  }

	  that.$element
		.addClass('in')
		.attr('aria-hidden', false)

	  that.enforceFocus()

	  var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget })

	  transition ?
		that.$element.find('.modal-dialog') // wait for modal to slide in
		  .one($.support.transition.end, function () {
			that.$element.focus().trigger(e)
		  })
		  .emulateTransitionEnd(300) :
		that.$element.focus().trigger(e)
	})
  }

  Modal.prototype.hide = function (e) {
	if (e) e.preventDefault()

	e = $.Event('hide.bs.modal')

	this.$element.triggerHandler(e)

	if (!this.isShown || e.isDefaultPrevented()) return

	this.isShown = false

	this.escape()

	$(document).off('focusin.bs.modal')

	this.$element
	  .removeClass('in')
	  .attr('aria-hidden', true)
	  .off('click.dismiss.modal')

	$.support.transition && this.$element.hasClass('fade') ?
	  this.$element
		.one($.support.transition.end, $.proxy(this.hideModal, this))
		.emulateTransitionEnd(300) :
	  this.hideModal()
  }

  Modal.prototype.enforceFocus = function () {
	$(document)
	  .off('focusin.bs.modal') // guard against infinite focus loop
	  .on('focusin.bs.modal', $.proxy(function (e) {
		if (this.$element[0] !== e.target && !this.$element.has(e.target).length) {
		  this.$element.focus()
		}
	  }, this))
  }

  Modal.prototype.escape = function () {
	if (this.isShown && this.options.keyboard) {
	  this.$element.on('keyup.dismiss.bs.modal', $.proxy(function (e) {
		e.which == 27 && this.hide()
	  }, this))
	} else if (!this.isShown) {
	  this.$element.off('keyup.dismiss.bs.modal')
	}
  }

  Modal.prototype.hideModal = function () {
	var that = this
	this.$element.hide()
	this.backdrop(function () {
	  that.removeBackdrop()
	  that.$element.trigger('hidden.bs.modal')
	})
  }

  Modal.prototype.removeBackdrop = function () {
	this.$backdrop && this.$backdrop.remove()
	this.$backdrop = null
  }

  Modal.prototype.backdrop = function (callback) {
	var that    = this
	var animate = this.$element.hasClass('fade') ? 'fade' : ''

	if (this.isShown && this.options.backdrop) {
	  var doAnimate = $.support.transition && animate

	  this.$backdrop = $('<div class="modal-backdrop ' + animate + '" />')
		.appendTo(document.body)

	  this.$element.on('click.dismiss.modal', $.proxy(function (e) {
		if (e.target !== e.currentTarget) return
		this.options.backdrop == 'static'
		  ? this.$element[0].focus.call(this.$element[0])
		  : this.hide.call(this)
	  }, this))

	  if (doAnimate) this.$backdrop[0].offsetWidth // force reflow

	  this.$backdrop.addClass('in')

	  if (!callback) return

	  doAnimate ?
		this.$backdrop
		  .one($.support.transition.end, callback)
		  .emulateTransitionEnd(150) :
		callback()

	} else if (!this.isShown && this.$backdrop) {
	  this.$backdrop.removeClass('in')

	  $.support.transition && this.$element.hasClass('fade')?
		this.$backdrop
		  .one($.support.transition.end, callback)
		  .emulateTransitionEnd(150) :
		callback()

	} else if (callback) {
	  callback()
	}
  }


  // MODAL PLUGIN DEFINITION
  // =======================

  var old = $.fn.modal

  $.fn.modal = function (option, _relatedTarget) {
	return this.each(function () {
	  var $this   = $(this)
	  var data    = $this.data('bs.modal')
	  var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option)

	  if (!data) $this.data('bs.modal', (data = new Modal(this, options)))
	  if (typeof option == 'string') data[option](_relatedTarget)
	  else if (options.show) data.show(_relatedTarget)
	})
  }

  $.fn.modal.Constructor = Modal


  // MODAL NO CONFLICT
  // =================

  $.fn.modal.noConflict = function () {
	$.fn.modal = old
	return this
  }


  // MODAL DATA-API
  // ==============

  $(document).on('click.bs.modal.data-api', '[data-bs-toggle="modal"]', function (e) {
	var $this   = $(this)
	var href    = $this.attr('href')
	var $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))) //strip for ie7
	var option  = $target.data('modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data())

	e.preventDefault()

	$target
	  .modal(option, this)
	  .one('hide', function () {
		$this.is(':visible') && $this.focus()
	  })
  })

  $(document)
	.on('show.bs.modal',  '.modal.bs', function () { $(document.body).addClass('modal-open') })
	.on('hidden.bs.modal', '.modal.bs', function () { $(document.body).removeClass('modal-open') })

}(jQuery);

/* ========================================================================
 * Bootstrap: tooltip.js v3.0.3
 * http://getbootstrap.com/javascript/#tooltip
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */


+function ($) { "use strict";

  // TOOLTIP PUBLIC CLASS DEFINITION
  // ===============================

  var Tooltip = function (element, options) {
	this.type       =
	this.options    =
	this.enabled    =
	this.timeout    =
	this.hoverState =
	this.$element   = null

	this.init('tooltip', element, options)
  }

  Tooltip.DEFAULTS = {
	animation: true
  , placement: 'top'
  , selector: false
  , template: '<div class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>'
  , trigger: 'hover focus'
  , title: ''
  , delay: 0
  , html: false
  , container: false
  }

  Tooltip.prototype.init = function (type, element, options) {
	this.enabled  = true
	this.type     = type
	this.$element = $(element)
	this.options  = this.getOptions(options)

	var triggers = this.options.trigger.split(' ')

	for (var i = triggers.length; i--;) {
	  var trigger = triggers[i]

	  if (trigger == 'click') {
		this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
	  } else if (trigger != 'manual') {
		var eventIn  = trigger == 'hover' ? 'mouseenter' : 'focus'
		var eventOut = trigger == 'hover' ? 'mouseleave' : 'blur'

		this.$element.on(eventIn  + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
		this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
	  }
	}

	this.options.selector ?
	  (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :
	  this.fixTitle()
  }

  Tooltip.prototype.getDefaults = function () {
	return Tooltip.DEFAULTS
  }

  Tooltip.prototype.getOptions = function (options) {
	options = $.extend({}, this.getDefaults(), this.$element.data(), options)

	if (options.delay && typeof options.delay == 'number') {
	  options.delay = {
		show: options.delay
	  , hide: options.delay
	  }
	}

	return options
  }

  Tooltip.prototype.getDelegateOptions = function () {
	var options  = {}
	var defaults = this.getDefaults()

	this._options && $.each(this._options, function (key, value) {
	  if (defaults[key] != value) options[key] = value
	})

	return options
  }

  Tooltip.prototype.enter = function (obj) {
	var self = obj instanceof this.constructor ?
	  obj : $(obj.currentTarget)[this.type](this.getDelegateOptions()).data('bs.' + this.type)

	clearTimeout(self.timeout)

	self.hoverState = 'in'

	if (!self.options.delay || !self.options.delay.show) return self.show()

	self.timeout = setTimeout(function () {
	  if (self.hoverState == 'in') self.show()
	}, self.options.delay.show)
  }

  Tooltip.prototype.leave = function (obj) {

	var self = obj instanceof this.constructor ?
	  obj : $(obj.currentTarget)[this.type](this.getDelegateOptions()).data('bs.' + this.type)

	clearTimeout(self.timeout)

	self.hoverState = 'out'

	if (!self.options.delay || !self.options.delay.hide) return self.hide()

	self.timeout = setTimeout(function () {
	  if (self.hoverState == 'out') self.hide()
	}, self.options.delay.hide)
  }

  Tooltip.prototype.show = function () {
	var e = $.Event('show.bs.'+ this.type)

	if (this.hasContent() && this.enabled) {
	  this.$element.triggerHandler(e)

	  if (e.isDefaultPrevented()) return

	  var $tip = this.tip()

	  this.setContent()

	  if (this.options.animation) $tip.addClass('fade')

	  var placement = typeof this.options.placement == 'function' ?
		this.options.placement.call(this, $tip[0], this.$element[0]) :
		this.options.placement

	  var autoToken = /\s?auto?\s?/i
	  var autoPlace = autoToken.test(placement)
	  if (autoPlace) placement = placement.replace(autoToken, '') || 'top'

	  $tip
		.detach()
		.css({ top: 0, left: 0, display: 'block' })
		.addClass(placement.split('-')[0]);

	  this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)

	  var pos          = this.getPosition()
	  var actualWidth  = $tip[0].offsetWidth
	  var actualHeight = $tip[0].offsetHeight

	  if (autoPlace) {
		var $parent = this.$element.parent()

		var orgPlacement = placement
		var docScroll    = document.documentElement.scrollTop || document.body.scrollTop
		var parentWidth  = this.options.container == 'body' ? window.innerWidth  : $parent.outerWidth()
		var parentHeight = this.options.container == 'body' ? window.innerHeight : $parent.outerHeight()
		var parentLeft   = this.options.container == 'body' ? 0 : $parent.offset().left

		placement = placement == 'bottom' && pos.top   + pos.height  + actualHeight - docScroll > parentHeight  ? 'top'    :
					placement == 'top'    && pos.top   - docScroll   - actualHeight < 0                         ? 'bottom' :
					placement == 'right'  && pos.right + actualWidth > parentWidth                              ? 'left'   :
					placement == 'left'   && pos.left  - actualWidth < parentLeft                               ? 'right'  :
					placement

		$tip
		  .removeClass(orgPlacement)
		  .addClass(placement)
	  }

	  var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)

	  this.applyPlacement(calculatedOffset, placement)
	  this.$element.trigger('shown.bs.' + this.type)
	}
  }

  Tooltip.prototype.applyPlacement = function(offset, placement) {
	var replace
	var $tip   = this.tip()
	var width  = $tip[0].offsetWidth
	var height = $tip[0].offsetHeight

	// manually read margins because getBoundingClientRect includes difference
	var marginTop = parseInt($tip.css('margin-top'), 10)
	var marginLeft = parseInt($tip.css('margin-left'), 10)

	// we must check for NaN for ie 8/9
	if (isNaN(marginTop))  marginTop  = 0
	if (isNaN(marginLeft)) marginLeft = 0

	offset.top  = offset.top  + marginTop
	offset.left = offset.left + marginLeft

	$tip
	  .offset(offset)
	  .addClass('in')

	// Add cursor to the background. #3393
	if (window.es.mobile && this.type == 'popover') {
		$('body').css('cursor', 'pointer');
	}

	// check to see if placing tip in new offset caused the tip to resize itself
	var actualWidth  = $tip[0].offsetWidth
	var actualHeight = $tip[0].offsetHeight

	if (placement == 'top' && actualHeight != height) {
	  replace = true
	  offset.top = offset.top + height - actualHeight
	}

	if (['top', 'bottom'].indexOf(placement.split('-')[0]) === 0) {
	  var delta = 0

	  if (offset.left < 0) {
		delta       = offset.left * -2
		offset.left = 0

		$tip.offset(offset)

		actualWidth  = $tip[0].offsetWidth
		actualHeight = $tip[0].offsetHeight
	  }

	  this.replaceArrow(delta - width + actualWidth, actualWidth, 'left')
	}

	if (['left', 'right'].indexOf(placement.split('-')[0]) === 0) {
	  this.replaceArrow(actualHeight - height, actualHeight, 'top')
	}

	if (replace) $tip.offset(offset)
  }

  Tooltip.prototype.replaceArrow = function(delta, dimension, position) {
	this.arrow().css(position, delta ? (50 * (1 - delta / dimension) + "%") : '')
  }

  Tooltip.prototype.setContent = function () {
	var $tip  = this.tip()
	var title = this.getTitle()

	$tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
	$tip.removeClass('fade in top bottom left right')
  }

  Tooltip.prototype.hide = function () {
	var that = this
	var $tip = this.tip()
	var e    = $.Event('hide.bs.' + this.type)

	function complete() {
	  if (that.hoverState != 'in') $tip.detach()
	}

	this.$element.triggerHandler(e)

	if (e.isDefaultPrevented()) return

	$tip.removeClass('in')

	$.support.transition && this.$tip.hasClass('fade') ?
	  $tip
		.one($.support.transition.end, complete)
		.emulateTransitionEnd(150) :
	  complete()

	// Remove cursor from the background. #3393
	if (window.es.mobile && this.type == 'popover') {
		$('body').css('cursor', '');
	}

	this.$element.trigger('hidden.bs.' + this.type)

	return this
  }

  Tooltip.prototype.fixTitle = function () {
	var $e = this.$element
	if ($e.attr('title') || typeof($e.attr('data-original-title')) != 'string') {
	  $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
	}
  }

  Tooltip.prototype.hasContent = function () {
	return this.getTitle()
  }

  Tooltip.prototype.getPosition = function () {
	var el = this.$element[0]
	return $.extend({}, (typeof el.getBoundingClientRect == 'function') ? el.getBoundingClientRect() : {
	  width: el.offsetWidth
	, height: el.offsetHeight
	}, this.$element.offset())
  }

  Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {

	return placement == 'left-top'     ? { top: pos.top, left: pos.left - actualWidth } :
		   placement == 'left-bottom'  ? { top: pos.top + pos.height - actualHeight, left: pos.left - actualWidth } :
		   placement == 'right-top'    ? { top: pos.top, left: pos.left + pos.width } :
		   placement == 'right-bottom' ? { top: pos.top + pos.height - actualHeight, left: pos.left + pos.width } :
		   placement == 'top-left'     ? { top: pos.top - actualHeight, left: pos.left } :
		   placement == 'top-right'    ? { top: pos.top - actualHeight, left: pos.left + pos.width - actualWidth } :
		   placement == 'bottom-left'  ? { top: pos.top + pos.height, left: pos.left } :
		   placement == 'bottom-right' ? { top: pos.top + pos.height, left: pos.left + pos.width - actualWidth } :
		   placement == 'bottom'       ? { top: pos.top + pos.height,   left: pos.left + pos.width / 2 - actualWidth / 2  } :
		   placement == 'top'    ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2  } :
		   placement == 'left'   ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :
		/* placement == 'right' */ { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width   }
  }

  Tooltip.prototype.getTitle = function () {
	var title
	var $e = this.$element
	var o  = this.options

	title = $e.attr('data-original-title')
	  || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)

	return title
  }

  Tooltip.prototype.tip = function () {
	return this.$tip = this.$tip || $(this.options.template)
  }

  Tooltip.prototype.arrow = function () {
	return this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow')
  }

  Tooltip.prototype.validate = function () {
	if (!this.$element[0].parentNode) {
	  this.hide()
	  this.$element = null
	  this.options  = null
	}
  }

  Tooltip.prototype.enable = function () {
	this.enabled = true
  }

  Tooltip.prototype.disable = function () {
	this.enabled = false
  }

  Tooltip.prototype.toggleEnabled = function () {
	this.enabled = !this.enabled
  }

  Tooltip.prototype.toggle = function (e) {
	var self = e ? $(e.currentTarget)[this.type](this.getDelegateOptions()).data('bs.' + this.type) : this
	self.tip().hasClass('in') ? self.leave(self) : self.enter(self)
  }

  Tooltip.prototype.destroy = function () {
	this.hide().$element.off('.' + this.type).removeData('bs.' + this.type)
  }


  // TOOLTIP PLUGIN DEFINITION
  // =========================

  var old = $.fn.tooltip

  $.fn.tooltip = function (option) {
	return this.each(function () {
	  var $this   = $(this)
	  var data    = $this.data('bs.tooltip')
	  var options = typeof option == 'object' && option

	  if (!data) $this.data('bs.tooltip', (data = new Tooltip(this, options)))
	  if (typeof option == 'string') data[option]()
	})
  }

  $.fn.tooltip.Constructor = Tooltip


  // TOOLTIP NO CONFLICT
  // ===================

  $.fn.tooltip.noConflict = function () {
	$.fn.tooltip = old
	return this
  }

}(jQuery);

/* ========================================================================
 * Bootstrap: popover.js v3.0.3
 * http://getbootstrap.com/javascript/#popovers
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */


+function ($) { "use strict";

  // POPOVER PUBLIC CLASS DEFINITION
  // ===============================

  var Popover = function (element, options) {
	this.init('popover', element, options)
  }

  if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js')

  Popover.DEFAULTS = $.extend({} , $.fn.tooltip.Constructor.DEFAULTS, {
	placement: 'right'
  , trigger: 'click'
  , content: ''
  , template: '<div id="es" class="o-popover--es"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
  })


  // NOTE: POPOVER EXTENDS tooltip.js
  // ================================

  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype)

  Popover.prototype.constructor = Popover

  Popover.prototype.getDefaults = function () {
	return Popover.DEFAULTS
  }

  Popover.prototype.setContent = function () {
	var $tip    = this.tip()
	var title   = this.getTitle()
	var content = this.getContent()

	$tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)
	$tip.find('.popover-content')[this.options.html ? 'html' : 'text'](content)

	$tip.removeClass('fade top bottom left right in')

	// IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
	// this manually by checking the contents.
	if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide()
  }

  Popover.prototype.hasContent = function () {
	return this.getTitle() || this.getContent()
  }

  Popover.prototype.getContent = function () {
	var $e = this.$element
	var o  = this.options

	return $e.attr('data-content')
	  || (typeof o.content == 'function' ?
			o.content.call($e[0]) :
			o.content)
  }

  Popover.prototype.arrow = function () {
	return this.$arrow = this.$arrow || this.tip().find('.arrow')
  }

  Popover.prototype.tip = function () {
	if (!this.$tip) this.$tip = $(this.options.template)
	return this.$tip
  }


  // POPOVER PLUGIN DEFINITION
  // =========================

  var old = $.fn.popover

  $.fn.popover = function (option) {
	return this.each(function () {
	  var $this   = $(this)
	  var data    = $this.data('bs.popover')
	  var options = typeof option == 'object' && option

	  if (!data) $this.data('bs.popover', (data = new Popover(this, options)))
	  if (typeof option == 'string') data[option]()
	})
  }

  $.fn.popover.Constructor = Popover


  // POPOVER NO CONFLICT
  // ===================

  $.fn.popover.noConflict = function () {
	$.fn.popover = old
	return this
  }

// It seems like Tooltips is still referring to popover?
// To solve the Tooltip issue, we need to create another instance and
// keep the original popover. #1444

  $.fn.popoverES = function (option) {
	return this.each(function () {
	  var $this   = $(this)
	  var data    = $this.data('bs.popover')
	  var options = typeof option == 'object' && option

	  if (!data) $this.data('bs.popover', (data = new Popover(this, options)))
	  if (typeof option == 'string') data[option]()
	})
  }

  $.fn.popoverES.Constructor = Popover


}(jQuery);

/* ========================================================================
 * Bootstrap: scrollspy.js v3.0.3
 * http://getbootstrap.com/javascript/#scrollspy
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */


+function ($) { "use strict";

  // SCROLLSPY CLASS DEFINITION
  // ==========================

  function ScrollSpy(element, options) {
	var href
	var process  = $.proxy(this.process, this)

	this.$element       = $(element).is('body') ? $(window) : $(element)
	this.$body          = $('body')
	this.$scrollElement = this.$element.on('scroll.bs.scroll-spy.data-api', process)
	this.options        = $.extend({}, ScrollSpy.DEFAULTS, options)
	this.selector       = (this.options.target
	  || ((href = $(element).attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '')) //strip for ie7
	  || '') + ' .nav li > a'
	this.offsets        = $([])
	this.targets        = $([])
	this.activeTarget   = null

	this.refresh()
	this.process()
  }

  ScrollSpy.DEFAULTS = {
	offset: 10
  }

  ScrollSpy.prototype.refresh = function () {
	var offsetMethod = this.$element[0] == window ? 'offset' : 'position'

	this.offsets = $([])
	this.targets = $([])

	var self     = this
	var $targets = this.$body
	  .find(this.selector)
	  .map(function () {
		var $el   = $(this)
		var href  = $el.data('target') || $el.attr('href')
		var $href = /^#\w/.test(href) && $(href)

		return ($href
		  && $href.length
		  && [[ $href[offsetMethod]().top + (!$.isWindow(self.$scrollElement.get(0)) && self.$scrollElement.scrollTop()), href ]]) || null
	  })
	  .sort(function (a, b) { return a[0] - b[0] })
	  .each(function () {
		self.offsets.push(this[0])
		self.targets.push(this[1])
	  })
  }

  ScrollSpy.prototype.process = function () {
	var scrollTop    = this.$scrollElement.scrollTop() + this.options.offset
	var scrollHeight = this.$scrollElement[0].scrollHeight || this.$body[0].scrollHeight
	var maxScroll    = scrollHeight - this.$scrollElement.height()
	var offsets      = this.offsets
	var targets      = this.targets
	var activeTarget = this.activeTarget
	var i

	if (scrollTop >= maxScroll) {
	  return activeTarget != (i = targets.last()[0]) && this.activate(i)
	}

	for (i = offsets.length; i--;) {
	  activeTarget != targets[i]
		&& scrollTop >= offsets[i]
		&& (!offsets[i + 1] || scrollTop <= offsets[i + 1])
		&& this.activate( targets[i] )
	}
  }

  ScrollSpy.prototype.activate = function (target) {
	this.activeTarget = target

	$(this.selector)
	  .parents('.active')
	  .removeClass('active')

	var selector = this.selector
	  + '[data-target="' + target + '"],'
	  + this.selector + '[href="' + target + '"]'

	var active = $(selector)
	  .parents('li')
	  .addClass('active')

	if (active.parent('.dropdown-menu').length)  {
	  active = active
		.closest('li.dropdown')
		.addClass('active')
	}

	active.trigger('activate.bs.scrollspy')
  }


  // SCROLLSPY PLUGIN DEFINITION
  // ===========================

  var old = $.fn.scrollspy

  $.fn.scrollspy = function (option) {
	return this.each(function () {
	  var $this   = $(this)
	  var data    = $this.data('bs.scrollspy')
	  var options = typeof option == 'object' && option

	  if (!data) $this.data('bs.scrollspy', (data = new ScrollSpy(this, options)))
	  if (typeof option == 'string') data[option]()
	})
  }

  $.fn.scrollspy.Constructor = ScrollSpy


  // SCROLLSPY NO CONFLICT
  // =====================

  $.fn.scrollspy.noConflict = function () {
	$.fn.scrollspy = old
	return this
  }


  // SCROLLSPY DATA-API
  // ==================

  $(window).on('load', function () {
	$('[data-bs-spy="scroll"]').each(function () {
	  var $spy = $(this)
	  $spy.scrollspy($spy.data())
	})
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: tab.js v3.0.3
 * http://getbootstrap.com/javascript/#tabs
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */


+function ($) { "use strict";

  // TAB CLASS DEFINITION
  // ====================

  var Tab = function (element) {
	this.element = $(element)
  }

  Tab.prototype.show = function () {
	var $this    = this.element
	var $ul      = $this.closest('ul:not(.dropdown-menu)')
	var selector = $this.data('target')

	if (!selector) {
	  selector = $this.attr('href')
	  selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '') //strip for ie7
	}

	if ($this.parent('li').hasClass('active')) return

	var previous = $ul.find('.active:last a')[0]
	var e        = $.Event('show.bs.tab', {
	  relatedTarget: previous
	})

	$this.triggerHandler(e)

	if (e.isDefaultPrevented()) return

	var $target = $(selector)

	this.activate($this.parent('li'), $ul)
	this.activate($target, $target.parent(), function () {
	  $this.trigger({
		type: 'shown.bs.tab'
	  , relatedTarget: previous
	  })
	})
  }

  Tab.prototype.activate = function (element, container, callback) {
	var $active    = container.find('> .active')
	var transition = callback
	  && $.support.transition
	  && $active.hasClass('fade')

	function next() {
	  $active
		.removeClass('active')
		.find('> .dropdown-menu > .active')
		.removeClass('active')

	  element.addClass('active')

	  if (transition) {
		element[0].offsetWidth // reflow for transition
		element.addClass('in')
	  } else {
		element.removeClass('fade')
	  }

	  if (element.parent('.dropdown-menu')) {
		element.closest('li.dropdown').addClass('active')
	  }

	  callback && callback()
	}

	transition ?
	  $active
		.one($.support.transition.end, next)
		.emulateTransitionEnd(150) :
	  next()

	$active.removeClass('in')
  }


  // TAB PLUGIN DEFINITION
  // =====================

  var old = $.fn.tab

  $.fn.tab = function ( option ) {
	return this.each(function () {
	  var $this = $(this)
	  var data  = $this.data('bs.tab')

	  if (!data) $this.data('bs.tab', (data = new Tab(this)))
	  if (typeof option == 'string') data[option]()
	})
  }

  $.fn.tab.Constructor = Tab


  // TAB NO CONFLICT
  // ===============

  $.fn.tab.noConflict = function () {
	$.fn.tab = old
	return this
  }


  // TAB DATA-API
  // ============

  $(document).on('click.bs.tab.data-api', '[data-bs-toggle="tab"], [data-bs-toggle="pill"]', function (e) {
	e.preventDefault()
	$(this).tab('show')
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: affix.js v3.0.3
 * http://getbootstrap.com/javascript/#affix
 * ========================================================================
 * Copyright 2013 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ======================================================================== */


+function ($) { "use strict";

  // AFFIX CLASS DEFINITION
  // ======================

  var Affix = function (element, options) {
	this.options = $.extend({}, Affix.DEFAULTS, options)
	this.$window = $(window)
	  .on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this))
	  .on('click.bs.affix.data-api',  $.proxy(this.checkPositionWithEventLoop, this))

	this.$element = $(element)
	this.affixed  =
	this.unpin    = null

	this.checkPosition()
  }

  Affix.RESET = 'affix affix-top affix-bottom'

  Affix.DEFAULTS = {
	offset: 0
  }

  Affix.prototype.checkPositionWithEventLoop = function () {
	setTimeout($.proxy(this.checkPosition, this), 1)
  }

  Affix.prototype.checkPosition = function () {
	if (!this.$element.is(':visible')) return

	var scrollHeight = $(document).height()
	var scrollTop    = this.$window.scrollTop()
	var position     = this.$element.offset()
	var offset       = this.options.offset
	var offsetTop    = offset.top
	var offsetBottom = offset.bottom

	if (typeof offset != 'object')         offsetBottom = offsetTop = offset
	if (typeof offsetTop == 'function')    offsetTop    = offset.top()
	if (typeof offsetBottom == 'function') offsetBottom = offset.bottom()

	var affix = this.unpin   != null && (scrollTop + this.unpin <= position.top) ? false :
				offsetBottom != null && (position.top + this.$element.height() >= scrollHeight - offsetBottom) ? 'bottom' :
				offsetTop    != null && (scrollTop <= offsetTop) ? 'top' : false

	if (this.affixed === affix) return
	if (this.unpin) this.$element.css('top', '')

	this.affixed = affix
	this.unpin   = affix == 'bottom' ? position.top - scrollTop : null

	this.$element.removeClass(Affix.RESET).addClass('affix' + (affix ? '-' + affix : ''))

	if (affix == 'bottom') {
	  this.$element.offset({ top: document.body.offsetHeight - offsetBottom - this.$element.height() })
	}
  }


  // AFFIX PLUGIN DEFINITION
  // =======================

  var old = $.fn.affix

  $.fn.affix = function (option) {
	return this.each(function () {
	  var $this   = $(this)
	  var data    = $this.data('bs.affix')
	  var options = typeof option == 'object' && option

	  if (!data) $this.data('bs.affix', (data = new Affix(this, options)))
	  if (typeof option == 'string') data[option]()
	})
  }

  $.fn.affix.Constructor = Affix


  // AFFIX NO CONFLICT
  // =================

  $.fn.affix.noConflict = function () {
	$.fn.affix = old
	return this
  }


  // AFFIX DATA-API
  // ==============

  $(window).on('load', function () {
	$('[data-bs-spy="affix"]').each(function () {
	  var $spy = $(this)
	  var data = $spy.data()

	  data.offset = data.offset || {}

	  if (data.offsetBottom) data.offset.bottom = data.offsetBottom
	  if (data.offsetTop)    data.offset.top    = data.offsetTop

	  $spy.affix(data)
	})
  })

}(jQuery);
/**
 * bootstrap-notify.js v1.0
 * --
 * http://twitter.com/nijikokun
 * Copyright 2012 Nijiko Yonskai, Goodybag
 * --
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

!function ($) {
  var Notification = function (element, options) {
	// Element collection
	this.$element = $(element);
	this.$note    = $('<div class="alert"></div>');
	this.options  = $.extend(true, $.fn.notify.defaults, options);

	// Setup from options
	if(this.options.transition)
	  if(this.options.transition == 'fade')
		this.$note.addClass('in').addClass(this.options.transition);
	  else this.$note.addClass(this.options.transition);
	else this.$note.addClass('fade').addClass('in');

	if(this.options.type)
	  this.$note.addClass('alert-' + this.options.type);
	else this.$note.addClass('alert-success');

	if(!this.options.message && this.$element.data("message") !== '') // dom text
	  this.$note.html(this.$element.data("message"));
	else
	  if(typeof this.options.message === 'object')
		if(this.options.message.html)
		  this.$note.html(this.options.message.html);
		else if(this.options.message.text)
		  this.$note.text(this.options.message.text);
	  else
		this.$note.html(this.options.message);

	if(this.options.closable)
	  var link = $('<a class="close pull-right" href="javascript: void(0);">&times;</a>');
	  $(link).on('click', $.proxy(onClose, this));
	  this.$note.prepend(link);

	return this;
  };

  onClose = function() {
	this.options.onClose();
	$(this.$note).remove();
	this.options.onClosed();
  };

  Notification.prototype.show = function () {
	if(this.options.fadeOut.enabled)
	  this.$note.delay(this.options.fadeOut.delay || 3000).fadeOut('slow', $.proxy(onClose, this));

	this.$element.append(this.$note);
	this.$note.alert();
  };

  Notification.prototype.hide = function () {
	if(this.options.fadeOut.enabled)
	  this.$note.delay(this.options.fadeOut.delay || 3000).fadeOut('slow', $.proxy(onClose, this));
	else onClose.call(this);
  };

  $.fn.notify = function (options) {
	return new Notification(this, options);
  };

  $.fn.notify.defaults = {
	type: 'success',
	closable: true,
	transition: 'fade',
	fadeOut: {
	  enabled: true,
	  delay: 3000
	},
	message: null,
	onClose: function () {},
	onClosed: function () {}
  }
}($);

});
FD40.plugin("utils", function($) {

/**
 * jquery.Bloop
 * Binary loop helper.
 * https://github.com/jstonne/jquery.Bloop
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne & Jason Rey
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

(function(){

	var Bloop = function(items) {

		this.items = items;
		this.start = 0;
		this.end = items.length - 1;
		this.node = null;
		this.stopped = false;
	};

	$.extend(Bloop.prototype, {

		isLooping: function() {

			if (this.stopped) return false;

			if (Math.abs(this.start - this.end) > 1) {
				this.node = Math.floor((this.start + this.end) / 2);
				return true;
			}

			return false;
		},

		flip: function(flip) {

			if (flip) {
				this.end = this.node - 1;
			} else {
				this.start = this.node + 1;
			}
		},

		stop: function() {
			this.stop = true;
		}
	});


	$.Bloop = function(items){

		return new Bloop(items);
	}

})();
;/*!
 * jquery.Chunk
 * Utility to handle large arrays by processing
 * them in smaller manageable chunks.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.Chunk = function(array, options) {

	if ($.isArray(array)) {
		array = [];
	}

	var options = $.extend({},
		{
			size: 256,
			every: 1000
		},
		options
	);

	var self = $.extend($.Deferred(), {

		size: options.size,

		every: options.every,

		from: 0,

		to: array.length,

		process: function(callback) {

			self.process.fn = callback;

			return self;
		},

		chunkStart: function(callback) {

			self.chunkStart.fn = callback;

			return self;
		},

		chunkEnd: function(callback) {

			self.chunkEnd.fn = callback;

			return self;
		},

		start: function() {

			self.stopped = false;

			self.iterate();

			return self;
		},

		iterate: function() {

			if (self.stopped) return;

			var iterator = self.process.fn;

			if (!iterator) return;

			self.to = from.size + self.size;

			var max = array.length;

			if (self.to > max) {

				self.to = max;
			}

			var range = {from: self.from, to: self.to};

			// Trigger chunkStart event
			self.chunkStart.fn && self.chunkStart.fn.call(self, range.from, range.to);

			while (self.from < self.to) {

				if (self.stopped) break;

				iterator.call(self, array[self.from]);

				self.from++;
			}

			// Trigger chunkEnd event
			self.chunkEnd.fn && self.chunkEnd.fn.call(self, range.from, range.to);

			// Always get the latest array length because
			// it may change through iteration
			self.completed = (self.from >= array.length - 1);

			if (self.completed) {

				self.resolveWith(self);

			} else {

				self.nextIteration = setTimeout(self.iterate, self.every);
			}

			return self;
		},

		pause: function() {

			self.stopped = true;

			clearTimeout(self.nextIteration);

			return self;
		},

		restart: function() {

			if (self.state()==="rejected") return self;

			self.from = 0;

			self.start();

			return self;
		},

		stop: function() {

			self.pause();

			self.rejectWith(self, [self.from]);

			return self;
		}
	});

	return self;
};
;/**
 * jquery.Enqueue
 * Execute only the last added callback.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne & Jason Rey
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

(function(isFunction) {

	var Enqueue = function() {
		this.lastId = 0;
	};

	Enqueue.prototype.queue = function(filter) {

		var self = this,
			id = $.uid();
			self.lastId = id;

		return function() {

			if (self.lastId===id) {

				var args = arguments,
					args = (isFunction(filter)) ? filter.apply(this, args) : args;

				return (isFunction(self.fn)) ? self.fn.apply(this, args) : args;
			}
		}
	};

	$.Enqueue = function(fn) {

		var self = new Enqueue();

		if (isFunction(fn)) self.fn = fn;

		var func = $.proxy(self.queue, self);

		func.reset = function() {
			self.lastId = 0;
		};

		return func;
	};
})($.isFunction);
;/**
 * jquery.Exception
 * Standardized exception object.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

(function(){
	var consoleMethod = {
		error: "error",
		warning: "warn",
		success: "log",
		info: "info"
	};

	// $.Exception("message");
	// $.Exception("success", "message");
	// $.Exception("error", "message", data);
	// $.Exception({type: "info", message: "message", foo: "bar", key: "val"});
	$.Exception = function(exception) {

		// Normalize arguments
		var args = arguments,
			simple = args.length==1,
			hasData = args.length==3;

		exception = $.isPlainObject(exception) ?
			exception :
			{
				type   : simple ? "error" : args[0],
				message: simple ? args[0] : args[1]
			}

		hasData && $.extend(exception, args[2]);

		if ($.environment=="development") {
			console[consoleMethod[exception.type]](exception.message, exception);
		}

		return exception;
	}
})();;/**
 * jquery.IE
 * Returns the current IE version.
 *
 * Based on Padolsey's IE detection script.
 * https://gist.github.com/padolsey/527683
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.IE = (function(){

	// It seems Padolsey's IE detection script
	// doesn't work on IE10 and 11.
	var ua = navigator.userAgent;
	if (ua.match(/MSIE 9/)) return 9;
	if (ua.match(/MSIE 10/)) return 10;
	if (ua.match(/rv:11/i)) return 11;

	var undef,
		v = 3,
		div = document.createElement('div'),
		all = div.getElementsByTagName('i');

	while (
		v++,
		div.innerHTML = '<!--[if gt IE ' + v + ']><i></i><![endif]-->',
		all[0]
	);

	return v > 4 ? v : undef;

}());;/**
 * jquery.Task
 * Task runner utility.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.Task = function(props) {

	var task = $.extend(
		$.Deferred(),
		{
			data: {},
			list: [],
			add: function(name) {

				var item = $.extend(
					$.Deferred(),
					{
						name: name,
						item: item
					}
				);

				task.list.push(item);

				return item;
			},
			process: function() {

				if (!task._promise) {

					task._promise =
						$.when.apply($, task.list)
							.then(
								task.resolve,
								task.reject,
								task.progress
							);
				}

				return task;
			}
		},
		props
	);

	return task;
};;/**
 * jquery.Threads
 * A manager that controls threads a.k.a. execution of function simultaneously.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne & Jason Rey
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

(function() {

	var Threads = function(options) {
		this.threads = [];
		this.threadCount = 0;
		this.threadLimit = options.threadLimit || 1;
		this.threadDelay = options.threadDelay || 0;
	}

	$.extend(Threads.prototype, {

		add: function(thread, type) {

			if (!$.isFunction(thread)) return;

			thread.type = type || "normal";

			if (type=="deferred") {
				thread.deferred = $.Deferred().always($.proxy(this.next, this));
			}

			this.threads.push(thread);

			this.run();
		},

		addDeferred: function(thread) {

			return this.add(thread, "deferred");
		},

		next: function() {

			// Reduce thread count
			this.threadCount--;

			// And see if there's anymore task to run
			this.run();
		},

		run: function() {

			var self = this;

			setTimeout(function(){

				if (self.threads.length < 1) return;

				if (self.threadCount < self.threadLimit) {

					self.threadCount++;

					var thread = self.threads.shift();

					// Wrap in a try catch in case if the thread
					// throws an error it doesn't break our chain.
					try { thread.call(thread, thread.deferred); }
					catch(e) { console.error(e); }

					!thread.deferred && self.next();
				}

			}, self.threadDelay);
		}
	});

	$.Threads = function(options) {

		return new Threads(options);
	};

})();
;/**
 * jquery.callback
 * Creates a global callback function that gets
 * removed from the window object after it has executed.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.callback = function(func, persist){

	// Create callback
	if ($.isFunction(func)) {

		var funcName = $.uid("cb");

		window[funcName] = function(){

			// Destroy itself after callback has been called
			if (!persist) {
				delete window[funcName];
			}

			return func.apply(null, arguments);
		}

		return funcName;
	}

	// Callback method
	if ($.isString(func)) {
		switch (func) {
			case "destroy":
				var funcName = persist;
				delete window[funcName];
				break;
		}
	}
};/**
 * jquery.fn.checkList.
 * Multiple checkbox handler.
 *
 * $(e).checkList({
 *    check  : function(){},   // callback when an input is checked
 *    uncheck: function(){},   // callback when an input is unchecked
 *
 *    // returns checked elements & unchecked elements in separate arguments
 *    change : function(checked, unchecked){}
 * })
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.fn.checkList = function(options) {

	var defaultOptions = {
		checkbox: ".checkbox",
		masterCheckbox: ".master-checkbox",
		check: function() {},
		uncheck: function() {},
		change: function() {}
	}

	var options = $.extend({}, defaultOptions, options),
		checkList       = this,
		checkboxes      = checkList.find(options.checkbox),
		masterCheckbox  = checkList.find(options.masterCheckbox),
		disableChangeEvent = false;

	var change = function() {

		if (!disableChangeEvent) {

			var checked = checkboxes.filter(':checked'),
				unchecked = checkboxes.not(':checked');

			if (checked.length < 1) {
				masterCheckbox.removeAttr("checked");
			}

			if (checked.length == checkboxes.length) {
				masterCheckbox.prop("checked", true);
			}

			options.change.call(checkList, checked, unchecked);
		}
	}

	checkboxes.checked(

		// checked
		function() {
			options.check.apply(checkList);
			change();
		},

		// unchecked
		function() {
			options.uncheck.apply(checkList);
			change();
		}
	);

	masterCheckbox.checked(

		// checked
		function() {
			disableChangeEvent = true;
			checkboxes.checked(true);
			disableChangeEvent = false;
			change();
		},

		// unchecked
		function() {
			disableChangeEvent = true;
			checkboxes.checked(false);
			disableChangeEvent = false;
			change();
		}
	);

	change();

	return this;
};;/**
 * jquery.classManip
 * Utilities to manipulate classnames.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

/**
 * $.fn.switchClass
 * Swaps a classname for another classname that bears identical prefix.
 *
 * $("div").switchClass("state-busy")l;
 *
 * Before:
 * <div class="state-idle"></div>
 *
 * After:
 * <div class="state-busy"></div>
 */
$.fn.switchClass = function(classname, delimiter){

	var delimiter = delimiter || "-",
		prefix = classname.split(delimiter)[0] + delimiter,
		length = prefix.length;

	return this.each(function(){

		var $el = $(this),
			classnames =
				$.map(($el.attr("class") || "").split(" "), function(classname){
					return (classname.slice(0, length)==prefix || classname=="") ? null : classname;
				});
			classnames.push(classname);

		$el.attr("class", classnames.join(" "));
	});
};

/**
 * $.fn.activateClass
 * Add classname on current set of elements and
 * remove classname on previous set of elements.
 *
 * $(".item").find("[data-id=64]").activateClass("active");
 *
 * Before:
 * <div class="item active" data-id="62"></div>
 * <div class="item" data-id="63"></div>
 * <div class="item" data-id="64"></div>
 *
 * After:
 * <div class="item" data-id="62"></div>
 * <div class="item" data-id="63"></div>
 * <div class="item active" data-id="64"></div>
 */
$.fn.activateClass = function(className) {
	this.prevObject.removeClass(className);
	return $(this).addClass(className);
};;/**
 * jquery.color
 * Color helpers.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */
(function(){

var hexToRgb = function(hex) {
	var hex = parseInt(((hex.indexOf('#') > -1) ? hex.substring(1) : hex), 16);
	return {r: hex >> 16, g: (hex & 0x00FF00) >> 8, b: (hex & 0x0000FF)};
};

var hexToHsb = function(hex) {
	return rgbToHsb(hexToRgb(hex));
};

var rgbToHsb = function(rgb) {
	var hsb = {h: 0, s: 0, b: 0};
	var min = Math.min(rgb.r, rgb.g, rgb.b);
	var max = Math.max(rgb.r, rgb.g, rgb.b);
	var delta = max - min;
	hsb.b = max;
	hsb.s = max != 0 ? 255 * delta / max : 0;
	if (hsb.s != 0) {
		if (rgb.r == max) hsb.h = (rgb.g - rgb.b) / delta;
		else if (rgb.g == max) hsb.h = 2 + (rgb.b - rgb.r) / delta;
		else hsb.h = 4 + (rgb.r - rgb.g) / delta;
		hsb.h *= 60;
	} else hsb.h = 360;
	if (hsb.h < 0) hsb.h += 360;
	hsb.s *= 100/255;
	hsb.b *= 100/255;
	return hsb;
};

var hsbToRgb = function(hsb) {
	var rgb = {};
	var h = hsb.h;
	var s = hsb.s*255/100;
	var v = hsb.b*255/100;
	if(s == 0) {
		rgb.r = rgb.g = rgb.b = v;
	} else {
		var t1 = v;
		var t2 = (255-s)*v/255;
		var t3 = (t1-t2)*(h%60)/60;
		if(h==360) h = 0;
		if(h<60) {rgb.r=t1; rgb.b=t2; rgb.g=t2+t3}
		else if(h<120) {rgb.g=t1; rgb.b=t2; rgb.r=t1-t3}
		else if(h<180) {rgb.g=t1; rgb.r=t2; rgb.b=t2+t3}
		else if(h<240) {rgb.b=t1; rgb.r=t2; rgb.g=t1-t3}
		else if(h<300) {rgb.b=t1; rgb.g=t2; rgb.r=t2+t3}
		else if(h<360) {rgb.r=t1; rgb.g=t2; rgb.b=t1-t3}
		else {rgb.r=0; rgb.g=0; rgb.b=0}
	}
	return {r:Math.round(rgb.r), g:Math.round(rgb.g), b:Math.round(rgb.b)};
};

var rgbToHex = function(rgb) {
	var hex = [
		rgb.r.toString(16),
		rgb.g.toString(16),
		rgb.b.toString(16)
	];
	$.each(hex, function (nr, val) {
		if (val.length == 1) {
			hex[nr] = '0' + val;
		}
	});
	return hex.join('');
};

var hsbToHex = function (hsb) {
	return rgbToHex(hsbToRgb(hsb));
};

var fixHsb = function (hsb) {
	return {
		h: Math.min(360, Math.max(0, hsb.h)),
		s: Math.min(100, Math.max(0, hsb.s)),
		b: Math.min(100, Math.max(0, hsb.b))
	};
};

var fixRgb = function (rgb) {
	return {
		r: Math.min(255, Math.max(0, rgb.r)),
		g: Math.min(255, Math.max(0, rgb.g)),
		b: Math.min(255, Math.max(0, rgb.b))
	};
};

var fixHex = function (hex) {
	var len = 6 - hex.length;

	if (len == 3) {
		var chars = hex.split(""), chr, hex = "";
		while (chr = chars.shift()) hex += chr + chr;
	} else {
		while (len--) hex = "0" + hex;
	}

	hex.replace(/[^A-Fa-f0-9]/g, "0");

	return hex;
};

$.extend($, {
	hexToRgb: hexToRgb,
	hexToHsb: hexToHsb,
	rgbToHsb: rgbToHsb,
	hsbToRgb: hsbToRgb,
	rgbToHex: rgbToHex,
	hsbToHex: hsbToHex,
	fixHsb: fixHsb,
	fixRgb: fixRgb,
	fixHex: fixHex
});

})();;;/**
 * jquery.fn.htmlData
 * Utilities to handle data within jQuery elements.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

/**
 * jquery.fn.htmlData
 * Converts inline data attributes into objects.
 */
$.fn.htmlData = function(prefix, nested) {

	var nested = nested===undefined ? true : nested,
		re = new RegExp("^" + "data-" + (prefix ? prefix + "-" : "") + "(.*)", "i"),
		parts,
		data = {};

	if (this.length <= 0) {
		return {};
	}

	// Extract options from data attributes
	$.each(this[0].attributes, function(i, attr){

		if (attr.specified && (parts = attr.name.match(re)) && parts[1]) {
			if (nested) {
				var props = parts[1].split("-"),
					i, prop, obj = data; max = props.length - 1;

				for (i=0; i<=max; i++) {
					prop = props[i];
					if (i==max) {
						obj[prop] = attr.value;
					} else {
						!obj[prop] && (obj[prop] = {});
						obj = obj[prop];
					}
				}
			} else {
				data[parts[1]] = attr.value;
			}
		}
	});

	return data;
};

/**
 * jquery.fn.defineData
 * Creates persistent data that cannot be changed.
 */
$.fn.defineData = function(name, value) {

	if (this.data(name)===undefined) {
		this.data(name, value);
	}

	return this;
};/**
 * jquery.deletes
 * Remove properties from objects.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.deletes = function(obj, props) {
	$.each(props, function(i, prop){
		delete obj[prop];
	});
};
;/**
 * jquery.fn.disabled
 * jquery.fn.enabled
 *
 * Determine if an element is disabled.
 * Also lets you disable or enable an element.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */


$.fn.disabled = function(state) {
	return (state===undefined) ?
				(this.is(":disabled") || this.hasClass('disabled')) :
				this.prop('disabled', !!state).toggleClass("disabled", !!state);
};

$.fn.enabled = function(state) {
	return (state===undefined) ? !this.disabled() : this.disabled(!state);
};
;/**
 * jquery.distinct
 * Enhanced version of jQuery.unique that also removes
 * removes object/string/integer duplicates within an array.
 * https://github.com/jstonne/jquery.distinct
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.distinct = function(items) {

	var uniqueElements = $.unique;

	if (items.length < 1) {
		return;
	};

	// If item is an array of DOM elements
	if (items[0].nodeType) {

		return uniqueElements.apply(this, arguments);
	};

	// If item is an array of objects
	if (typeof items[0]=='object') {

		var unique = Math.random(),
			uniqueObjects = [];

		$.each(items, function(i) {

			if (!items[i][unique]) {

				uniqueObjects.push(items[i]);

				items[i][unique] = true;
			}
		});

		$.each(uniqueObjects, function(i) {

			delete uniqueObjects[i][unique];
		});

		return uniqueObjects;
	};

	// Anything else (can be combination of string, integers and boolean)
	return $.grep(items, function(item, i) {

		return $.inArray(item, items) === i;
	});

};
;/**
 * jquery.fn.domManip
 * Shorthands for common DOM operations.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.fn.tagName = function(){
	return (this[0] || {}).tagName;
};

$.create = function(tagName) {
	return $(document.createElement(tagName));
};

$.fn.editable = function(editable) {
	if ($.isUndefined(editable)) return this.prop("contenteditable")==="true";
	this.prop("contenteditable", editable);
	editable===false && this.removeAttr("contenteditable");
	return this;
};/**
 * jquery.download
 * Simulate a download programatically.
 *
 * The download url should return the correct
 * Content-Type in the response headers to work.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.download = function(src) {
	return $("<iframe>").hide().appendTo("body").bind("load", function(){$(this).remove()}).attr("src", src);
};;/**
 * jquery.eventManip
 * Utilities to handle events in jQuery.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

/**
 * jquery.ns
 * Adds namespace to events.
 * $(el).on($.ns("mousedown keyup keydown", ".foobar"), function(){});
 */
$.ns = function(event, ns) {
	return event.split(" ").join(ns + " ") + ns;
};


/**
 * jquery.getPointerPosition
 * Get pointer position whether it came from mouse or touch events.
 */
$.getPointerPosition = function(event) {

	return event.type.match("touch") ?
		{
			x: event.originalEvent.changedTouches[0].pageX,
			y: event.originalEvent.changedTouches[0].pageY
		} :
		{
			x: event.pageX,
			y: event.pageY
		};
};;/**
 * jquery.eventable
 * Extend objects with simple event system.
 *
 * Requires jquery.deletes.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

(function() {

	var instance = "___eventable",
		publicMethods = ["on", "off", "fire"],
		getEventName = function(name){
			return name.split(".")[0];
		};

	var Eventable = function(mode) {
		this.fnList = {};
		this.events = {};
		this.mode = mode;
	}

	$.extend(
		Eventable.prototype,
		{
			createEvent: function(name) {

				return this.events[name] = $.Callbacks(this.mode);
			},

			on: function(name, fn) {

				if (!name || !$.isFunction(fn)) return this;

				var fnList = this.fnList;

				(fnList[name] || (fnList[name] = [])).push(fn);

				// Translate into base event name
				var basename = getEventName(name);

				// Add the event
				(this.events[basename] || this.createEvent(basename)).add(fn);

				return this;
			},

			off: function(name) {

				if (!name) return this;

				var basename = getEventName(name),
					event = this.events[basename];

				if (!event) return this;

				var removeCallbacks = function(fnList) {

					$.each(fnList, function(i, fn) {
						event.remove(fn);
					});
				}

				if (basename!==name) {

					$.each(this.fnList, function(name, fnList) {

						if (name.indexOf(basename) > -1) {

							removeCallbacks(fnList);
						}
					});

				} else {

					removeCallbacks(this.fnList[name]);
				}

				return this;
			},

			fire: function(name) {

				var event = this.events[name];

				if (!event) return;

				event.fire.apply(event, $.makeArray(arguments).slice(1));

				return this;
			},

			destroy: function() {
				for (name in this.events) {
					this.events[name].disable();
				}
			}
		}
	);

	$.eventable = function(obj, mode) {

		var eventable = obj[instance];

		if (eventable && mode==="destroy") {
			eventable.destroy();
			$.deletes(obj, publicMethods);
			return delete obj[instance];
		}

		eventable = obj[instance] = new Eventable(mode);

		obj.on = $.proxy(eventable.on, eventable);
		obj.off = $.proxy(eventable.off, eventable);
		obj.fire = $.proxy(eventable.fire, eventable);

		return obj;
	}

})();
;/**
 * jquery.fn.checkList.
 * Multiple checkbox handler.
 *
 * $(e).checkList({
 *    check  : function(){},   // callback when an input is checked
 *    uncheck: function(){},   // callback when an input is unchecked
 *
 *    // returns checked elements & unchecked elements in separate arguments
 *    change : function(checked, unchecked){}
 * })
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.fn.checkList = function(options) {

	var defaultOptions = {
		checkbox: ".checkbox",
		masterCheckbox: ".master-checkbox",
		check: function() {},
		uncheck: function() {},
		change: function() {}
	}

	var options = $.extend({}, defaultOptions, options),
		checkList       = this,
		checkboxes      = checkList.find(options.checkbox),
		masterCheckbox  = checkList.find(options.masterCheckbox),
		disableChangeEvent = false;

	var change = function() {

		if (!disableChangeEvent) {

			var checked = checkboxes.filter(':checked'),
				unchecked = checkboxes.not(':checked');

			if (checked.length < 1) {
				masterCheckbox.removeAttr("checked");
			}

			if (checked.length == checkboxes.length) {
				masterCheckbox.prop("checked", true);
			}

			options.change.call(checkList, checked, unchecked);
		}
	}

	checkboxes.checked(

		// checked
		function() {
			options.check.apply(checkList);
			change();
		},

		// unchecked
		function() {
			options.uncheck.apply(checkList);
			change();
		}
	);

	masterCheckbox.checked(

		// checked
		function() {
			disableChangeEvent = true;
			checkboxes.checked(true);
			disableChangeEvent = false;
			change();
		},

		// unchecked
		function() {
			disableChangeEvent = true;
			checkboxes.checked(false);
			disableChangeEvent = false;
			change();
		}
	);

	change();

	return this;
};/**
 * jquery.fn.checked
 * Checked/unchecked event handler for checkbox & radio button.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.fn.checked = function(checked, unchecked) {

	// Return checked value if no arguments are given;
	if (arguments.length < 1)
		return this.is(':checked');

	this.each(function(i) {

		var input = $(this);

		if (typeof checked == "boolean") {
			input.attr('checked', checked).trigger('change');
			return;
		}

		if (input.is('input[type=checkbox]') || input.is('input[type=radio]')) {
			input
				.off('change.checked')
				.on('change.checked', function() {
					try {
						return (input.is(':checked')) ? checked.apply(input) : unchecked.apply(input);
					} catch(e) {};
				});
		}
	});

	return this;
};
;/**
 * jquery.fn.locate
 * Locate a related child element based on data attribute.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.fn.locate = function(key) {

	var prefix = "data";

	$.each(this[0].attributes, function(i, attr){
		if (attr.specified && attr.value==="$") {
			prefix = attr.name;
			return false;
		}
	});

	return this.find("[" + prefix + "-" + key.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase() + "]");
};
;/**
 * jquery.fn.noscroll
 * Disable scrollbar on elements
 * with the ability to restore it.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

(function(){

	var props = ["overflow", "overflow-x", "overflow-y"];

	$.fn.noscroll = function(lock) {

		if (lock===undefined) lock = true;

		return this.each(function(){

			var el = $(this),
				overflow = el.data("noscroll");

			// No original overflow values was stored before
			if (!overflow && lock) {

				// Get the original overflow values
				overflow = {};
				$.each(props, function(i, prop){
					overflow[prop] = el.css(prop);
				});

				// Store original values
				el.data("noscroll", overflow);
			}

			if (lock) {
				$.each(props, function(i, prop){
					el.css(prop, "hidden");
				});
			} else {
				overflow && el.css(overflow);
			}
		});
	};

})();
;/**
* Copyright 2012, Digital Fusion
* Licensed under the MIT license.
* http://teamdf.com/jquery-plugins/license/
*
* @author Sam Sehnert
* @desc A small plugin that checks whether elements are within
* the user visible viewport of a web browser.
* only accounts for vertical position, not horizontal.
*/

$.fn.visible = function(partial) {

	var $t = $(this),
		$w = $(window);

	if ($t.length < 1) return;

	var viewTop      = $w.scrollTop(),
		viewBottom   = viewTop + $w.height(),
		_top         = $t.offset().top,
		_bottom      = _top + $t.height(),
		compareTop    = partial === true ? _bottom : _top,
		compareBottom = partial === true ? _top : _bottom;

	return ((compareBottom <= viewBottom) && (compareTop >= viewTop));
};;/**
 * jquery.fn.where
 * Filter jQuery elements by data attributes.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.fn.where = $.fn.filterBy = function(key, val, operator) {

	var operator = operator || "=",
		selector = "[data-" + key.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase() + operator + "'" + val + "']";

	return this.filter(selector);
};
;/**
 * jquery.formManip
 * Utilities to manipulate form elements.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

// For checkboxes and radio buttons
$.fn.checked = function(checked, unchecked) {

	// Return checked value if no arguments are given;
	if (arguments.length < 1)
		return this.is(':checked');

	this.each(function(i) {

		var input = $(this);

		if (typeof checked == "boolean") {
			input.attr('checked', checked).trigger('change');
			return;
		}

		if (input.is('input[type=checkbox]') || input.is('input[type=radio]')) {
			input
				.off('change.checked')
				.on('change.checked', function() {
					try {
						return (input.is(':checked')) ? checked.apply(input) : unchecked.apply(input);
					} catch(e) {};
				});
		}
	});

	return this;
};

// For select boxes
$.fn.selectAll = function() {
	return this.each(function(){this.select()});
};

$.fn.unselect = function() {
	return this.each(function(){
		var input = this,
			value = input.value;
			input.value += " ";
			input.value = value;
	});
};;/**
 * jquery.formSerializers
 * Serializes form values to Object or JSON.
 * Utilities to manipulate html content.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.fn.toObject = $.fn.serializeObject = function() {

	var obj = {};

	$.each($(this).serializeArray(), function(i, prop) {
		if (obj.hasOwnProperty(prop.name)) {
			// Convert it into an array
			if (!$.isArray(obj[prop.name])) {
				obj[prop.name] = [obj[prop.name]];
			}
			obj[prop.name].push(prop.value);
		} else {
			obj[prop.name] = prop.value;
		}
	});

	return obj;
};

$.fn.toJSON = $.fn.serializeJSON = function() {

	return JSON.stringify($(this).serializeObject());
};
;/**
 * jquery.htmlManip
 * Utilities to manipulate html content.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.sanitizeHTML = function(html) {
	return $($.parseHTML(html, document, true)).toHTML();
};

// This also encodes html entities.
$.toHTML = function(str) {
	return $("<div>").html(str).html();
};

$.fn.toHTML = function() {
	return $.toHTML(this.clone());
};

// Based on http://stackoverflow.com/questions/1231770/innerhtml-removes-attribute-quotes-in-internet-explorer
$.toXHTML = function(obj, maintainUppercaseTag) {

	var zz = obj.innerHTML ? String(obj.innerHTML) : obj,
		z  = zz.match(/(<.+[^>])/g);

	if (z) {
		for (var i=0; i<z.length; (i=i+1)) {

			var y,
				zSaved = z[i],
				attrRE = /\=[a-zA-Z\.\:\[\]_\(\)\&\$\%#\@\!0-9\/]+[?\s+|?>]/g;

			z[i] =
				z[i].replace(/([<|<\/].+?\w+).+[^>]/, function(a){
					return a;
				});

			y = z[i].match(attrRE);

			if (y) {
				var j = 0,
					len = y.length;

				while (j < len) {

					var replaceRE = /(\=)([a-zA-Z\.\:\[\]_\(\)\&\$\%#\@\!0-9\/]+)?([\s+|?>])/g,
						replacer = function() {
							var args = Array.prototype.slice.call(arguments);
							return '="' + (maintainUppercaseTag ? args[2] : args[2].toLowerCase()) + '"' + args[3];
						};

					z[i] = z[i].replace(y[j], y[j].replace(replaceRE,replacer));
					j += 1;
				}
			}

			zz = zz.replace(zSaved,z[i]);
		}
	}

	return zz;
};

$.fn.xhtml = function() {
	return $.IE ? $.toXHTML(this[0]) : this.html();
};

/**
 * jquery.buildHTML
 * Converts html string into jQuery element where
 * script tags within it gets removed after it is
 * inserted into the DOM.
 *
 * Using $.buildHTML(html) over $(html) also circumvents
 * CloudFlare from modifying the execution behaviour of
 * script elements.
 */

$.buildHTML = function(html, keepScripts) {

	// If a jquery element was passed in, return as it is.
	if (html instanceof $) return html;

	var doc = document;

	// If CloudFlare exists, use document from iframe
	// because CloudFlare Rocketscript overrides native methods.
	if (window["CloudFlare"]) {

		var iframe = $.buildHTML.iframe;

		// If iframe wasn't created, or iframe was removed or detached,
		// create the iframe element again;
		if (!iframe || !iframe.contentDocument) {

			// Create iframe
			var iframe =
				$.buildHTML.iframe =
				document.createElement("iframe");

			// Hide iframe
			iframe.style.display = "none";

			// Append iframe to body
			document.body.appendChild(iframe);
		}

		doc = iframe.contentDocument;
	}

	// Trim out any whitespace so no unusable text nodes are introduced.
	var html = $.trim(html),

		// Build html fragment while keeping a separate reference to the script
		scripts = [],
		fragment = $.buildFragment([html], doc, scripts),

		// Convert childNodes into a proper array
		nodes = $.merge([], fragment.childNodes);

	// If we want to remove the script after
	// it is appended to the DOM & executed
	if (!keepScripts && scripts.length > 0) {

		// Create script remover
		var script = doc.createElement("script");
			// This is wrapped in try..catch because Cloudflare's
			// proxy node executes this twice for some reason.
			// The second time this executes, the callback has been removed,
			// so let it fail silently.
			script.text = "try{" + $.callback(function(){$(scripts).remove();}) + "();}catch(e){}";

		// Go through nodes in reverse
		var i = nodes.length-1, node, inserted;

		while (node = nodes[i--]) {

			// If a script node is found first, we'll just append
			// script remover next to it to ensure this last script
			// executes before any script removal happens.
			if (node.nodeName==="SCRIPT") {
				inserted = nodes.push(script);
			} else if (node.nodeType===1) {
				inserted = node.appendChild(script);
			}

			if (inserted) break;
		}

		// If script remover was not inserted,
		// then just add it to the array of nodes
		if (!inserted) nodes.push(script);

		// Add script remover itself to the
		// array of scripts to be removed.
		scripts.push(script);
	}

	// Convert nodes into jquery instance and return
	return $(nodes);
};;/**
 * jquery.intersects
 * jquery.fn.intersectsWith
 *
 * Determines if an area intersects with another area.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.intersects = function(a, b) {

	if ($.isArray(b)) {
	   b = {top: b.y, left: b.x, bottom: b.y, right: b.x}
	}

	return (
	   b.left <= a.right  &&
	   a.left <= b.right  &&
	   b.top  <= a.bottom &&
	   a.top  <= b.bottom
	);
};

$.fn.intersectsWith = function(top, left, width, height) {

	// TODO: intersectsWith(element)

	var offset = this.offset(),

	   reference = {
			top   : offset.top,
			left  : offset.left,
			bottom: offset.top  + (sourceHeight = this.height()),
			right : offset.left + (sourceWidth  = this.width()),
			width : sourceWidth,
			height: sourceHeight
	   },

	   subject = {
			top   : top,
			left  : left,
			bottom: top  + (height || (height = 0)),
			right : left + (width  || (width  = 0)),
			width : width,
			height: height
	   };

	return ($.intersects(reference, subject)) ? {reference: reference, subject: subject} : false;
};;/**
 * jquery.isDeferred
 * Test if an object is a jQuery Deferred object.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.isDeferred = function(obj) {
	return obj && $.isFunction(obj.always);
};
;/**
 * jquery.number
 * Utilities to deal with numbers.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.isNumeric = function(n) {
	// http://stackoverflow.com/questions/18082/validate-numbers-in-javascript-isnumeric
	return !isNaN(parseFloat(n)) && isFinite(n);
};

$.rotateNumber = function(n, min, max, offset) {

	if (offset===undefined) {
		offset = 0;
	}

	n += offset;

	if (n < min) {
		n += max + 1;
	} else if (n > max) {
		n -= max + 1;
	}

	return n;
};;/**
 * jquery.regExpEscape
 * Makes string regex safe.
 * http://stackoverflow.com/questions/2593637/how-to-escape-regular-expression-in-javascript
 */

$.regExpEscape = function(str) {
	return str.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
}
;/**
 * jquery.remap
 * Utility for remapping properties of an object selectively from another object.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.remap = function(to, from, props) {
	$.each(props, function(i, prop){
		to[prop] = from[prop];
	});
	return obj;
};
;/**
 * jquery.throttledAjax
 * jQuery AJAX with throttling.
 *
 * Requires jquery.Threads.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

(function(){

var self = $.Ajax = function(options) {

	// Start ajax manually
	options.autostart = false;

	var ajax = $.ajax(options);

	if ('function' == typeof ajax.send) {
		self.queue
			.addDeferred(function(queue){

				// Start ajax now
				ajax.send();

				// Mark this queue as resolved
				setTimeout(queue.resolve, self.interval);
			});
	}

	return ajax;
}

self.queue    = $.Threads({threadLimit: 1});
self.interval = 1200;

self.interval = 0;

})();

/*!
 * jquery.transitionClass.
 * jQuery functions to invoke classnames that has CSS3 transitions.
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://www.jstonne.com
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

(function(){

// addTransitoryClass
$.fn.addTransitoryClass = function(classname, duration) {
	var elem = this.addClass(classname);
	setTimeout(function(){elem.removeClass(classname)}, duration || 1);
	return this;
};

// addClassAfter
// removeClassAfter
var classAfter = function(operation, classname, timer) {
	var elem = this;
	setTimeout(function(){elem[operation+"Class"](classname)}, timer || 50);
	return this;
};

$.fn.addClassAfter = function(classname, timer) {
	return classAfter.call(this, "add", classname, timer);
};

$.fn.removeClassAfter = function(classname, timer) {
	return classAfter.call(this, "remove", classname, timer);
};

// addTransitionClass
// removeTransitionClass
var transitionClass = function(toggle, classname, duration, callback) {
	var suffix = toggle ? "-in" : "-out";
	this.addTransitoryClass(classname.replace(/ /g, suffix + " ") + suffix, duration || 1000)
		[(toggle ? "add" : "remove") + "ClassAfter"](classname);
	callback && setTimeout(callback, duration);
	return this;
};

$.fn.addTransitionClass = function(classname, duration, callback) {
	return transitionClass.call(this, true, classname, duration, callback);
};

$.fn.removeTransitionClass = function(classname, duration, callback) {
	return transitionClass.call(this, false, classname, duration, callback);
};

})();;/**
 * jquery.trimSeparators
 * Trims whitespace and separators.
 *
 * Turns this: ",df        ,,,  ,,,abc, sdasd sdfsdf    ,   asdsad, ,, , "
 * into this : "df,abc,sdasd sdfsdf,asdsad"
 *
 * Requires jquery.distinct
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.trimSeparators = function(keyword, separator, removeDuplicates) {

	var s = separator;

	keyword = keyword
		.replace(new RegExp('^['+s+'\\s]+|['+s+',\\s]+$','g'), '') // /^[,\s]+|[,\s]+$/g
		.replace(new RegExp(s+'['+s+'\\s]*'+s,'g'), s)             // /,[,\s]*,/g
		.replace(new RegExp('[\\s]+'+s,'g'), s)                    // /[\s]+,/g
		.replace(new RegExp(s+'[\\s]+','g'), s);                   // /,[\s]+/g

	if (removeDuplicates) {
		keyword = $.distinct(keyword.split(s)).join(s);
	}

	return keyword;
};
;/**
 * jquery.uid
 * Generates a unique id with optional prefix/suffix.
 *
 * Part of the jQuery Utils family:
 * https://github.com/jstonne/jquery.utils
 *
 * Copyright (c) 2014 Jensen Tonne
 * http://jstonne.me
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.uid = function(p,s) {
	return ((p) ? p : '') + Math.random().toString().replace('.','') + ((s) ? s : '');
};

});
FD40.plugin("uri", function($) {

$.isUrl = function(s)
{
	var regexp = /^(http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?/;
	return regexp.test(s);
};


var Query = function (queryString) {

    // query string parsing, parameter manipulation and stringification

    'use strict';

    var // parseQuery(q) parses the uri query string and returns a multi-dimensional array of the components
        parseQuery = function (q) {
            var arr = [], i, ps, p, kvp, k, v;

            if (typeof (q) === 'undefined' || q === null || q === '') {
                return arr;
            }

            if (q.indexOf('?') === 0) {
                q = q.substring(1);
            }

            ps = q.toString().split(/[&;]/);

            for (i = 0; i < ps.length; i++) {
                p = ps[i];
                kvp = p.split('=');
                k = kvp[0];
                v = p.indexOf('=') === -1 ? null : (kvp[1] === null ? '' : kvp[1]);
                arr.push([k, v]);
            }

            return arr;
        },

        params = parseQuery(queryString),

        // toString() returns a string representation of the internal state of the object
        toString = function () {
            var s = '', i, param;
            for (i = 0; i < params.length; i++) {
                param = params[i];
                if (s.length > 0) {
                    s += '&';
                }
                if (param[1] === null) {
                  s += param[0];
                }
                else {
                  s += param.join('=');
                }
            }
            return s.length > 0 ? '?' + s : s;
        },

        decode = function (s) {
            s = decodeURIComponent(s);
            s = s.replace('+', ' ');
            return s;
        },

        // getParamValues(key) returns the first query param value found for the key 'key'
        getParamValue = function (key) {
            var param, i;
            for (i = 0; i < params.length; i++) {
                param = params[i];
                if (decode(key) === decode(param[0])) {
                    return param[1];
                }
            }
        },

        // getParamValues(key) returns an array of query param values for the key 'key'
        getParamValues = function (key) {
            var arr = [], i, param;
            for (i = 0; i < params.length; i++) {
                param = params[i];
                if (decode(key) === decode(param[0])) {
                    arr.push(param[1]);
                }
            }
            return arr;
        },

        // deleteParam(key) removes all instances of parameters named (key)
        // deleteParam(key, val) removes all instances where the value matches (val)
        deleteParam = function (key, val) {

            var arr = [], i, param, keyMatchesFilter, valMatchesFilter;

            for (i = 0; i < params.length; i++) {

                param = params[i];
                keyMatchesFilter = decode(param[0]) === decode(key);
                valMatchesFilter = decode(param[1]) === decode(val);

                if ((arguments.length === 1 && !keyMatchesFilter) || (arguments.length === 2 && !keyMatchesFilter && !valMatchesFilter)) {
                    arr.push(param);
                }
            }

            params = arr;

            return this;
        },

        // addParam(key, val) Adds an element to the end of the list of query parameters
        // addParam(key, val, index) adds the param at the specified position (index)
        addParam = function (key, val, index) {

            if (arguments.length === 3 && index !== -1) {
                index = Math.min(index, params.length);
                params.splice(index, 0, [key, val]);
            } else if (arguments.length > 0) {
                params.push([key, val]);
            }
            return this;
        },

        // replaceParam(key, newVal) deletes all instances of params named (key) and replaces them with the new single value
        // replaceParam(key, newVal, oldVal) deletes only instances of params named (key) with the value (val) and replaces them with the new single value
        // this function attempts to preserve query param ordering
        replaceParam = function (key, newVal, oldVal) {

            var index = -1, i, param;

            if (arguments.length === 3) {
                for (i = 0; i < params.length; i++) {
                    param = params[i];
                    if (decode(param[0]) === decode(key) && decodeURIComponent(param[1]) === decode(oldVal)) {
                        index = i;
                        break;
                    }
                }
                deleteParam(key, oldVal).addParam(key, newVal, index);
            } else {
                for (i = 0; i < params.length; i++) {
                    param = params[i];
                    if (decode(param[0]) === decode(key)) {
                        index = i;
                        break;
                    }
                }
                deleteParam(key);
                addParam(key, newVal, index);
            }
            return this;
        };

    // public api
    return {
        getParamValue: getParamValue,
        getParamValues: getParamValues,
        deleteParam: deleteParam,
        addParam: addParam,
        replaceParam: replaceParam,

        toString: toString
    };
};
var Uri = function (uriString) {

    // uri string parsing, attribute manipulation and stringification

    'use strict';

    /*global Query: true */
    /*jslint regexp: false, plusplus: false */

    var strictMode = false,

        urlExtractor = /[-a-zA-Z0-9@:%_\+.~#?&//=]{2,256}\.[a-z]{2,4}\b(\/[-a-zA-Z0-9@:%_\+.~#?&\/\/=]*)?/gi,

        // parseUri(str) parses the supplied uri and returns an object containing its components
        parseUri = function (str) {

            /*jslint unparam: true */
            var parsers = {
                    strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
                    loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
                },
                keys = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"],
                q = {
                    name: "queryKey",
                    parser: /(?:^|&)([^&=]*)=?([^&]*)/g
                },
                m = parsers[strictMode ? "strict" : "loose"].exec(str),
                uri = {},
                i = 14;

            while (i--) {
                uri[keys[i]] = m[i] || "";
            }

            uri[q.name] = {};
            uri[keys[12]].replace(q.parser, function ($0, $1, $2) {
                if ($1) {
                    uri[q.name][$1] = $2;
                }
            });

            return uri;
        },

        uriParts = parseUri(uriString || ''),

        queryObj = new Query(uriParts.query),


        /*
            Basic get/set functions for all properties
        */

        protocol = function (val) {
            if (typeof val !== 'undefined') {
                uriParts.protocol = val;
            }
            return uriParts.protocol;
        },

        hasAuthorityPrefixUserPref = null,

        // hasAuthorityPrefix: if there is no protocol, the leading // can be enabled or disabled
        hasAuthorityPrefix = function (val) {

            if (typeof val !== 'undefined') {
                hasAuthorityPrefixUserPref = val;
            }

            if (hasAuthorityPrefixUserPref === null) {
                return (uriParts.source.indexOf('//') !== -1);
            } else {
                return hasAuthorityPrefixUserPref;
            }
        },

        userInfo = function (val) {
            if (typeof val !== 'undefined') {
                uriParts.userInfo = val;
            }
            return uriParts.userInfo;
        },

        host = function (val) {
            if (typeof val !== 'undefined') {
                uriParts.host = val;
            }
            return uriParts.host;
        },

        port = function (val) {
            if (typeof val !== 'undefined') {
                uriParts.port = val;
            }
            return uriParts.port;
        },

        path = function (val) {
            if (typeof val !== 'undefined') {
                uriParts.path = val;
            }
            return uriParts.path;
        },

        query = function (val) {
            if (typeof val !== 'undefined') {
                queryObj = new Query(val);
            }
            return queryObj;
        },

        anchor = function (val) {
            if (typeof val !== 'undefined') {
                uriParts.anchor = val;
            }
            return uriParts.anchor;
        },


        /*
            Fluent setters for Uri uri properties
        */

        setProtocol = function (val) {
            protocol(val);
            return this;
        },

        setHasAuthorityPrefix = function (val) {
            hasAuthorityPrefix(val);
            return this;
        },

        setUserInfo = function (val) {
            userInfo(val);
            return this;
        },

        setHost = function (val) {
            host(val);
            return this;
        },

        setPort = function (val) {
            port(val);
            return this;
        },

        setPath = function (val) {
            path(val);
            return this;
        },

        setQuery = function (val) {
            query(val);
            return this;
        },

        setAnchor = function (val) {
            anchor(val);
            return this;
        },

        /*
            Query method wrappers
        */
        getQueryParamValue = function (key) {
            return query().getParamValue(key);
        },

        getQueryParamValues = function (key) {
            return query().getParamValues(key);
        },

        deleteQueryParam = function (key, val) {
            if (arguments.length === 2) {
                query().deleteParam(key, val);
            } else {
                query().deleteParam(key);
            }

            return this;
        },

        addQueryParam = function (key, val, index) {
            if (arguments.length === 3) {
                query().addParam(key, val, index);
            } else {
                query().addParam(key, val);
            }
            return this;
        },

        replaceQueryParam = function (key, newVal, oldVal) {
            if (arguments.length === 3) {
                query().replaceParam(key, newVal, oldVal);
            } else {
                query().replaceParam(key, newVal);
            }

            return this;
        },

        /*
            Converters
        */

        // toPath() converts a relative path into its absolute path, e.g.
        //
        // Current path:  /foo/bar/today
        // Relative path: ../tomorrow
        // Result:        /foo/bar/tomorrow

        toPath = function (val) {
            if (val===undefined) {
                return uriParts.path;
            }

            // If relative path starts with '/'
            if (val.substring(0,1)=='/') {
                return uriParts.path = val;
            }

            var base_path = uriParts.path.split('/'),
                rel_path = val.split('/');

            if (base_path.slice(-1)[0]==='') {
                base_path.pop();
            }

            var part;
            while (part = rel_path.shift()) {
                switch (part) {
                    case '..':
                        if (base_path.length > 1) {
                            base_path.pop();
                        }
                        break;

                    case '.':
                        // skip
                        break;

                    default:
                        base_path.push(part);
                }
            }

            uriParts.path = base_path.join('/');

            return this;
        },

        /*
            Serialization
        */

        // toString() stringifies the current state of the uri
        toString = function () {

            var s = '',
                is = function (s) {
                    return (s !== null && s !== '');
                };

            if (is(protocol())) {
                s += protocol();
                if (protocol().indexOf(':') !== protocol().length - 1) {
                    s += ':';
                }
                s += '//';
            } else {
                if (hasAuthorityPrefix() && is(host())) {
                    s += '//';
                }
            }

            if (is(userInfo()) && is(host())) {
                s += userInfo();
                if (userInfo().indexOf('@') !== userInfo().length - 1) {
                    s += '@';
                }
            }

            if (is(host())) {
                s += host();
                if (is(port())) {
                    s += ':' + port();
                }
            }

            if (is(path())) {
                s += path();
            } else {
                if (is(host()) && (is(query().toString()) || is(anchor()))) {
                    s += '/';
                }
            }
            if (is(query().toString())) {
                if (query().toString().indexOf('?') !== 0) {
                    s += '?';
                }
                s += query().toString();
            }

            if (is(anchor())) {
                if (anchor().indexOf('#') !== 0) {
                    s += '#';
                }
                s += anchor();
            }

            return s;
        },

        extract = function(i) {
            var urls = uriString.match(urlExtractor) || [];
            return (i===undefined) ? urls : (urls[i] || "");
        },

        /*
            Cloning
        */

        // clone() returns a new, identical Uri instance
        clone = function () {
            return new Uri(toString());
        };

    // public api
    return {

        protocol: protocol,
        hasAuthorityPrefix: hasAuthorityPrefix,
        userInfo: userInfo,
        host: host,
        port: port,
        path: path,
        query: query,
        anchor: anchor,

        setProtocol: setProtocol,
        setHasAuthorityPrefix: setHasAuthorityPrefix,
        setUserInfo: setUserInfo,
        setHost: setHost,
        setPort: setPort,
        setPath: setPath,
        setQuery: setQuery,
        setAnchor: setAnchor,

        getQueryParamValue: getQueryParamValue,
        getQueryParamValues: getQueryParamValues,
        deleteQueryParam: deleteQueryParam,
        addQueryParam: addQueryParam,
        replaceQueryParam: replaceQueryParam,
        extract: extract,

        toPath: toPath,

        toString: toString,
        clone: clone
    };
};
$.uri = function (s) {
    return new Uri(s);
}

});FD40.plugin("mvc", function($) {

(function(){
    // Several of the methods in this plugin use code adapated from Prototype
    //  Prototype JavaScript framework, version 1.6.0.1
    //  (c) 2005-2007 Sam Stephenson
    var regs = {
        undHash: /_|-/,
        colons: /::/,
        words: /([A-Z]+)([A-Z][a-z])/g,
        lowUp: /([a-z\d])([A-Z])/g,
        dash: /([a-z\d])([A-Z])/g,
        replacer: /\{([^\}]+)\}/g,
        dot: /\./
    },
        // gets the nextPart property from current
        // add - if true and nextPart doesnt exist, create it as an empty object
        getNext = function(current, nextPart, add){
            return current[nextPart] !== undefined ? current[nextPart] : ( add && (current[nextPart] = {}) );
        },
        // returns true if the object can have properties (no nulls)
        isContainer = function(current){
            var type = typeof current;
            return current && ( type == 'function' || type == 'object' );
        },
        // a reference
        getObject,
        /**
         * @class jQuery.String
         * @parent jquerymx.lang
         *
         * A collection of useful string helpers. Available helpers are:
         * <ul>
         *   <li>[jQuery.String.capitalize|capitalize]: Capitalizes a string (some_string &raquo; Some_string)</li>
         *   <li>[jQuery.String.camelize|camelize]: Capitalizes a string from something undercored
         *       (some_string &raquo; someString, some-string &raquo; someString)</li>
         *   <li>[jQuery.String.classize|classize]: Like [jQuery.String.camelize|camelize],
         *       but the first part is also capitalized (some_string &raquo; SomeString)</li>
         *   <li>[jQuery.String.niceName|niceName]: Like [jQuery.String.classize|classize], but a space separates each 'word' (some_string &raquo; Some String)</li>
         *   <li>[jQuery.String.underscore|underscore]: Underscores a string (SomeString &raquo; some_string)</li>
         *   <li>[jQuery.String.sub|sub]: Returns a string with {param} replaced values from data.
         *       <code><pre>
         *       $.String.sub("foo {bar}",{bar: "far"})
         *       //-> "foo far"</pre></code>
         *   </li>
         * </ul>
         *
         */

        str = $.String = $.extend($.String || {} , {


            /**
             * @function getObject
             * Gets an object from a string.  It can also modify objects on the
             * 'object path' by removing or adding properties.
             *
             *     Foo = {Bar: {Zar: {"Ted"}}}
             *     $.String.getObject("Foo.Bar.Zar") //-> "Ted"
             *
             * @param {String} name the name of the object to look for
             * @param {Array} [roots] an array of root objects to look for the
             *   name.  If roots is not provided, the window is used.
             * @param {Boolean} [add] true to add missing objects to
             *  the path. false to remove found properties. undefined to
             *  not modify the root object
             * @return {Object} The object.
             */
            getObject : getObject = function( name, roots, add ) {

                // the parts of the name we are looking up
                // ['App','Models','Recipe']
                var parts = name ? name.split(regs.dot) : [],
                    length =  parts.length,
                    current,
                    ret,
                    i,
                    r = 0,
                    type;

                // make sure roots is an array
                roots = $.isArray(roots) ? roots : [roots || window];

                if(length == 0){
                    return roots[0];
                }
                // for each root, mark it as current
                while( current = roots[r++] ) {
                    // walk current to the 2nd to last object
                    // or until there is not a container
                    for (i =0; i < length - 1 && isContainer(current); i++ ) {
                        current = getNext(current, parts[i], add);
                    }
                    // if we can get a property from the 2nd to last object
                    if( isContainer(current) ) {

                        // get (and possibly set) the property
                        ret = getNext(current, parts[i], add);

                        // if there is a value, we exit
                        if( ret !== undefined ) {
                            // if add is false, delete the property
                            if ( add === false ) {
                                delete current[parts[i]];
                            }
                            return ret;

                        }
                    }
                }
            },
            /**
             * Capitalizes a string
             * @param {String} s the string.
             * @return {String} a string with the first character capitalized.
             */
            capitalize: function( s, cache ) {
                return s.charAt(0).toUpperCase() + s.substr(1);
            },
            /**
             * Capitalizes a string from something undercored. Examples:
             * @codestart
             * jQuery.String.camelize("one_two") //-> "oneTwo"
             * "three-four".camelize() //-> threeFour
             * @codeend
             * @param {String} s
             * @return {String} a the camelized string
             */
            camelize: function( s ) {
                s = str.classize(s);
                return s.charAt(0).toLowerCase() + s.substr(1);
            },
            /**
             * Like [jQuery.String.camelize|camelize], but the first part is also capitalized
             * @param {String} s
             * @return {String} the classized string
             */
            classize: function( s , join) {
                var parts = s.split(regs.undHash),
                    i = 0;
                for (; i < parts.length; i++ ) {
                    parts[i] = str.capitalize(parts[i]);
                }

                return parts.join(join || '');
            },
            /**
             * Like [jQuery.String.classize|classize], but a space separates each 'word'
             * @codestart
             * jQuery.String.niceName("one_two") //-> "One Two"
             * @codeend
             * @param {String} s
             * @return {String} the niceName
             */
            niceName: function( s ) {
                return str.classize(s,' ');
            },

            /**
             * Underscores a string.
             * @codestart
             * jQuery.String.underscore("OneTwo") //-> "one_two"
             * @codeend
             * @param {String} s
             * @return {String} the underscored string
             */
            underscore: function( s ) {
                return s.replace(regs.colons, '/').replace(regs.words, '$1_$2').replace(regs.lowUp, '$1_$2').replace(regs.dash, '_').toLowerCase();
            },
            /**
             * Returns a string with {param} replaced values from data.
             *
             *     $.String.sub("foo {bar}",{bar: "far"})
             *     //-> "foo far"
             *
             * @param {String} s The string to replace
             * @param {Object} data The data to be used to look for properties.  If it's an array, multiple
             * objects can be used.
             * @param {Boolean} [remove] if a match is found, remove the property from the object
             */
            sub: function( s, data, remove ) {
                var obs = [];
                obs.push(s.replace(regs.replacer, function( whole, inside ) {

                    // !-- FOUNDRY HACK --! //
                    // Prefer {foobar} over foobar

                    //convert inside to type
                    var ob = getObject(whole, data, typeof remove == 'boolean' ? !remove : remove) ||
                             getObject(inside, data, typeof remove == 'boolean' ? !remove : remove),
                        type = typeof ob;

                    if ((type === 'object' || type === 'function') && type !== null) {
                        obs.push(ob);
                        return "";
                    } else {
                        return ""+ob;
                    }
                }));
                return obs.length <= 1 ? obs[0] : obs;
            },
            _regs : regs
        });

    // !-- FOUNDRY HACK --! //
    // Expose string methods to $.
    $.extend($, str);
})();(function(){
    /**
     * @add jQuery.String
     */
    $.String.
    /**
     * Splits a string with a regex correctly cross browser
     * 
     *     $.String.rsplit("a.b.c.d", /\./) //-> ['a','b','c','d']
     * 
     * @param {String} string The string to split
     * @param {RegExp} regex A regular expression
     * @return {Array} An array of strings
     */
    rsplit = function( string, regex ) {
        var result = regex.exec(string),
            retArr = [],
            first_idx, last_idx;
        while ( result !== null ) {
            first_idx = result.index;
            last_idx = regex.lastIndex;
            if ( first_idx !== 0 ) {
                retArr.push(string.substring(0, first_idx));
                string = string.slice(first_idx);
            }
            retArr.push(result[0]);
            string = string.slice(result[0].length);
            result = regex.exec(string);
        }
        if ( string !== '' ) {
            retArr.push(string);
        }
        return retArr;
    };
})();(function(){
    
    var digitTest = /^\d+$/,
        keyBreaker = /([^\[\]]+)|(\[\])/g,
        plus = /\+/g,
        paramTest = /([^?#]*)(#.*)?$/;
    
    /**
     * @add jQuery.String
     */
    $.String = $.extend($.String || {}, { 
        
        /**
         * @function deparam
         * 
         * Takes a string of name value pairs and returns a Object literal that represents those params.
         * 
         * @param {String} params a string like <code>"foo=bar&person[age]=3"</code>
         * @return {Object} A JavaScript Object that represents the params:
         * 
         *     {
         *       foo: "bar",
         *       person: {
         *         age: "3"
         *       }
         *     }
         */
        deparam: function(params){
        
            if(! params || ! paramTest.test(params) ) {
                return {};
            } 
           
        
            var data = {},
                pairs = params.split('&'),
                current;
                
            for(var i=0; i < pairs.length; i++){
                current = data;
                var pair = pairs[i].split('=');
                
                // if we find foo=1+1=2
                if(pair.length != 2) { 
                    pair = [pair[0], pair.slice(1).join("=")]
                }
                  
        var key = decodeURIComponent(pair[0].replace(plus, " ")), 
          value = decodeURIComponent(pair[1].replace(plus, " ")),
                    parts = key.match(keyBreaker);
        
                for ( var j = 0; j < parts.length - 1; j++ ) {
                    var part = parts[j];
                    if (!current[part] ) {
                        // if what we are pointing to looks like an array
                        current[part] = digitTest.test(parts[j+1]) || parts[j+1] == "[]" ? [] : {}
                    }
                    current = current[part];
                }
                lastPart = parts[parts.length - 1];
                if(lastPart == "[]"){
                    current.push(value)
                }else{
                    current[lastPart] = value;
                }
            }
            return data;
        }
    });
    
})();(function(){
    /**
     * @attribute destroyed
     * @parent specialevents
     * @download  http://jmvcsite.heroku.com/pluginify?plugins[]=jquery/dom/destroyed/destroyed.js
     * @test jquery/event/destroyed/qunit.html
     * Provides a destroyed event on an element.
     * <p>
     * The destroyed event is called when the element
     * is removed as a result of jQuery DOM manipulators like remove, html,
     * replaceWith, etc. Destroyed events do not bubble, so make sure you don't use live or delegate with destroyed
     * events.
     * </p>
     * <h2>Quick Example</h2>
     * @codestart
     * $(".foo").bind("destroyed", function(){
     *    //clean up code
     * })
     * @codeend
     * <h2>Quick Demo</h2>
     * @demo jquery/event/destroyed/destroyed.html
     * <h2>More Involved Demo</h2>
     * @demo jquery/event/destroyed/destroyed_menu.html
     */

    var oldClean = $.cleanData;

    $.cleanData = function( elems ) {
        for ( var i = 0, elem;
        (elem = elems[i]) !== undefined; i++ ) {
            $(elem).triggerHandler("destroyed");
            //$.event.remove( elem, 'destroyed' );
        }
        oldClean(elems);
    };

})();(function(){
    /**
     * @function closest
     * @parent dom
     * @plugin jquery/dom/closest
     * Overwrites closest to allow open > selectors.  This allows controller
     * actions such as:
     *
     *     ">li click" : function( el, ev ) { ... }
     */
    var oldClosest = $.fn._closest = $.fn.closest;
    $.fn.closest = function(selectors, context){

        // FOUNDRY_HACK
        // If a jQuery or node element was passed in, use original closest method.
        if (selectors instanceof $ || $.isElement(selectors)) {
            return oldClosest.call(this, arguments);
        }

        var rooted = {}, res, result, thing, i, j, selector, rootedIsEmpty = true, selector, selectorsArr = selectors;
        if(typeof selectors == "string") selectorsArr = [selectors];

        $.each(selectorsArr, function(i, selector){
            if(selector.indexOf(">") == 0 ){
                if(selector.indexOf(" ") != -1){
                    throw " closest does not work with > followed by spaces!"
                }
                rooted[( selectorsArr[i] = selector.substr(1)  )] = selector;
                if(typeof selectors == "string") selectors = selector.substr(1);
                rootedIsEmpty = false;
            }
        })

        res = oldClosest.call(this, selectors, context);

        if(rootedIsEmpty) return res;
        i =0;
        while(i < res.length){
            result = res[i], selector = result.selector;
            if (rooted[selector] !== undefined) {
                result.selector = rooted[selector];
                rooted[selector] = false;
                if(typeof result.selector !== "string"  || result.elem.parentNode !== context ){
                    res.splice(i,1);
                        continue;
                }
            }
            i++;
        }
        return res;
    }
})();(function(){
    // break
    /**
     * @function jQuery.cookie
     * @parent dom
     * @plugin jquery/dom/cookie
     * @author Klaus Hartl/klaus.hartl@stilbuero.de
     *
     *  JavaScriptMVC's packaged cookie plugin is written by
     *  Klaus Hartl (stilbuero.de)<br />
     *  Dual licensed under the MIT and GPL licenses:<br />
     *  http://www.opensource.org/licenses/mit-license.php<br />
     *  http://www.gnu.org/licenses/gpl.html
     *  </p>
     *  <p>
     *  Create a cookie with the given name and value and other optional parameters.
     *  / Get the value of a cookie with the given name.
     *  </p>
     *  <h3>Quick Examples</h3>
     *
     *  Set the value of a cookie.
     *
     *     $.cookie('the_cookie', 'the_value');
     *
     *  Create a cookie with all available options.
     *  @codestart
     *  $.cookie('the_cookie', 'the_value',
     *  { expires: 7, path: '/', domain: 'jquery.com', secure: true });
     *  @codeend
     *
     *  Create a session cookie.
     *  @codestart
     *  $.cookie('the_cookie', 'the_value');
     *  @codeend
     *
     *  Delete a cookie by passing null as value. Keep in mind that you have to use the same path and domain
     *  used when the cookie was set.
     *  @codestart
     *  $.cookie('the_cookie', null);
     *  @codeend
     *
     *  Get the value of a cookie.
     *  @codestart
     *  $.cookie('the_cookie');
     *  @codeend
     *
     *
     * @param {String} [name] The name of the cookie.
     * @param {String} [value] The value of the cookie.
     * @param {Object} [options] An object literal containing key/value pairs to provide optional cookie attributes.<br />
     * @param {Number|Date} [expires] Either an integer specifying the expiration date from now on in days or a Date object.
     *                             If a negative value is specified (e.g. a date in the past), the cookie will be deleted.
     *                             If set to null or omitted, the cookie will be a session cookie and will not be retained
     *                             when the the browser exits.<br />
     * @param {String} [path] The value of the path atribute of the cookie (default: path of page that created the cookie).<br />
     * @param {String} [domain] The value of the domain attribute of the cookie (default: domain of page that created the cookie).<br />
     * @param {Boolean} secure If true, the secure attribute of the cookie will be set and the cookie transmission will
     *                        require a secure protocol (like HTTPS).<br />
     * @return {String} the value of the cookie or {undefined} when setting the cookie.
     */
    $.cookie = function(name, value, options) {
        if (typeof value != 'undefined') { // name and value given, set cookie
            options = options ||
            {};
            if (value === null) {
                value = '';
                options.expires = -1;
            }
            if (typeof value == 'object' && jQuery.toJSON) {
                value = jQuery.toJSON(value);
            }
            var expires = '';
            if (options.expires && (typeof options.expires == 'number' || options.expires.toUTCString)) {
                var date;
                if (typeof options.expires == 'number') {
                    date = new Date();
                    date.setTime(date.getTime() + (options.expires * 24 * 60 * 60 * 1000));
                }
                else {
                    date = options.expires;
                }
                expires = '; expires=' + date.toUTCString(); // use expires attribute, max-age is not supported by IE
            }
            // CAUTION: Needed to parenthesize options.path and options.domain
            // in the following expressions, otherwise they evaluate to undefined
            // in the packed version for some reason...
            var path = options.path ? '; path=' + (options.path) : '';
            var domain = options.domain ? '; domain=' + (options.domain) : '';
            var secure = options.secure ? '; secure' : '';
            document.cookie = [name, '=', encodeURIComponent(value), expires, path, domain, secure].join('');
        }
        else { // only name given, get cookie
            var cookieValue = null;
            if (document.cookie && document.cookie != '') {
                var cookies = document.cookie.split(';');
                for (var i = 0; i < cookies.length; i++) {
                    var cookie = jQuery.trim(cookies[i]);
                    // Does this cookie string begin with the name we want?
                    if (cookie.substring(0, name.length + 1) == (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            if (jQuery.evalJSON && cookieValue && cookieValue.match(/^\s*\{/)) {
                try {
                    cookieValue = jQuery.evalJSON(cookieValue);
                }
                catch (e) {
                }
            }
            return cookieValue;
        }
    };

})();(function(){

    // =============== HELPERS =================

        // if we are initializing a new class
    var initializing = false,
        makeArray = $.makeArray,
        isFunction = $.isFunction,
        isArray = $.isArray,
        extend = $.extend,
        getObject = $.String.getObject,
        concatArgs = function(arr, args){
            return arr.concat(makeArray(args));
        },

        // tests if we can get super in .toString()
        fnTest = /xyz/.test(function() {
            xyz;
        }) ? /\b_super\b/ : /.*/,

        // overwrites an object with methods, sets up _super
        //   newProps - new properties
        //   oldProps - where the old properties might be
        //   addTo - what we are adding to
        inheritProps = function( newProps, oldProps, addTo ) {
            addTo = addTo || newProps
            for ( var name in newProps ) {
                // Check if we're overwriting an existing function
                addTo[name] = isFunction(newProps[name]) &&
                              isFunction(oldProps[name]) &&
                              fnTest.test(newProps[name]) ? (function( name, fn ) {
                    return function() {
                        var tmp = this._super,
                            ret;

                        // Add a new ._super() method that is the same method
                        // but on the super-class
                        this._super = oldProps[name];

                        // The method only need to be bound temporarily, so we
                        // remove it when we're done executing
                        ret = fn.apply(this, arguments);
                        this._super = tmp;
                        return ret;
                    };
                })(name, newProps[name]) : newProps[name];
            }
        },
        STR_PROTOTYPE = 'prototype'

    /**
     * @class jQuery.Class
     * @plugin jquery/class
     * @parent jquerymx
     * @download dist/jquery/jquery.class.js
     * @test jquery/class/qunit.html
     * @description Easy inheritance in JavaScript.
     *
     * Class provides simulated inheritance in JavaScript. Use clss to bridge the gap between
     * jQuery's functional programming style and Object Oriented Programming. It
     * is based off John Resig's [http://ejohn.org/blog/simple-javascript-inheritance/|Simple Class]
     * Inheritance library.  Besides prototypal inheritance, it includes a few important features:
     *
     *   - Static inheritance
     *   - Introspection
     *   - Namespaces
     *   - Setup and initialization methods
     *   - Easy callback function creation
     *
     *
     * The [mvc.class Get Started with jQueryMX] has a good walkthrough of $.Class.
     *
     * ## Static v. Prototype
     *
     * Before learning about Class, it's important to
     * understand the difference between
     * a class's __static__ and __prototype__ properties.
     *
     *     //STATIC
     *     MyClass.staticProperty  //shared property
     *
     *     //PROTOTYPE
     *     myclass = new MyClass()
     *     myclass.prototypeMethod() //instance method
     *
     * A static (or class) property is on the Class constructor
     * function itself
     * and can be thought of being shared by all instances of the
     * Class. Prototype propertes are available only on instances of the Class.
     *
     * ## A Basic Class
     *
     * The following creates a Monster class with a
     * name (for introspection), static, and prototype members.
     * Every time a monster instance is created, the static
     * count is incremented.
     *
     * @codestart
     * $.Class('Monster',
     * /* @static *|
     * {
     *   count: 0
     * },
     * /* @prototype *|
     * {
     *   init: function( name ) {
     *
     *     // saves name on the monster instance
     *     this.name = name;
     *
     *     // sets the health
     *     this.health = 10;
     *
     *     // increments count
     *     this.constructor.count++;
     *   },
     *   eat: function( smallChildren ){
     *     this.health += smallChildren;
     *   },
     *   fight: function() {
     *     this.health -= 2;
     *   }
     * });
     *
     * hydra = new Monster('hydra');
     *
     * dragon = new Monster('dragon');
     *
     * hydra.name        // -> hydra
     * Monster.count     // -> 2
     * Monster.shortName // -> 'Monster'
     *
     * hydra.eat(2);     // health = 12
     *
     * dragon.fight();   // health = 8
     *
     * @codeend
     *
     *
     * Notice that the prototype <b>init</b> function is called when a new instance of Monster is created.
     *
     *
     * ## Inheritance
     *
     * When a class is extended, all static and prototype properties are available on the new class.
     * If you overwrite a function, you can call the base class's function by calling
     * <code>this._super</code>.  Lets create a SeaMonster class.  SeaMonsters are less
     * efficient at eating small children, but more powerful fighters.
     *
     *
     *     Monster("SeaMonster",{
     *       eat: function( smallChildren ) {
     *         this._super(smallChildren / 2);
     *       },
     *       fight: function() {
     *         this.health -= 1;
     *       }
     *     });
     *
     *     lockNess = new SeaMonster('Lock Ness');
     *     lockNess.eat(4);   //health = 12
     *     lockNess.fight();  //health = 11
     *
     * ### Static property inheritance
     *
     * You can also inherit static properties in the same way:
     *
     *     $.Class("First",
     *     {
     *         staticMethod: function() { return 1;}
     *     },{})
     *
     *     First("Second",{
     *         staticMethod: function() { return this._super()+1;}
     *     },{})
     *
     *     Second.staticMethod() // -> 2
     *
     * ## Namespaces
     *
     * Namespaces are a good idea! We encourage you to namespace all of your code.
     * It makes it possible to drop your code into another app without problems.
     * Making a namespaced class is easy:
     *
     *
     *     $.Class("MyNamespace.MyClass",{},{});
     *
     *     new MyNamespace.MyClass()
     *
     *
     * <h2 id='introspection'>Introspection</h2>
     *
     * Often, it's nice to create classes whose name helps determine functionality.  Ruby on
     * Rails's [http://api.rubyonrails.org/classes/ActiveRecord/Base.html|ActiveRecord] ORM class
     * is a great example of this.  Unfortunately, JavaScript doesn't have a way of determining
     * an object's name, so the developer must provide a name.  Class fixes this by taking a String name for the class.
     *
     *     $.Class("MyOrg.MyClass",{},{})
     *     MyOrg.MyClass.shortName //-> 'MyClass'
     *     MyOrg.MyClass.fullName //->  'MyOrg.MyClass'
     *
     * The fullName (with namespaces) and the shortName (without namespaces) are added to the Class's
     * static properties.
     *
     *
     * ## Setup and initialization methods
     *
     * <p>
     * Class provides static and prototype initialization functions.
     * These come in two flavors - setup and init.
     * Setup is called before init and
     * can be used to 'normalize' init's arguments.
     * </p>
     * <div class='whisper'>PRO TIP: Typically, you don't need setup methods in your classes. Use Init instead.
     * Reserve setup methods for when you need to do complex pre-processing of your class before init is called.
     *
     * </div>
     * @codestart
     * $.Class("MyClass",
     * {
     *   setup: function() {} //static setup
     *   init: function() {} //static constructor
     * },
     * {
     *   setup: function() {} //prototype setup
     *   init: function() {} //prototype constructor
     * })
     * @codeend
     *
     * ### Setup
     *
     * Setup functions are called before init functions.  Static setup functions are passed
     * the base class followed by arguments passed to the extend function.
     * Prototype static functions are passed the Class constructor
     * function arguments.
     *
     * If a setup function returns an array, that array will be used as the arguments
     * for the following init method.  This provides setup functions the ability to normalize
     * arguments passed to the init constructors.  They are also excellent places
     * to put setup code you want to almost always run.
     *
     *
     * The following is similar to how [jQuery.Controller.prototype.setup]
     * makes sure init is always called with a jQuery element and merged options
     * even if it is passed a raw
     * HTMLElement and no second parameter.
     *
     *     $.Class("jQuery.Controller",{
     *       ...
     *     },{
     *       setup: function( el, options ) {
     *         ...
     *         return [$(el),
     *                 $.extend(true,
     *                    this.Class.defaults,
     *                    options || {} ) ]
     *       }
     *     })
     *
     * Typically, you won't need to make or overwrite setup functions.
     *
     * ### Init
     *
     * Init functions are called after setup functions.
     * Typically, they receive the same arguments
     * as their preceding setup function.  The Foo class's <code>init</code> method
     * gets called in the following example:
     *
     *     $.Class("Foo", {
     *       init: function( arg1, arg2, arg3 ) {
     *         this.sum = arg1+arg2+arg3;
     *       }
     *     })
     *     var foo = new Foo(1,2,3);
     *     foo.sum //-> 6
     *
     * ## Proxies
     *
     * Similar to jQuery's proxy method, Class provides a
     * [jQuery.Class.static.proxy proxy]
     * function that returns a callback to a method that will always
     * have
     * <code>this</code> set to the class or instance of the class.
     *
     *
     * The following example uses this.proxy to make sure
     * <code>this.name</code> is available in <code>show</code>.
     *
     *     $.Class("Todo",{
     *       init: function( name ) {
     *          this.name = name
     *       },
     *       get: function() {
     *         $.get("/stuff",this.proxy('show'))
     *       },
     *       show: function( txt ) {
     *         alert(this.name+txt)
     *       }
     *     })
     *     new Todo("Trash").get()
     *
     * Callback is available as a static and prototype method.
     *
     * ##  Demo
     *
     * @demo jquery/class/class.html
     *
     *
     * @constructor
     *
     * To create a Class call:
     *
     *     $.Class( [NAME , STATIC,] PROTOTYPE ) -> Class
     *
     * <div class='params'>
     *   <div class='param'><label>NAME</label><code>{optional:String}</code>
     *   <p>If provided, this sets the shortName and fullName of the
     *      class and adds it and any necessary namespaces to the
     *      window object.</p>
     *   </div>
     *   <div class='param'><label>STATIC</label><code>{optional:Object}</code>
     *   <p>If provided, this creates static properties and methods
     *   on the class.</p>
     *   </div>
     *   <div class='param'><label>PROTOTYPE</label><code>{Object}</code>
     *   <p>Creates prototype methods on the class.</p>
     *   </div>
     * </div>
     *
     * When a Class is created, the static [jQuery.Class.static.setup setup]
     * and [jQuery.Class.static.init init]  methods are called.
     *
     * To create an instance of a Class, call:
     *
     *     new Class([args ... ]) -> instance
     *
     * The created instance will have all the
     * prototype properties and methods defined by the PROTOTYPE object.
     *
     * When an instance is created, the prototype [jQuery.Class.prototype.setup setup]
     * and [jQuery.Class.prototype.init init]  methods
     * are called.
     */

    clss = $.Class = function() {
        if (arguments.length) {
            clss.extend.apply(clss, arguments);
        }
    };

    /* @Static*/
    extend(clss, {
        /**
         * @function proxy
         * Returns a callback function for a function on this Class.
         * Proxy ensures that 'this' is set appropriately.
         * @codestart
         * $.Class("MyClass",{
         *     getData: function() {
         *         this.showing = null;
         *         $.get("data.json",this.proxy('gotData'),'json')
         *     },
         *     gotData: function( data ) {
         *         this.showing = data;
         *     }
         * },{});
         * MyClass.showData();
         * @codeend
         * <h2>Currying Arguments</h2>
         * Additional arguments to proxy will fill in arguments on the returning function.
         * @codestart
         * $.Class("MyClass",{
         *    getData: function( <b>callback</b> ) {
         *      $.get("data.json",this.proxy('process',<b>callback</b>),'json');
         *    },
         *    process: function( <b>callback</b>, jsonData ) { //callback is added as first argument
         *        jsonData.processed = true;
         *        callback(jsonData);
         *    }
         * },{});
         * MyClass.getData(showDataFunc)
         * @codeend
         * <h2>Nesting Functions</h2>
         * Proxy can take an array of functions to call as
         * the first argument.  When the returned callback function
         * is called each function in the array is passed the return value of the prior function.  This is often used
         * to eliminate currying initial arguments.
         * @codestart
         * $.Class("MyClass",{
         *    getData: function( callback ) {
         *      //calls process, then callback with value from process
         *      $.get("data.json",this.proxy(['process2',callback]),'json')
         *    },
         *    process2: function( type,jsonData ) {
         *        jsonData.processed = true;
         *        return [jsonData];
         *    }
         * },{});
         * MyClass.getData(showDataFunc);
         * @codeend
         * @param {String|Array} fname If a string, it represents the function to be called.
         * If it is an array, it will call each function in order and pass the return value of the prior function to the
         * next function.
         * @return {Function} the callback function.
         */
        proxy: function( funcs ) {

            //args that should be curried
            var args = makeArray(arguments),
                self;

            // get the functions to callback
            funcs = args.shift();

            // if there is only one function, make funcs into an array
            if (!isArray(funcs) ) {
                funcs = [funcs];
            }

            // keep a reference to us in self
            self = this;

            
            return function class_cb() {
                // add the arguments after the curried args
                var cur = concatArgs(args, arguments),
                    isString,
                    length = funcs.length,
                    f = 0,
                    func;

                // go through each function to call back
                for (; f < length; f++ ) {
                    func = funcs[f];
                    if (!func ) {
                        continue;
                    }

                    // set called with the name of the function on self (this is how this.view works)
                    isString = typeof func == "string";
                    if ( isString && self._set_called ) {
                        self.called = func;
                    }

                    // call the function
                    cur = (isString ? self[func] : func).apply(self, cur || []);

                    // pass the result to the next function (if there is a next function)
                    if ( f < length - 1 ) {
                        cur = !isArray(cur) || cur._use_call ? [cur] : cur
                    }
                }
                return cur;
            }
        },
        /**
         * @function newInstance
         * Creates a new instance of the class.  This method is useful for creating new instances
         * with arbitrary parameters.
         * <h3>Example</h3>
         * @codestart
         * $.Class("MyClass",{},{})
         * var mc = MyClass.newInstance.apply(null, new Array(parseInt(Math.random()*10,10))
         * @codeend
         * @return {class} instance of the class
         */
        newInstance: function() {
            // get a raw instance objet (init is not called)
            var inst = this.rawInstance(),
                args;

            // call setup if there is a setup
            if ( inst.setup ) {
                args = inst.setup.apply(inst, arguments);
            }
            // call init if there is an init, if setup returned args, use those as the arguments
            if ( inst.init ) {
                inst.init.apply(inst, isArray(args) ? args : arguments);
            }
            return inst;
        },
        /**
         * Setup gets called on the inherting class with the base class followed by the
         * inheriting class's raw properties.
         *
         * Setup will deeply extend a static defaults property on the base class with
         * properties on the base class.  For example:
         *
         *     $.Class("MyBase",{
         *       defaults : {
         *         foo: 'bar'
         *       }
         *     },{})
         *
         *     MyBase("Inheriting",{
         *       defaults : {
         *         newProp : 'newVal'
         *       }
         *     },{}
         *
         *     Inheriting.defaults -> {foo: 'bar', 'newProp': 'newVal'}
         *
         * @param {Object} baseClass the base class that is being inherited from
         * @param {String} fullName the name of the new class
         * @param {Object} staticProps the static properties of the new class
         * @param {Object} protoProps the prototype properties of the new class
         */
        setup: function( baseClass, fullName ) {
            // set defaults as the merger of the parent defaults and this object's defaults
            this.defaults = extend(true, {}, baseClass.defaults, this.defaults);
            return arguments;
        },
        rawInstance: function() {
            // prevent running init
            initializing = true;
            var inst = new this();
            initializing = false;
            // allow running init
            return inst;
        },
        /**
         * Extends a class with new static and prototype functions.  There are a variety of ways
         * to use extend:
         *
         *     // with className, static and prototype functions
         *     $.Class('Task',{ STATIC },{ PROTOTYPE })
         *     // with just classname and prototype functions
         *     $.Class('Task',{ PROTOTYPE })
         *     // with just a className
         *     $.Class('Task')
         *
         * You no longer have to use <code>.extend</code>.  Instead, you can pass those options directly to
         * $.Class (and any inheriting classes):
         *
         *     // with className, static and prototype functions
         *     $.Class('Task',{ STATIC },{ PROTOTYPE })
         *     // with just classname and prototype functions
         *     $.Class('Task',{ PROTOTYPE })
         *     // with just a className
         *     $.Class('Task')
         *
         * @param {String} [fullName]  the classes name (used for classes w/ introspection)
         * @param {Object} [klass]  the new classes static/class functions
         * @param {Object} [proto]  the new classes prototype functions
         *
         * @return {jQuery.Class} returns the new class
         */
        extend: function( fullName, klass, proto ) {
            // figure out what was passed and normalize it
            if ( typeof fullName != 'string' ) {
                proto = klass;
                klass = fullName;
                fullName = null;
            }
            if (!proto ) {
                proto = klass;
                klass = null;
            }

            proto = proto || {};
            var _super_class = this,
                _super = this[STR_PROTOTYPE],
                name, shortName, namespace, prototype;

            // Instantiate a base class (but only create the instance,
            // don't run the init constructor)
            initializing = true;
            prototype = new this();
            initializing = false;

            // Copy the properties over onto the new prototype
            inheritProps(proto, _super, prototype);

            // The dummy class constructor
            function Class() {
                // All construction is actually done in the init method
                if ( initializing ) return;

                // we are being called w/o new, we are extending
                if ( this.constructor !== Class && arguments.length ) {
                    return arguments.callee.extend.apply(arguments.callee, arguments)
                } else { //we are being called w/ new
                    return this.Class.newInstance.apply(this.Class, arguments)
                }
            }
            // Copy old stuff onto class
            for ( name in this ) {
                if ( this.hasOwnProperty(name) ) {
                    Class[name] = this[name];
                }
            }

            // copy new static props on class
            inheritProps(klass, this, Class);

            // do namespace stuff
            if ( fullName ) {

                var root;
                if (klass && klass.root) {
                    root = klass.root;
                    if ($.isString(root)) {
                        root = getObject(root, window, true);
                    }
                }

                var parts = fullName.split(/\./),
                    shortName = parts.pop(),
                    current = getObject(parts.join('.'), root || window, true),
                    namespace = current;

                

                // !-- FOUNDRY HACK --! //
                // Inherit any existing properties from the namespace where Class is being assigned to.
                extend(true, Class, current[shortName]);

                current[shortName] = Class;
            }

            // set things that can't be overwritten
            extend(Class, {
                prototype: prototype,
                /**
                 * @attribute namespace
                 * The namespaces object
                 *
                 *     $.Class("MyOrg.MyClass",{},{})
                 *     MyOrg.MyClass.namespace //-> MyOrg
                 *
                 */
                namespace: namespace,
                /**
                 * @attribute shortName
                 * The name of the class without its namespace, provided for introspection purposes.
                 *
                 *     $.Class("MyOrg.MyClass",{},{})
                 *     MyOrg.MyClass.shortName //-> 'MyClass'
                 *     MyOrg.MyClass.fullName //->  'MyOrg.MyClass'
                 *
                 */
                shortName: shortName,
                constructor: Class,
                /**
                 * @attribute fullName
                 * The full name of the class, including namespace, provided for introspection purposes.
                 *
                 *     $.Class("MyOrg.MyClass",{},{})
                 *     MyOrg.MyClass.shortName //-> 'MyClass'
                 *     MyOrg.MyClass.fullName //->  'MyOrg.MyClass'
                 *
                 */
                fullName: fullName
            });

            //make sure our prototype looks nice
            Class[STR_PROTOTYPE].Class = Class[STR_PROTOTYPE].constructor = Class;



            // call the class setup
            var args = Class.setup.apply(Class, concatArgs([_super_class],arguments));

            // call the class init
            if ( Class.init ) {
                Class.init.apply(Class, args || concatArgs([_super_class],arguments));
            }

            /* @Prototype*/
            return Class;
            /**
             * @function setup
             * If a setup method is provided, it is called when a new
             * instances is created.  It gets passed the same arguments that
             * were given to the Class constructor function (<code> new Class( arguments ... )</code>).
             *
             *     $.Class("MyClass",
             *     {
             *        setup: function( val ) {
             *           this.val = val;
             *         }
             *     })
             *     var mc = new MyClass("Check Check")
             *     mc.val //-> 'Check Check'
             *
             * Setup is called before [jQuery.Class.prototype.init init].  If setup
             * return an array, those arguments will be used for init.
             *
             *     $.Class("jQuery.Controller",{
             *       setup : function(htmlElement, rawOptions){
             *         return [$(htmlElement),
             *                   $.extend({}, this.Class.defaults, rawOptions )]
             *       }
             *     })
             *
             * <div class='whisper'>PRO TIP:
             * Setup functions are used to normalize constructor arguments and provide a place for
             * setup code that extending classes don't have to remember to call _super to
             * run.
             * </div>
             *
             * Setup is not defined on $.Class itself, so calling super in inherting classes
             * will break.  Don't do the following:
             *
             *     $.Class("Thing",{
             *       setup : function(){
             *         this._super(); // breaks!
             *       }
             *     })
             *
             * @return {Array|undefined} If an array is return, [jQuery.Class.prototype.init] is
             * called with those arguments; otherwise, the original arguments are used.
             */
            //break up
            /**
             * @function init
             * If an <code>init</code> method is provided, it gets called when a new instance
             * is created.  Init gets called after [jQuery.Class.prototype.setup setup], typically with the
             * same arguments passed to the Class
             * constructor: (<code> new Class( arguments ... )</code>).
             *
             *     $.Class("MyClass",
             *     {
             *        init: function( val ) {
             *           this.val = val;
             *        }
             *     })
             *     var mc = new MyClass(1)
             *     mc.val //-> 1
             *
             * [jQuery.Class.prototype.setup Setup] is able to modify the arguments passed to init.  Read
             * about it there.
             *
             */
            //Breaks up code
            /**
             * @attribute constructor
             *
             * A reference to the Class (or constructor function).  This allows you to access
             * a class's static properties from an instance.
             *
             * ### Quick Example
             *
             *     // a class with a static property
             *     $.Class("MyClass", {staticProperty : true}, {});
             *
             *     // a new instance of myClass
             *     var mc1 = new MyClass();
             *
             *     // read the static property from the instance:
             *     mc1.constructor.staticProperty //-> true
             *
             * Getting static properties with the constructor property, like
             * [jQuery.Class.static.fullName fullName], is very common.
             *
             */
        }

    })





    clss.callback = clss[STR_PROTOTYPE].callback = clss[STR_PROTOTYPE].
    /**
     * @function proxy
     * Returns a method that sets 'this' to the current instance.  This does the same thing as
     * and is described better in [jQuery.Class.static.proxy].
     * The only difference is this proxy works
     * on a instance instead of a class.
     * @param {String|Array} fname If a string, it represents the function to be called.
     * If it is an array, it will call each function in order and pass the return value of the prior function to the
     * next function.
     * @return {Function} the callback function
     */
    proxy = clss.proxy;


})();(function(){
    // ------- HELPER FUNCTIONS  ------

    // Binds an element, returns a function that unbinds
    var bind = function( el, ev, callback, eventData ) {
        var wrappedCallback,
            binder = el.bind && el.unbind ? el : $(isFunction(el) ? [el] : el);
        //this is for events like >click.
        if ( ev.indexOf(">") === 0 ) {
            ev = ev.substr(1);
            wrappedCallback = function( event ) {
                if ( event.target === el ) {
                    callback.apply(this, arguments);
                }
            };
        }
        // !-- FOUNDRY HACK --! //
        // Support for passing event data
        if (eventData) {
            binder.bind(ev, eventData, wrappedCallback || callback);
        } else {
            binder.bind(ev, wrappedCallback || callback);
        }
        // if ev name has >, change the name and bind
        // in the wrapped callback, check that the element matches the actual element
        return function() {
            binder.unbind(ev, wrappedCallback || callback);
            el = ev = callback = wrappedCallback = null;
        };
    },
        makeArray = $.makeArray,
        isArray = $.isArray,
        isFunction = $.isFunction,
        isString = $.isString,
        extend = $.extend,
        Str = $.String,
        each = $.each,
        getObject = Str.getObject,

        STR_PROTOTYPE = 'prototype',
        STR_CONSTRUCTOR = 'constructor',
        slice = Array[STR_PROTOTYPE].slice,

        // Binds an element, returns a function that unbinds
        delegate = function( el, selector, ev, callback, eventData ) {

            // !-- FOUNDRY HACK --! //
            // Make event delegation work with direct child selector
            if ( selector.indexOf(">") === 0 ) {
                selector = (el.data("directSelector") + " " || "") + selector;
            }

            var binder = el.delegate && el.undelegate ? el : $(isFunction(el) ? [el] : el)

            // !-- FOUNDRY HACK --! //
            // Support for passing event data
            if (eventData) {
                binder.delegate(selector, ev, eventData, callback);
            } else {
                binder.delegate(selector, ev, callback);
            }

            return function() {
                binder.undelegate(selector, ev, callback);
                binder = el = ev = callback = selector = null;
            };
        },

        // calls bind or unbind depending if there is a selector
        binder = function( el, ev, callback, selector, eventData ) {
            // !-- FOUNDRY HACK --! //
            // Support for passing event data
            return selector ? delegate(el, selector, ev, callback, eventData) : bind(el, ev, callback, eventData);
        },

        // moves 'this' to the first argument, wraps it with jQuery if it's an element
        shifter = function shifter(context, name) {
            var method = typeof name == "string" ? context[name] : name;

            // !-- FOUNDRY HACK --! //
            // Support for passing event data
            if (isArray(method) && isFunction(method[1])) {
                method = method[1];
            }

            return function() {
                context.called = name;
                return method.apply(context, [this.nodeName ? $(this) : this].concat( slice.call(arguments, 0) ) );
            };
        },
        // matches dots
        dotsReg = /\./g,
        // matches controller
        controllersReg = /_?controllers?/ig,
        //used to remove the controller from the name
        underscoreAndRemoveController = function( className ) {
            return Str.underscore(className.replace($.globalNamespace + ".", "").replace(dotsReg, '_').replace(controllersReg, ""));
        },
        // checks if it looks like an action
        // actionMatcher = /[^\w]/,

        // !-- FOUNDRY HACK --! //
        // Prevent inclusion of single word property name that starts with a symbol, e.g. $family from MooTools.
        // This is coming from an environment where jQuery and MooTools may coexist.
        actionMatcher = /^\S(.*)\s(.*)/,

        // handles parameterized action names
        parameterReplacer = /\{([^\}]+)\}/g,
        controllerReplacer = /\{([^\.]+[\.][^\.]+)\}/g,
        breaker = /^(?:(.*?)\s)?([\w\.\:>]+)$/,
        basicProcessor,
        data = function(el, data){
            return $.data(el, "controllers", data)
        };
    /**
     * @class jQuery.Controller
     * @parent jquerymx
     * @plugin jquery/controller
     * @download  http://jmvcsite.heroku.com/pluginify?plugins[]=jquery/controller/controller.js
     * @test jquery/controller/qunit.html
     * @inherits jQuery.Class
     * @description jQuery widget factory.
     *
     * jQuery.Controller helps create organized, memory-leak free, rapidly performing
     * jQuery widgets.  Its extreme flexibility allows it to serve as both
     * a traditional View and a traditional Controller.
     *
     * This means it is used to
     * create things like tabs, grids, and contextmenus as well as
     * organizing them into higher-order business rules.
     *
     * Controllers make your code deterministic, reusable, organized and can tear themselves
     * down auto-magically. Read about [http://jupiterjs.com/news/writing-the-perfect-jquery-plugin
     * the theory behind controller] and
     * a [http://jupiterjs.com/news/organize-jquery-widgets-with-jquery-controller walkthrough of its features]
     * on Jupiter's blog. [mvc.controller Get Started with jQueryMX] also has a great walkthrough.
     *
     * Controller inherits from [jQuery.Class $.Class] and makes heavy use of
     * [http://api.jquery.com/delegate/ event delegation]. Make sure
     * you understand these concepts before using it.
     *
     * ## Basic Example
     *
     * Instead of
     *
     *
     *     $(function(){
     *       $('#tabs').click(someCallbackFunction1)
     *       $('#tabs .tab').click(someCallbackFunction2)
     *       $('#tabs .delete click').click(someCallbackFunction3)
     *     });
     *
     * do this
     *
     *     $.Controller('Tabs',{
     *       click: function() {...},
     *       '.tab click' : function() {...},
     *       '.delete click' : function() {...}
     *     })
     *     $('#tabs').tabs();
     *
     *
     * ## Tabs Example
     *
     * @demo jquery/controller/controller.html
     *
     * ## Using Controller
     *
     * Controller helps you build and organize jQuery plugins.  It can be used
     * to build simple widgets, like a slider, or organize multiple
     * widgets into something greater.
     *
     * To understand how to use Controller, you need to understand
     * the typical lifecycle of a jQuery widget and how that maps to
     * controller's functionality:
     *
     * ### A controller class is created.
     *
     *     $.Controller("MyWidget",
     *     {
     *       defaults :  {
     *         message : "Remove Me"
     *       }
     *     },
     *     {
     *       init : function(rawEl, rawOptions){
     *         this.element.append(
     *            "<div>"+this.options.message+"</div>"
     *           );
     *       },
     *       "div click" : function(div, ev){
     *         div.remove();
     *       }
     *     })
     *
     * This creates a <code>$.fn.my_widget</code> jQuery helper function
     * that can be used to create a new controller instance on an element. Find
     * more information [jquery.controller.plugin  here] about the plugin gets created
     * and the rules around its name.
     *
     * ### An instance of controller is created on an element
     *
     *     $('.thing').my_widget(options) // calls new MyWidget(el, options)
     *
     * This calls <code>new MyWidget(el, options)</code> on
     * each <code>'.thing'</code> element.
     *
     * When a new [jQuery.Class Class] instance is created, it calls the class's
     * prototype setup and init methods. Controller's [jQuery.Controller.prototype.setup setup]
     * method:
     *
     *  - Sets [jQuery.Controller.prototype.element this.element] and adds the controller's name to element's className.
     *  - Merges passed in options with defaults object and sets it as [jQuery.Controller.prototype.options this.options]
     *  - Saves a reference to the controller in <code>$.data</code>.
     *  - [jquery.controller.listening Binds all event handler methods].
     *
     *
     * ### The controller responds to events
     *
     * Typically, Controller event handlers are automatically bound.  However, there are
     * multiple ways to [jquery.controller.listening listen to events] with a controller.
     *
     * Once an event does happen, the callback function is always called with 'this'
     * referencing the controller instance.  This makes it easy to use helper functions and
     * save state on the controller.
     *
     *
     * ### The widget is destroyed
     *
     * If the element is removed from the page, the
     * controller's [jQuery.Controller.prototype.destroy] method is called.
     * This is a great place to put any additional teardown functionality.
     *
     * You can also teardown a controller programatically like:
     *
     *     $('.thing').my_widget('destroy');
     *
     * ## Todos Example
     *
     * Lets look at a very basic example -
     * a list of todos and a button you want to click to create a new todo.
     * Your HTML might look like:
     *
     * @codestart html
     * &lt;div id='todos'>
     *  &lt;ol>
     *    &lt;li class="todo">Laundry&lt;/li>
     *    &lt;li class="todo">Dishes&lt;/li>
     *    &lt;li class="todo">Walk Dog&lt;/li>
     *  &lt;/ol>
     *  &lt;a class="create">Create&lt;/a>
     * &lt;/div>
     * @codeend
     *
     * To add a mousover effect and create todos, your controller might look like:
     *
     *     $.Controller('Todos',{
     *       ".todo mouseover" : function( el, ev ) {
     *         el.css("backgroundColor","red")
     *       },
     *       ".todo mouseout" : function( el, ev ) {
     *         el.css("backgroundColor","")
     *       },
     *       ".create click" : function() {
     *         this.find("ol").append("<li class='todo'>New Todo</li>");
     *       }
     *     })
     *
     * Now that you've created the controller class, you've must attach the event handlers on the '#todos' div by
     * creating [jQuery.Controller.prototype.setup|a new controller instance].  There are 2 ways of doing this.
     *
     * @codestart
     * //1. Create a new controller directly:
     * new Todos($('#todos'));
     * //2. Use jQuery function
     * $('#todos').todos();
     * @codeend
     *
     * ## Controller Initialization
     *
     * It can be extremely useful to add an init method with
     * setup functionality for your widget.
     *
     * In the following example, I create a controller that when created, will put a message as the content of the element:
     *
     *     $.Controller("SpecialController",
     *     {
     *       init: function( el, message ) {
     *         this.element.html(message)
     *       }
     *     })
     *     $(".special").special("Hello World")
     *
     * ## Removing Controllers
     *
     * Controller removal is built into jQuery.  So to remove a controller, you just have to remove its element:
     *
     * @codestart
     * $(".special_controller").remove()
     * $("#containsControllers").html("")
     * @codeend
     *
     * It's important to note that if you use raw DOM methods (<code>innerHTML, removeChild</code>), the controllers won't be destroyed.
     *
     * If you just want to remove controller functionality, call destroy on the controller instance:
     *
     * @codestart
     * $(".special_controller").controller().destroy()
     * @codeend
     *
     * ## Accessing Controllers
     *
     * Often you need to get a reference to a controller, there are a few ways of doing that.  For the
     * following example, we assume there are 2 elements with <code>className="special"</code>.
     *
     * @codestart
     * //creates 2 foo controllers
     * $(".special").foo()
     *
     * //creates 2 bar controllers
     * $(".special").bar()
     *
     * //gets all controllers on all elements:
     * $(".special").controllers() //-> [foo, bar, foo, bar]
     *
     * //gets only foo controllers
     * $(".special").controllers(FooController) //-> [foo, foo]
     *
     * //gets all bar controllers
     * $(".special").controllers(BarController) //-> [bar, bar]
     *
     * //gets first controller
     * $(".special").controller() //-> foo
     *
     * //gets foo controller via data
     * $(".special").data("controllers")["FooController"] //-> foo
     * @codeend
     *
     * ## Calling methods on Controllers
     *
     * Once you have a reference to an element, you can call methods on it.  However, Controller has
     * a few shortcuts:
     *
     * @codestart
     * //creates foo controller
     * $(".special").foo({name: "value"})
     *
     * //calls FooController.prototype.update
     * $(".special").foo({name: "value2"})
     *
     * //calls FooController.prototype.bar
     * $(".special").foo("bar","something I want to pass")
     * @codeend
     *
     * These methods let you call one controller from another controller.
     *
     */
    var controllerRoot = $.globalNamespace + ".Controller";

    $.Controller = function(name) {

        // !-- FOUNDRY HACK --! //
        // By default, all controllers are created under the
        // $.Controller root namespace.
        var args = makeArray(arguments),
            _static = {
                root: controllerRoot
            },
            _prototype;

        if (args.length > 2) {
            // Namespace can be overriden
            _static = $.extend(_static, args[1]);
            _prototype = args[2];
        } else {
            _prototype = args[1];
        }

        if (_static.namespace) {
            name = _static.namespace + "." + name;
        }

        return $.Controller.Class(name, _static, _prototype);
    }

    var controllerClass = controllerRoot + ".Class";

    $.Class(controllerClass,
    /**
     * @Static
     */
    {
        /**
         * Does 2 things:
         *
         *   - Creates a jQuery helper for this controller.</li>
         *   - Calculates and caches which functions listen for events.</li>
         *
         * ### jQuery Helper Naming Examples
         *
         *
         *     "TaskController" -> $().task_controller()
         *     "Controllers.Task" -> $().controllers_task()
         *
         */
        setup: function(baseClass, name) {

            // Allow contollers to inherit "defaults" from superclasses as it done in $.Class
            this._super.apply(this, arguments);

            // if you didn't provide a name, or are controller, don't do anything
            if (!this.shortName || this.fullName == controllerClass) {
                return;
            }

            // !-- FOUNDRY HACK --! //
            // Added support for expandable elements.
            var elements = this.elements || [],
                i = 0,
                defaults = this.defaults;

            while (element = elements[i++]) {

                var start  = element.indexOf("{"),
                    end    = element.indexOf("}"),
                    length = element.length,
                    prefix = element.slice(0, start),
                    suffix = element.slice(end + 1),
                    names  = element.slice(start + 1, end).split("|"),
                    j = 0;

                    // "^width [data-eb{label|slider}]" turns into
                    // widthLabel  => [data-eb-label]
                    // widthSlider => [data-eb-slider]

                    // "^width [data-eb".match(/^\^(\S*)\s(.*)/);
                    // 0 ==> "^width [data-eb"
                    // 1 ==> "width",
                    // 2 ==> "[data-eb"
                    var parts = prefix.match(/^\^(\S*)\s(.*)/),
                        propPrefix = "";

                    if (parts) {
                        propPrefix = parts[1] + "-";
                        prefix = parts[2];
                    }

                    while (name = names[j++]) {
                        var prop = "{" + $.camelize(propPrefix + name) + "}";

                        !$.has(defaults, prop) &&
                            (defaults[prop] = prefix + name + suffix);
                    }
            }

            // cache the underscored names
            this._fullName = underscoreAndRemoveController(this.fullName);
            this._shortName = underscoreAndRemoveController(this.shortName);

            var controller = this,
                /**
                 * @attribute pluginName
                 * Setting the <code>pluginName</code> property allows you
                 * to change the jQuery plugin helper name from its
                 * default value.
                 *
                 *     $.Controller("Mxui.Layout.Fill",{
                 *       pluginName: "fillWith"
                 *     },{});
                 *
                 *     $("#foo").fillWith();
                 */
                funcName, forLint;

            // !-- FOUNDRY HACK --! //
            // Make creation of jQuery plugin by testing the existence of pluginName.
            if (isString(this.pluginName)) {

                // !-- FOUNDRY HACK --! //
                // Add a reference to the fullname
                var _fullName = this._fullName;
                var pluginname = this.pluginName;

                // create jQuery plugin
                if (!$.fn[pluginname] ) {
                    $.fn[pluginname] = function( options ) {

                        var args = makeArray(arguments);

                        // Returning controller instance if it exists
                        if ($.isString(options) && options==="controller") {

                            var controllers = data(this[0]),
                                instance = controllers && controllers[_fullName];

                            return instance;
                        }

                        return this.each(function() {
                            //check if created
                            var controllers = data(this),
                                //plugin is actually the controller instance
                                //plugin = controllers && controllers[pluginname];

                                // !-- FOUNDRY HACK --! //
                                // Check using controller full name
                                instance = controllers && controllers[_fullName];

                            if (instance) {

                                // call a method on the controller with the remaining args
                                if ($.isString(options)) {
                                    var method = instance[options];
                                    $.isFunction(method) && method.apply(instance, args.slice(1));
                                    return;
                                }

                                // call the plugin's update method
                                instance.update.apply(instance, args);

                            } else {
                                //create a new controller instance
                                controller.newInstance.apply(controller, [this].concat(args));
                            }
                        });
                    };
                }
            }

            // !-- FOUNDRY HACK --! //
            // If a prototype factory function was given instead of a prototype object,
            // we expect the factory function to return the prototype object upon execution
            // of the factory function. This factory function gets executed during the
            // instantiation of the controller.

            var args         = makeArray(arguments),
                prototype    = this[STR_PROTOTYPE],
                protoFactory = args[(args.length > 3) ? 3 : 2];

            if (isFunction(protoFactory)) {

                // Remap the factory function
                this.protoFactory = protoFactory;

                // Attempt to execute the prototype factory once to get
                // a list of actions that we can cache first.
                prototype = this.protoFactory.call(this, null);
            }

            // calculate and cache actions
            this.actions = {};

            // !-- FOUNDRY HACK --! //
            // Support for handlers that also pass in event data
            for (funcName in prototype) {

                if (funcName=='constructor') continue;

                if (this._isAction(funcName)) {

                    var method   = prototype[funcName],
                        isMethod = isFunction(method) || (isArray(method) && isFunction(method[1]));

                    if (!isMethod) continue;

                    this.actions[funcName] = this._action(funcName);
                }
            }

            // !-- FOUNDRY HACK --! //
            // Controller has been created. Resolve module.
            $.module("$:/Controllers/" + this.fullName).resolve(this);
        },

        hookup: function( el ) {
            return new this(el);
        },

        /**
         * @hide
         * @param {String} methodName a prototype function
         * @return {Boolean} truthy if an action or not
         */
        _isAction: function( methodName ) {
            if ( actionMatcher.test(methodName) ) {
                return true;
            } else {
                return $.inArray(methodName, this.listensTo) > -1 || $.event.special[methodName] || processors[methodName];
            }

        },
        /**
         * @hide
         * This takes a method name and the options passed to a controller
         * and tries to return the data necessary to pass to a processor
         * (something that binds things).
         *
         * For performance reasons, this called twice.  First, it is called when
         * the Controller class is created.  If the methodName is templated
         * like : "{window} foo", it returns null.  If it is not templated
         * it returns event binding data.
         *
         * The resulting data is added to this.actions.
         *
         * When a controller instance is created, _action is called again, but only
         * on templated actions.
         *
         * @param {Object} methodName the method that will be bound
         * @param {Object} [options] first param merged with class default options
         * @return {Object} null or the processor and pre-split parts.
         * The processor is what does the binding/subscribing.
         */
        _action: function( methodName, options ) {
            // reset the test index
            parameterReplacer.lastIndex = 0;

            //if we don't have options (a controller instance), we'll run this later
            if (!options && parameterReplacer.test(methodName) ) {
                return null;
            }

            // !-- FOUNDRY HACK --! //
            // Ability to bind custom event to self.
            // "{self} customEvent"
            methodName = methodName.replace("{self} ", "");

            // If we have options, run sub to replace templates "{}" with a value from the options
            // or the window
            var convertedName = methodName;

            if (options) {

                var bindingOtherController = false;

                if (controllerReplacer.test(methodName)) {

                    var controller, selector = "";
                    convertedName =
                        methodName
                            .replace(controllerReplacer, function(whole, inside){
                                var parts = inside.split(".");
                                controller = options["{"+parts[0]+"}"] || {};
                                if ($.isControllerInstance(controller)) {
                                    selector = (controller[parts[1]] || {})["selector"];
                                }
                                return selector;
                            })
                            .match(breaker);

                    // If there is a selector, this will be true.
                    bindingOtherController = !!selector;

                    convertedName = [controller.element].concat(convertedName || []);
                }

                if (!bindingOtherController) {

                    convertedName = Str.sub(methodName, [options, window]);
                }
            }

            // If a "{}" resolves to an object, convertedName will be an array
            var arr = isArray(convertedName),

                // get the parts of the function = [convertedName, delegatePart, eventPart]
                parts = (arr ? convertedName[1] : convertedName).match(breaker),
                event = parts[2],
                processor = processors[event] || basicProcessor;

            return {
                processor: processor,
                parts: parts,
                delegate : arr ? convertedName[0] : undefined
            };
        },

        /**
         * @attribute processors
         * An object of {eventName : function} pairs that Controller uses to hook up events
         * auto-magically.  A processor function looks like:
         *
         *     jQuery.Controller.processors.
         *       myprocessor = function( el, event, selector, cb, controller ) {
         *          //el - the controller's element
         *          //event - the event (myprocessor)
         *          //selector - the left of the selector
         *          //cb - the function to call
         *          //controller - the binding controller
         *       };
         *
         * This would bind anything like: "foo~3242 myprocessor".
         *
         * The processor must return a function that when called,
         * unbinds the event handler.
         *
         * Controller already has processors for the following events:
         *
         *   - change
         *   - click
         *   - contextmenu
         *   - dblclick
         *   - focusin
         *   - focusout
         *   - keydown
         *   - keyup
         *   - keypress
         *   - mousedown
         *   - mouseenter
         *   - mouseleave
         *   - mousemove
         *   - mouseout
         *   - mouseover
         *   - mouseup
         *   - reset
         *   - resize
         *   - scroll
         *   - select
         *   - submit
         *
         * Listen to events on the document or window
         * with templated event handlers:
         *
         *
         *     $.Controller('Sized',{
         *       "{window} resize" : function(){
         *         this.element.width(this.element.parent().width() / 2);
         *       }
         *     });
         *
         *     $('.foo').sized();
         */
        processors: {},
        /**
         * @attribute listensTo
         * An array of special events this controller
         * listens too.  You only need to add event names that
         * are whole words (ie have no special characters).
         *
         *     $.Controller('TabPanel',{
         *       listensTo : ['show']
         *     },{
         *       'show' : function(){
         *         this.element.show();
         *       }
         *     })
         *
         *     $('.foo').tab_panel().trigger("show");
         *
         */
        listensTo: [],
        /**
         * @attribute defaults
         * A object of name-value pairs that act as default values for a controller's
         * [jQuery.Controller.prototype.options options].
         *
         *     $.Controller("Message",
         *     {
         *       defaults : {
         *         message : "Hello World"
         *       }
         *     },{
         *       init : function(){
         *         this.element.text(this.options.message);
         *       }
         *     })
         *
         *     $("#el1").message(); //writes "Hello World"
         *     $("#el12").message({message: "hi"}); //writes hi
         *
         * In [jQuery.Controller.prototype.setup setup] the options passed to the controller
         * are merged with defaults.  This is not a deep merge.
         */
        defaults: {},

        hostname: "parent"
    },
    /**
     * @Prototype
     */
    {
        /**
         * Setup is where most of controller's magic happens.  It does the following:
         *
         * ### 1. Sets this.element
         *
         * The first parameter passed to new Controller(el, options) is expected to be
         * an element.  This gets converted to a jQuery wrapped element and set as
         * [jQuery.Controller.prototype.element this.element].
         *
         * ### 2. Adds the controller's name to the element's className.
         *
         * Controller adds it's plugin name to the element's className for easier
         * debugging.  For example, if your Controller is named "Foo.Bar", it adds
         * "foo_bar" to the className.
         *
         * ### 3. Saves the controller in $.data
         *
         * A reference to the controller instance is saved in $.data.  You can find
         * instances of "Foo.Bar" like:
         *
         *     $("#el").data("controllers")['foo_bar'].
         *
         * ### Binds event handlers
         *
         * Setup does the event binding described in [jquery.controller.listening Listening To Events].
         *
         * @param {HTMLElement} element the element this instance operates on.
         * @param {Object} [options] option values for the controller.  These get added to
         * this.options and merged with [jQuery.Controller.static.defaults defaults].
         * @return {Array} return an array if you wan to change what init is called with. By
         * default it is called with the element and options passed to the controller.
         */
        setup: function(elem, options) {

            var instance  = this,
                Class     = instance[STR_CONSTRUCTOR],
                prototype = instance[STR_PROTOTYPE];

            var _fullName = Class._fullName;

            // !-- FOUNDRY HACK --! //
            // Unique id for every controller instance.
            instance.instanceId = $.uid(_fullName + '_');

            // !-- FOUNDRY HACK --! //
            // Added defaultOptions as an alternative to defaults
            var instanceOptions = instance.options
                                = extend(true, {}, Class.defaults, Class.defaultOptions, options);

            // Convert HTML element into a jQuery element
            // and store it inside instance.element.
            var element = instance.element
                        = $(elem);

            // !-- FOUNDRY HACK --! //
            // Execute factory function if exists, extends the properties
            // of the returned object onto the instance.
            if (Class.protoFactory) {

                // This is where "self" keyword is passed as first argument.
                prototype = Class.protoFactory.apply(Class, [instance, instanceOptions, element]);

                // Extend the properties of the prototype object onto the instance.
                extend(true, instance, prototype);
            }

            // !-- FOUNDRY HACK --! //
            // Use _fullName instead
            // This actually does $(e).data("controllers", _fullName);
            (data(elem) || data(elem, {}))[_fullName] = instance;

            // !-- FOUNDRY HACK --~ //
            // Add a unique direct selector for every controller instance.
            if (!element.data("directSelector")) {
                var selector = $.uid("DS");
                element
                    .addClass(selector)
                    .data("directSelector", "." + selector);
            }

            // !-- FOUNDRY HACK --! //
            // Augment selector properties into selector functions.
            // The rest are passed in as controller properties.
            instance.selectors = {};

            for (var name in instanceOptions) {

                if (!name.match(/^\{.+\}$/)) continue;

                var key = name.replace(/^\{|\}$/g,''),
                    val = instanceOptions[name];

                // Augmented selector function
                if (isString(val)) {

                    var selectorFuncExtension = instance[key];

                    instance[key] = instance.selectors[key] = (function(instance, selector, funcName) {

                        // Selector shorthand for controllers
                        selector = /^(\.|\#)$/.test(selector) ? selector + funcName : selector;

                        // Create selector function
                        var selectorFunc = function(filter) {

                            var elements = (selectorFunc.baseElement || instance.element).find(selector);

                            if ($.isString(filter)) {
                                elements = elements.filter(filter);
                            }

                            if ($.isPlainObject(filter)) {
                                $.each(filter, function(key, val){
                                    elements = elements.filterBy(key, val);
                                });
                            }

                            return elements;
                        };

                        // Keep the selector as a property of the function
                        selectorFunc.selector = selector;

                        selectorFunc.css = function() {

                            var cssRule = selectorFunc.cssRule;

                            if (!cssRule) {

                                var directSelector = element.data("directSelector"),

                                    ruleSelector = $.map(selector.split(","), function(selector) {
                                                        return directSelector + " " + selector
                                                    });

                                cssRule = selectorFunc.cssRule = $.cssRule(ruleSelector);
                                cssRule.important = true;
                            }

                            return (arguments.length) ? cssRule.css.apply(cssRule, arguments) : cssRule;
                        };

                        selectorFunc.inside = function(el) {
                            return $(el).find(selector);
                        };

                        selectorFunc.of = function(el) {
                            return $(el).parents(selector).eq(0);
                        };

                        selectorFunc.under = function(el) {

                            var nodes = [];

                            selectorFunc().each(function(){
                                if ($(this).parents().filter(el).length) {
                                    nodes.push(this);
                                }
                            });

                            return $(nodes);
                        };
                        
                        if ($.isPlainObject(selectorFuncExtension)) {
                            $.extend(selectorFunc, selectorFuncExtension);
                        }

                        return selectorFunc;

                    })(instance, val, key);

                // Else just reference it, e.g. controller instance
                } else {

                    instance[key] = val;
                }
            }

            // !-- FOUNDRY HACK --! //
            // Augment view properties into view functions.
            // self.view.listItem(useHtml, data, callback);
            var views = instanceOptions.view;

            // Prevent augmented functions from being
            // extended onto the prototype view function.
            var __view = instance.view;

            instance.view = function() {
                return __view.apply(this, arguments);
            };

            each(views || {}, function(name, view){

                instance.view[name] = function(useHtml) {

                    var args = makeArray(arguments);

                    if ($.isBoolean(useHtml)) {
                        args = args.slice(1);
                    } else {
                        useHtml = false;
                    }

                    return instance.view.apply(instance, [useHtml, name].concat(args));
                }
            });

            // !-- FOUNDRY HACK --! //
            // Instance property override
            $.extend(instance, instanceOptions.controller);

            // !--- FOUNDRY HACK --! //
            instance.pluginInstances = {};

            /**
             * @attribute called
             * String name of current function being called on controller instance.  This is
             * used for picking the right view in render.
             * @hide
             */
            instance.called = "init";

            // bind all event handlers
            instance._bind();

            var __init = instance.init || $.noop;

            // !-- FOUNDRY HACK --! //
            // Trigger init event when controller is created.
            instance.init = function(){
                instance.init = __init;
                result = __init.apply(instance, arguments);
                instance.trigger("init." + Class.fullName.toLowerCase(), [instance]);
                return result;
            }

            /**
             * @attribute element
             * The controller instance's delegated element. This
             * is set by [jQuery.Controller.prototype.setup setup]. It
             * is a jQuery wrapped element.
             *
             * For example, if I add MyWidget to a '#myelement' element like:
             *
             *     $.Controller("MyWidget",{
             *       init : function(){
             *         this.element.css("color","red")
             *       }
             *     })
             *
             *     $("#myelement").my_widget()
             *
             * MyWidget will turn #myelement's font color red.
             *
             * ## Using a different element.
             *
             * Sometimes, you want a different element to be this.element.  A
             * very common example is making progressively enhanced form widgets.
             *
             * To change this.element, overwrite Controller's setup method like:
             *
             *     $.Controller("Combobox",{
             *       setup : function(el, options){
             *          this.oldElement = $(el);
             *          var newEl = $('<div/>');
             *          this.oldElement.wrap(newEl);
             *          this._super(newEl, options);
             *       },
             *       init : function(){
             *          this.element //-> the div
             *       },
             *       ".option click" : function(){
             *         // event handler bound on the div
             *       },
             *       destroy : function(){
             *          var div = this.element; //save reference
             *          this._super();
             *          div.replaceWith(this.oldElement);
             *       }
             *     }
             */
            return [element, instanceOptions].concat(makeArray(arguments).slice(2));
            /**
             * @function init
             *
             * Implement this.
             */
        },
        /**
         * Bind attaches event handlers that will be
         * removed when the controller is removed.
         *
         * This used to be a good way to listen to events outside the controller's
         * [jQuery.Controller.prototype.element element].  However,
         * using templated event listeners is now the prefered way of doing this.
         *
         * ### Example:
         *
         *     init: function() {
         *        // calls somethingClicked(el,ev)
         *        this.bind('click','somethingClicked')
         *
         *        // calls function when the window is clicked
         *        this.bind(window, 'click', function(ev){
         *          //do something
         *        })
         *     },
         *     somethingClicked: function( el, ev ) {
         *
         *     }
         *
         * @param {HTMLElement|jQuery.fn|Object} [el=this.element]
         * The element to be bound.  If an eventName is provided,
         * the controller's element is used instead.
         *
         * @param {String} eventName The event to listen for.
         * @param {Function|String} func A callback function or the String name of a controller function.  If a controller
         * function name is given, the controller function is called back with the bound element and event as the first
         * and second parameter.  Otherwise the function is called back like a normal bind.
         * @return {Integer} The id of the binding in this._bindings
         */

        on: function(eventName) {

            var args = makeArray(arguments),
                element = this.element,
                length = args.length;

            // Listen to the controller's element
            // on(eventName, eventHandler);
            if (length==2) {
                return this._binder(element, eventName, args[1]);
            }

            // Listen to controller's child elements matching the selector
            // on(eventName, selector, eventHandler);
            // args[1] == selector, jquery collection or dom node.
            // args[2] == eventHandler.
            if (length==3 && isString(args[1])) {
                return this._binder(element, eventName, args[2], args[1]);
            } else {
                return this._binder(args[1], eventName, args[2]);
            }

            // Listen to an element from another element
            // on(eventName, element, selector, eventHandler);
            if (length==4) {
                return this._binder($(args[1]), eventName, args[3], args[2]);
            }
        },

        // !-- FOUNDRY HACK --! //
        // Rename this.bind from this_bind. Conflict with mootools.
        // _bind: function( el, eventName, func ) {
        _bind: function() {

            var instance = this,
                Class    = instance[STR_CONSTRUCTOR],
                actions  = Class.actions,
                bindings = instance._bindings = [],
                element  = instance.element;

            each(actions || {}, function(name, action){

                if (!actions.hasOwnProperty(name)) return;

                var ready = Class.actions[name] || Class._action(name, instance.options);

                // Translate to the controller element first
                if ($.isControllerInstance(ready.delegate)) {
                    ready.delegate = ready.delegate.element;
                }

                bindings.push(
                    ready.processor(
                        ready.delegate || element,
                        ready.parts[2],
                        ready.parts[1],
                        name,
                        instance
                    )
                );
            });

            //setup to be destroyed ... don't bind b/c we don't want to remove it
            var destroyCB = shifter(this,"destroy");
            element.bind("destroyed", destroyCB);
            bindings.push(function( el ) {
                $(el).unbind("destroyed", destroyCB);
            });
            return bindings.length;
        },
        _binder: function( el, eventName, func, selector ) {
            if ( typeof func == 'string' ) {
                func = shifter(this,func);
            }
            this._bindings.push(binder(el, eventName, func, selector));
            return this._bindings.length;
        },
        _unbind : function(){
            var el = this.element[0];
            each(this._bindings, function( key, value ) {
                value(el);
            });
            //adds bindings
            this._bindings = [];
        },
        // !-- FOUNDRY HACK --! //
        // Element event triggering
        trigger: function(name) {

            var el = this.element;
            if (!el) return;

            var event = $.Event(name);
                el.trigger.apply(el, [event].concat($.makeArray(arguments).slice(1)));

            return event;
        },
        /**
         * Delegate will delegate on an elememt and will be undelegated when the controller is removed.
         * This is a good way to delegate on elements not in a controller's element.<br/>
         * <h3>Example:</h3>
         * @codestart
         * // calls function when the any 'a.foo' is clicked.
         * this.delegate(document.documentElement,'a.foo', 'click', function(ev){
         *   //do something
         * })
         * @codeend
         * @param {HTMLElement|jQuery.fn} [element=this.element] the element to delegate from
         * @param {String} selector the css selector
         * @param {String} eventName the event to bind to
         * @param {Function|String} func A callback function or the String name of a controller function.  If a controller
         * function name is given, the controller function is called back with the bound element and event as the first
         * and second parameter.  Otherwise the function is called back like a normal bind.
         * @return {Integer} The id of the binding in this._bindings
         */
        delegate: function( element, selector, eventName, func ) {
            if ( typeof element == 'string' ) {
                func = eventName;
                eventName = selector;
                selector = element;
                element = this.element;
            }
            return this._binder(element, eventName, func, selector);
        },
        /**
         * Update extends [jQuery.Controller.prototype.options this.options]
         * with the `options` argument and rebinds all events.  It basically
         * re-configures the controller.
         *
         * For example, the following controller wraps a recipe form. When the form
         * is submitted, it creates the recipe on the server.  When the recipe
         * is `created`, it resets the form with a new instance.
         *
         *     $.Controller('Creator',{
         *       "{recipe} created" : function(){
         *         this.update({recipe : new Recipe()});
         *         this.element[0].reset();
         *         this.find("[type=submit]").val("Create Recipe")
         *       },
         *       "submit" : function(el, ev){
         *         ev.preventDefault();
         *         var recipe = this.options.recipe;
         *         recipe.attrs( this.element.formParams() );
         *         this.find("[type=submit]").val("Saving...")
         *         recipe.save();
         *       }
         *     });
         *     $('#createRecipes').creator({recipe : new Recipe()})
         *
         *
         * @demo jquery/controller/demo-update.html
         *
         * Update is called if a controller's [jquery.controller.plugin jQuery helper] is
         * called on an element that already has a controller instance
         * of the same type.
         *
         * For example, a widget that listens for model updates
         * and updates it's html would look like.
         *
         *     $.Controller('Updater',{
         *       // when the controller is created, update the html
         *       init : function(){
         *         this.updateView();
         *       },
         *
         *       // update the html with a template
         *       updateView : function(){
         *         this.element.html( "content.ejs",
         *                            this.options.model );
         *       },
         *
         *       // if the model is updated
         *       "{model} updated" : function(){
         *         this.updateView();
         *       },
         *       update : function(options){
         *         // make sure you call super
         *         this._super(options);
         *
         *         this.updateView();
         *       }
         *     })
         *
         *     // create the controller
         *     // this calls init
         *     $('#item').updater({model: recipe1});
         *
         *     // later, update that model
         *     // this calls "{model} updated"
         *     recipe1.update({name: "something new"});
         *
         *     // later, update the controller with a new recipe
         *     // this calls update
         *     $('#item').updater({model: recipe2});
         *
         *     // later, update the new model
         *     // this calls "{model} updated"
         *     recipe2.update({name: "something newer"});
         *
         * _NOTE:_ If you overwrite `update`, you probably need to call
         * this._super.
         *
         * ### Example
         *
         *     $.Controller("Thing",{
         *       init: function( el, options ) {
         *         alert( 'init:'+this.options.prop )
         *       },
         *       update: function( options ) {
         *         this._super(options);
         *         alert('update:'+this.options.prop)
         *       }
         *     });
         *     $('#myel').thing({prop : 'val1'}); // alerts init:val1
         *     $('#myel').thing({prop : 'val2'}); // alerts update:val2
         *
         * @param {Object} options A list of options to merge with
         * [jQuery.Controller.prototype.options this.options].  Often, this method
         * is called by the [jquery.controller.plugin jQuery helper function].
         */
        update: function( options ) {
            extend(this.options, options);
            this._unbind();
            this._bind();
        },
        /**
         * Destroy unbinds and undelegates all event handlers on this controller,
         * and prevents memory leaks.  This is called automatically
         * if the element is removed.  You can overwrite it to add your own
         * teardown functionality:
         *
         *     $.Controller("ChangeText",{
         *       init : function(){
         *         this.oldText = this.element.text();
         *         this.element.text("Changed!!!")
         *       },
         *       destroy : function(){
         *         this.element.text(this.oldText);
         *         this._super(); //Always call this!
         *     })
         *
         * Make sure you always call <code>_super</code> when overwriting
         * controller's destroy event.  The base destroy functionality unbinds
         * all event handlers the controller has created.
         *
         * You could call destroy manually on an element with ChangeText
         * added like:
         *
         *     $("#changed").change_text("destroy");
         *
         */
        destroy: function() {

            if ( this._destroyed ) {
                return;
            }
            var fname = this[STR_CONSTRUCTOR]._fullName,
                controllers;

            // remove all plugins
            for (pname in this.pluginInstances) {
                this.removePlugin(pname);
            }

            // mark as destroyed
            this._destroyed = true;

            // remove the className
            this.element.removeClass(fname);

            // unbind bindings
            this._unbind();
            // clean up
            delete this._actions;

            delete this.element.data("controllers")[fname];

            $(this).triggerHandler("destroyed"); //in case we want to know if the controller is removed

            // !-- FOUNDRY HACK --! //
            // Reassign this.element to an empty jQuery element instead.
            this.element = $();
        },
        /**
         * Queries from the controller's element.
         * @codestart
         * ".destroy_all click" : function() {
         *    this.find(".todos").remove();
         * }
         * @codeend
         * @param {String} selector selection string
         * @return {jQuery.fn} returns the matched elements
         */
        find: function( selector ) {
            return this.element.find(selector);
        },

        // !-- FOUNDRY HACK --! //
        // Quick acccess to views.
        view: function() {

            var args = makeArray(arguments),
                name,
                options = args,
                useHtml = false,
                context = this[STR_CONSTRUCTOR].component || $,
                html = "",
                view = this.options.view || {};

            if (typeof args[0] == "boolean") {
                useHtml = args[0];
                options = args.slice(1);
            }

            name = options[0] = view[options[0]];

            // If view is not assigned, return empty string.
            if (name==undefined) {
                return (useHtml) ? "" : $("");
            }

            html = context.View.apply(context, options);

            return (useHtml) ? html : $($.parseHTML($.trim(html)));
        },

        getPlugin: function(name) {

            return this.pluginInstances[name];
        },

        addSubscriber: function(instance) {

            var instances = ($.isArray(instance)) ? instance : [instance || {}];

            // Prep options
            var host = this,
                hostname = this.Class.hostname,
                options = {};
                options["{" + hostname + "}"] = host;

            $.map(instances, function(instance, i){

                // If this is not a controller instance.
                if (!$.isControllerInstance(instance)) return false;

                // If instance is already a subscriber,skip.
                if (instance.options[hostname]===this) return instance;

                // Also map itself as a method name
                instance[hostname] = host;

                // Attach publisher to subscriber
                return instance.update(options);
            });

            return instances;
        },

        // addPlugin(name, object, [options]);
        // The object should consist of a method called destroy();

        // addPlugin(name, function, [options]);
        // The function should return an object with a method called destroy();

        addPlugin: function(name, plugin, options) {

            if (!name) return;

            // This means we are working with plugin shorthand
            if ((!plugin && !options) || $.isPlainObject(plugin)) {
                options = plugin;
                plugin = [this.Class.root, this.Class.fullName, $.String.capitalize(name)].join(".");
            }

            // If plugin is a string, get the controller from it.
            if ($.isString(plugin)) {
                plugin = $.getController(plugin);
            }

            var isPluginInstance = $.isControllerInstance(plugin);

            // Controller class are also functions,
            // so this simple test is good enough.
            if (!isFunction(plugin) && !isPluginInstance) return;

            // Normalize plugin options
            var pluginOptions =
                this.Class.pluginExtendsInstance ?
                    this.options[name] :
                    (this.options.plugin || {})[name];

            options = $.extend(true, {element: this.element}, options, pluginOptions);

            // Determine plugin type
            var type =
                ((isPluginInstance) ? "instance" :
                (($.isController(plugin)) ? "controller" : "function"));

            // Trigger addPlugin event so controller can decorate the options
            this.trigger("addPlugin", [name, plugin, options, type]);

            var hostname = this.Class.hostname;

            // Subcontrollers should have a way to listen back to host controller
            options["{" + hostname + "}"] = this;

            var pluginInstance;

            switch(type) {

                // Plugin instance
                case "instance":

                    pluginInstance = plugin;

                    // Update child plugin with custom plugin options from host
                    plugin.update(options);

                    plugin[hostname] = this;
                    break;

                // Plugin controller
                case "controller":
                    pluginInstance = options.element.addController(plugin, options);
                    break;

                // Plugin function
                case "function":
                    pluginInstance = plugin(this, options);
                    break;
            }

            // If pluginInstance could not be created, stop.
            if (!pluginInstance) return;

            // Register plugin
            this.pluginInstances[name] = pluginInstance;

            // Also extend instance with a property point to the plugin
            if (this.Class.pluginExtendsInstance) {
                this[name] = pluginInstance;
            }

            // Host controller should also have a way to listen back to the child controller
            if (type!=="function") {

                var hostOptions = {};
                hostOptions["{" + name + "}"] = pluginInstance;

                this.update(hostOptions);
            }

            // Trigger registerPlugin
            this.trigger("registerPlugin", [name, pluginInstance, options, type]);

            return pluginInstance;
        },

        removePlugin: function(name) {

            var plugin = this.getPlugin(name);

            if (!plugin) return;

            // Trigger removePlugin
            this.trigger("removePlugin", [name, plugin]);

            delete this.pluginInstances[name];

            return $.isFunction(plugin.destroy) ? plugin.destroy() : null;
        },

        invokePlugin: function(name, method, args) {

            var plugin = this.getPlugin(name);

            // If plugin not exist, stop.
            if (!plugin) return;

            // If plugin method not exist, stop.
            if (!$.isFunction(plugin[method])) return;

            // Let any third party modify the arguments if required
            this.trigger("invokePlugin", [name, plugin, args]);

            return plugin[method].apply(this, args);
        },

        getMessageGroup: function() {

            // Find parent element
            var messageGroup = ($.isFunction(this.messageGroup)) ? this.messageGroup() : this.element.find("[data-message-group]");

            if (messageGroup.length < 1) {
                messageGroup = $("<div data-message-group></div>").prependTo(this.element);
            }

            return messageGroup;
        },

        setMessage: function(message, type) {

            // Normalize arguments
            var defaultOptions = {
                    type   : "warning", // type: info, error, success
                    message: "",
                    parent : this.getMessageGroup(),
                    element: $('<div class="o-alert o-alert--dismissible"><button type="button" class="o-alert__close" data-bs-dismiss="alert">×</button></div>')
                },
                userOptions = {},
                isDeferred = $.isDeferred(message);

            // Normalize user options
            if ($.isPlainObject(message) && !isDeferred) {
                userOptions = message;
            } else {
                userOptions = {
                    message: message,
                    type   : type || "warning"
                }
            }

            var options = $.extend({}, defaultOptions, userOptions),
                element = options.element;

            if ($.isDeferred(message)) {

                var myself = arguments.callee,
                    context = this;

                message.done(function(message, type) {
                    options.message = message;
                    options.type = type || "warning";
                    myself.call(context, options);
                    element.show();
                });

            } else {

                element
                    .addClass("o-alert--" + options.type)
                    .append(options.message);

                if ($('html').has(element).length < 1) {
                    element.appendTo(options.parent);
                }
            }

            return element;
        },

        clearMessage: function() {

            this.getMessageGroup().empty();
        },

        //tells callback to set called on this.  I hate this.
        _set_called: true
    });

    var processors = $.Controller.Class.processors,

    //------------- PROCESSSORS -----------------------------
    //processors do the binding.  They return a function that
    //unbinds when called.
    //the basic processor that binds events
    basicProcessor = function( el, event, selector, methodName, controller ) {

        // !-- FOUNDRY HACK --! //
        // Support for passing event data

        var method = controller[methodName],
            eventData;

        if (isArray(method) && isFunction(method[1])) {
            eventData = method[0];
        }

        return binder(el, event, shifter(controller, methodName), selector, eventData);
    };


    //set common events to be processed as a basicProcessor
    each("change click contextmenu dblclick keydown keyup keypress mousedown mousemove mouseout mouseover mouseup reset resize scroll select submit focusin focusout mouseenter mouseleave".split(" "), function( i, v ) {
        processors[v] = basicProcessor;
    });
    /**
     *  @add jQuery.fn
     */

    //used to determine if a controller instance is one of controllers
    //controllers can be strings or classes

    var normalizeController = function(controller) {
        return controller.replace("$.Controller", controllerRoot);
    }

    var getController = function(controller) {
        if (isString(controller)) {
            controller = normalizeController(controller);
            controller = getObject(controller) || getObject(controllerRoot + "." + controller);
        };
        if (isController(controller)) {
            return controller;
        };
    }

    var isController = function(controller) {
        return isFunction(controller) && controller.hasOwnProperty("_fullName");
    }

    var flattenControllers = function(controllers) {
        return $.map(controllers, function(controller){
            return (isArray(controller)) ? flattenControllers(controller) : getController(controller);
        });
    };

    $.getController = getController;

    $.isController = function(controller) {
        return !!getController(controller);
    }

    $.isControllerInstance = function(instance) {
        return instance && instance[STR_CONSTRUCTOR] && isController(instance[STR_CONSTRUCTOR]);
    }

    $.isControllerOf = function(instance, controllers) {

        if (!controllers) return false;

        if (!isArray(controllers)) {
            controllers = [controllers];
        }

        for (var i=0; i<controllers.length; i++) {
            var controller = getController(controllers[i]);
            if (instance instanceof controller) return true;
        }

        return false;
    };

    $.fn.extend({
        /**
         * @function controllers
         * Gets all controllers in the jQuery element.
         * @return {Array} an array of controller instances.
         */
        controllers: function() {

            var candidates = flattenControllers(makeArray(arguments)),
                instances = [];

            this.each(function() {

                var controllers = $.data(this, "controllers");

                each(controllers || {}, function(_fullName, instance){

                    if (!controllers.hasOwnProperty(_fullName)) return;

                    if (!candidates.length || $.isControllerOf(instance, candidates)) {
                        instances.push(instance);
                    }
                });
            });

            return instances;
        },

        /**
         * @function controller
         * Gets a controller in the jQuery element.  With no arguments, returns the first one found.
         * @param {Object} controller (optional) if exists, the first controller instance with this class type will be returned.
         * @return {jQuery.Controller} the first controller.
         */
        controller: function(controller, options) {

            // Getter
            if (options===undefined) {
                return this.controllers(controller)[0];
            }

            // Setter
            this.addController.apply(this, arguments);
            return this;
        },

        hasController: function(controller) {

            var _fullName =
                (getController(controller) || {})._fullName ||
                (isString(controller) ? underscoreAndRemoveController(normalizeController(controller)) : "");

            return (!_fullName) ? false : (($(this).data("controllers") || {}).hasOwnProperty(_fullName));
        },

        addController: function(controller, options, callback) {

            var Controller = getController(controller);

            if (!Controller) return;

            var instances = [];

            this.each(function(){

                // Do not add controller on script node or non-element nodes.
                if (this.nodeType!==1 || this.nodeName=="SCRIPT") return;

                // Just return existing instance
                var existingInstance = $(this).controller(controller);
                if (existingInstance) {
                    instances.push(existingInstance);
                    return;
                }

                // Or create a new instance
                var instance = new Controller(this, options);
                isFunction(callback) && callback.apply(instance, [$(this), instance]);
                instances.push(instance);
            });

            return (instances.length > 1) ? instances : instances[0];
        },

        removeController: function(controller) {
            this.each(function(){
                var instances = $(this).controllers(controller);
                while (instances.length) {
                    instances.shift().destroy();
                }
            });
            return this;
        },

        addControllerWhenAvailable: function(controller) {

            var elements = this,
                args = arguments,
                task = $.Deferred();

            if ($.isController(controller)) {
                controller = controller.fullName;
            }

            if (!isString(controller)) {
                return task.reject();
            }

            $.module("$:/Controllers/" + controller)
                .pipe(
                    function(){
                        var instance = elements.addController.apply(elements, args);
                        task.resolveWith(instance, [elements, instance]);
                    },
                    task.reject,
                    task.fail
                );

            return task;
        },

        // @deprecated 2.2
        implement: function() {
            this.addController.apply(this, arguments);
            return this;
        }

    });

    // !-- FOUNDRY HACK --! //
    // Add support for augmented selector function on jQuery's DOM traversal/filtering methods.
    (function(){
    var fns = ["is", "find"],
        _fns = {},
        fn;

    while (fn = fns.shift()) {
        _fns[fn] = $.fn[fn];
        $.fn[fn] = (function(fn) {
            return function(obj) {
                return _fns[fn].apply(this, (obj || {}).hasOwnProperty("of") ? [obj.selector] : arguments);
            }
        })(fn);
    }
    })();

})();(function(){

    // a path like string into something that's ok for an element ID
    var toId = function( src ) {
        return src.replace(/^\/\//, "").replace(/[\/\.]/g, "_");
    },
        makeArray = $.makeArray,
        // used for hookup ids
        id = 1;
    // this might be useful for testing if html
    // htmlTest = /^[\s\n\r\xA0]*<(.|[\r\n])*>[\s\n\r\xA0]*$/
    /**
     * @class jQuery.View
     * @parent jquerymx
     * @plugin jquery/view
     * @test jquery/view/qunit.html
     * @download dist/jquery.view.js
     *
     * @description A JavaScript template framework.
     *
     * View provides a uniform interface for using templates with
     * jQuery. When template engines [jQuery.View.register register]
     * themselves, you are able to:
     *
     *  - Use views with jQuery extensions [jQuery.fn.after after], [jQuery.fn.append append],
     *   [jQuery.fn.before before], [jQuery.fn.html html], [jQuery.fn.prepend prepend],
     *   [jQuery.fn.replaceWith replaceWith], [jQuery.fn.text text].
     *  - Template loading from html elements and external files.
     *  - Synchronous and asynchronous template loading.
     *  - [view.deferreds Deferred Rendering].
     *  - Template caching.
     *  - Bundling of processed templates in production builds.
     *  - Hookup jquery plugins directly in the template.
     *
     * The [mvc.view Get Started with jQueryMX] has a good walkthrough of $.View.
     *
     * ## Use
     *
     *
     * When using views, you're almost always wanting to insert the results
     * of a rendered template into the page. jQuery.View overwrites the
     * jQuery modifiers so using a view is as easy as:
     *
     *     $("#foo").html('mytemplate.ejs',{message: 'hello world'})
     *
     * This code:
     *
     *  - Loads the template a 'mytemplate.ejs'. It might look like:
     *    <pre><code>&lt;h2>&lt;%= message %>&lt;/h2></pre></code>
     *
     *  - Renders it with {message: 'hello world'}, resulting in:
     *    <pre><code>&lt;div id='foo'>"&lt;h2>hello world&lt;/h2>&lt;/div></pre></code>
     *
     *  - Inserts the result into the foo element. Foo might look like:
     *    <pre><code>&lt;div id='foo'>&lt;h2>hello world&lt;/h2>&lt;/div></pre></code>
     *
     * ## jQuery Modifiers
     *
     * You can use a template with the following jQuery modifiers:
     *
     * <table>
     * <tr><td>[jQuery.fn.after after]</td><td> <code>$('#bar').after('temp.jaml',{});</code></td></tr>
     * <tr><td>[jQuery.fn.append append] </td><td>  <code>$('#bar').append('temp.jaml',{});</code></td></tr>
     * <tr><td>[jQuery.fn.before before] </td><td> <code>$('#bar').before('temp.jaml',{});</code></td></tr>
     * <tr><td>[jQuery.fn.html html] </td><td> <code>$('#bar').html('temp.jaml',{});</code></td></tr>
     * <tr><td>[jQuery.fn.prepend prepend] </td><td> <code>$('#bar').prepend('temp.jaml',{});</code></td></tr>
     * <tr><td>[jQuery.fn.replaceWith replaceWith] </td><td> <code>$('#bar').replaceWith('temp.jaml',{});</code></td></tr>
     * <tr><td>[jQuery.fn.text text] </td><td> <code>$('#bar').text('temp.jaml',{});</code></td></tr>
     * </table>
     *
     * You always have to pass a string and an object (or function) for the jQuery modifier
     * to user a template.
     *
     * ## Template Locations
     *
     * View can load from script tags or from files.
     *
     * ## From Script Tags
     *
     * To load from a script tag, create a script tag with your template and an id like:
     *
     * <pre><code>&lt;script type='text/ejs' id='recipes'>
     * &lt;% for(var i=0; i &lt; recipes.length; i++){ %>
     *   &lt;li>&lt;%=recipes[i].name %>&lt;/li>
     * &lt;%} %>
     * &lt;/script></code></pre>
     *
     * Render with this template like:
     *
     * @codestart
     * $("#foo").html('recipes',recipeData)
     * @codeend
     *
     * Notice we passed the id of the element we want to render.
     *
     * ## From File
     *
     * You can pass the path of a template file location like:
     *
     *     $("#foo").html('templates/recipes.ejs',recipeData)
     *
     * However, you typically want to make the template work from whatever page they
     * are called from.  To do this, use // to look up templates from JMVC root:
     *
     *     $("#foo").html('//app/views/recipes.ejs',recipeData)
     *
     * Finally, the [jQuery.Controller.prototype.view controller/view] plugin can make looking
     * up a thread (and adding helpers) even easier:
     *
     *     $("#foo").html( this.view('recipes', recipeData) )
     *
     * ## Packaging Templates
     *
     * If you're making heavy use of templates, you want to organize
     * them in files so they can be reused between pages and applications.
     *
     * But, this organization would come at a high price
     * if the browser has to
     * retrieve each template individually. The additional
     * HTTP requests would slow down your app.
     *
     * Fortunately, [steal.static.views steal.views] can build templates
     * into your production files. You just have to point to the view file like:
     *
     *     steal.views('path/to/the/view.ejs');
     *
     * ## Asynchronous
     *
     * By default, retrieving requests is done synchronously. This is
     * fine because StealJS packages view templates with your JS download.
     *
     * However, some people might not be using StealJS or want to delay loading
     * templates until necessary. If you have the need, you can
     * provide a callback paramter like:
     *
     *     $("#foo").html('recipes',recipeData, function(result){
     *       this.fadeIn()
     *     });
     *
     * The callback function will be called with the result of the
     * rendered template and 'this' will be set to the original jQuery object.
     *
     * ## Deferreds (3.0.6)
     *
     * If you pass deferreds to $.View or any of the jQuery
     * modifiers, the view will wait until all deferreds resolve before
     * rendering the view.  This makes it a one-liner to make a request and
     * use the result to render a template.
     *
     * The following makes a request for todos in parallel with the
     * todos.ejs template.  Once todos and template have been loaded, it with
     * render the view with the todos.
     *
     *     $('#todos').html("todos.ejs",Todo.findAll());
     *
     * ## Just Render Templates
     *
     * Sometimes, you just want to get the result of a rendered
     * template without inserting it, you can do this with $.View:
     *
     *     var out = $.View('path/to/template.jaml',{});
     *
     * ## Preloading Templates
     *
     * You can preload templates asynchronously like:
     *
     *     $.get('path/to/template.jaml',{},function(){},'view');
     *
     * ## Supported Template Engines
     *
     * JavaScriptMVC comes with the following template languages:
     *
     *   - EmbeddedJS
     *     <pre><code>&lt;h2>&lt;%= message %>&lt;/h2></code></pre>
     *
     *   - JAML
     *     <pre><code>h2(data.message);</code></pre>
     *
     *   - Micro
     *     <pre><code>&lt;h2>{%= message %}&lt;/h2></code></pre>
     *
     *   - jQuery.Tmpl
     *     <pre><code>&lt;h2>${message}&lt;/h2></code></pre>

     *
     * The popular <a href='http://awardwinningfjords.com/2010/08/09/mustache-for-javascriptmvc-3.html'>Mustache</a>
     * template engine is supported in a 2nd party plugin.
     *
     * ## Using other Template Engines
     *
     * It's easy to integrate your favorite template into $.View and Steal.  Read
     * how in [jQuery.View.register].
     *
     * @constructor
     *
     * Looks up a template, processes it, caches it, then renders the template
     * with data and optional helpers.
     *
     * With [stealjs StealJS], views are typically bundled in the production build.
     * This makes it ok to use views synchronously like:
     *
     * @codestart
     * $.View("//myplugin/views/init.ejs",{message: "Hello World"})
     * @codeend
     *
     * If you aren't using StealJS, it's best to use views asynchronously like:
     *
     * @codestart
     * $.View("//myplugin/views/init.ejs",
     *        {message: "Hello World"}, function(result){
     *   // do something with result
     * })
     * @codeend
     *
     * @param {String} view The url or id of an element to use as the template's source.
     * @param {Object} data The data to be passed to the view.
     * @param {Object} [helpers] Optional helper functions the view might use. Not all
     * templates support helpers.
     * @param {Object} [callback] Optional callback function.  If present, the template is
     * retrieved asynchronously.  This is a good idea if you aren't compressing the templates
     * into your view.
     * @return {String} The rendered result of the view or if deferreds
     * are passed, a deferred that will resolve to
     * the rendered result of the view.
     */
    var $view = $.View = function( view, data, helpers, callback ) {
        // if helpers is a function, it is actually a callback
        if ( typeof helpers === 'function' ) {
            callback = helpers;
            helpers = undefined;
        }

        // see if we got passed any deferreds
        var deferreds = getDeferreds(data);


        if ( deferreds.length ) { // does data contain any deferreds?
            // the deferred that resolves into the rendered content ...
            var deferred = $.Deferred();

            // add the view request to the list of deferreds
            deferreds.push(get(view, true))

            // wait for the view and all deferreds to finish
            $.when.apply($, deferreds).then(function( resolved ) {
                // get all the resolved deferreds
                var objs = makeArray(arguments),
                    // renderer is last [0] is the data
                    renderer = objs.pop()[0],
                    // the result of the template rendering with data
                    result;

                // make data look like the resolved deferreds
                if ( isDeferred(data) ) {
                    data = usefulPart(resolved);
                }
                else {
                    // go through each prop in data again,
                    // replace the defferreds with what they resolved to
                    for ( var prop in data ) {
                        if ( isDeferred(data[prop]) ) {
                            data[prop] = usefulPart(objs.shift());
                        }
                    }
                }
                // get the rendered result
                result = renderer(data, helpers);

                //resolve with the rendered view
                deferred.resolve(result);
                // if there's a callback, call it back with the result
                callback && callback(result);
            });
            // return the deferred ....
            return deferred.promise();
        }
        else {
            // no deferreds, render this bad boy
            var response,
                // if there's a callback function
                async = typeof callback === "function",
                // get the 'view' type
                deferred = get(view, async);

            // if we are async,
            if ( async ) {
                // return the deferred
                response = deferred;
                // and callback callback with the rendered result
                deferred.done(function( renderer ) {
                    callback(renderer(data, helpers))
                })
            } else {
                // otherwise, the deferred is complete, so
                // set response to the result of the rendering
                deferred.done(function( renderer ) {
                    response = renderer(data, helpers);
                });
            }

            return response;
        }
    },
        // makes sure there's a template, if not, has steal provide a warning
        checkText = function( text, url ) {
            if (!text.match(/[^\s]/) ) {
                
                throw "$.View ERROR: There is no template or an empty template at " + url;
            }
        },
        // returns a 'view' renderer deferred
        // url - the url to the view template
        // async - if the ajax request should be synchronous
        get = function( url, async ) {
            return $.ajax({
                url: url,
                dataType: "view",
                async: async
            });
        },
        // returns true if something looks like a deferred
        isDeferred = function( obj ) {
            return obj && $.isFunction(obj.always) // check if obj is a $.Deferred
        },
        // gets an array of deferreds from an object
        // this only goes one level deep
        getDeferreds = function( data ) {
            var deferreds = [];

            // pull out deferreds
            if ( isDeferred(data) ) {
                return [data]
            } else {
                for ( var prop in data ) {
                    if ( isDeferred(data[prop]) ) {
                        deferreds.push(data[prop]);
                    }
                }
            }
            return deferreds;
        },
        // gets the useful part of deferred
        // this is for Models and $.ajax that resolve to array (with success and such)
        // returns the useful, content part
        usefulPart = function( resolved ) {
            return $.isArray(resolved) && resolved.length === 3 && resolved[1] === 'success' ? resolved[0] : resolved
        };



    // you can request a view renderer (a function you pass data to and get html)
    // Creates a 'view' transport.  These resolve to a 'view' renderer
    // a 'view' renderer takes data and returns a string result.
    // For example:
    //
    //  $.ajax({dataType : 'view', src: 'foo.ejs'}).then(function(renderer){
    //     renderer({message: 'hello world'})
    //  })
    $.ajaxTransport("view", function( options, orig ) {
        // the url (or possibly id) of the view content
        var url = orig.url,
            // check if a suffix exists (ex: "foo.ejs")
            suffix = url.match(/\.[\w\d]+$/),
            type,
            // if we are reading a script element for the content of the template
            // el will be set to that script element
            el,
            // a unique identifier for the view (used for caching)
            // this is typically derived from the element id or
            // the url for the template
            id,
            // the AJAX request used to retrieve the template content
            jqXHR,

            // used to generate the response
            response = function( text ) {
                // get the renderer function
                var func = type.renderer(id, text);
                // cache if if we are caching
                if ( $view.cache ) {
                    $view.cached[id] = func;
                }
                // return the objects for the response's dataTypes
                // (in this case view)
                return {
                    view: func
                };
            };

        // if we have an inline template, derive the suffix from the 'text/???' part
        // this only supports '<script></script>' tags
        if ( el = document.getElementById(url) ) {
            suffix = "."+el.type.match(/\/(x\-)?(.+)/)[2];
        }

        // if there is no suffix, add one
        if (!suffix ) {
            suffix = $view.ext;
            url = url + $view.ext;
        }

        // convert to a unique and valid id
        id = toId(url);

        // if a absolute path, use steal to get it
        // you should only be using // if you are using steal
        if ( url.match(/^\/\//) ) {
            var sub = url.substr(2);
            url = typeof steal === "undefined" ?
                url = "/" + sub :
                steal.root.mapJoin(sub) +'';
        }

        //set the template engine type
        type = $view.types[suffix];

        // !-- FOUNDRY HACK --! //
        // Retrieve templates stored within $.template
        var template = $.template()[orig.url];

        // return the ajax transport contract: http://api.jquery.com/extending-ajax/
        return {
            send: function( headers, callback ) {

                // !-- FOUNDRY HACK --! //
                // Retrieve templates stored within $.template
                if ( template ) {

                    type = $view.types["." + template.type];

                    return callback(200, "success", response(template.content));

                // if it is cached,
                } else if ( $view.cached[id] ) {

                    // return the catched renderer
                    return callback(200, "success", {
                        view: $view.cached[id]
                    });

                // otherwise if we are getting this from a script elment
                } else if ( el ) {
                    // resolve immediately with the element's innerHTML
                    callback(200, "success", response(el.innerHTML));
                } else {
                    // make an ajax request for text
                    jqXHR = $.ajax({
                        async: orig.async,
                        url: url,
                        dataType: "text",
                        error: function() {
                            checkText("", url);
                            callback(404);
                        },
                        success: function( text ) {
                            // make sure we got some text back
                            checkText(text, url);
                            // cache and send back text
                            callback(200, "success", response(text))
                        }
                    });
                }
            },
            abort: function() {
                jqXHR && jqXHR.abort();
            }
        }
    })
    $.extend($view, {
        /**
         * @attribute hookups
         * @hide
         * A list of pending 'hookups'
         */
        hookups: {},
        /**
         * @function hookup
         * Registers a hookup function that can be called back after the html is
         * put on the page.  Typically this is handled by the template engine.  Currently
         * only EJS supports this functionality.
         *
         *     var id = $.View.hookup(function(el){
         *            //do something with el
         *         }),
         *         html = "<div data-view-id='"+id+"'>"
         *     $('.foo').html(html);
         *
         *
         * @param {Function} cb a callback function to be called with the element
         * @param {Number} the hookup number
         */
        hookup: function( cb ) {
            var myid = ++id;
            $view.hookups[myid] = cb;
            return myid;
        },
        /**
         * @attribute cached
         * @hide
         * Cached are put in this object
         */
        cached: {},
        /**
         * @attribute cache
         * Should the views be cached or reloaded from the server. Defaults to true.
         */
        cache: true,
        /**
         * @function register
         * Registers a template engine to be used with
         * view helpers and compression.
         *
         * ## Example
         *
         * @codestart
         * $.View.register({
         *  suffix : "tmpl",
         *  plugin : "jquery/view/tmpl",
         *  renderer: function( id, text ) {
         *      return function(data){
         *          return jQuery.render( text, data );
         *      }
         *  },
         *  script: function( id, text ) {
         *      var tmpl = $.tmpl(text).toString();
         *      return "function(data){return ("+
         *          tmpl+
         *          ").call(jQuery, jQuery, data); }";
         *  }
         * })
         * @codeend
         * Here's what each property does:
         *
         *    * plugin - the location of the plugin
         *    * suffix - files that use this suffix will be processed by this template engine
         *    * renderer - returns a function that will render the template provided by text
         *    * script - returns a string form of the processed template function.
         *
         * @param {Object} info a object of method and properties
         *
         * that enable template integration:
         * <ul>
         *   <li>plugin - the location of the plugin.  EX: 'jquery/view/ejs'</li>
         *   <li>suffix - the view extension.  EX: 'ejs'</li>
         *   <li>script(id, src) - a function that returns a string that when evaluated returns a function that can be
         *    used as the render (i.e. have func.call(data, data, helpers) called on it).</li>
         *   <li>renderer(id, text) - a function that takes the id of the template and the text of the template and
         *    returns a render function.</li>
         * </ul>
         */
        register: function( info ) {
            this.types["." + info.suffix] = info;

            if ( window.steal ) {
                steal.type(info.suffix + " view js", function( options, success, error ) {
                    var type = $view.types["." + options.type],
                        id = toId(options.rootSrc+'');

                    options.text = type.script(id, options.text)
                    success();
                })
            }
        },
        types: {},
        /**
         * @attribute ext
         * The default suffix to use if none is provided in the view's url.
         * This is set to .ejs by default.
         */
        ext: ".ejs",
        /**
         * Returns the text that
         * @hide
         * @param {Object} type
         * @param {Object} id
         * @param {Object} src
         */
        registerScript: function( type, id, src ) {
            return "$.View.preload('" + id + "'," + $view.types["." + type].script(id, src) + ");";
        },
        /**
         * @hide
         * Called by a production script to pre-load a renderer function
         * into the view cache.
         * @param {String} id
         * @param {Function} renderer
         */
        preload: function( id, renderer ) {
            $view.cached[id] = function( data, helpers ) {
                return renderer.call(data, data, helpers);
            };
        }

    });
    if ( window.steal ) {
        steal.type("view js", function( options, success, error ) {
            var type = $view.types["." + options.type],
                id = toId(options.rootSrc+'');

            options.text = "steal('" + (type.plugin || "jquery/view/" + options.type) + "').then(function($){" + "$.View.preload('" + id + "'," + options.text + ");\n})";
            success();
        })
    }

    //---- ADD jQUERY HELPERS -----
    //converts jquery functions to use views
    var convert, modify, isTemplate, isHTML, isDOM, getCallback, hookupView, funcs,
        // text and val cannot produce an element, so don't run hookups on them
        noHookup = {'val':true,'text':true};

    convert = function( func_name ) {
        // save the old jQuery helper
        var old = $.fn[func_name];

        // replace it wiht our new helper
        $.fn[func_name] = function() {

            var args = makeArray(arguments),
                callbackNum,
                callback,
                self = this,
                result;

            // if the first arg is a deferred
            // wait until it finishes, and call
            // modify with the result
            if ( isDeferred(args[0]) ) {
                args[0].done(function( res ) {
                    modify.call(self, [res], old);
                })
                return this;
            }
            //check if a template
            else if ( isTemplate(args) ) {

                // if we should operate async
                if ((callbackNum = getCallback(args))) {
                    callback = args[callbackNum];
                    args[callbackNum] = function( result ) {
                        modify.call(self, [result], old);
                        callback.call(self, result);
                    };
                    $view.apply($view, args);
                    return this;
                }
                // call view with args (there might be deferreds)
                result = $view.apply($view, args);

                // if we got a string back
                if (!isDeferred(result) ) {
                    // we are going to call the old method with that string
                    args = [result];
                } else {
                    // if there is a deferred, wait until it is done before calling modify
                    result.done(function( res ) {
                        modify.call(self, [res], old);
                    })
                    return this;
                }
            }
            return noHookup[func_name] ? old.apply(this,args) :
                modify.call(this, args, old);
        };
    };

    // modifies the content of the element
    // but also will run any hookup
    modify = function( args, old ) {
        var res, stub, hooks;

        //check if there are new hookups
        for ( var hasHookups in $view.hookups ) {
            break;
        }

        //if there are hookups, get jQuery object
        if ( hasHookups && args[0] && isHTML(args[0]) ) {
            hooks = $view.hookups;
            $view.hookups = {};
            args[0] = $(args[0]);
        }
        res = old.apply(this, args);

        //now hookup the hookups
        if ( hooks
        /* && args.length*/
        ) {
            hookupView(args[0], hooks);
        }
        return res;
    };

    // returns true or false if the args indicate a template is being used
    // $('#foo').html('/path/to/template.ejs',{data})
    // in general, we want to make sure the first arg is a string
    // and the second arg is data
    isTemplate = function( args ) {
        // save the second arg type
        var secArgType = typeof args[1];

        // the first arg is a string
        return typeof args[0] == "string" &&
                // the second arg is an object or function
               (secArgType == 'object' || secArgType == 'function') &&
               // but it is not a dom element
               !isDOM(args[1]);
    };
    // returns true if the arg is a jQuery object or HTMLElement
    isDOM = function(arg){
        return arg.nodeType || arg.jquery
    };
    // returns whether the argument is some sort of HTML data
    isHTML = function( arg ) {
        if ( isDOM(arg) ) {
            // if jQuery object or DOM node we're good
            return true;
        } else if ( typeof arg === "string" ) {
            // if string, do a quick sanity check that we're HTML
            arg = $.trim(arg);
            return arg.substr(0, 1) === "<" && arg.substr(arg.length - 1, 1) === ">" && arg.length >= 3;
        } else {
            // don't know what you are
            return false;
        }
    };

    //returns the callback arg number if there is one (for async view use)
    getCallback = function( args ) {
        return typeof args[3] === 'function' ? 3 : typeof args[2] === 'function' && 2;
    };

    hookupView = function( els, hooks ) {
        //remove all hookups
        var hookupEls, len, i = 0,
            id, func;
        els = els.filter(function() {
            return this.nodeType != 3; //filter out text nodes
        })
        hookupEls = els.add("[data-view-id]", els);
        len = hookupEls.length;
        for (; i < len; i++ ) {
            if ( hookupEls[i].getAttribute && (id = hookupEls[i].getAttribute('data-view-id')) && (func = hooks[id]) ) {
                func(hookupEls[i], id);
                delete hooks[id];
                hookupEls[i].removeAttribute('data-view-id');
            }
        }
        //copy remaining hooks back
        $.extend($view.hookups, hooks);
    };

    /**
     *  @add jQuery.fn
     *  @parent jQuery.View
     *  Called on a jQuery collection that was rendered with $.View with pending hookups.  $.View can render a
     *  template with hookups, but not actually perform the hookup, because it returns a string without actual DOM
     *  elements to hook up to.  So hookup performs the hookup and clears the pending hookups, preventing errors in
     *  future templates.
     *
     * @codestart
     * $($.View('//views/recipes.ejs',recipeData)).hookup()
     * @codeend
     */
    $.fn.hookup = function() {
        var hooks = $view.hookups;
        $view.hookups = {};
        hookupView(this, hooks);
        return this;
    };

    /**
     *  @add jQuery.fn
     */
    $.each([
    /**
     *  @function prepend
     *  @parent jQuery.View
     *
     *  Extending the original [http://api.jquery.com/prepend/ jQuery().prepend()]
     *  to render [jQuery.View] templates inserted at the beginning of each element in the set of matched elements.
     *
     *      $('#test').prepend('path/to/template.ejs', { name : 'javascriptmvc' });
     *
     *  @param {String|Object|Function} content A template filename or the id of a view script tag
     *  or a DOM element, array of elements, HTML string, or jQuery object.
     *  @param {Object} [data] The data to render the view with.
     *  If rendering a view template this parameter always has to be present
     *  (use the empty object initializer {} for no data).
     */
    "prepend",
    /**
     *  @function append
     *  @parent jQuery.View
     *
     *  Extending the original [http://api.jquery.com/append/ jQuery().append()]
     *  to render [jQuery.View] templates inserted at the end of each element in the set of matched elements.
     *
     *      $('#test').append('path/to/template.ejs', { name : 'javascriptmvc' });
     *
     *  @param {String|Object|Function} content A template filename or the id of a view script tag
     *  or a DOM element, array of elements, HTML string, or jQuery object.
     *  @param {Object} [data] The data to render the view with.
     *  If rendering a view template this parameter always has to be present
     *  (use the empty object initializer {} for no data).
     */
    "append",
    /**
     *  @function after
     *  @parent jQuery.View
     *
     *  Extending the original [http://api.jquery.com/after/ jQuery().after()]
     *  to render [jQuery.View] templates inserted after each element in the set of matched elements.
     *
     *      $('#test').after('path/to/template.ejs', { name : 'javascriptmvc' });
     *
     *  @param {String|Object|Function} content A template filename or the id of a view script tag
     *  or a DOM element, array of elements, HTML string, or jQuery object.
     *  @param {Object} [data] The data to render the view with.
     *  If rendering a view template this parameter always has to be present
     *  (use the empty object initializer {} for no data).
     */
    "after",
    /**
     *  @function before
     *  @parent jQuery.View
     *
     *  Extending the original [http://api.jquery.com/before/ jQuery().before()]
     *  to render [jQuery.View] templates inserted before each element in the set of matched elements.
     *
     *      $('#test').before('path/to/template.ejs', { name : 'javascriptmvc' });
     *
     *  @param {String|Object|Function} content A template filename or the id of a view script tag
     *  or a DOM element, array of elements, HTML string, or jQuery object.
     *  @param {Object} [data] The data to render the view with.
     *  If rendering a view template this parameter always has to be present
     *  (use the empty object initializer {} for no data).
     */
    "before",
    /**
     *  @function text
     *  @parent jQuery.View
     *
     *  Extending the original [http://api.jquery.com/text/ jQuery().text()]
     *  to render [jQuery.View] templates as the content of each matched element.
     *  Unlike [jQuery.fn.html] jQuery.fn.text also works with XML, escaping the provided
     *  string as necessary.
     *
     *      $('#test').text('path/to/template.ejs', { name : 'javascriptmvc' });
     *
     *  @param {String|Object|Function} content A template filename or the id of a view script tag
     *  or a DOM element, array of elements, HTML string, or jQuery object.
     *  @param {Object} [data] The data to render the view with.
     *  If rendering a view template this parameter always has to be present
     *  (use the empty object initializer {} for no data).
     */
    "text",
    /**
     *  @function html
     *  @parent jQuery.View
     *
     *  Extending the original [http://api.jquery.com/html/ jQuery().html()]
     *  to render [jQuery.View] templates as the content of each matched element.
     *
     *      $('#test').html('path/to/template.ejs', { name : 'javascriptmvc' });
     *
     *  @param {String|Object|Function} content A template filename or the id of a view script tag
     *  or a DOM element, array of elements, HTML string, or jQuery object.
     *  @param {Object} [data] The data to render the view with.
     *  If rendering a view template this parameter always has to be present
     *  (use the empty object initializer {} for no data).
     */
    "html",
    /**
     *  @function replaceWith
     *  @parent jQuery.View
     *
     *  Extending the original [http://api.jquery.com/replaceWith/ jQuery().replaceWith()]
     *  to render [jQuery.View] templates replacing each element in the set of matched elements.
     *
     *      $('#test').replaceWith('path/to/template.ejs', { name : 'javascriptmvc' });
     *
     *  @param {String|Object|Function} content A template filename or the id of a view script tag
     *  or a DOM element, array of elements, HTML string, or jQuery object.
     *  @param {Object} [data] The data to render the view with.
     *  If rendering a view template this parameter always has to be present
     *  (use the empty object initializer {} for no data).
     */
    "replaceWith", "val"],function(i, func){
        convert(func);
    });

    //go through helper funcs and convert


})();(function(){

    // HELPER METHODS ==============
    var myEval = function( script ) {
        eval(script);
    },
        // removes the last character from a string
        // this is no longer needed
        // chop = function( string ) {
        //  return string.substr(0, string.length - 1);
        //},
        rSplit = $.String.rsplit,
        extend = $.extend,
        isArray = $.isArray,
        // regular expressions for caching
        returnReg = /\r\n/g,
        retReg = /\r/g,
        newReg = /\n/g,
        nReg = /\n/,
        slashReg = /\\/g,
        quoteReg = /"/g,
        singleQuoteReg = /'/g,
        tabReg = /\t/g,
        leftBracket = /\{/g,
        rightBracket = /\}/g,
        quickFunc = /\s*\(([\$\w]+)\)\s*->([^\n]*)/,
        // escapes characters starting with \
        clean = function( content ) {
            return content.replace(slashReg, '\\\\').replace(newReg, '\\n').replace(quoteReg, '\\"').replace(tabReg, '\\t');
        },
        // escapes html
        // - from prototype  http://www.prototypejs.org/
        escapeHTML = function( content ) {
            return content.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(quoteReg, '&#34;').replace(singleQuoteReg, "&#39;");
        },
        $View = $.View,
        bracketNum = function(content){
            var lefts = content.match(leftBracket),
                rights = content.match(rightBracket);

            return (lefts ? lefts.length : 0) -
                   (rights ? rights.length : 0);
        },
        /**
         * @class jQuery.EJS
         *
         * @plugin jquery/view/ejs
         * @parent jQuery.View
         * @download  http://jmvcsite.heroku.com/pluginify?plugins[]=jquery/view/ejs/ejs.js
         * @test jquery/view/ejs/qunit.html
         *
         *
         * Ejs provides <a href="http://www.ruby-doc.org/stdlib/libdoc/erb/rdoc/">ERB</a>
         * style client side templates.  Use them with controllers to easily build html and inject
         * it into the DOM.
         *
         * ###  Example
         *
         * The following generates a list of tasks:
         *
         * @codestart html
         * &lt;ul>
         * &lt;% for(var i = 0; i < tasks.length; i++){ %>
         *     &lt;li class="task &lt;%= tasks[i].identity %>">&lt;%= tasks[i].name %>&lt;/li>
         * &lt;% } %>
         * &lt;/ul>
         * @codeend
         *
         * For the following examples, we assume this view is in <i>'views\tasks\list.ejs'</i>.
         *
         *
         * ## Use
         *
         * ### Loading and Rendering EJS:
         *
         * You should use EJS through the helper functions [jQuery.View] provides such as:
         *
         *   - [jQuery.fn.after after]
         *   - [jQuery.fn.append append]
         *   - [jQuery.fn.before before]
         *   - [jQuery.fn.html html],
         *   - [jQuery.fn.prepend prepend],
         *   - [jQuery.fn.replaceWith replaceWith], and
         *   - [jQuery.fn.text text].
         *
         * or [jQuery.Controller.prototype.view].
         *
         * ### Syntax
         *
         * EJS uses 5 types of tags:
         *
         *   - <code>&lt;% CODE %&gt;</code> - Runs JS Code.
         *     For example:
         *
         *         <% alert('hello world') %>
         *
         *   - <code>&lt;%= CODE %&gt;</code> - Runs JS Code and writes the _escaped_ result into the result of the template.
         *     For example:
         *
         *         <h1><%= 'hello world' %></h1>
         *
         *   - <code>&lt;%== CODE %&gt;</code> - Runs JS Code and writes the _unescaped_ result into the result of the template.
         *     For example:
         *
         *         <h1><%== '<span>hello world</span>' %></h1>
         *
         *   - <code>&lt;%%= CODE %&gt;</code> - Writes <%= CODE %> to the result of the template.  This is very useful for generators.
         *
         *         <%%= 'hello world' %>
         *
         *   - <code>&lt;%# CODE %&gt;</code> - Used for comments.  This does nothing.
         *
         *         <%# 'hello world' %>
         *
         * ## Hooking up controllers
         *
         * After drawing some html, you often want to add other widgets and plugins inside that html.
         * View makes this easy.  You just have to return the Contoller class you want to be hooked up.
         *
         * @codestart
         * &lt;ul &lt;%= Mxui.Tabs%>>...&lt;ul>
         * @codeend
         *
         * You can even hook up multiple controllers:
         *
         * @codestart
         * &lt;ul &lt;%= [Mxui.Tabs, Mxui.Filler]%>>...&lt;ul>
         * @codeend
         *
         * To hook up a controller with options or any other jQuery plugin use the
         * [jQuery.EJS.Helpers.prototype.plugin | plugin view helper]:
         *
         * @codestart
         * &lt;ul &lt;%= plugin('mxui_tabs', { option: 'value' }) %>>...&lt;ul>
         * @codeend
         *
         * Don't add a semicolon when using view helpers.
         *
         *
         * <h2>View Helpers</h2>
         * View Helpers return html code.  View by default only comes with
         * [jQuery.EJS.Helpers.prototype.view view] and [jQuery.EJS.Helpers.prototype.text text].
         * You can include more with the view/helpers plugin.  But, you can easily make your own!
         * Learn how in the [jQuery.EJS.Helpers Helpers] page.
         *
         * @constructor Creates a new view
         * @param {Object} options A hash with the following options
         * <table class="options">
         *     <tbody><tr><th>Option</th><th>Default</th><th>Description</th></tr>
         *     <tr>
         *      <td>text</td>
         *      <td>&nbsp;</td>
         *      <td>uses the provided text as the template. Example:<br/><code>new View({text: '&lt;%=user%>'})</code>
         *      </td>
         *     </tr>
         *     <tr>
         *      <td>type</td>
         *      <td>'<'</td>
         *      <td>type of magic tags.  Options are '&lt;' or '['
         *      </td>
         *     </tr>
         *     <tr>
         *      <td>name</td>
         *      <td>the element ID or url </td>
         *      <td>an optional name that is used for caching.
         *      </td>
         *     </tr>
         *    </tbody></table>
         */
        EJS = function( options ) {
            // If called without new, return a function that
            // renders with data and helpers like
            // EJS({text: '<%= message %>'})({message: 'foo'});
            // this is useful for steal's build system
            if ( this.constructor != EJS ) {
                var ejs = new EJS(options);
                return function( data, helpers ) {
                    return ejs.render(data, helpers);
                };
            }
            // if we get a function directly, it probably is coming from
            // a steal-packaged view
            if ( typeof options == "function" ) {
                this.template = {
                    fn: options
                };
                return;
            }
            //set options on self
            extend(this, EJS.options, options);
            this.template = compile(this.text, this.type, this.name);
        };
    // add EJS to jQuery if it exists
    $ && ($.EJS = EJS);
    /**
     * @Prototype
     */
    EJS.prototype.
    /**
     * Renders an object with view helpers attached to the view.
     *
     *     new EJS({text: "<%= message %>"}).render({
     *       message: "foo"
     *     },{helper: function(){ ... }})
     *
     * @param {Object} object data to be rendered
     * @param {Object} [extraHelpers] an object with view helpers
     * @return {String} returns the result of the string
     */
    render = function( object, extraHelpers ) {
        object = object || {};
        this._extra_helpers = extraHelpers;
        var v = new EJS.Helpers(object, extraHelpers || {});
        return this.template.fn.call(object, object, v);
    };
    /**
     * @Static
     */

    extend(EJS, {
        /**
         * Used to convert what's in &lt;%= %> magic tags to a string
         * to be inserted in the rendered output.
         *
         * Typically, it's a string, and the string is just inserted.  However,
         * if it's a function or an object with a hookup method, it can potentially be
         * be ran on the element after it's inserted into the page.
         *
         * This is a very nice way of adding functionality through the view.
         * Usually this is done with [jQuery.EJS.Helpers.prototype.plugin]
         * but the following fades in the div element after it has been inserted:
         *
         * @codestart
         * &lt;%= function(el){$(el).fadeIn()} %>
         * @codeend
         *
         * @param {String|Object|Function} input the value in between the
         * write magic tags: &lt;%= %>
         * @return {String} returns the content to be added to the rendered
         * output.  The content is different depending on the type:
         *
         *   * string - the original string
         *   * null or undefined - the empty string ""
         *   * an object with a hookup method - the attribute "data-view-id='XX'", where XX is a hookup number for jQuery.View
         *   * a function - the attribute "data-view-id='XX'", where XX is a hookup number for jQuery.View
         *   * an array - the attribute "data-view-id='XX'", where XX is a hookup number for jQuery.View
         */
        text: function( input ) {
            // if it's a string, return
            if ( typeof input == 'string' ) {
                return input;
            }
            // if has no value
            if ( input === null || input === undefined ) {
                return '';
            }

            // if it's an object, and it has a hookup method
            var hook = (input.hookup &&
            // make a function call the hookup method

            function( el, id ) {
                input.hookup.call(input, el, id);
            }) ||
            // or if it's a function, just use the input
            (typeof input == 'function' && input) ||
            // of it its an array, make a function that calls hookup or the function
            // on each item in the array
            (isArray(input) &&
            function( el, id ) {
                for ( var i = 0; i < input.length; i++ ) {
                    input[i].hookup ? input[i].hookup(el, id) : input[i](el, id);
                }
            });
            // finally, if there is a funciton to hookup on some dom
            // pass it to hookup to get the data-view-id back
            if ( hook ) {
                return "data-view-id='" + $View.hookup(hook) + "'";
            }
            // finally, if all else false, toString it
            return input.toString ? input.toString() : "";
        },
        /**
         * Escapes the text provided as html if it's a string.
         * Otherwise, the value is passed to EJS.text(text).
         *
         * @param {String|Object|Array|Function} text to escape.  Otherwise,
         * the result of [jQuery.EJS.text] is returned.
         * @return {String} the escaped text or likely a $.View data-view-id attribute.
         */
        clean: function( text ) {
            //return sanatized text
            if ( typeof text == 'string' ) {
                return escapeHTML(text);
            } else if ( typeof text == 'number' ) {
                return text;
            } else {
                return EJS.text(text);
            }
        },
        /**
         * @attribute options
         * Sets default options for all views.
         *
         *     $.EJS.options.type = '['
         *
         * Only one option is currently supported: type.
         *
         * Type is the left hand magic tag.
         */
        options: {
            type: '[',
            ext: '.ejs'
        }
    });
    // ========= SCANNING CODE =========
    // Given a scanner, and source content, calls block  with each token
    // scanner - an object of magicTagName : values
    // source - the source you want to scan
    // block - function(token, scanner), called with each token
    var scan = function( scanner, source, block ) {
        // split on /\n/ to have new lines on their own line.
        var source_split = rSplit(source, nReg),
            i = 0;
        for (; i < source_split.length; i++ ) {
            scanline(scanner, source_split[i], block);
        }

    },
        scanline = function( scanner, line, block ) {
            scanner.lines++;
            var line_split = rSplit(line, scanner.splitter),
                token;
            for ( var i = 0; i < line_split.length; i++ ) {
                token = line_split[i];
                if ( token !== null ) {
                    block(token, scanner);
                }
            }
        },
        // creates a 'scanner' object.  This creates
        // values for the left and right magic tags
        // it's splitter property is a regexp that splits content
        // by all tags
        makeScanner = function( left, right ) {
            var scanner = {};
            extend(scanner, {
                left: left + '%',
                right: '%' + right,
                dLeft: left + '%%',
                dRight: '%%' + right,
                eeLeft : left + '%==',
                eLeft: left + '%=',
                cmnt: left + '%#',
                cleanLeft: left+"%~",
                scan: scan,
                lines: 0
            });
            scanner.splitter = new RegExp("(" + [scanner.dLeft, scanner.dRight, scanner.eeLeft, scanner.eLeft, scanner.cmnt, scanner.left, scanner.right + '\n', scanner.right, '\n'].join(")|(").
            replace(/\[/g, "\\[").replace(/\]/g, "\\]") + ")");
            return scanner;
        },


        // compiles a template where
        // source - template text
        // left - the left magic tag
        // name - the name of the template (for debugging)
        // returns an object like: {out : "", fn : function(){ ... }} where
        //   out -  the converted JS source of the view
        //   fn - a function made from the JS source
        compile = function( source, left, name ) {
            // make everything only use \n
            source = source.replace(returnReg, "\n").replace(retReg, "\n");
            // if no left is given, assume <
            left = left || '[';

            // put and insert cmds are used for adding content to the template
            // currently they are identical, I am not sure why
            var put_cmd = "___v1ew.push(",
                insert_cmd = put_cmd,
                // the text that starts the view code (or block function)
                startTxt = 'var ___v1ew = [];',
                // the text that ends the view code (or block function)
                finishTxt = "return ___v1ew.join('')",
                // initialize a buffer
                buff = new EJS.Buffer([startTxt], []),
                // content is used as the current 'processing' string
                // this is the content between magic tags
                content = '',
                // adds something to be inserted into the view template
                // this comes out looking like __v1ew.push("CONENT")
                put = function( content ) {
                    buff.push(put_cmd, '"', clean(content), '");');
                },
                // the starting magic tag
                startTag = null,
                // cleans the running content
                empty = function() {
                    content = ''
                },
                // what comes after clean or text
                doubleParen = "));",
                // a stack used to keep track of how we should end a bracket }
                // once we have a <%= %> with a leftBracket
                // we store how the file should end here (either '))' or ';' )
                endStack =[];

            // start going token to token
            scan(makeScanner(left, left === '[' ? ']' : '>'), source || "", function( token, scanner ) {
                // if we don't have a start pair
                var bn;
                if ( startTag === null ) {
                    switch ( token ) {
                    case '\n':
                        content = content + "\n";
                        put(content);
                        buff.cr();
                        empty();
                        break;
                        // set start tag, add previous content (if there is some)
                        // clean content
                    case scanner.left:
                    case scanner.eLeft:
                    case scanner.eeLeft:
                    case scanner.cmnt:
                        // a new line, just add whatever content w/i a clean
                        // reset everything
                        startTag = token;
                        if ( content.length > 0 ) {
                            put(content);
                        }
                        empty();
                        break;

                    case scanner.dLeft:
                        // replace <%% with <%
                        content += scanner.left;
                        break;
                    default:
                        content += token;
                        break;
                    }
                }
                else {
                    //we have a start tag
                    switch ( token ) {
                    case scanner.right:
                        // %>
                        switch ( startTag ) {
                        case scanner.left:
                            // <%

                            // get the number of { minus }
                            bn = bracketNum(content);
                            // how are we ending this statement
                            var last =
                                // if the stack has value and we are ending a block
                                endStack.length && bn == -1 ?
                                // use the last item in the block stack
                                endStack.pop() :
                                // or use the default ending
                                ";";

                            // if we are ending a returning block
                            // add the finish text which returns the result of the
                            // block
                            if(last === doubleParen) {
                                buff.push(finishTxt)
                            }
                            // add the remaining content
                            buff.push(content, last);

                            // if we have a block, start counting
                            if(bn === 1 ){
                                endStack.push(";")
                            }
                            break;
                        case scanner.eLeft:
                            // <%= clean content
                            bn = bracketNum(content);
                            if( bn ) {
                                endStack.push(doubleParen)
                            }
                            if(quickFunc.test(content)){
                                var parts = content.match(quickFunc)
                                content = "function(__){var "+parts[1]+"=$(__);"+parts[2]+"}"
                            }
                            buff.push(insert_cmd, $.globalNamespace + ".EJS.clean(", content,bn ? startTxt : doubleParen);
                            break;
                        case scanner.eeLeft:
                            // <%== content

                            // get the number of { minus }
                            bn = bracketNum(content);
                            // if we have more {, it means there is a block
                            if( bn ){
                                // when we return to the same # of { vs } end wiht a doubleParen
                                endStack.push(doubleParen)
                            }

                            buff.push(insert_cmd, $.globalNamespace + ".EJS.text(", content,
                                // if we have a block
                                bn ?
                                // start w/ startTxt "var _v1ew = [])"
                                startTxt :
                                // if not, add doubleParent to close push and text
                                doubleParen
                                );
                            break;
                        }
                        startTag = null;
                        empty();
                        break;
                    case scanner.dRight:
                        content += scanner.right;
                        break;
                    default:
                        content += token;
                        break;
                    }
                }
            })
            if ( content.length > 0 ) {
                // Should be content.dump in Ruby
                buff.push(put_cmd, '"', clean(content) + '");');
            }
            var template = buff.close(),
                out = {
                    out: 'try { with(_VIEW) { with (_CONTEXT) {' + template + " "+finishTxt+"}}}catch(e){e.lineNumber=null;throw e;}"
                };
            //use eval instead of creating a function, b/c it is easier to debug
            // myEval.call(out, 'this.fn = (function(_CONTEXT,_VIEW){' + out.out + '});\r\n//@ sourceURL=' + name + ".js");

            // !-- FOUNDRY HACK --! //
            // Removed //@ sourceURL as it will break with conditional compilation turned on in IE.
            myEval.call(out, 'this.fn = (function(_CONTEXT,_VIEW){ var $ = ' + $.globalNamespace + ';' + out.out + '});');

            return out;
        };


    // A Buffer used to add content to.
    // This is useful for performance and simplifying the
    // code above.
    // We also can use this so we know line numbers when there
    // is an error.
    // pre_cmd - code that sets up the buffer
    // post - code that finalizes the buffer
    EJS.Buffer = function( pre_cmd, post ) {
        // the current line we are on
        this.line = [];
        // the combined content added to this buffer
        this.script = [];
        // content at the end of the buffer
        this.post = post;
        // add the pre commands to the first line
        this.push.apply(this, pre_cmd);
    };
    EJS.Buffer.prototype = {
        // add content to this line
        // need to maintain your own semi-colons (for performance)
        push: function() {
            this.line.push.apply(this.line, arguments);
        },
        // starts a new line
        cr: function() {
            this.script.push(this.line.join(''), "\n");
            this.line = [];
        },
        //returns the script too
        close: function() {
            // if we have ending line content, add it to the script
            if ( this.line.length > 0 ) {
                this.script.push(this.line.join(''));
                this.line = [];
            }
            // if we have ending content, add it
            this.post.length && this.push.apply(this, this.post);
            // always end in a ;
            this.script.push(";");
            return this.script.join("");
        }

    };

    /**
     * @class jQuery.EJS.Helpers
     * @parent jQuery.EJS
     * By adding functions to jQuery.EJS.Helpers.prototype, those functions will be available in the
     * views.
     *
     * The following helper converts a given string to upper case:
     *
     *  $.EJS.Helpers.prototype.toUpper = function(params)
     *  {
     *      return params.toUpperCase();
     *  }
     *
     * Use it like this in any EJS template:
     *
     *  <%= toUpper('javascriptmvc') %>
     *
     * To access the current DOM element return a function that takes the element as a parameter:
     *
     *  $.EJS.Helpers.prototype.upperHtml = function(params)
     *  {
     *      return function(el) {
     *          $(el).html(params.toUpperCase());
     *      }
     *  }
     *
     * In your EJS view you can then call the helper on an element tag:
     *
     *  <div <%= upperHtml('javascriptmvc') %>></div>
     *
     *
     * @constructor Creates a view helper.  This function
     * is called internally.  You should never call it.
     * @param {Object} data The data passed to the
     * view.  Helpers have access to it through this._data
     */
    EJS.Helpers = function( data, extras ) {
        this._data = data;
        this._extras = extras;
        extend(this, extras);
    };
    /**
     * @prototype
     */
    EJS.Helpers.prototype = {
        /**
         * Hooks up a jQuery plugin on.
         * @param {String} name the plugin name
         */
        plugin: function( name ) {
            var args = $.makeArray(arguments),
                widget = args.shift();
            return function( el ) {
                var jq = $(el);
                jq[widget].apply(jq, args);
            };
        },
        /**
         * Renders a partial view.  This is deprecated in favor of <code>$.View()</code>.
         */
        view: function( url, data, helpers ) {
            helpers = helpers || this._extras;
            data = data || this._data;
            return $View(url, data, helpers); //new EJS(options).render(data, helpers);
        }
    };

    // options for steal's build
    $View.register({
        suffix: "ejs",
        //returns a function that renders the view
        script: function( id, src ) {
            return $.globalNamespace + ".EJS(function(_CONTEXT,_VIEW) { " + new EJS({
                text: src,
                name: id
            }).template.out + " })";
        },
        renderer: function( id, text ) {
            return EJS({
                text: text,
                name: id
            });
        }
    });
})();(function(){

    // Alias helpful methods from jQuery
    var isArray = $.isArray,
        isObject = function( obj ) {
            return typeof obj === 'object' && obj !== null && obj;
        },
        makeArray = $.makeArray,
        each = $.each,
        // listens to changes on val and 'bubbles' the event up
        // - val the object to listen to changes on
        // - prop the property name val is at on
        // - parent the parent object of prop
        hookup = function( val, prop, parent ) {
            // if it's an array make a list, otherwise a val
            if (val instanceof $.Observe){
                // we have an observe already
                // make sure it is not listening to this already
                unhookup([val], parent._namespace)
            } else if ( isArray(val) ) {
                val = new $.Observe.List(val)
            } else {
                val = new $.Observe(val)
            }
            // attr (like target, how you (delegate) to get to the target)
            // currentAttr (how to get to you)
            // delegateAttr (hot to get to the delegated Attr)

            //
            //
            //listen to all changes and trigger upwards
            val.bind("change" + parent._namespace, function( ev, attr ) {
                // trigger the type on this ...
                var args = $.makeArray(arguments),
                    ev = args.shift();
                if(prop === "*"){
                    args[0] = parent.indexOf(val)+"." + args[0]
                } else {
                    args[0] = prop +  "." + args[0]
                }
                // change the attr
                //ev.origTarget = ev.origTarget || ev.target;
                // the target should still be the original object ...
                $.event.trigger(ev, args, parent)
            });

            return val;
        },
        unhookup = function(items, namespace){
            var item;
            for(var i =0; i < items.length; i++){
                item = items[i]
                if(  item && item.unbind ){
                    item.unbind("change" + namespace)
                }
            }
        },
        // an id to track events for a given observe
        id = 0,
        collecting = null,
        // call to start collecting events (Observe sends all events at once)
        collect = function() {
            if (!collecting ) {
                collecting = [];
                return true;
            }
        },
        // creates an event on item, but will not send immediately
        // if collecting events
        // - item - the item the event should happen on
        // - event - the event name ("change")
        // - args - an array of arguments
        trigger = function( item, event, args ) {
            // send no events if initalizing
            if (item._init) {
                return;
            }
            if (!collecting ) {
                return $.event.trigger(event, args, item, true)
            } else {
                collecting.push({
                    t: item,
                    ev: event,
                    args: args
                })
            }
        },
        // which batch of events this is for, might not want to send multiple
        // messages on the same batch.  This is mostly for
        // event delegation
        batchNum = 0,
        // sends all pending events
        sendCollection = function() {
            var len = collecting.length,
                items = collecting.slice(0),
                cur;
            collecting = null;
            batchNum ++;
            for ( var i = 0; i < len; i++ ) {
                cur = items[i];
                // batchNum
                $.event.trigger({
                    type: cur.ev,
                    batchNum : batchNum
                }, cur.args, cur.t)
            }

        },
        // a helper used to serialize an Observe or Observe.List where:
        // observe - the observable
        // how - to serialize with 'attrs' or 'serialize'
        // where - to put properties, in a {} or [].
        serialize = function( observe, how, where ) {
            // go through each property
            observe.each(function( name, val ) {
                // if the value is an object, and has a attrs or serialize function
                where[name] = isObject(val) && typeof val[how] == 'function' ?
                // call attrs or serialize to get the original data back
                val[how]() :
                // otherwise return the value
                val
            })
            return where;
        };

    /**
     * @class jQuery.Observe
     * @parent jquerymx.lang
     * @test jquery/lang/observe/qunit.html
     *
     * Observe provides the awesome observable pattern for
     * JavaScript Objects and Arrays. It lets you
     *
     *   - Set and remove property or property values on objects and arrays
     *   - Listen for changes in objects and arrays
     *   - Work with nested properties
     *
     * ## Creating an $.Observe
     *
     * To create an $.Observe, or $.Observe.List, you can simply use
     * the `$.O(data)` shortcut like:
     *
     *     var person = $.O({name: 'justin', age: 29}),
     *         hobbies = $.O(['programming', 'basketball', 'nose picking'])
     *
     * Depending on the type of data passed to $.O, it will create an instance of either:
     *
     *   - $.Observe, which is used for objects like: `{foo: 'bar'}`, and
     *   - [jQuery.Observe.List $.Observe.List], which is used for arrays like `['foo','bar']`
     *
     * $.Observe.List and $.Observe are very similar. In fact,
     * $.Observe.List inherits $.Observe and only adds a few extra methods for
     * manipulating arrays like [jQuery.Observe.List.prototype.push push].  Go to
     * [jQuery.Observe.List $.Observe.List] for more information about $.Observe.List.
     *
     * You can also create a `new $.Observe` simply by pass it the data you want to observe:
     *
     *     var data = {
     *       addresses : [
     *         {
     *           city: 'Chicago',
     *           state: 'IL'
     *         },
     *         {
     *           city: 'Boston',
     *           state : 'MA'
     *         }
     *         ],
     *       name : "Justin Meyer"
     *     },
     *     o = new $.Observe(data);
     *
     * _o_ now represents an observable copy of _data_.
     *
     * ## Getting and Setting Properties
     *
     * Use [jQuery.Observe.prototype.attr attr] and [jQuery.Observe.prototype.attr attrs]
     * to get and set properties.
     *
     * For example, you can read the property values of _o_ with
     * `observe.attr( name )` like:
     *
     *     // read name
     *     o.attr('name') //-> Justin Meyer
     *
     * And set property names of _o_ with
     * `observe.attr( name, value )` like:
     *
     *     // update name
     *     o.attr('name', "Brian Moschel") //-> o
     *
     * Observe handles nested data.  Nested Objects and
     * Arrays are converted to $.Observe and
     * $.Observe.Lists.  This lets you read nested properties
     * and use $.Observe methods on them.  The following
     * updates the second address (Boston) to 'New York':
     *
     *     o.attr('addresses.1').attrs({
     *       city: 'New York',
     *       state: 'NY'
     *     })
     *
     * `attrs()` can be used to get all properties back from the observe:
     *
     *     o.attrs() // ->
     *     {
     *       addresses : [
     *         {
     *           city: 'Chicago',
     *           state: 'IL'
     *         },
     *         {
     *           city: 'New York',
     *           state : 'MA'
     *         }
     *       ],
     *       name : "Brian Moschel"
     *     }
     *
     * ## Listening to property changes
     *
     * When a property value is changed, it creates events
     * that you can listen to.  There are two ways to listen
     * for events:
     *
     *   - [jQuery.Observe.prototype.bind bind] - listen for any type of change
     *   - [jQuery.Observe.prototype.delegate delegate] - listen to a specific type of change
     *
     * With `bind( "change" , handler( ev, attr, how, newVal, oldVal ) )`, you can listen
     * to any change that happens within the
     * observe. The handler gets called with the property name that was
     * changed, how it was changed ['add','remove','set'], the new value
     * and the old value.
     *
     *     o.bind('change', function( ev, attr, how, nevVal, oldVal ) {
     *
     *     })
     *
     * `delegate( attr, event, handler(ev, newVal, oldVal ) )` lets you listen
     * to a specific event on a specific attribute.
     *
     *     // listen for name changes
     *     o.delegate("name","set", function(){
     *
     *     })
     *
     * Delegate lets you specify multiple attributes and values to match
     * for the callback. For example,
     *
     *     r = $.O({type: "video", id : 5})
     *     r.delegate("type=images id","set", function(){})
     *
     * This is used heavily by [jQuery.route $.route].
     *
     * @constructor
     *
     * @param {Object} obj a JavaScript Object that will be
     * converted to an observable
     */
    $.Class($.globalNamespace + '.Observe',
    /**
     * @prototype
     */
    {
        init: function( obj ) {
            // _data is where we keep the properties
            this._data = {};
            // the namespace this object uses to listen to events
            this._namespace = ".observe" + (++id);
            // sets all attrs
            this._init = true;
            this.attrs(obj);
            delete this._init;
        },
        /**
         * Get or set an attribute on the observe.
         *
         *     o = new $.Observe({});
         *
         *     // sets a user property
         *     o.attr('user',{name: 'hank'});
         *
         *     // read the user's name
         *     o.attr('user.name') //-> 'hank'
         *
         * If a value is set for the first time, it will trigger
         * an `'add'` and `'set'` change event.  Once
         * the value has been added.  Any future value changes will
         * trigger only `'set'` events.
         *
         *
         * @param {String} attr the attribute to read or write.
         *
         *     o.attr('name') //-> reads the name
         *     o.attr('name', 'Justin') //-> writes the name
         *
         * You can read or write deep property names.  For example:
         *
         *     o.attr('person', {name: 'Justin'})
         *     o.attr('person.name') //-> 'Justin'
         *
         * @param {Object} [val] if provided, sets the value.
         * @return {Object} the observable or the attribute property.
         *
         * If you are reading, the property value is returned:
         *
         *     o.attr('name') //-> Justin
         *
         * If you are writing, the observe is returned for chaining:
         *
         *     o.attr('name',"Brian").attr('name') //-> Justin
         */
        attr: function( attr, val ) {

            if ( val === undefined ) {
                // if we are getting a value
                return this._get(attr)
            } else {
                // otherwise we are setting
                this._set(attr, val);
                return this;
            }
        },
        /**
         * Iterates through each attribute, calling handler
         * with each attribute name and value.
         *
         *     new Observe({foo: 'bar'})
         *       .each(function(name, value){
         *         equals(name, 'foo')
         *         equals(value,'bar')
         *       })
         *
         * @param {function} handler(attrName,value) A function that will get
         * called back with the name and value of each attribute on the observe.
         *
         * Returning `false` breaks the looping.  The following will never
         * log 3:
         *
         *     new Observe({a : 1, b : 2, c: 3})
         *       .each(function(name, value){
         *         console.log(value)
         *         if(name == 2){
         *           return false;
         *         }
         *       })
         *
         * @return {jQuery.Observe} the original observable.
         */
        each: function() {
            return each.apply(null, [this.__get()].concat(makeArray(arguments)))
        },
        /**
         * Removes a property
         *
         *     o =  new $.Observe({foo: 'bar'});
         *     o.removeAttr('foo'); //-> 'bar'
         *
         * This creates a `'remove'` change event. Learn more about events
         * in [jQuery.Observe.prototype.bind bind] and [jQuery.Observe.prototype.delegate delegate].
         *
         * @param {String} attr the attribute name to remove.
         * @return {Object} the value that was removed.
         */
        removeAttr: function( attr ) {
            // convert the attr into parts (if nested)
            var parts = isArray(attr) ? attr : attr.split("."),
                // the actual property to remove
                prop = parts.shift(),
                // the current value
                current = this._data[prop];

            // if we have more parts, call removeAttr on that part
            if ( parts.length ) {
                return current.removeAttr(parts)
            } else {
                // otherwise, delete
                delete this._data[prop];
                // create the event
                trigger(this, "change", [prop, "remove", undefined, current]);
                return current;
            }
        },
        // reads a property from the object
        _get: function( attr ) {
            var parts = isArray(attr) ? attr : (""+attr).split("."),
                current = this.__get(parts.shift());
            if ( parts.length ) {
                return current ? current._get(parts) : undefined
            } else {
                return current;
            }
        },
        // reads a property directly if an attr is provided, otherwise
        // returns the 'real' data object itself
        __get: function( attr ) {
            return attr ? this._data[attr] : this._data;
        },
        // sets attr prop as value on this object where
        // attr - is a string of properties or an array  of property values
        // value - the raw value to set
        // description - an object with converters / serializers / defaults / getterSetters?
        _set: function( attr, value ) {
            // convert attr to attr parts (if it isn't already)
            var parts = isArray(attr) ? attr : ("" + attr).split("."),
                // the immediate prop we are setting
                prop = parts.shift(),
                // its current value
                current = this.__get(prop);

            // if we have an object and remaining parts
            if ( isObject(current) && parts.length ) {
                // that object should set it (this might need to call attr)
                current._set(parts, value)
            } else if (!parts.length ) {
                // otherwise, we are setting it on this object
                // todo: check if value is object and transform
                // are we changing the value
                if ( value !== current ) {

                    // check if we are adding this for the first time
                    // if we are, we need to create an 'add' event
                    var changeType = this.__get().hasOwnProperty(prop) ? "set" : "add";

                    // set the value on data
                    this.__set(prop,
                    // if we are getting an object
                    isObject(value) ?
                    // hook it up to send event to us
                    hookup(value, prop, this) :
                    // value is normal
                    value);



                    // trigger the change event
                    trigger(this, "change", [prop, changeType, value, current]);

                    // if we can stop listening to our old value, do it
                    current && unhookup([current], this._namespace);
                }

            } else {
                throw "jQuery.Observe: set a property on an object that does not exist"
            }
        },
        // directly sets a property on this object
        __set: function( prop, val ) {
            this._data[prop] = val;
            // add property directly for easy writing
            // check if its on the prototype so we don't overwrite methods like attrs
            if (!(prop in this.constructor.prototype)) {
                this[prop] = val
            }
        },
        /**
         * Listens to changes on a jQuery.Observe.
         *
         * When attributes of an observe change, including attributes on nested objects,
         * a `'change'` event is triggered on the observe.  These events come
         * in three flavors:
         *
         *   - `add` - a attribute is added
         *   - `set` - an existing attribute's value is changed
         *   - `remove` - an attribute is removed
         *
         * The change event is fired with:
         *
         *  - the attribute changed
         *  - how it was changed
         *  - the newValue of the attribute
         *  - the oldValue of the attribute
         *
         * Example:
         *
         *     o = new $.Observe({name : "Payal"});
         *     o.bind('change', function(ev, attr, how, newVal, oldVal){
         *       // ev    -> {type: 'change'}
         *       // attr  -> "name"
         *       // how   -> "add"
         *       // newVal-> "Justin"
         *       // oldVal-> undefined
         *     })
         *
         *     o.attr('name', 'Justin')
         *
         * Listening to `change` is only useful for when you want to
         * know every change on an Observe.  For most applications,
         * [jQuery.Observe.prototype.delegate delegate] is
         * much more useful as it lets you listen to specific attribute
         * changes and sepecific types of changes.
         *
         *
         * @param {String} eventType the event name.  Currently,
         * only 'change' events are supported. For more fine
         * grained control, use [jQuery.Observe.prototype.delegate].
         *
         * @param {Function} handler(event, attr, how, newVal, oldVal) A
         * callback function where
         *
         *   - event - the event
         *   - attr - the name of the attribute changed
         *   - how - how the attribute was changed (add, set, remove)
         *   - newVal - the new value of the attribute
         *   - oldVal - the old value of the attribute
         *
         * @return {$.Observe} the observe for chaining.
         */
        bind: function( eventType, handler ) {
            $.fn.bind.apply($([this]), arguments);
            return this;
        },
        /**
         * Unbinds a listener.  This uses [http://api.jquery.com/unbind/ jQuery.unbind]
         * and works very similar.  This means you can
         * use namespaces or unbind all event handlers for a given event:
         *
         *     // unbind a specific event handler
         *     o.unbind('change', handler)
         *
         *     // unbind all change event handlers bound with the
         *     // foo namespace
         *     o.unbind('change.foo')
         *
         *     // unbind all change event handlers
         *     o.unbind('change')
         *
         * @param {String} eventType - the type of event with
         * any optional namespaces.  Currently, only `change` events
         * are supported with bind.
         *
         * @param {Function} [handler] - The original handler function passed
         * to [jQuery.Observe.prototype.bind bind].
         *
         * @return {jQuery.Observe} the original observe for chaining.
         */
        unbind: function( eventType, handler ) {
            $.fn.unbind.apply($([this]), arguments);
            return this;
        },
        /**
         * Get the serialized Object form of the observe.  Serialized
         * data is typically used to send back to a server.
         *
         *     o.serialize() //-> { name: 'Justin' }
         *
         * Serialize currently returns the same data
         * as [jQuery.Observe.prototype.attrs].  However, in future
         * versions, serialize will be able to return serialized
         * data similar to [jQuery.Model].  The following will work:
         *
         *     new Observe({time: new Date()})
         *       .serialize() //-> { time: 1319666613663 }
         *
         * @return {Object} a JavaScript Object that can be
         * serialized with `JSON.stringify` or other methods.
         *
         */
        serialize: function() {
            return serialize(this, 'serialize', {});
        },
        /**
         * Set multiple properties on the observable
         * @param {Object} props
         * @param {Boolean} remove true if you should remove properties that are not in props
         */
        attrs: function( props, remove ) {
            if ( props === undefined ) {
                return serialize(this, 'attrs', {})
            }

            props = $.extend(true, {}, props);
            var prop, collectingStarted = collect();

            for ( prop in this._data ) {
                var curVal = this._data[prop],
                    newVal = props[prop];

                // if we are merging ...
                if ( newVal === undefined ) {
                    remove && this.removeAttr(prop);
                    continue;
                }
                if ( isObject(curVal) && isObject(newVal) ) {
                    curVal.attrs(newVal, remove)
                } else if ( curVal != newVal ) {
                    this._set(prop, newVal)
                } else {

                }
                delete props[prop];
            }
            // add remaining props
            for ( var prop in props ) {
                newVal = props[prop];
                this._set(prop, newVal)
            }
            if ( collectingStarted ) {
                sendCollection();
            }
        }
    });
    // Helpers for list
    /**
     * @class jQuery.Observe.List
     * @inherits jQuery.Observe
     * @parent jQuery.Observe
     *
     * An observable list.  You can listen to when items are push, popped,
     * spliced, shifted, and unshifted on this array.
     *
     *
     */
    var list = $.Observe($.globalNamespace + '.Observe.List',
    /**
     * @prototype
     */
    {
        init: function( instances, options ) {
            this.length = 0;
            this._namespace = ".list" + (++id);
            this._init = true;
            this.bind('change',this.proxy('_changes'));
            this.push.apply(this, makeArray(instances || []));
            $.extend(this, options);
            if(this.comparator){
                this.sort()
            }
            delete this._init;
        },
        _changes : function(ev, attr, how, newVal, oldVal){
            // detects an add, sorts it, re-adds?
            //console.log("")



            // if we are sorting, and an attribute inside us changed
            if(this.comparator && /^\d+./.test(attr) ) {

                // get the index
                var index = +(/^\d+/.exec(attr)[0]),
                    // and item
                    item = this[index],
                    // and the new item
                    newIndex = this.sortedIndex(item);

                if(newIndex !== index){
                    // move ...
                    [].splice.call(this, index, 1);
                    [].splice.call(this, newIndex, 0, item);

                    trigger(this, "move", [item, newIndex, index]);
                    ev.stopImmediatePropagation();
                    trigger(this,"change", [
                        attr.replace(/^\d+/,newIndex),
                        how,
                        newVal,
                        oldVal
                    ]);
                    return;
                }
            }


            // if we add items, we need to handle
            // sorting and such

            // trigger direct add and remove events ...
            if(attr.indexOf('.') === -1){

                if( how === 'add' ) {
                    trigger(this, how, [newVal,+attr]);
                } else if( how === 'remove' ) {
                    trigger(this, how, [oldVal, +attr])
                }

            }
            // issue add, remove, and move events ...
        },
        sortedIndex : function(item){
            var itemCompare = item.attr(this.comparator),
                equaled = 0,
                i;
            for(var i =0; i < this.length; i++){
                if(item === this[i]){
                    equaled = -1;
                    continue;
                }
                if(itemCompare <= this[i].attr(this.comparator) ) {
                    return i+equaled;
                }
            }
            return i+equaled;
        },
        __get : function(attr){
            return attr ? this[attr] : this;
        },
        __set : function(attr, val){
            this[attr] = val;
        },
        /**
         * Returns the serialized form of this list.
         */
        serialize: function() {
            return serialize(this, 'serialize', []);
        },
        /**
         * Iterates through each item of the list, calling handler
         * with each index and value.
         *
         *     new Observe.List(['a'])
         *       .each(function(index, value){
         *         equals(index, 1)
         *         equals(value,'a')
         *       })
         *
         * @param {function} handler(index,value) A function that will get
         * called back with the index and value of each item on the list.
         *
         * Returning `false` breaks the looping.  The following will never
         * log 'c':
         *
         *     new Observe(['a','b','c'])
         *       .each(function(index, value){
         *         console.log(value)
         *         if(index == 1){
         *           return false;
         *         }
         *       })
         *
         * @return {jQuery.Observe.List} the original observable.
         */
        // placeholder for each
        /**
         * Remove items or add items from a specific point in the list.
         *
         * ### Example
         *
         * The following creates a list of numbers and replaces 2 and 3 with
         * "a", and "b".
         *
         *     var l = new $.Observe.List([0,1,2,3]);
         *
         *     l.bind('change', function( ev, attr, how, newVals, oldVals, where ) { ... })
         *
         *     l.splice(1,2, "a", "b"); // results in [0,"a","b",3]
         *
         * This creates 2 change events.  The first event is the removal of
         * numbers one and two where it's callback values will be:
         *
         *   - attr - "1" - indicates where the remove event took place
         *   - how - "remove"
         *   - newVals - undefined
         *   - oldVals - [1,2] -the array of removed values
         *   - where - 1 - the location of where these items where removed
         *
         * The second change event is the addition of the "a", and "b" values where
         * the callback values will be:
         *
         *   - attr - "1" - indicates where the add event took place
         *   - how - "added"
         *   - newVals - ["a","b"]
         *   - oldVals - [1, 2] - the array of removed values
         *   - where - 1 - the location of where these items where added
         *
         * @param {Number} index where to start removing or adding items
         * @param {Object} count the number of items to remove
         * @param {Object} [added] an object to add to
         */
        splice: function( index, count ) {
            var args = makeArray(arguments),
                i;

            for ( i = 2; i < args.length; i++ ) {
                var val = args[i];
                if ( isObject(val) ) {
                    args[i] = hookup(val, "*", this)
                }
            }
            if ( count === undefined ) {
                count = args[1] = this.length - index;
            }
            var removed = [].splice.apply(this, args);
            if ( count > 0 ) {
                trigger(this, "change", [""+index, "remove", undefined, removed]);
                unhookup(removed, this._namespace);
            }
            if ( args.length > 2 ) {
                trigger(this, "change", [""+index, "add", args.slice(2), removed]);
            }
            return removed;
        },
        /**
         * Updates an array with a new array.  It is able to handle
         * removes in the middle of the array.
         *
         * @param {Array} props
         * @param {Boolean} remove
         */
        attrs: function( props, remove ) {
            if ( props === undefined ) {
                return serialize(this, 'attrs', []);
            }

            // copy
            props = props.slice(0);

            var len = Math.min(props.length, this.length),
                collectingStarted = collect();
            for ( var prop = 0; prop < len; prop++ ) {
                var curVal = this[prop],
                    newVal = props[prop];

                if ( isObject(curVal) && isObject(newVal) ) {
                    curVal.attrs(newVal, remove)
                } else if ( curVal != newVal ) {
                    this._set(prop, newVal)
                } else {

                }
            }
            if ( props.length > this.length ) {
                // add in the remaining props
                this.push(props.slice(this.length))
            } else if ( props.length < this.length && remove ) {
                this.splice(props.length)
            }
            //remove those props didn't get too
            if ( collectingStarted ) {
                sendCollection()
            }
        },
        sort: function(method, silent){
            var comparator = this.comparator,
                args = comparator ? [function(a, b){
                    a = a[comparator]
                    b = b[comparator]
                    return a === b ? 0 : (a < b ? -1 : 1);
                }] : [],
                res = [].sort.apply(this, args);

            !silent && trigger(this, "reset");

        }
    }),


        // create push, pop, shift, and unshift
        // converts to an array of arguments
        getArgs = function( args ) {
            if ( args[0] && ($.isArray(args[0])) ) {
                return args[0]
            }
            else {
                return makeArray(args)
            }
        };
    // describes the method and where items should be added
    each({
        /**
         * @function push
         * Add items to the end of the list.
         *
         *     var l = new $.Observe.List([]);
         *
         *     l.bind('change', function(
         *         ev,        // the change event
         *         attr,      // the attr that was changed, for multiple items, "*" is used
         *         how,       // "add"
         *         newVals,   // an array of new values pushed
         *         oldVals,   // undefined
         *         where      // the location where these items where added
         *         ) {
         *
         *     })
         *
         *     l.push('0','1','2');
         *
         * @return {Number} the number of items in the array
         */
        push: "length",
        /**
         * @function unshift
         * Add items to the start of the list.  This is very similar to
         * [jQuery.Observe.prototype.push].
         */
        unshift: 0
    },
    // adds a method where
    // - name - method name
    // - where - where items in the array should be added


    function( name, where ) {
        list.prototype[name] = function() {
            // get the items being added
            var args = getArgs(arguments),
                // where we are going to add items
                len = where ? this.length : 0;

            // go through and convert anything to an observe that needs to be converted
            for ( var i = 0; i < args.length; i++ ) {
                var val = args[i];
                if ( isObject(val) ) {
                    args[i] = hookup(val, "*", this)
                }
            }

            // if we have a sort item, add that
            if( args.length == 1 && this.comparator ) {
                // add each item ...
                // we could make this check if we are already adding in order
                // but that would be confusing ...
                var index = this.sortedIndex(args[0]);
                this.splice(index, 0, args[0]);
                return this.length;
            }

            // call the original method
            var res = [][name].apply(this, args)

            // cause the change where the args are:
            // len - where the additions happened
            // add - items added
            // args - the items added
            // undefined - the old value
            if ( this.comparator  && args.length > 1) {
                this.sort(null, true);
                trigger(this,"reset", [args])
            } else {
                trigger(this, "change", [""+len, "add", args, undefined])
            }


            return res;
        }
    });

    each({
        /**
         * @function pop
         *
         * Removes an item from the end of the list.
         *
         *     var l = new $.Observe.List([0,1,2]);
         *
         *     l.bind('change', function(
         *         ev,        // the change event
         *         attr,      // the attr that was changed, for multiple items, "*" is used
         *         how,       // "remove"
         *         newVals,   // undefined
         *         oldVals,   // 2
         *         where      // the location where these items where added
         *         ) {
         *
         *     })
         *
         *     l.pop();
         *
         * @return {Object} the element at the end of the list
         */
        pop: "length",
        /**
         * @function shift
         * Removes an item from the start of the list.  This is very similar to
         * [jQuery.Observe.prototype.pop].
         *
         * @return {Object} the element at the start of the list
         */
        shift: 0
    },
    // creates a 'remove' type method


    function( name, where ) {
        list.prototype[name] = function() {

            var args = getArgs(arguments),
                len = where && this.length ? this.length - 1 : 0;


            var res = [][name].apply(this, args)

            // create a change where the args are
            // "*" - change on potentially multiple properties
            // "remove" - items removed
            // undefined - the new values (there are none)
            // res - the old, removed values (should these be unbound)
            // len - where these items were removed
            trigger(this, "change", [""+len, "remove", undefined, [res]])

            if ( res && res.unbind ) {
                res.unbind("change" + this._namespace)
            }
            return res;
        }
    });

    list.prototype.
    /**
     * @function indexOf
     * Returns the position of the item in the array.  Returns -1 if the
     * item is not in the array.
     * @param {Object} item
     * @return {Number}
     */
    indexOf = [].indexOf || function(item){
        return $.inArray(item, this)
    }

    /**
     * @class $.O
     */
    $.O = function(data, options){
        if(isArray(data) || data instanceof $.Observe.List){
            return new $.Observe.List(data, options)
        } else {
            return new $.Observe(data, options)
        }
    }
})();

});
FD40.plugin("joomla", function($) {

/**
 * joomla
 * Abstraction layer for Joomla client-side API.
 * https://github.com/foundry-modules/joomla
 *
 * Copyright (c) 2012 Jason Ramos
 * www.stackideas.com
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

var parser = {
	squeezebox: function() {
		return window.parent.SqueezeBox;
	}
};

var self = $.Joomla = function(method, args) {

	// Overriding function
	if ($.isFunction(args)) {

		var fn = args;

		if (self.isJoomla15) {
			window[method] = fn;
		} else {
			window.Joomla[method] = fn;
		};

		return;
	}

	// Calling function
	var method = parser[method] || ((self.isJoomla15) ? window[method] : window.Joomla[method]);

	if ($.isFunction(method)) {
		return method.apply(window, args);
	}
};

});FD40.plugin("module", function($) {

/**
 * jquery.module.
 * An AMD manager built on top of $.Deferred() backbone.
 * An alternative take on RequireJS's define().
 *
 * Part of the jquery.require family.
 * https://github.com/jstonne/jquery.require
 *
 * Copyright (c) 2012 Jensen Tonne
 * www.jstonne.com
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

var Module = function(name) {

	var module = this,
		ready = $.Callbacks("once memory");

	$.extend(this, $.Deferred(), {

		// Name of the module
		name: name,

		// Module status
		// pending, ready, executing, resolved, rejected
		status: "pending",

		// When a module factory is received,
		// this event is fired.
		ready: function(fn) {
			if (fn===true) ready.fire.call(module, $);
			if ($.isFunction(fn)) ready.add(fn);
		}
	});

	// Listen to the events of the module
	// and update the module status as necessary.
	module.then(
		function() {
			module.exports = this;
			module.status  = "resolved";
		},
		function() {
			module.status  = "rejected";
		}
	);

	// Keep a copy of the original done method.
	// This is so that we can track when this done
	// method is being called for the first time,
	// and perform the necessary actions below.
	var done = module.done;

	module.done = function() {

		// Flag this module as required
		// This indicates that we should
		// execute the module factory.
		module.required = true;

		// Execute the module factory
		// if this module has received it
		// and it hasn't been executed yet.
		var factory = module.factory;
		if (factory && module.status==="ready") {
			factory.call(module, $);
		}

		// Replace this first-time done method
		// with the original done method.
		module.done = done;

		// Execute the original done method.
		return module.done.apply(this, arguments);
	}
}

$.module = (function() {

	var self = function(name, factory) {

		var module;

		if (typeof name === "string") {

			module = self.get(name);

			/** Facade #1. Get module.
			 *
			 *  $.module('foobar'); // returns module
             *
		     */
			if (factory === undefined) {
				return module;
			}

			/** Facade #2. Factory assignment.
             *
			 *  $.module('foobar', function() {
			 *
			 *      // This is required in every module factory.
			 *      // Resolve module, return exports.
			 *
			 *      this.resolveWith(exports, [args]);
			 *
		     *  });
             *
		     */

			if ($.isFunction(factory)) {

				// If module is resolved, don't let new factory overwrite it.
				if (module.status=="resolved") return module;

				module.factory = factory;

				module.status = "ready";

				// Indicates that the module factory
				// for this module has been received.
				module.ready("true");

				// If the module is required,
				// execute the module factory.
				if (module.required) {

					module.status = "executing";

					// Execute factory
					factory.call(module, $);
				}

				return module;
			}
		}

		/** Facade #3. Multiple factory assignments / Predefine modules.
		 *	This is used by Foundry compiler when combining multiple script files into one.
         *
		 *  $.module([
	     *
	     *      // Module task object
	     *      {
	     *			name: "module.name"
	     *			factory: function(){}
	     *      }
	     *
	     *      // Module which is loading
	     *      // but factory assignment kicks in later
	     *      "module.name"
		 *	]);
		 *
		 */

		// Predefine modules
		if ($.isArray(name)) {

			var tasks = $.map(name, function(task) {

				var module = self.get($.isString(task) ? task : task.name);

				if (!module) return;

				// If module is pending, set it to ready.
				// This trick require calls into thinking that
				// the script file of this module has been loaded,
				// so it won't go and load the script file again.
				if (module.status === "pending") {
					module.status = "ready";
				}

				if ($.isPlainObject(task)) return task;
			});

			// Run through the list of tasks and assign its factory to the module.
			$.each(tasks, function(i, task) {

				// Assign factory to module
				self(task.name, task.factory);
			});
		}
	}

	// $.module static methods
	$.extend(self, {

		registry: {},

		get: function(name) {
			if (!name) return;

			if ($.isModule(name)) {
				name = name.replace("module://", "");
			}

			return self.registry[name] || self.create(name);
		},

		create: function(name) {
			return self.registry[name] = new Module(name);
		},

		remove: function(name) {
			delete self.registry[name];
		}
	});

	return self;

})();

$.isModule = function(module) {

	if ($.isString(module)) {
		return !!module.match("module://");
	}

	return module && module instanceof Module;
}

});FD40.plugin("script", function($) {

/**
 * jquery.script
 * Script injection utility built on top $.Deferred() backbone.
 * https://github.com/jstonne/jquery.script
 *
 * Copyright (c) 2012 Jensen Tonne
 * www.jstonne.com
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.Script = function(fn) {

    var script = document.createElement("script");
    script.text = $.isString(fn) ? fn : $.callback(fn) + "();";

    return $(script);
};

$.script = (function(){

    var self = function(options) {

        if (options===undefined) {
            return;
        }

        if (typeof options==="string") {
            options = {
                url: options
            }
        }

        var script = new Script(options);

        return script;
    };

    var Script = function(options) {

        var script = $.extend(this, options);

        script.manager = $.Deferred();

        $.extend(script, script.manager.promise());

        script.load();
    };

    var head = document.getElementsByTagName("head")[0];
    var baseElement = document.getElementsByTagName("base")[0];

    $.extend(Script.prototype, {

        timeout: 7000,
        retry: 3,
        retryCount: 1,
        type: "text/javascript",
        async: false,
        charset: "UTF-8",
        verbose: false,
        head: head,

        insert: function() {

            var node = this.node;

            this.head.appendChild(node);
        },

        remove: function() {

            var node = this.node;

            // This prevents IE7-8 locking up.
            setTimeout(function(){

                // Handle memory leak in IE
                node.onload = node.onerror = node.onreadystatechange = null;

                try {
                    head.removeChild(node);
                } catch(e) {};

            }, 1000);
        },

        load: function() {

            var script = this,
                node;

            script.endTime = undefined;

            script.startTime = new Date();

            script.node = node = document.createElement('script');

            script.insert();

            // Create a reference to these proxied functions,
            // so that we can detach them from event listeners.
            script._ready = $.proxy(script.ready, script);
            script._error = $.proxy(script.error, script);

            // On IE9, addEventListener() does not necessary fire the onload event after
            // the script is loaded, attachEvent() method behaves correctly.
            if (node.attachEvent && !$.browser.opera) {
                node.attachEvent("onreadystatechange", script._ready);
                node.attachEvent("onerror"           , script._error); // IE9 only.
            } else {
                node.addEventListener("load"         , script._ready, false);
                node.addEventListener("error"        , script._error, false);
            }

            $(node).attr({
                type    : script.type,
                async   : script.async,
                charset : script.charset,
                src     : script.url
            });

            script.monitor();
        },

        monitor: function() {

            var script = this;

            if (script.retryCount > script.retry) {

                script._error();

                return;
            }

            setTimeout(function() {

                if (script.state()!=="resolved") {

                    if (script.verbose) {
                        console.warn('$.script: Load timeout. [Retry: ' + script.retryCount + ']', script);
                    }

                    script.remove();

                    script.retryCount++;

                    script.load();
                }

            }, script.timeout * script.retryCount);

        },

        ready: function(event) {

            var script = this,
                node = script.node;

            // if (script.verbose) {
            //     console.info('$.script: Loaded' + (($.browser.msie) ? ' ' + script.url.replace($.scriptPath, '') + ' ': ''), script);
            // }

            if (event.type==="load" || /loaded|complete/.test(node.readyState)) {

                script.complete.call(script, event);

                script.manager.resolve(script);
            }
        },

        error: function(event) {

            var script = this;

            if (script.verbose) {
                console.error('$.script: Unable to load ', script);
            }

            script.complete.call(script, event);

            script.remove();

            script.manager.reject(script);
        },

        complete: function(event) {

            var script = this,
                node = script.node;

            script.endTime = new Date();

            if (node.detachEvent && !$.browser.opera) {
                node.detachEvent("onreadystatechange", script._ready);
                node.detachEvent("onerror"           , script._error);
            } else {
                node.removeEventListener("load"      , script._ready, false);
                node.removeEventListener("error"     , script._error, false);
            }
        }

    });

    return self;

})();

});FD40.plugin("stylesheet", function($) {

/**
 * jquery.stylesheet
 * Stylesheet injector utility with workarounds
 * for IE's 31 stylesheet limitation.
 *
 * Copyright (c) 2012 Jensen Tonne
 * www.jstonne.com
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

var head = document.getElementsByTagName('head')[0],
	stylesheets = document.styleSheets,
	IE_STYLESHEET = document.createStyleSheet,
	IE_MAX_STYLESHEET = 31,
	IE_MAX_IMPORT = 31,
	IE_MAX_RULE = 4095;

$.stylesheet = (function() {

	var self = function(url, attr) {

		var options = {};

		$.extend(

			options,

			self.defaultOptions,

			($.isPlainObject(url)) ?
				url :
				{
					url: url,
					attr: attr || {}
				}
		);

		// Create a new stylesheet object
		if (options.url===undefined) {

			return self.create(options);
		}

		// Loading an external stylesheet
		return self.load(options);
	};

	$.extend(self, {

		defaultOptions: {

			type: "text/css",

			rel: "stylesheet",

			media: "all",

			title: "",

			// Force link injection, ignores IE workarounds, overrides XHR value.
			forceInject: false,

			// @TODO: XHR loading.
			xhr: false
		},

		setup: function(options) {

			$.extend(self.defaultOptions, options);
		},

		availability: function() {

			// @TODO: Also calculate bleedImports.
			var stat = {},
				links = $('link[rel*="stylesheet"]')
				styles = $('style');

			stat.groups = IE_MAX_STYLESHEET - links.length - styles.length;

			stat.slots = stat.groups * IE_MAX_IMPORT;

			if (self.currentGroup) {
				stat.slots += IE_MAX_IMPORT - self.currentGroup.imports.length;
			}

			return stat;
		},

		get: function(style) {

			var i=0;

			for (; i<stylesheets.length; i++) {

				var stylesheet = stylesheets[i];

				if ((stylesheet.ownerNode || stylesheet.owningElement)==style) {
					return stylesheet;
				}
			}
		},

		create: function(options) {

			var stylesheet,
				style,
				length = stylesheets.length;

			if (IE_STYLESHEET) {
				// Unable to create further stylesheets
				if (length>=IE_MAX_STYLESHEET) return;
				stylesheet = document.createStyleSheet();
				style = stylesheet.ownerNode || stylesheet.owningElement;
			} else {
				style = document.createElement('style');
				head.appendChild(style);
			}

			$.extend(style, {
				type : options.type,
				title: options.title,
				media: options.media,
				rel  : options.rel
			});

			// Insert stylesheet content
			var content = options.content;
			if (content!==undefined) {
				if (IE_STYLESHEET) {
					stylesheet.cssText = content;
				} else {
					style.appendChild(document.createTextNode(content));
				}
			}

			return style;
		},

		nextAvailable: function(alsoCreateIfUnavailable) {

			var stylesheet,
				length = stylesheets.length;

			if (length) {

				var i;

				for (i=length; i--; i<0) {

					stylesheet = stylesheets[i];

					// If this is IE and the maximum amount of rules have exceeded,
					if (IE_STYLESHEET && ((stylesheet.cssRules || stylesheet.rules).length >= IE_MAX_RULE)) {

						// then this stylesheet cannot be used.
						stylesheet = undefined;

						// try an older stylesheet.
						continue;
					}

					break;
				}
			}

			return stylesheet.ownerNode || stylesheet.owningElement || ((alsoCreateIfUnavailable) ? self() : undefined);
		},

		load: function(options) {

			if ($.browser.msie && !options.forceInject) {

				return self._import(options);

			} else {

				// @TODO: Use onload/onerror events on browsers that support them.
				var link =
					$('<link>')
						.attr({
							href: options.url,
							type: options.type,
							rel: options.rel,
							media: options.media
						})
						.appendTo('head');

				return link[0];
			}
		},

		_import: function(options) {

			var failed;

			if (self.currentGroup===undefined) {

				var group;

				try {

					group = document.createStyleSheet();

					// It is only a getter on IE.
					// group.type = "text/css";

					group.media = "all";
					group.title = "jquery_stylesheet";

				} catch(e) {

					failed = true;

					if (options.verbose) {
						console.error('There is not enough slots left to create a new stylesheet group.');
					}
				}

				if (failed) return false;

				self.currentGroup = group;
			}

			try {

				self.currentGroup.addImport(options.url);

			} catch(e) {

				failed = true;

				if (options.verbose) {
					console.info('Import slots exceeded. Creating a new stylesheet group.');
				}
			}

			if (failed) {

				self.currentGroup = undefined;

				return self._import(options);
			}

			return true;
		}

	});

	return self;

})();

(function(){

var cssRule = function(selectors, rules, style) {

	$.extend(this, {
		id       : $.uid(),
		style    : style,
		selectors: [],
		preRule  : "",
		rules    : {},
		legacy   : $.IE===8,
		important: false
	});

	// If selector is given, automatically add rule.
	// Else assume caller wants a blank rule object.
	if (selectors) {
		this.set(selectors, rules);
	}
}

$.extend(cssRule.prototype, {

	set: function(selectors, rules) {

		// Normalize selectors into array
		if ($.isString(selectors)) {
			this.selectors = selectors.split(",");
		} else {
			this.selectors = selectors;
		}

		// Normalize rules
		if ($.isString(rules)) {
			this.preRule = rules + "\n";
			this.rules = {};
		} else {
			this.preRule = "";
			this.rules = rules || this.rules;
		}

		this.update();

		return this;
	},

	cssText: function() {
		return this.selectors.join(",") + "{" + this.ruleText() + "}\n";
	},

	ruleText: function() {

		var important = this.important;
		return this.preRule +
		       ((this.legacy) ? "-rule-id:" + this.id + ";" : "") +
			   $.map(this.rules, function(val, prop) {
			   		if ($.isNumeric(val) && !$.cssNumber[prop]) val += "px";
			   		if (important) val += " !important";
			   		return prop + ":" + val;
			   }).join(";");
	},

	update: function() {

		if (this.legacy) return this.updateLegacy();

		// Generate css text
		var cssText = this.cssText();

		// If new, insert textnode
		if (this.textNode===undefined) {
			this.textNode = document.createTextNode(cssText);
			this.style.appendChild(this.textNode);

		// Or update existing textnode.
		} else {
			this.textNode.nodeValue = cssText;
		}

		return this;
	},

	updateLegacy: function() {

		this.removeLegacy();

		var stylesheet = $.stylesheet.get(this.style),
			selectors = this.selectors,
			ruleText = this.ruleText(),
			i=0;

		for (;i<selectors.length;i++) {
			stylesheet.addRule(selectors[i], ruleText);
		}

		return this;
	},

	remove: function() {

		if (this.legacy) return this.removeLegacy();

		if (this.textNode!==undefined) {

			// Removing text node is so much quicker
			// than searching for the rule
			this.style.removeChild(this.textNode);

			delete this.textNode;
		}

		return this;
	},

	removeLegacy: function() {

		var stylesheet = $.stylesheet.get(this.style),
			rules = stylesheet.rules,
			i = 0;

		for (;i<rules.length;i++) {

			if (rules[i].cssText.match(this.id)!==null) {
				stylesheet.removeRule(i);
			}
		}

		return this;
	},

	css: function(prop, val) {

		// Getter
		if ($.isString(prop) && val===undefined) {
			return this.rules[prop];
		}

		// Setter
		if ($.isPlainObject(prop)) {
			$.extend(this.rules, prop);
		} else {
			this.rules[prop] = val;
		}

		this.update();

		return this;
	}
});

var self = $.cssRule = function(selector, rules, style) {

	var style = style || self.style || $.stylesheet.nextAvailable(true);

	// If no stylesheet available at this point, stop.
	if (!style) return;

	return new cssRule(selector, rules, style);
};

self.style = $.stylesheet();

})();

(function(){
$.cssUrl = function(url) {
	return 'url("' + encodeURI(url) + '")';
}
})();

});FD40.plugin("template", function($) {

/**
 * jquery.template
 * Template repository
 *
 * Copyright (c) 2012 Jensen Tonne
 * www.jstonne.com
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.template = (function() {

	var defaultTemplate = {
		content: "",
		type: "ejs"
	};

	var self = function(name, content) {

		if (name===undefined) {
			return self.templates;
		}

		var template;

		if (typeof content == "string") {

			if ($.isPlainObject(content)) {

				template = content;

			} else {

				template = $.extend({}, defaultTemplate, {name: name, content: content});
			}

			self.templates[name] = template;

			return template;

		} else {

			template = self.templates[name] || {};

			return template.content || "";
		}
	};

	$.extend(self, {

		templates: {},

		remove: function(name) {

			delete self.templates[name];
		}
	});

	return self;

 })();

});FD40.plugin("require", function($) {

/**
 * jquery.require.
 * A dependency loader built on top of $.Deferred() backbone.
 * An alternative take on RequireJS.
 * https://github.com/jstonne/jquery.require
 *
 * Copyright (c) 2012 Jensen Tonne
 * www.jstonne.com
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.require = (function() {

	// internal function
	var getFolderPath = function(path) {
		return $.uri(path).setAnchor('').setQuery('').toPath('../').toString();
	};

	var self = function(options) {

		var batch = new Batch(options);

		self.batches[batch.id] = batch;

		return batch;
	};

	// Require methods & properties

	$.extend(self, {

		defaultOptions: {

			// Path selection order:
			path: (function() {
				var path = 
					$.path ||

					// By "require_path" attribute
					$('[require-path]').attr('require-path') ||

					// By last script tag's "src" attribute
					getFolderPath($('script:last').attr('src')) ||

					// By window location
					getFolderPath(window.location.href);

				if (/^(\/|\.)/.test(path)) {
					path = $.uri(window.location.href).toPath(path).toString();
				}

				return path;
			})(),

			timeout: 10000,

			retry: 3,

			verbose: ($.environment=="development")
		},

		setup: function(options) {

			$.extend(self.defaultOptions, options);
		},

		batches: {},

		status: function(filter) {

			$.each(self.batches, function(i, batch){

				var count = {pending: 0, resolved: 0, rejected: 0, ready: 0, total: 0},
					messages = [];

				// Calculate statistics
				$.each(batch.tasks, function(i, task){

					state = (task.module && task.module.status=="ready") ? "ready" : task.state();
					count[state]++;
					count.total++;

					messages.push({
						state: state,
						content: '[' + state + '] ' + task.name 
					});
				});

				var batchName = batch.id + ": " + batch.state() + " [" + count.resolved + "/" + count.total + "]";

				if (filter && count[filter] < 1) return;

				if ($.IE) {

					console.log("$.require.batches[\"" + batch.id + "\"]");
					$.each(messages, function(i, message){
						console.log(message.content);
					});
					console.log("");

				} else {

					// Create log group
					console.groupCollapsed(batchName);

					// Generate list
					console.log("$.require.batches[\"" + batch.id + "\"]", batch);

					$.each(messages, function(i, message){

						var state   = message.state,
							content = message.content;

						if (!filter || state==filter) {
							switch (state) {
								case 'pending' : console.warn(content);  break;
								case 'rejected': console.error(content); break;
								default        : console.info(content);  break;
							}
						}
					});

					console.groupEnd(batchName);
				}
			});

			return "$.require.status(pending|resolved|rejected|ready);";
		},

		loaders: {},

		addLoader: function(name, factory) {

			// Static call, e.g.
			// $.require.script.setup({});
			self[name] = factory;

			// Create proxy functions to require loaders,
			// assigning current batch to factory's "this".
			Batch.prototype[name] = function() {

				var batch = this;

				// Reset auto-finalize timer
				batch.autoFinalize();

				// this == batch
				factory.apply(batch, arguments);

				// Ensure require calls are chainable
				return batch;
			};

			self.loaders[name] = self[name] = factory;
		},

		removeLoader: function(name) {
			delete Batch.prototype[name];
			delete self[name];
		}

	});

	// This serves as batch id counter, it increments
	// whenever a new batch instance is created.
	var id = 0;

	// Batch class.
	// When calling $.require(), it is actually
	// returning an new instance of this class.
	var Batch = function(options) {

		var required = $.Callbacks("once memory"),
		    isRequired = false;

		// We are extending the batch instance
		// with the following properties.
		var batch = $.extend(this, {

			// Unique ID for this batch.
			id: ++id,

			// This array keeps a list of tasks to load.
			tasks: [],

			// Stores options like load path, timeout and retry count. 
			options: $.extend({}, self.defaultOptions, options),

			// Require chain automatically finalizes itself after
			// 300ms if no promise methods were called in the require chain.
			// Set false to disable.
			autoFinalizeDuration: 300,

			// When batch is finalized, further loader calls will be ignored.
			finalized: false,

			// Determine if the contents of the loaded task is required.
			required: function(fn) {
				if (fn===true) isRequired=true && required.fire();
				if ($.isFunction(fn)) required.add(fn);
				return isRequired;
			}
		});

		return batch;
	}

	$.extend(Batch.prototype, {

		addTask: function(task) {

			var batch = this;

			// Don't add invalid tasks.
			// Tasks should be a deferred object.
			if (!$.isDeferred(task)) return;

			// Don't accept anymore tasks if this batch is finalized.
			// Batch is finalized upon calling any of the promises, e.g.
			// done, fail, progress, always, then, pipe
			if (batch.finalized) return;

			// Add this task to the batch's task list
			batch.tasks.push(task);

			// Decorate task with a reference to the current batch
			task.batch = batch;
		},

		autoFinalize: function() {

			var batch = this,
				duration = batch.autoFinalizeDuration;

			// If autoFinalize is disabled, stop.
			if (duration===false) return;

			// Clear previous timer
			clearTimeout(batch.autoFinalizeTimer);

			// Start a new timer
			batch.autoFinalizeTimer = 
				setTimeout(function(){
					batch.finalize();
				}, duration);
		},

		finalize: function() {

			var batch = this;

			// If this batch has been finalized, stop.
			if (batch.finalized) return;

			// Finalize all tasks so no further
			// tasks can be added to this batch.
			batch.finalized = true;

			// Create batch manager which is a
			// master deferred object for all tasks.
			var manager = batch.manager = $.when.apply(null, batch.tasks);

			// Now that tasks are finalized, we can override
			// this batch's pseudo-promise methods with actual
			// promise methods from batch manager.
			var promise  = manager.promise(),
				progress = $.Callbacks();

			$.extend(batch, promise, {

				// Progress & notify method behaves differently.
				// We want progress callback to continue executing
				// even after after manager has been resolved or rejected.
				progress: progress.add,
				notify  : progress.fire,

				// Done method also behaves differently.
				// It will trigger an event notifying all tasks that
				// there is a demand for the content of the task.
				// This is currently used to lazy execute module factories
				// to ensure they don't execute until they are asked for.
				done: function(){

					// Trigger required event
					batch.required(true);

					// After done has been called once, it will be
					// replaced with the actual done method from the
					// master deferred object.
					batch.done = promise.done;

					// And the actual done method gets executed.
					return batch.done.apply(batch, arguments);
				}
			});

			// Flag to indicate whether to make
			// generate debug messages.
			var verbose = batch.options.verbose;

			manager
				.progress(function(state, task){
					if (verbose && state=="rejected") {
						console.warn('Require: Task ' + task.name + ' failed to load.', task);
					}
				})
				.fail(function(){
					if (verbose) {
						console.warn('Require: Batch ' + batch.id + ' failed.', batch);
					}
				});

			// We wrap this in a setTimeout to let existing require chain
			// to continue execute. This ensures that progress call in that
			// require chain receives the activities of each task below.
			setTimeout(function(){

				// Always notify whenever there is an activity on every task.
				$.each(batch.tasks, function(i, task){
					task.then(
						function(){ batch.notify("resolved", task) },
						function(){ batch.notify("rejected", task) },
						function(){ batch.notify("progress", task) }
					);
				});
			}, 1);
		},

		expand: function(args, opts) {

			var args = $.makeArray(args),
				options = opts || {},
				names = [];

	        if ($.isPlainObject(args[0])) {
	            options = $.extend(args[0], opts);
	            names = args.slice(1);
	        } else {
	            names = args;
	        }

	        return {
	        	options: options,
	        	names: names
	        }
		}
	});

	// Masquerade newly created batch instances as a pseudo-promise object
	// until one of those promise's method is called. This is to ensure that
	// no callbacks are fired too early until all require tasks are finalized.
	$.each(["done","fail","progress","always","then"], function(i, method) {

		Batch.prototype[method] = function() {

			var batch = this;

			// Finalize batch
			batch.finalize();

			// Execute method that was originally called
			return batch[method].apply(batch, arguments);
		}
	});

	return self;

})();
/**
 * jquery.require.script
 * Script loader plugin for $.require.
 *
 * Part of jquery.require family.
 * https://github.com/jstonne/jquery.require
 *
 * Copyright (c) 2012 Jensen Tonne
 * www.jstonne.com
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.require.addLoader('script', (function() {

	// IE & Opera thinks punycoded urls are cross-domain requests,
	// and rejects the ajax request because they think they don't have
	// the necesary transport to facilitate such requests.

	var ajaxHost = $.uri($.indexUrl).host(),
		documentHost = $.uri(document.location.href).host();

	if (ajaxHost!==documentHost && ajaxHost.match("xn--")) {
		$.support.cors = true;
	}

	var canAsync = document.createElement("script").async === true || "MozAppearance" in document.documentElement.style || window.opera;

	var self = function() {

		var batch = this,
			args = $.makeArray(arguments),
			options,
			names;

		// Expand arguments into its actual definition
		if ($.isPlainObject(args[0])) {
			options = args[0];
			names = args.slice(1);
		} else {
			names = args;
		}

		options = $.extend(
			{},
			self.defaultOptions,
			batch.options,
			options,
			{batch: batch}
		);

		// Create tasks and add it to the batch.
		var taskBefore;

		$.each(names, function(i, name) {

			var task = new self.task(name, options, taskBefore);

			batch.addTask(task);

			// Serial script loading
			if (options.serial && taskBefore!==undefined) {

				// Only start current task when the
				// task before is resolved/rejected.
				taskBefore.always(task.start);

			} else {

				task.start();
			}

			taskBefore = task;

		});

	};

	$.extend(self, {

		defaultOptions: {
			// Overrides require path.
			path: '',

			extension: (($.mode=='compressed') ? 'min.js' : 'js'),

			// Serial script loading. Default: Parallel script loading.
			serial: false,

			// Asynchronous script execution. Default: Synchronous script execution.
			async: false,

			// Use XHR to load script. Default: Script injection.
			xhr: false
		},

		setup: function() {

			$.extend(self.defaultOptions, options);
		},

		scripts: {},

		task: function(name, options, taskBefore) {

			var task = $.extend(this, $.Deferred());

			task.name = name;

			task.options = options;

			task.taskBefore = taskBefore;

			// Module assignment or module url override
			if ($.isArray(name)) {

				task.name = name[0] + "@" + name[1];

				task.moduleName = name[0];

				var overrideModuleUrl = name[2];

				// Module assignment
				if (!overrideModuleUrl) {

					// Set module flag
					task.defineModule = true;

					// Raise a warning if the module already exist
					if ($.module.registry[task.moduleName]) {
						console.warn("$.require.script: " + task.moduleName + ' exists! Using existing module instead.');
					}

					// Use XHR for module assignments
					task.options.xhr = true;
				}

				// Assign path to be resolved
				name = name[1];

				task.module = $.module(task.moduleName);
			}

			// Resolve name to paths

			// Absolute path
			if ($.isUrl(name)) {

				task.url = name;

			// Relative path
			} else if (/^(\/|\.)/.test(name)) {

				task.url = $.uri(task.options.path)
							.toPath(name)
							.toString();

			// Module path
			} else {

				task.url = $.uri(task.options.path)
							.toPath('./' + name + '.' + task.options.extension)
							.toString();

				task.module = $.module(name);
			}
		}

	});

	$.extend(self.task.prototype, {

		start: function() {

			var task = this,
				module = task.module;

			// If module has already been loaded,
			// we can skip the whole script loading process.
			if (module && module.status!=="pending") {
				task.waitForModule();
				return;
			}

			// Else load the script that has this module.
			task.load();
		},

		waitForModule: function() {

			var task = this,
				module = task.module;

			// Listen to the events in the module
			// without causing the module factory to execute.
			module.then(
				task.resolve,
				task.reject,
				task.notify
			);

			// When there is demand for this module,
			// we will call the module's done method.
			task.batch.required(function(){

				// This will execute the module factory
				// in case it wasn't executed before.
				module.done(task.resolve);
			});
		},

		load: function() {

			var task = this,
				taskBefore = task.taskBefore,
				options = {};

			// Use previously created script instance if exists,
			// else create a new one.
			task.script = self.scripts[task.url] || (function() {

				var script = (task.options.xhr) ?

					// Load script via ajax.
					$.ajax({

						url: task.url,

						dataType: "text"

					}) :

					// Load script using script injection.
					$.script({

						url: task.url,

						type: "text/javascript",

						async: task.options.async,

						timeout: task.batch.options.timeout,

						retry: task.batch.options.retry,

						verbose: task.batch.options.verbose

					});

				return self.scripts[task.url] = script;

			})();

			// At this point, script may be loaded, BUT may yet
			// to be executed under the following conditions:
			// - Module loaded via script injection/xhr.
			// - Script loaded via via xhr.
			task.script
				.done(function(data) {

					var resolveTask = function() {

						// If task loads a module, resolve/reject task only when
						// the module is resolved/rejected as the module itself
						// may perform additional require tasks.
						if (task.module) {

							task.waitForModule();

						} else {

							task.resolve();
						}
					};

					if (task.options.xhr) {

						if (task.defineModule) {

							// Create our own module factory
							task.module = $.module(task.moduleName, function() {

								var module = this;

								$.globalEval(data);

								module.resolveWith(data);
							});
						};

						// For XHR, if scripts needs to be executed synchronously
						// a.k.a. ordered script execution, then only eval it when
						// the task before it is resolved.
						if (!task.options.async || taskBefore) {

							taskBefore.done(function() {

								$.globalEval(data);

								resolveTask();

							});

							return;
						}

					};

					resolveTask();

				})
				.fail(function() {

					task.reject();
				});
		}
	});

	return self;

})()
);

/**
 * jquery.require.library
 * Foundry script loader.
 *
 * Copyright (c) 2011 Jason Ramos
 * www.stackideas.com
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.require.addLoader('library', function() {

	var batch = this,
		args = $.makeArray(arguments),
		options = {},
		names;

	// Expand arguments into its actual definition
	if ($.isPlainObject(args[0])) {
		options = args[0];
		names = args.slice(1);
	} else {
		names = args;
	}

	$.extend(options, {
		path: $.scriptPath
	});

	return batch.script.apply(batch, [options].concat(names));

});
/**
 * jquery.require.stylesheet
 * Stylesheet loader plugin for $.require.
 *
 * Part of jquery.require family.
 * https://github.com/jstonne/jquery.require
 *
 * Copyright (c) 2012 Jensen Tonne
 * www.jstonne.com
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

$.require.addLoader('image', (function() {

	var self = function() {

		var batch = this,
			args = $.makeArray(arguments),
			options,
			names;

		// Expand arguments into its actual definition
		if ($.isPlainObject(args[0])) {
			options = args[0];
			names = args.slice(1);
		} else {
			names = args;
		}

		options = $.extend(
			{},
			self.defaultOptions,
			batch.options,
			options,
			{batch: batch}
		);

		$.each(names, function(i, name) {

			var task = new self.task(name, options),
				existingTask = self.images[task.url];

			task = existingTask || task;

			batch.addTask(task);

			if (!existingTask) {
				self.images[task.url] = task;
				task.start();
			}
		});
	};

	$.extend(self, {

		defaultOptions: {
			// Overrides require path.
			path: ''
		},

		setup: function() {

			$.extend(self.defaultOptions, options);
		},

		images: {},

		task: function(name, options) {

			var task = $.extend(this, $.Deferred());

			task.name = name;

			task.options = options;

			// Absolute path
			if ($.isUrl(name)) {

				task.url = name;

			// Relative path
			} else if (/^(\/|\.)/.test(name)) {

				task.url = $.uri(task.options.path)
							.toPath(name)
							.toString();

			// Module path
			} else {

				task.url = $.uri(task.options.path)
							.toPath('./' + name)
							.toString();
			}

			// Remap task.url to task.options.url
			task.options.url = task.url;
		}

	});

	$.extend(self.task.prototype, {

		start: function() {

			var task = this;

			task.image = $(new Image())
							.load(function(){
								task.resolve();
							})
							.error(function(){
								task.reject();
							})
							.attr("src", task.options.url);
		}

	});

	return self;

})()
);

});FD40.plugin("iframe-transport", function($) {

// This [jQuery](http://jquery.com/) plugin implements an `<iframe>`
// [transport](http://api.jquery.com/extending-ajax/#Transports) so that
// `$.ajax()` calls support the uploading of files using standard HTML file
// input fields. This is done by switching the exchange from `XMLHttpRequest`
// to a hidden `iframe` element containing a form that is submitted.

// The [source for the plugin](http://github.com/cmlenz/jquery-iframe-transport)
// is available on [Github](http://github.com/) and dual licensed under the MIT
// or GPL Version 2 licenses.

// ## Usage

// To use this plugin, you simply add an `iframe` option with the value `true`
// to the Ajax settings an `$.ajax()` call, and specify the file fields to
// include in the submssion using the `files` option, which can be a selector,
// jQuery object, or a list of DOM elements containing one or more
// `<input type="file">` elements:

//     $("#myform").submit(function() {
//         $.ajax(this.action, {
//             files: $(":file", this),
//             iframe: true
//         }).complete(function(data) {
//             console.log(data);
//         });
//     });

// The plugin will construct hidden `<iframe>` and `<form>` elements, add the
// file field(s) to that form, submit the form, and process the response.

// If you want to include other form fields in the form submission, include
// them in the `data` option, and set the `processData` option to `false`:

//     $("#myform").submit(function() {
//         $.ajax(this.action, {
//             data: $(":text", this).serializeArray(),
//             files: $(":file", this),
//             iframe: true,
//             processData: false
//         }).complete(function(data) {
//             console.log(data);
//         });
//     });

// ### Response Data Types

// As the transport does not have access to the HTTP headers of the server
// response, it is not as simple to make use of the automatic content type
// detection provided by jQuery as with regular XHR. If you can't set the
// expected response data type (for example because it may vary depending on
// the outcome of processing by the server), you will need to employ a
// workaround on the server side: Send back an HTML document containing just a
// `<textarea>` element with a `data-type` attribute that specifies the MIME
// type, and put the actual payload in the textarea:

//     <textarea data-type="application/json">
//       {"ok": true, "message": "Thanks so much"}
//     </textarea>

// The iframe transport plugin will detect this and pass the value of the
// `data-type` attribute on to jQuery as if it was the "Content-Type" response
// header, thereby enabling the same kind of conversions that jQuery applies
// to regular responses. For the example above you should get a Javascript
// object as the `data` parameter of the `complete` callback, with the
// properties `ok: true` and `message: "Thanks so much"`.

// ### Handling Server Errors

// Another problem with using an `iframe` for file uploads is that it is
// impossible for the javascript code to determine the HTTP status code of the
// servers response. Effectively, all of the calls you make will look like they
// are getting successful responses, and thus invoke the `done()` or
// `complete()` callbacks. You can only determine communicate problems using
// the content of the response payload. For example, consider using a JSON
// response such as the following to indicate a problem with an uploaded file:

//     <textarea data-type="application/json">
//       {"ok": false, "message": "Please only upload reasonably sized files."}
//     </textarea>

// ### Compatibility

// This plugin has primarily been tested on Safari 5 (or later), Firefox 4 (or
// later), and Internet Explorer (all the way back to version 6). While I
// haven't found any issues with it so far, I'm fairly sure it still doesn't
// work around all the quirks in all different browsers. But the code is still
// pretty simple overall, so you should be able to fix it and contribute a
// patch :)

// ## Annotated Source



  // Register a prefilter that checks whether the `iframe` option is set, and
  // switches to the "iframe" data type if it is `true`.
  $.ajaxPrefilter(function(options, origOptions, jqXHR) {
    if (options.iframe) {
      return "iframe";
    }
  });

  // Register a transport for the "iframe" data type. It will only activate
  // when the "files" option has been set to a non-empty list of enabled file
  // inputs.
  $.ajaxTransport("iframe", function(options, origOptions, jqXHR) {
    var form = null,
        iframe = null,
        name = "iframe-" + $.now(),
        files = $(options.files).filter(":file:enabled"),
        hasFiles = files.length > 0,
        markers = null;

    // This function gets called after a successful submission or an abortion
    // and should revert all changes made to the page to enable the
    // submission via this transport.
    function cleanUp() {
      if (hasFiles) {
        markers.replaceWith(function(idx) {
          return files.get(idx);
        });
      }
      form.remove();
      iframe.attr("src", "javascript:false;").remove();
    }

    // Remove "iframe" from the data types list so that further processing is
    // based on the content type returned by the server, without attempting an
    // (unsupported) conversion from "iframe" to the actual type.
    options.dataTypes.shift();

      form = $("<form enctype='multipart/form-data' method='post'></form>").
        hide().attr({action: options.url, target: name});

      // If there is any additional data specified via the `data` option,
      // we add it as hidden fields to the form. This (currently) requires
      // the `processData` option to be set to false so that the data doesn't
      // get serialized to a string.
      if (typeof(options.data) === "string" && options.data.length > 0) {
        $.error("data must not be serialized");
      }
      $.each(options.data || {}, function(name, value) {
        if ($.isPlainObject(value)) {
          name = value.name;
          value = value.value;
        }

        if (!$.isArray(value)) {
          value = [value];
        }

        $.each(value, function(i, value){
          $("<input type='hidden' />").attr({name:  name, value: value}).
            appendTo(form);
        });

      });


      // Add a hidden `X-Requested-With` field with the value `IFrame` to the
      // field, to help server-side code to determine that the upload happened
      // through this transport.
      $("<input type='hidden' value='IFrame' name='X-Requested-With' />").
        appendTo(form);

      // Move the file fields into the hidden form, but first remember their
      // original locations in the document by replacing them with disabled
      // clones. This should also avoid introducing unwanted changes to the
      // page layout during submission.
      if (hasFiles) {
        markers = files.after(function(idx) {
          return $(this).clone().prop("disabled", true);
        }).next();
        files.appendTo(form);
      }

      return {

        // The `send` function is called by jQuery when the request should be
        // sent.
        send: function(headers, completeCallback) {
          iframe = $("<iframe src='about:blank' name='" + name +
            "' id='" + name + "' style='display:none'></iframe>");

          // The first load event gets fired after the iframe has been injected
          // into the DOM, and is used to prepare the actual submission.
          iframe.bind("load", function() {

            // The second load event gets fired when the response to the form
            // submission is received. The implementation detects whether the
            // actual payload is embedded in a `<textarea>` element, and
            // prepares the required conversions to be made in that case.
            iframe.unbind("load").bind("load", function() {
              var doc = this.contentWindow ? this.contentWindow.document :
                (this.contentDocument ? this.contentDocument : this.document),
                root = doc.documentElement ? doc.documentElement : doc.body,
                textarea = root.getElementsByTagName("textarea")[0],
                type = textarea ? textarea.getAttribute("data-type") : null,
                status = textarea ? textarea.getAttribute("data-status") : 200,
                statusText = textarea ? textarea.getAttribute("data-statusText") : "OK",
                content = {
                  html: root.innerHTML,
                  text: type ?
                    textarea.value :
                    root ? (root.textContent || root.innerText) : null
                };
              cleanUp();
              completeCallback(status, statusText, content, type ?
                ("Content-Type: " + type) :
                null);
            });

            // Now that the load handler has been set up, submit the form.
            form[0].submit();
          });

          // After everything has been set up correctly, the form and iframe
          // get injected into the DOM so that the submission can be
          // initiated.
          $("body").append(form, iframe);
        },

        // The `abort` function is called by jQuery when the request should be
        // aborted.
        abort: function() {
          if (iframe !== null) {
            iframe.unbind("load").attr("src", "javascript:false;");
            cleanUp();
          }
        }

      };
  });


});FD40.plugin("server", function($) {

/*!
 * jquery.server.
 * Extension of jquery.ajax with ability to parse server commands.
 *
 * Copyright (c) 2011 Jason Ramos
 * www.stackideas.com
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */
var self = $.server = function(options) {

	var request = $.Deferred(),

		ajaxOptions = $.extend(true, {}, self.defaultOptions, options, {success: function(){}}),

		xhr = request.xhr =
			$.Ajax(ajaxOptions)
				.done(function(commands){

					if (typeof commands==="string") {
						try {
							commands = $.parseJSON(commands);
						} catch(e) {
							request.rejectWith(request, ["Unable to parse Ajax commands.", "error"])
						}
					}

					if (!$.isArray(commands)) {

						request.rejectWith(request, ["Invalid ajax commands.", "error"]);

					} else {

						var parse = function(command){
							var type = command.type,
								parser = self.parsers[type] || options[type];

							if ($.isFunction(parser)) {
								return parser.apply(request, command.data);
							}
						}

						// Execute all the notifications first
						var commands = $.map(commands, function(command) {
							if (command.type=="notify") {
								parse(command);
							} else {
								return command;
							}
						})

						$.each(commands, function(i, command) {
							parse(command);
						});
					}

					// If server did not resolve this request
					if (request.state()==="pending") {

						// We'll resolve it ourselves
						request.resolveWith(request);
					}
				})
				.fail(function(jqXHR, status, statusText){

					request.rejectWith(request, [statusText, status]);
				});

		// Add abort method
		request.abort = xhr.abort;

	return request;
};

self.defaultOptions = {
	type: 'POST',
	data: {
		tmpl: 'component',
		format: 'ajax',
		no_html: 1
	},
	cache: false,
	contentType: 'application/x-www-form-urlencoded',
	dataType: 'json'
};

self.parsers = {

	script: function() {

		var data = $.makeArray(arguments);

		// For hardcoded javascript codes
		if (typeof data[0] == 'string') {
			try { eval(data[0]) } catch(err) {};
			return;
		}

		/**
		* Execute each method and assign returned object back to the chain.
		*
		* Foundry().attr('checked', true);
		* 	is equivalent to:
		* window['Foundry']('.element')[attr]('checked', true);
		*/
		var chain = window, chainBroken = false;

		$.each(data, function(i, chainer)
		{
			if (chainer.property==="Foundry") {
				chainer.property = $.globalNamespace;
			}

			if (chainer.method==="Foundry") {
				chainer.method = $.globalNamespace;
			}

			try {
				switch(chainer.type)
				{
					case 'get':
						chain = chain[chainer.property];
						break;

					case 'set':
						chain[chainer.property] = chainer.value;
						chainBroken=true;
						break;

					case 'call':
						chain = chain[chainer.method].apply(chain, chainer.args);
						break;
				}
			} catch(err) {
				chainBroken = true;
			}
		})
	},

	resolve: function() {

		this.resolveWith(this, arguments);
	},

	reject: function() {

		this.rejectWith(this, arguments);
	},

	notify: function() {

		this.notifyWith(this, arguments);
	},

	redirect: function(url) {

		window.location = url;
	}
};
});FD40.plugin("component", function($) {

/**
 * jquery.component.
 * Boilerplate for client-side MVC application.
 *
 * Copyright (c) 2011 Jason Ramos
 * www.stackideas.com
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */

var Component = $.Component = function(name, options) {

    if (arguments.length < 1) {
        return Component.registry;
    }

    if (arguments.length < 2) {
        return Component.registry[name];
    }

    return Component.register(name, options);
}

Component.registry = {};

Component.proxy = function(component, property, value) {

    // If it's a method
    if ($.isFunction(value)) {

        // Change the "this" context to the component itself
        component[property] = $.proxy(value, component);

    } else {

        component[property] = value;
    }
}

Component.register = function(name, options) {

    // If an abstract component was passed in
    var abstractComponent;

    // Normalize arguments
    if ($.isFunction(name)) {
        abstractComponent = name;
        name = abstractComponent.className;
        options = abstractComponent.options;
    }

    var self =

        // Put it in component registry
        Component.registry[name] =

        // Set it to the global namespace
        window[name] =

        // When called as a function, it will return the correct jQuery object.
        function(command) {

            return ($.isFunction(command)) ? command($) : component;
        };

    // Extend component with properties in component prototype
    $.each(Component.prototype, function(property, value) {

        Component.proxy(self, property, value);
    });


    self.$ = $;
    self.options = options;
    self.className = name;
    self.identifier = 'easysocial';
    self.componentName = "com_easysocial";
    self.prefix = self.identifier + "/";
    self.version = options.version;
    self.safeVersion = self.version.replace(/\./g,"");
    self.environment = options.environment  || $.environment;
    self.mode = options.mode || $.mode;
    self.debug = (self.environment==='development');
    self.console = Component.console(self);
    self.language = options.language || $.locale.lang || "en";
    self.baseUrl = options.baseUrl || $.indexUrl + "?option=" + self.componentName;
    self.ajaxUrl = options.ajaxUrl || $.basePath + "/?option=" + self.componentName;
    self.scriptPath = options.scriptPath || $.rootPath + "/media/" + self.componentName + "/scripts/";

    // Legacy and needs to be removed
    self.stylePath = options.stylePath    || $.rootPath + "/media/" + self.componentName + "/styles/";
    self.templatePath = options.templatePath || options.scriptPath;
    self.languagePath = options.languagePath || self.ajaxUrl + '&tmpl=component&no_html=1&controller=lang&task=getLanguage';
    self.viewPath = options.viewPath     || self.ajaxUrl + '&tmpl=component&no_html=1&controller=themes&task=getAjaxTemplate';
    self.optimizeResources = true;
    self.resourcePath = options.resourcePath || self.ajaxUrl + '&tmpl=component&no_html=1&controller=foundry&task=getResource';
    self.resourceInterval = 1200; // Joomla session timestamp is per second, we add another 200ms just to be safe.
    
    self.scriptVersioning  = options.scriptVersioning || false;
    self.tasks = [];

    // Register component to bootleader
    FD40.component(name, self);

    // If there's no abstract componet prior to this, we're done!
    if (!abstractComponent) {
        return;
    }

    // If we're on development mode
    if (self.debug) {

        // Execute queue in abstract component straightaway
        abstractComponent.queue.execute();

    // If we're on static or optimized mode
    } else {

        // Get component installers from bootloader and install them
        var installer, installers = FD40.installer(name);
        while(installer = installers.shift()) {
            self.install.apply(self, installer);
        }

        // Wait until definitions, scripts & resources are installed
        $.when(
            self.install("definitions"),
            self.install("scripts"),
            self.install("resources")
        ).done(function(){

            // Then only execute queue in abstract component.
            abstractComponent.queue.execute();
        });
    }

    var storage = self.storage = function(key, val) {

        var prefix = self.prefix,
            key = prefix + key,
            length = arguments.length;

        // Getter
        if (length==1) return $.Storage.get(key)

        // Setter (remove or set)
        if (length==2) return key===false ? $.Storage.remove(prefix + val) : $.Storage.set(key, val);

        return storage.getAll();
    };

    $.extend(self.storage, {

        getAll: function() {

            var prefix = self.prefix,
                i = prefix.length,
                storage = $.Storage.getAll(),
                obj = {};

            for (key in storage) {
                if (key.substr(0, i)==prefix) {
                    obj[key.substr(i)] = storage[key];
                }
            }

            return obj;
        },

        remove: function(key) {
            $.Storage.remove(self.prefix + key);
        },

        clear: function() {
            for (key in storage.getAll()) {
                storage.remove(key);
            }
        }
    });
}

Component.extend = function(property, value) {

    // For later components
    Component.prototype[property] = value;

    // For existing components
    $.each(Component.registry, function(name, component) {
        Component.proxy(component, property, value);
    });
}

$.template("component/console",'<div id="[%== component.identifier %]-console" class="foundry-console" style="display: none; z-index: 999999;"><div class="console-header"><div class="console-title">[%= component.className %] [%= component.version %]</div><div class="console-remove-button">x</div></div><div class="console-log-item-group"></div><style type="text/css">.foundry-console{position:fixed;width:50%;height:50%;bottom:0;left:0;background:white;box-shadow: 0 0 5px 0;margin-left: 25px;}.console-log-item-group{width: 100%;height: 100%;overflow-y:scroll;}.console-header{position: absolute;background:red;color:white;font-weight:bold;top:-24px;left: 0;line-height:24px;width:100%}.console-remove-button{text-align:center;cursor: pointer;display:block;width: 24px;float:right}.console-remove-button:hover{color: yellow}.console-title{padding: 0 5px;float:left}.console-log-item{padding: 5px}.console-log-item + .console-log-item{border-top: 1px solid #ccc}</style></div>');

Component.console = function(component) {

    return (function(self){

        var instance = function(method) {

                if (arguments.length < 1) {
                    return instance.toggle();
                }

                return instance[method] && instance[method].apply(instance, arguments);
            },

            element;

            instance.selector = "#" + self.identifier + "-console";

            instance.init = function() {

                element = $(instance.selector);

                if (element.length < 1) {
                    element = $($.View("component/console", {component: self})).appendTo("body");

                    element.find(".console-remove-button").click(function(){
                        element.hide();
                    });
                }

                instance.element = element;

                return arguments.callee;
            };

            instance.methods = {

                log: function(message, type, code) {

                    type = type || "info";

                    var itemGroup = element.find(".console-log-item-group"),
                        item =
                            $(document.createElement("div"))
                                .addClass("console-log-item type-" + type)
                                .attr("data-code", code)
                                .html(message);

                    itemGroup.append(item);
                    itemGroup[0].scrollTop = itemGroup[0].scrollHeight;

                    // Automatically show window on each log
                    if (self.debug) { element.show(); }
                },

                toggle: function() {
                    element.toggle();
                },

                reset: function() {
                    element.find(".console-log-item-group").empty();
                }
            };

        $.each(instance.methods, function(method, fn) {
            instance[method] = function() {
                instance.init(); // Always call init in case of destruction of element
                return fn.apply(instance, arguments);
            }
        });

        return instance;

    })(component);
}

var doc = $(document),
    proto = Component.prototype;

$.extend(proto, {

    run: function(command) {

        return ($.isFunction(command)) ? command($) : this;
    },

    ready: (function(){

        // Replace itself once document is ready
        doc.ready(function(){
            proto.ready = proto.run;
        });

        return function(callback) {

            if (!$.isFunction(callback)) return;

            // When document is ready
            doc.ready(function() {
                callback($);
            });
        }
    })(),

    install: function(name, factory) {

        var self = this,
            task = self.tasks[name] || (self.tasks[name] = $.Deferred());

        // Getter
        if (!factory) return task;

        // Setter
        var install = function(){
            factory($, self);
            return task.resolve();
        }

        // If this is installer contains component definitions,
        // install straightaway.
        if (name=="definitions") return install();

        // Else for component definitiosn to install first,
        // then only install this installer.
        $.when(self.install("definitions")).done(install);
    },

    token: function() {

        var self = this;

        if (self.token.value) {
            return self.token.value;
        }

        return self.token.value = window.es.token;
    },

    template: function(name) {

        var self = this;

        // Get all component templates
        if (name==undefined) {

            return $.grep($.template(), function(template) {

                return template.indexOf(self.prefix)==0;
            });
        }

        // Prepend component prefix
        arguments[0] = self.prefix + name;

        // Getter or setter
        return $.template.apply(null, arguments);
    },

    // Component require extends $.require with the following additional methods:
    // - resource()
    // - view()
    // - language()
    //
    // It also changes the behaviour of existing methods to load in component-specific behaviour.
    require: function(options) {

        var self = this,

            options = options || {},

            require = $.require(options),

            _require = {};

            // Keep a copy of the original method so the duck punchers below can use it.
            $.each(["library", "script", "template", "done"], function(i, method){
                _require[method] = require[method];
            });

        // Resource call should NOT be called directly.
        // .resource({type: "view", name: "photo.item", loader: deferredObject})
        require.resource = function(resource) {

            // If this is not a valid resource object, skip.
            if (!$.isPlainObject(resource)) return;
            if (!resource.type || !resource.name || !$.isDeferred(resource.loader)) return;

            var batch = this;

            // Get resource collector
            var resourceCollector = self.resourceCollector;

            // If we haven't started collecting resources
            if (!resourceCollector) {

                // Then start collecting resources
                resourceCollector = self.resourceCollector = $.Deferred();

                $.extend(resourceCollector, {

                    name: $.uid("ResourceCollector"),

                    manifest: [],

                    loaderList: [],

                    loaders: [],

                    load: function() {

                        // End this batch of resource collecting
                        delete self.resourceCollector;

                        // If there are not resources to pull,
                        // just resolve resource collector.
                        if (resourceCollector.manifest.length < 0) {
                            resourceCollector.resolve();
                            return;
                        }

                        var retry = 0;

                        var loadResources = function(){

                            retry++;

                            $.Ajax(
                                {
                                    type: 'POST',
                                    url: self.resourcePath,
                                    dataType: "json",
                                    data: {
                                        resource: resourceCollector.manifest
                                    }
                                })
                                .done(function(manifest) {

                                    if (!$.isArray(manifest)) {
                                        resourceCollector.reject("Server did not return a valid resource manifest.");
                                        return;
                                    }

                                    $.each(manifest, function(i, resource) {

                                        var content = resource.content;

                                        resourceCollector.loaders[resource.id]
                                            [content!==undefined ? "resolve" : "reject"]
                                            (content);
                                    });

                                    if (retry > 1 && self.debug) {
                                        console.info("Attempt to try and get resources again was successful!");
                                    }
                                })
                                .fail(function(){
                                    if (retry > 2) {
                                        if (self.debug) { console.error("Unable to get resource again. Giving up!"); };
                                        return;
                                    }
                                    if (self.debug) {
                                        console.warn("Unable to get resource. Trying again...");
                                    }
                                    loadResources();
                                });
                        }

                        loadResources();

                        // Resolve resource collector when all is done
                        $.when.apply(null, resourceCollector.loaderList)
                            .done(resourceCollector.resolve)
                            .fail(resourceCollector.reject);
                    }
                });

                setTimeout(resourceCollector.load, self.resourceCollectionInterval);
            }

            // Create a resource id
            var id = resource.id = $.uid("Resource");

            // Add to the loader map
            // - to be used to resolve the loader with the returned content
            resourceCollector.loaders[id] = resource.loader;

            // Add to the loader list
            // - to be used with $.when()
            resourceCollector.loaderList.push(resource.loader);

            // Remove the reference to the loader
            // - so the loader doesn't get included in the manifest that gets sent to the server
            delete resource.loader;

            // Then add it to our list of resource manifest
            resourceCollector.manifest.push(resource);

            // Note: Only resource loaders are batch tasks, not resource collectors.
            // var task = resourceCollector;
            // batch.addTask(task);
            return require;
        };

        require.view = function() {

            var batch   = this,

                request = batch.expand(arguments, {path: self.viewPath}),

                loaders = {},

                options = request.options,

                names   = $.map(request.names, function(name) {

                    // Get template loader
                    var absoluteName = self.prefix + name,
                        loader = $.require.template.loaders[absoluteName];

                    // If this is being loaded, skip.
                    if (loader) return;

                    loader = $.require.template.loader(absoluteName);

                    loader.name = absoluteName;

                    // Add template loader as a task of this batch
                    batch.addTask(loader);

                    // Load as part of a coalesced ajax call if enabled
                    if (self.optimizeResources) {

                        require.resource({
                            type: "view",
                            name: name,
                            loader: loader
                        });

                        return;

                    } else {

                        loaders[name] = loader;
                        return name;
                    }
                });

            // Load using regular ajax call
            // This will always be zero when optimizeResources is enabled.
            if (names.length > 0) {

                $.Ajax(
                    {
                        url: options.path,
                        dataType: "json",
                        data: { names: names }
                    })
                    .done(function(templates) {

                        if (!$.isArray(templates)) return;

                        $.each(templates, function(i, template) {

                            var content = template.content;

                            loaders[template.name]
                                [content!==undefined ? "resolve" : "reject"]
                                (content);
                        });
                    });
            }

            return require;
        };

        require.library = function() {

            _require.script.apply(this, arguments);

            return require;
        };

        require.script = function() {

            var batch = this,

                request = batch.expand(arguments, {path: self.scriptPath}),

                names = $.map(request.names, function(name) {

                    // Ignore module definitions
                    if ($.isArray(name) ||

                        // and urls
                        $.isUrl(name) ||

                        // and relative paths.
                        /^(\/|\.)/.test(name)) return name;

                    var moduleName = self.prefix + name,

                        moduleUrl =

                            $.uri(request.options.path)
                                .toPath(
                                    './' + name + '.' + (request.options.extension || 'js') +
                                    ((self.scriptVersioning) ? "?" + "version=" + self.safeVersion : "")
                                )
                                .toString();

                    return [[moduleName, moduleUrl, true]];
                });

            _require.script.apply(require, [request.options].concat(names));

            return require;
        };

        // Override path
        require.template = function() {

            var batch   = this,

                request = batch.expand(arguments, {path: self.templatePath});

            _require.template.apply(require, [request.options].concat(

                $.map(request.names, function(name) {

                    return [[self.prefix + name, name]];
                })
            ));

            return require;
        };

        require.app = function() {

            var batch = this,

                request = batch.expand(arguments, {path: self.scriptPath})

                names = $.map(request.names, function(name) {

                    // Ignore module definitions
                    if ($.isArray(name) ||

                        // and urls
                        $.isUrl(name) ||

                        // and relative paths.
                        /^(\/|\.)/.test(name)) return name;

                    var parts = name.split('/'),
                        path = $.rootPath + '/media/' + self.componentName + '/apps';

                    // Currently used by fields
                    if (parts.length===4) {
                        path += '/' + parts.shift();
                    }

                    // Build path
                    path += '/' + parts[0] + '/' + parts[1] + '/scripts/' + parts[2];

                    var moduleName = self.prefix + name,

                        moduleUrl = path + '.' +
                            (request.options.extension || 'js') +
                            ((self.scriptVersioning) ? "?" + "version=" + self.safeVersion : "");

                    return [[moduleName, moduleUrl, true]];
                });

            _require.script.apply(require, [request.options].concat(names));

            return require;
        };

        // Only execute require done callback when component is ready
        require.done = function(callback) {

            return _require.done.call(require, function(){

                self.ready(callback);
            });
        };

        return require;
    },

    module: function(name, factory) {

        var self = this;

        // TODO: Support for multiple module factory assignment
        if ($.isArray(name)) {
            return;
        }

        var fullname = self.prefix + name;

        return (factory) ?

            // Set module
            $.module.apply(null, [fullname, function(){

                var module = this;

                factory.call(module, $);
            }])

            :

            // Get module
            $.module(fullname);
    }
});
$.Component.extend("ajax", function(namespace, params, callback) {

    var self = this;
    var date = new Date();

    var options = {
            url: self.ajaxUrl + "&_ts=" + date.getTime(),
            data: $.extend(
                params, {
                    option: self.componentName,
                    namespace: namespace
                }
            )
        };

    options = $.extend(true, options, self.options.ajax);
    options.data[self.token()] = 1;

    // This is for server-side function arguments
    if (options.data.hasOwnProperty('args')) {
        options.data.args = $.toJSON(options.data.args);
    }

    if ($.isPlainObject(callback)) {

        if (callback.type) {

            switch (callback.type) {

                case 'jsonp':

                    callback.dataType = 'jsonp';

                    // This ensure jQuery doesn't use XHR should it detect the ajax url is a local domain.
                    callback.crossDomain = true;

                    options.data.transport = 'jsonp';
                    break;

                case 'iframe':

                    // For use with iframe-transport
                    callback.iframe = true;

                    callback.processData = false;

                    callback.files = options.data.files;

                    delete options.data.files;

                    options.data.transport = 'iframe';
                    break;
            }

            delete callback.type;
        }

        $.extend(options, callback);
    }

    if ($.isFunction(callback)) {
        options.success = callback;
    }

    var ajax = $.server(options);

    ajax.progress(function(message, type, code) {
        if (self.debug && type=="debug") {
            self.console.log(message, type, code);
        }
    });

    return ajax;
});

$.Component.extend("Controller", function() {

    var self = this,
        args = $.makeArray(arguments),
        name = args[0],
        staticProps,
        protoFactory;

    // Getter
    if (args.length==1) {
        return $.String.getObject(name);
    };

    // Setter
    if (args.length > 2) {
        staticProps = args[1],
        protoFactory = args[2]
    } else {
        staticProps = {},
        protoFactory = args[1]
    }

    // Map component as a static property
    // of the controller class
    $.extend(staticProps, {
        root: self.className + '.Controller',
        component: self
    });

    return $.Controller.apply(this, [name, staticProps, protoFactory]);
});

$.Component.extend("Model", function() {
    var self = this,
        args = $.makeArray(arguments),
        name = self.className + '.Model.' + args[0],
        staticProps,
        protoFactory;

    // Getter
    if (args.length==1) {
        return $.String.getObject(args[0]);
    }

    if( args.length==2) {
        staticProps = {},
        protoFactory = args[1]
    }

    if( args.length > 2) {
        staticProps = args[1],
        protoFactory = args[2]
    }

    // Map component as a static property
    // of the model class
    $.extend(staticProps, {
        component: self
    });

    return $.Model.apply(this, [name, staticProps, protoFactory]);
});

$.Component.extend("Model.List", function() {
    var self = this,
        args = $.makeArray(arguments),
        name = self.className + '.Model.List.' + args[0],
        staticProps,
        protoFactory;

    // Getter
    if (args.length==1) {
        return $.String.getObject(args[0]);
    }

    if( args.length==2) {
        staticProps = {},
        protoFactory = args[1]
    }

    if( args.length > 2) {
        staticProps = args[1],
        protoFactory = args[2]
    }

    // Map component as a static property
    // of the model class
    $.extend(staticProps, {
        component: self
    });

    return $.Model.List.apply(this, [name, staticProps, protoFactory]);
});

$.Component.extend("View", function(name) {

    var self = this;

    // Gett all component views
    if (arguments.length < 1) {
        return self.template();
    }

    // Prepend component prefix
    arguments[0] = self.prefix + arguments[0];

    // Getter or setter
    return $.View.apply(this, arguments);
});
// Component should always be the last core plugin to load.

// Execute all pending foundry modules
FD40.module.execute();

// Get all abstract components
$.each(FD40.component(), function(i, abstractComponent){

    // If this component is registered, stop.
    if (abstractComponent.registered) return;

    // Create an instance of the component
    $.Component.register(abstractComponent);
});

});FD40.plugin("static", function($) {
	$.module(["autosize.input","datetimepicker","dialog","expanding","gmaps","history","image","leaflet-providers","leaflet","markitup","mentions","mobile-events","moment","passwordstrength","placeholder","plupload","popbox","scrollTo","select2","sly","textboxlist","toast","ui\/core","ui\/mouse","ui\/position","ui\/resizable","ui\/slider","ui\/widget","wavesurfer"]);

	// Now we need to retrieve the contents of each files
			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var jQuery = $; 
var exports = function() { 

var AutosizeInput = function(input, options) {

    var self = this;

    self.input   = $(input);
    self.options = $.extend(AutosizeInput.defaultOptions, options);
    self.mirror  = $('<span style="position:absolute; top:-999px; left:0; white-space:pre;"/>');

    $.each([
        'fontFamily',
        'fontSize',
        'fontWeight',
        'fontStyle',
        'letterSpacing',
        'textTransform',
        'wordSpacing',
        'textIndent'
    ], function (i, val) {
        self.mirror[0].style[val] = self.input.css(val);
    });

    $("body").append(self.mirror);

    self.input.bind("keydown keyup input", function(e){
        self.update();
    });

    self.update();
}

AutosizeInput.defaultOptions = {
    space: 30
}

AutosizeInput.validTypes = [
    "text",
    "password",
    "search",
    "url",
    "tel",
    "email"
];

AutosizeInput.prototype.update = function() {

    var self   = this,
        input  = self.input,
        mirror = self.mirror,
        value  = input.val();

    if (!value) {
        value = input.attr("placeholder");
    }

    if (value === mirror.text()) {
        return;
    }

    mirror.text(value);

    var newWidth = mirror.width() + self.options.space;
    input.width(newWidth);
};

$.fn.autosizeInput = function(options) {

    return this.each(function () {
        if(!(this.tagName == "INPUT" && $.inArray(this.type, AutosizeInput.validTypes) > -1)) {
            return;
        }
        var $this = $(this);
        if (!$this.data("autosizeInputInstance")) {
            $this.data("autosizeInputInstance", new AutosizeInput(this, options));
        }
    });
};

$(function () {
    $("input[data-autosize-input]").autosizeInput();
});


}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("autosize.input", moduleFactory);

}());			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
$.require() 
 .script("moment") 
 .done(function() { 
var exports = function() { 

/*
Version 3.0.0
=========================================================
bootstrap-datetimepicker.js
https://github.com/Eonasdan/bootstrap-datetimepicker
=========================================================
The MIT License (MIT)

Copyright (c) 2014 Jonathan Peterson

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

	var dpgId = 0,

	pMoment = $.moment,

// ReSharper disable once InconsistentNaming
	DateTimePicker = function (element, options) {
		var defaults = {
			pickDate: true,
			pickTime: true,
			useMinutes: true,
			useSeconds: false,
			useCurrent: true,
			minuteStepping: 1,
			minDate: new pMoment({ y: 1900 }),
			maxDate: new pMoment().add(100, "y"),
			showToday: true,
			collapse: true,
			language: "en",
			defaultDate: "",
			disabledDates: false,
			enabledDates: false,
			icons: {},
			useStrict: false,
			direction: "auto",
			sideBySide: false,
			daysOfWeekDisabled: false,
			component: "",
			dow: 0
		},

		icons = {
			time  : 'far fa-clock',
			date  : 'fa fa-calendar',
			up    : 'fa fa-chevron-up',
			down  : 'fa fa-chevron-down'
		},

		picker = this,

		init = function () {

			var icon = false, i, dDate, longDateFormat;
			picker.options = $.extend({}, defaults, options);
			picker.options.icons = $.extend({}, icons, picker.options.icons);

			picker.element = $(element);

			dataToOptions();

			if (!(picker.options.pickTime || picker.options.pickDate))
				throw new Error('Must choose at least one picker');

			picker.id = dpgId++;
			pMoment.lang(picker.options.language);
			picker.date = pMoment();
			picker.unset = false;
			picker.isInput = picker.element.is('input');
			picker.component = false;

			// Set the start of week
			pMoment()._lang._week.dow = picker.options.dow;

			if (picker.element.hasClass('input-group')) {
				if (picker.element.find('.datepickerbutton').size() == 0) {//in case there is more then one 'input-group-addon' Issue #48
					picker.component = picker.element.find("[class^='input-group-']");
				}
				else {
					picker.component = picker.element.find('.datepickerbutton');
				}
			}
			picker.format = picker.options.format;

			longDateFormat = pMoment()._lang._longDateFormat;

			if (!picker.format) {
				picker.format = (picker.options.pickDate ? longDateFormat.L : '');
				if (picker.options.pickDate && picker.options.pickTime) picker.format += ' ';
				picker.format += (picker.options.pickTime ? longDateFormat.LT : '');
				if (picker.options.useSeconds) {
					if (~longDateFormat.LT.indexOf(' A')) {
						picker.format = picker.format.split(" A")[0] + ":ss A";
					}
					else {
						picker.format += ':ss';
					}
				}
			}
			picker.use24hours = picker.format.toLowerCase().indexOf("a") < 1;

			if (picker.component) icon = picker.component.find('span');

			if (picker.options.pickTime) {
				if (icon) icon.addClass(picker.options.icons.time);
			}
			if (picker.options.pickDate) {
				if (icon) {
					icon.removeClass(picker.options.icons.time);
					icon.addClass(picker.options.icons.date);
				}
			}

			picker.widget = $(getTemplate()).appendTo('body');

			if (picker.options.useSeconds && !picker.use24hours) {
				picker.widget.width(300);
			}

			picker.minViewMode = picker.options.minViewMode || 0;
			if (typeof picker.minViewMode === 'string') {
				switch (picker.minViewMode) {
					case 'months':
						picker.minViewMode = 1;
						break;
					case 'years':
						picker.minViewMode = 2;
						break;
					default:
						picker.minViewMode = 0;
						break;
				}
			}
			picker.viewMode = picker.options.viewMode || 0;
			if (typeof picker.viewMode === 'string') {
				switch (picker.viewMode) {
					case 'months':
						picker.viewMode = 1;
						break;
					case 'years':
						picker.viewMode = 2;
						break;
					default:
						picker.viewMode = 0;
						break;
				}
			}

			picker.options.disabledDates = indexGivenDates(picker.options.disabledDates);
			picker.options.enabledDates = indexGivenDates(picker.options.enabledDates);

			picker.startViewMode = picker.viewMode;
			picker.setMinDate(picker.options.minDate);
			picker.setMaxDate(picker.options.maxDate);
			fillDow();
			fillMonths();
			fillHours();
			fillMinutes();
			fillSeconds();
			update();
			showMode();
			attachDatePickerEvents();
			if (picker.options.defaultDate !== "" && getPickerInput().val() == "") picker.setValue(picker.options.defaultDate);
			if (picker.options.minuteStepping !== 1) {
				var rInterval = picker.options.minuteStepping;
				picker.date.minutes((Math.round(picker.date.minutes() / rInterval) * rInterval) % 60).seconds(0);
			}
		},

		getPickerInput = function () {
			if (picker.isInput) {
				return picker.element;
			} else {
				return dateStr = picker.element.find('input');
			}
		},

		dataToOptions = function () {
			var eData
			if (picker.element.is('input')) {
				eData = picker.element.data();
			}
			else {
				eData = picker.element.data();
			}
			if (eData.dateFormat !== undefined) picker.options.format = eData.dateFormat;
			if (eData.datePickdate !== undefined) picker.options.pickDate = eData.datePickdate;
			if (eData.datePicktime !== undefined) picker.options.pickTime = eData.datePicktime;
			if (eData.dateUseminutes !== undefined) picker.options.useMinutes = eData.dateUseminutes;
			if (eData.dateUseseconds !== undefined) picker.options.useSeconds = eData.dateUseseconds;
			if (eData.dateUsecurrent !== undefined) picker.options.useCurrent = eData.dateUsecurrent;
			if (eData.dateMinutestepping !== undefined) picker.options.minuteStepping = eData.dateMinutestepping;
			if (eData.dateMindate !== undefined) picker.options.minDate = eData.dateMindate;
			if (eData.dateMaxdate !== undefined) picker.options.maxDate = eData.dateMaxdate;
			if (eData.dateShowtoday !== undefined) picker.options.showToday = eData.dateShowtoday;
			if (eData.dateCollapse !== undefined) picker.options.collapse = eData.dateCollapse;
			if (eData.dateLanguage !== undefined) picker.options.language = eData.dateLanguage;
			if (eData.dateDefaultdate !== undefined) picker.options.defaultDate = eData.dateDefaultdate;
			if (eData.dateDisableddates !== undefined) picker.options.disabledDates = eData.dateDisableddates;
			if (eData.dateEnableddates !== undefined) picker.options.enabledDates = eData.dateEnableddates;
			if (eData.dateIcons !== undefined) picker.options.icons = eData.dateIcons;
			if (eData.dateUsestrict !== undefined) picker.options.useStrict = eData.dateUsestrict;
			if (eData.dateDirection !== undefined) picker.options.direction = eData.dateDirection;
			if (eData.dateSidebyside !== undefined) picker.options.sideBySide = eData.dateSidebyside;
		},

		place = function () {
			var position = 'absolute',
			offset = picker.component ? picker.component.offset() : picker.element.offset(), $window = $(window);
			picker.width = picker.component ? picker.component.outerWidth() : picker.element.outerWidth();
			offset.top = offset.top + picker.element.outerHeight();

			var placePosition;
			if (picker.options.direction === 'up') {
				placePosition = 'top'
			} else if (picker.options.direction === 'bottom') {
				placePosition = 'bottom'
			} else if (picker.options.direction === 'auto') {
				if (offset.top + picker.widget.height() > $window.height() + $window.scrollTop() && picker.widget.height() + picker.element.outerHeight() < offset.top) {
					placePosition = 'top';
				} else {
					placePosition = 'bottom';
				}
			};
			if (placePosition === 'top') {
				offset.top -= picker.widget.height() + picker.element.outerHeight() + 15;
				picker.widget.addClass('top').removeClass('bottom');
			} else {
				offset.top += 1;
				picker.widget.addClass('bottom').removeClass('top');
			}

			if (picker.options.width !== undefined) {
				picker.widget.width(picker.options.width);
			}

			if (picker.options.orientation === 'left') {
				picker.widget.addClass('left-oriented');
				offset.left = offset.left - picker.widget.width() + 20;
			}

			if (isInFixed()) {
				position = 'fixed';
				offset.top -= $window.scrollTop();
				offset.left -= $window.scrollLeft();
			}

			if ($window.width() < offset.left + picker.widget.outerWidth()) {
				offset.right = $window.width() - offset.left - picker.width;
				offset.left = 'auto';
				picker.widget.addClass('pull-right');
			} else {
				offset.right = 'auto';
				picker.widget.removeClass('pull-right');
			}

			picker.widget.css({
				position: position,
				top: offset.top,
				left: offset.left,
				right: offset.right
			});
		},

		notifyChange = function (oldDate, eventType) {
			if (pMoment(picker.date).isSame(pMoment(oldDate))) return;
			picker.element.trigger({
				type: 'dp.change',
				date: pMoment(picker.date),
				oldDate: pMoment(oldDate)
			});

			if (eventType !== 'change')
				picker.element.change();
		},

		notifyError = function (date) {
			picker.element.trigger({
				type: 'dp.error',
				date: pMoment(date)
			});
		},

		update = function (newDate) {
			pMoment.lang(picker.options.language);
			var dateStr = newDate;
			if (!dateStr) {
				dateStr = getPickerInput().val()
				if (dateStr) picker.date = pMoment(dateStr, picker.format, picker.options.useStrict);
				if (!picker.date) picker.date = pMoment();
			}
			picker.viewDate = pMoment(picker.date).startOf("month");
			fillDate();
			fillTime();
		},

		fillDow = function () {
			pMoment.lang(picker.options.language);
			var html = $('<tr>'), weekdaysMin = pMoment.weekdaysMin(), i;

			// Reconstruct weekdays structure by start day of the week
			var spliced = weekdaysMin.splice(pMoment()._lang._week.dow);
			weekdaysMin = spliced.concat(weekdaysMin);

			$.each(weekdaysMin, function(i, w) {
				html.append('<th class="dow">' + w + '</th>');
			});

			// if (pMoment()._lang._week.dow == 0) { // starts on Sunday
			//     for (i = 0; i < 7; i++) {
			//         html.append('<th class="dow">' + weekdaysMin[i] + '</th>');
			//     }
			// } else {
			//     for (i = 1; i < 8; i++) {
			//         if (i == 7) {
			//             html.append('<th class="dow">' + weekdaysMin[0] + '</th>');
			//         } else {
			//             html.append('<th class="dow">' + weekdaysMin[i] + '</th>');
			//         }
			//     }
			// }
			picker.widget.find('.datepicker-days thead').append(html);
		},

		fillMonths = function () {
			pMoment.lang(picker.options.language);
			var html = '', i = 0, monthsShort = pMoment.monthsShort();
			while (i < 12) {
				html += '<span class="month">' + monthsShort[i++] + '</span>';
			}
			picker.widget.find('.datepicker-months td').append(html);
		},

		fillDate = function () {
			pMoment.lang(picker.options.language);
			var year = picker.viewDate.year(),
				month = picker.viewDate.month(),
				startYear = picker.options.minDate.year(),
				startMonth = picker.options.minDate.month(),
				endYear = picker.options.maxDate.year(),
				endMonth = picker.options.maxDate.month(),
				currentDate,
				prevMonth, nextMonth, html = [], row, clsName, i, days, yearCont, currentYear, months = pMoment.months();

			picker.widget.find('.datepicker-days').find('.disabled').removeClass('disabled');
			picker.widget.find('.datepicker-months').find('.disabled').removeClass('disabled');
			picker.widget.find('.datepicker-years').find('.disabled').removeClass('disabled');

			picker.widget.find('.datepicker-days th:eq(1)').text(
				months[month] + ' ' + year);

			prevMonth = pMoment(picker.viewDate).subtract("months", 1);
			days = prevMonth.daysInMonth();
			prevMonth.date(days).startOf('week');
			if ((year == startYear && month <= startMonth) || year < startYear) {
				picker.widget.find('.datepicker-days th:eq(0)').addClass('disabled');
			}
			if ((year == endYear && month >= endMonth) || year > endYear) {
				picker.widget.find('.datepicker-days th:eq(2)').addClass('disabled');
			}

			nextMonth = pMoment(prevMonth).add(42, "d");
			while (prevMonth.isBefore(nextMonth)) {
				if (prevMonth.weekday() === pMoment().startOf('week').weekday()) {
					row = $('<tr>');
					html.push(row);
				}
				clsName = '';
				if (prevMonth.year() < year || (prevMonth.year() == year && prevMonth.month() < month)) {
					clsName += ' old';
				} else if (prevMonth.year() > year || (prevMonth.year() == year && prevMonth.month() > month)) {
					clsName += ' new';
				}
				if (prevMonth.isSame(pMoment({ y: picker.date.year(), M: picker.date.month(), d: picker.date.date() }))) {
					clsName += ' active';
				}
				if (isInDisableDates(prevMonth) || !isInEnableDates(prevMonth)) {
					clsName += ' disabled';
				}
				if (picker.options.showToday === true) {
					if (prevMonth.isSame(pMoment(), 'day')) {
						clsName += ' today';
					}
				}
				if (picker.options.daysOfWeekDisabled) {
					for (i in picker.options.daysOfWeekDisabled) {
						if (prevMonth.day() == picker.options.daysOfWeekDisabled[i]) {
							clsName += ' disabled';
							break;
						}
					}
				}
				row.append('<td class="day' + clsName + '">' + prevMonth.date() + '</td>');

				currentDate = prevMonth.date();
				prevMonth.add(1, "d");

				if (currentDate == prevMonth.date()) {
				  prevMonth.add(1, "d");
				}
			}
			picker.widget.find('.datepicker-days tbody').empty().append(html);
			currentYear = picker.date.year(), months = picker.widget.find('.datepicker-months')
				.find('th:eq(1)').text(year).end().find('span').removeClass('active');
			if (currentYear === year) {
				months.eq(picker.date.month()).addClass('active');
			}
			if (currentYear - 1 < startYear) {
				picker.widget.find('.datepicker-months th:eq(0)').addClass('disabled');
			}
			if (currentYear + 1 > endYear) {
				picker.widget.find('.datepicker-months th:eq(2)').addClass('disabled');
			}
			for (i = 0; i < 12; i++) {
				if ((year == startYear && startMonth > i) || (year < startYear)) {
					$(months[i]).addClass('disabled');
				} else if ((year == endYear && endMonth < i) || (year > endYear)) {
					$(months[i]).addClass('disabled');
				}
			}

			html = '';
			year = parseInt(year / 10, 10) * 10;
			yearCont = picker.widget.find('.datepicker-years').find(
				'th:eq(1)').text(year + '-' + (year + 9)).end().find('td');
			picker.widget.find('.datepicker-years').find('th').removeClass('disabled');
			if (startYear > year) {
				picker.widget.find('.datepicker-years').find('th:eq(0)').addClass('disabled');
			}
			if (endYear < year + 9) {
				picker.widget.find('.datepicker-years').find('th:eq(2)').addClass('disabled');
			}
			year -= 1;
			for (i = -1; i < 11; i++) {
				html += '<span class="year' + (i === -1 || i === 10 ? ' old' : '') + (currentYear === year ? ' active' : '') + ((year < startYear || year > endYear) ? ' disabled' : '') + '">' + year + '</span>';
				year += 1;
			}
			yearCont.html(html);
		},

		fillHours = function () {
			pMoment.lang(picker.options.language);
			var table = picker.widget.find('.timepicker .timepicker-hours table'), html = '', current, i, j;
			table.parent().hide();
			if (picker.use24hours) {
				current = 0;
				for (i = 0; i < 6; i += 1) {
					html += '<tr>';
					for (j = 0; j < 4; j += 1) {
						html += '<td class="hour">' + padLeft(current.toString()) + '</td>';
						current++;
					}
					html += '</tr>';
				}
			}
			else {
				current = 1;
				for (i = 0; i < 3; i += 1) {
					html += '<tr>';
					for (j = 0; j < 4; j += 1) {
						html += '<td class="hour">' + padLeft(current.toString()) + '</td>';
						current++;
					}
					html += '</tr>';
				}
			}
			table.html(html);
		},

		fillMinutes = function () {
			var table = picker.widget.find('.timepicker .timepicker-minutes table'), html = '', current = 0, i, j, step = picker.options.minuteStepping;
			table.parent().hide();
			if (step == 1) step = 5;
			for (i = 0; i < Math.ceil(60 / step / 4) ; i++) {
				html += '<tr>';
				for (j = 0; j < 4; j += 1) {
					if (current < 60) {
						html += '<td class="minute">' + padLeft(current.toString()) + '</td>';
						current += step;
					} else {
						html += '<td></td>';
					}
				}
				html += '</tr>';
			}
			table.html(html);
		},

		fillSeconds = function () {
			var table = picker.widget.find('.timepicker .timepicker-seconds table'), html = '', current = 0, i, j;
			table.parent().hide();
			for (i = 0; i < 3; i++) {
				html += '<tr>';
				for (j = 0; j < 4; j += 1) {
					html += '<td class="second">' + padLeft(current.toString()) + '</td>';
					current += 5;
				}
				html += '</tr>';
			}
			table.html(html);
		},

		fillTime = function () {
			if (!picker.date) return;
			var timeComponents = picker.widget.find('.timepicker span[data-time-component]'),
			hour = picker.date.hours(),
			period = 'AM';

			if (!picker.use24hours) {
				
				if (hour >= 12) {
					period = 'PM';
				}
				
				if (hour === 0) {
					hour = 12;
				} else if (hour != 12) {
					hour = hour % 12;
				}

				picker.widget.find('.timepicker [data-action=togglePeriod]').text(period);
			}

			timeComponents.filter('[data-time-component=hours]').text(padLeft(hour));
			timeComponents.filter('[data-time-component=minutes]').text(padLeft(picker.date.minutes()));
			timeComponents.filter('[data-time-component=seconds]').text(padLeft(picker.date.second()));
		},

		click = function (e) {
			e.stopPropagation();
			e.preventDefault();
			picker.unset = false;
			var target = $(e.target).closest('span, td, th'), month, year, step, day, oldDate = pMoment(picker.date);
			if (target.length === 1) {
				if (!target.is('.disabled')) {
					switch (target[0].nodeName.toLowerCase()) {
						case 'th':
							switch (target[0].className) {
								case 'switch':
									showMode(1);
									break;
								case 'prev':
								case 'next':
									step = dpGlobal.modes[picker.viewMode].navStep;
									if (target[0].className === 'prev') step = step * -1;
									picker.viewDate.add(step, dpGlobal.modes[picker.viewMode].navFnc);
									fillDate();
									break;
							}
							break;
						case 'span':
							if (target.is('.month')) {
								month = target.parent().find('span').index(target);
								picker.viewDate.month(month);
							} else {
								year = parseInt(target.text(), 10) || 0;
								picker.viewDate.year(year);
							}
							if (picker.viewMode === picker.minViewMode) {
								picker.date = pMoment({
									y: picker.viewDate.year(),
									M: picker.viewDate.month(),
									d: picker.viewDate.date(),
									h: picker.date.hours(),
									m: picker.date.minutes(),
									s: picker.date.seconds()
								});
								notifyChange(oldDate, e.type);
								set();
							}
							showMode(-1);
							fillDate();
							break;
						case 'td':
							if (target.is('.day')) {
								day = parseInt(target.text(), 10) || 1;
								month = picker.viewDate.month();
								year = picker.viewDate.year();
								if (target.is('.old')) {
									if (month === 0) {
										month = 11;
										year -= 1;
									} else {
										month -= 1;
									}
								} else if (target.is('.new')) {
									if (month == 11) {
										month = 0;
										year += 1;
									} else {
										month += 1;
									}
								}
								picker.date = pMoment({
									y: year,
									M: month,
									d: day,
									h: picker.date.hours(),
									m: picker.date.minutes(),
									s: picker.date.seconds()
								}
								);
								picker.viewDate = pMoment({
									y: year, M: month, d: Math.min(28, day)
								});
								fillDate();
								set();
								notifyChange(oldDate, e.type);
							}
							break;
					}
				}
			}
		},

		actions = {
			incrementHours: function () {
				checkDate("add", "hours", 1);
			},

			incrementMinutes: function () {
				checkDate("add", "minutes", picker.options.minuteStepping);
			},

			incrementSeconds: function () {
				checkDate("add", "seconds", 1);
			},

			decrementHours: function () {
				checkDate("subtract", "hours", 1);
			},

			decrementMinutes: function () {
				checkDate("subtract", "minutes", picker.options.minuteStepping);
			},

			decrementSeconds: function () {
				checkDate("subtract", "seconds", 1);
			},

			togglePeriod: function () {
				var hour = picker.date.hours();
				if (hour >= 12) hour -= 12;
				else hour += 12;
				picker.date.hours(hour);
			},

			showPicker: function () {
				picker.widget.find('.timepicker > div:not(.timepicker-picker)').hide();
				picker.widget.find('.timepicker .timepicker-picker').show();
			},

			showHours: function () {
				picker.widget.find('.timepicker .timepicker-picker').hide();
				picker.widget.find('.timepicker .timepicker-hours').show();
			},

			showMinutes: function () {
				picker.widget.find('.timepicker .timepicker-picker').hide();
				picker.widget.find('.timepicker .timepicker-minutes').show();
			},

			showSeconds: function () {
				picker.widget.find('.timepicker .timepicker-picker').hide();
				picker.widget.find('.timepicker .timepicker-seconds').show();
			},

			selectHour: function (e) {
				var period = picker.widget.find('.timepicker [data-action=togglePeriod]').text(), hour = parseInt($(e.target).text(), 10);
				if (period == "PM") hour += 12
				picker.date.hours(hour);
				actions.showPicker.call(picker);
			},

			selectMinute: function (e) {
				picker.date.minutes(parseInt($(e.target).text(), 10));
				actions.showPicker.call(picker);
			},

			selectSecond: function (e) {
				picker.date.seconds(parseInt($(e.target).text(), 10));
				actions.showPicker.call(picker);
			}
		},

		doAction = function (e) {
			var oldDate = pMoment(picker.date), action = $(e.currentTarget).data('action'), rv = actions[action].apply(picker, arguments);
			stopEvent(e);
			if (!picker.date) picker.date = pMoment({ y: 1970 });
			set();
			fillTime();
			notifyChange(oldDate, e.type);
			return rv;
		},

		stopEvent = function (e) {
			e.stopPropagation();
			e.preventDefault();
		},

		change = function (e) {
			pMoment.lang(picker.options.language);
			var input = $(e.target), oldDate = pMoment(picker.date), newDate = pMoment(input.val(), picker.format, picker.options.useStrict);
			if (newDate.isValid() && !isInDisableDates(newDate) && isInEnableDates(newDate)) {
				update();
				picker.setValue(newDate);
				notifyChange(oldDate, e.type);
				set();
			}
			else {
				picker.viewDate = oldDate;
				notifyChange(oldDate, e.type);
				notifyError(newDate);
				picker.unset = true;
			}
		},

		showMode = function (dir) {
			if (dir) {
				picker.viewMode = Math.max(picker.minViewMode, Math.min(2, picker.viewMode + dir));
			}
			var f = dpGlobal.modes[picker.viewMode].clsName;
			picker.widget.find('.datepicker > div').hide().filter('.datepicker-' + dpGlobal.modes[picker.viewMode].clsName).show();
		},

		attachDatePickerEvents = function () {
			var $this, $parent, expanded, closed, collapseData;
			picker.widget.on('click', '.datepicker *', $.proxy(click, this)); // this handles date picker clicks
			picker.widget.on('click', '[data-action]', $.proxy(doAction, this)); // this handles time picker clicks
			picker.widget.on('mousedown', $.proxy(stopEvent, this));
			if (picker.options.pickDate && picker.options.pickTime) {
				picker.widget.on('click.togglePicker', '.accordion-toggle', function (e) {
					e.stopPropagation();
					$this = $(this);
					$parent = $this.closest('ul');
					expanded = $parent.find('.in');
					closed = $parent.find('.collapse:not(.in)');

					if (expanded && expanded.length) {
						collapseData = expanded.data('collapse');
						if (collapseData && collapseData.date - transitioning) return;
						expanded.collapse('hide');
						closed.collapse('show');
						$this.find('span').toggleClass(picker.options.icons.time + ' ' + picker.options.icons.date);
						picker.element.find('.input-group-addon span').toggleClass(picker.options.icons.time + ' ' + picker.options.icons.date);
					}
				});
			}
			if (picker.isInput) {
				picker.element.on({
					'focus': $.proxy(picker.show, this),
					'change': $.proxy(change, this),
					'blur': $.proxy(picker.hide, this)
				});
			} else {
				picker.element.on({
					'change': $.proxy(change, this)
				}, 'input');
				if (picker.component) {
					picker.component.on('click', $.proxy(picker.show, this));
				} else {
					picker.element.on('click', $.proxy(picker.show, this));
				}
			}
		},

		attachDatePickerGlobalEvents = function () {
			$(window).on(
				'resize.datetimepicker' + picker.id, $.proxy(place, this));
			if (!picker.isInput) {
				$(document).on(
					'mousedown.datetimepicker' + picker.id, $.proxy(picker.hide, this));
			}
		},

		detachDatePickerEvents = function () {
			picker.widget.off('click', '.datepicker *', picker.click);
			picker.widget.off('click', '[data-action]');
			picker.widget.off('mousedown', picker.stopEvent);
			if (picker.options.pickDate && picker.options.pickTime) {
				picker.widget.off('click.togglePicker');
			}
			if (picker.isInput) {
				picker.element.off({
					'focus': picker.show,
					'change': picker.change
				});
			} else {
				picker.element.off({
					'change': picker.change
				}, 'input');
				if (picker.component) {
					picker.component.off('click', picker.show);
				} else {
					picker.element.off('click', picker.show);
				}
			}
		},

		detachDatePickerGlobalEvents = function () {
			$(window).off('resize.datetimepicker' + picker.id);
			if (!picker.isInput) {
				$(document).off('mousedown.datetimepicker' + picker.id);
			}
		},

		isInFixed = function () {
			if (picker.element) {
				var parents = picker.element.parents(), inFixed = false, i;
				for (i = 0; i < parents.length; i++) {
					if ($(parents[i]).css('position') == 'fixed') {
						inFixed = true;
						break;
					}
				}
				;
				return inFixed;
			} else {
				return false;
			}
		},

		set = function () {
			pMoment.lang(picker.options.language);
			var formatted = '', input;
			if (!picker.unset) formatted = pMoment(picker.date).format(picker.format);
			getPickerInput().val(formatted);
			picker.element.data('date', formatted);
			if (!picker.options.pickTime) picker.hide();
		},

		checkDate = function (direction, unit, amount) {
			pMoment.lang(picker.options.language);
			var newDate;
			if (direction == "add") {
				newDate = pMoment(picker.date);
				if (newDate.hours() == 23) newDate.add(amount, unit);
				newDate.add(amount, unit);
			}
			else {
				newDate = pMoment(picker.date).subtract(amount, unit);
			}
			if (isInDisableDates(pMoment(newDate.subtract(amount, unit))) || isInDisableDates(newDate)) {
				notifyError(newDate.format(picker.format));
				return;
			}

			if (direction == "add") {
				picker.date.add(amount, unit);
			}
			else {
				picker.date.subtract(amount, unit);
			}
			picker.unset = false;
		},

		isInDisableDates = function (date) {
			pMoment.lang(picker.options.language);
			if (date.isAfter(picker.options.maxDate) || date.isBefore(picker.options.minDate)) return true;
			if (picker.options.disabledDates === false) {
				return false;
			}
			return picker.options.disabledDates[pMoment(date).format("YYYY-MM-DD")] === true;
		},
		isInEnableDates = function (date) {
			pMoment.lang(picker.options.language);
			if (picker.options.enabledDates === false) {
				return true;
			}
			return picker.options.enabledDates[pMoment(date).format("YYYY-MM-DD")] === true;
		},

		indexGivenDates = function (givenDatesArray) {
			// Store given enabledDates and disabledDates as keys.
			// This way we can check their existence in O(1) time instead of looping through whole array.
			// (for example: picker.options.enabledDates['2014-02-27'] === true)
			var givenDatesIndexed = {};
			var givenDatesCount = 0;
			for (i = 0; i < givenDatesArray.length; i++) {
				dDate = pMoment(givenDatesArray[i]);
				if (dDate.isValid()) {
					givenDatesIndexed[dDate.format("YYYY-MM-DD")] = true;
					givenDatesCount++;
				}
			}
			if (givenDatesCount > 0) {
				return givenDatesIndexed;
			}
			return false;
		},

		padLeft = function (string) {
			string = string.toString();
			if (string.length >= 2) return string;
			else return '0' + string;
		},

		getTemplate = function () {
			if (picker.options.pickDate && picker.options.pickTime) {
				var ret = '';
				ret = '<div id="es" class="ui bootstrap-datetimepicker-widget' + (picker.options.sideBySide ? ' timepicker-sbs' : '') + ' ' + (picker.options.component) + '" style="z-index:99999 !important;">';
				if (picker.options.sideBySide) {
					ret += '<div class="row">' +
					   '<div class="col-sm-6 datepicker">' + dpGlobal.template + '</div>' +
					   '<div class="col-sm-6 timepicker">' + tpGlobal.getTemplate() + '</div>' +
					 '</div>';
				} else {
					ret += '<ul class="g-list-unstyled">' +
						'<li' + (picker.options.collapse ? ' class="collapse in"' : '') + '>' +
							'<div class="datepicker">' + dpGlobal.template + '</div>' +
						'</li>' +
						'<li class="picker-switch accordion-toggle"><a class="btn btn-es-primary" style="width:100%"><span class="' + picker.options.icons.time + '"></span></a></li>' +
						'<li' + (picker.options.collapse ? ' class="collapse"' : '') + '>' +
							'<div class="timepicker">' + tpGlobal.getTemplate() + '</div>' +
						'</li>' +
				   '</ul>';

				   // Reserved in case if topdown layout is needed
				   //  ret += '<ul class="list-unstyled">' +
				   //      '<li>' +
				   //          '<div class="datepicker">' + dpGlobal.template + '</div>' +
				   //      '</li>' +
				   //      '<li>' +
				   //          '<div class="timepicker">' + tpGlobal.getTemplate() + '</div>' +
				   //      '</li>' +
				   // '</ul>';
				}
				ret += '</div>';
				return ret;
			} else if (picker.options.pickTime) {
				return (
					'<div id="es" class="ui bootstrap-datetimepicker-widget">' +
						'<div class="timepicker">' + tpGlobal.getTemplate() + '</div>' +
					'</div>'
				);
			} else {
				return (
					'<div id="es" class="ui bootstrap-datetimepicker-widget">' +
						'<div class="datepicker">' + dpGlobal.template + '</div>' +
					'</div>'
				);
			}
		},

		dpGlobal = {
			modes: [
				{
					clsName: 'days',
					navFnc: 'month',
					navStep: 1
				},
				{
					clsName: 'months',
					navFnc: 'year',
					navStep: 1
				},
				{
					clsName: 'years',
					navFnc: 'year',
					navStep: 10
				}],
			headTemplate:
					'<thead>' +
						'<tr>' +
							'<th class="prev">&lsaquo;</th><th colspan="5" class="switch"></th><th class="next">&rsaquo;</th>' +
						'</tr>' +
					'</thead>',
			contTemplate:
		'<tbody><tr><td colspan="7"></td></tr></tbody>'
		},

		tpGlobal = {
			hourTemplate: '<span data-action="showHours"   data-time-component="hours"   class="timepicker-hour"></span>',
			minuteTemplate: '<span data-action="showMinutes" data-time-component="minutes" class="timepicker-minute"></span>',
			secondTemplate: '<span data-action="showSeconds"  data-time-component="seconds" class="timepicker-second"></span>'
		};

		dpGlobal.template =
			'<div class="datepicker-days">' +
				'<table class="table-condensed">' + dpGlobal.headTemplate + '<tbody></tbody></table>' +
			'</div>' +
			'<div class="datepicker-months">' +
				'<table class="table-condensed">' + dpGlobal.headTemplate + dpGlobal.contTemplate + '</table>' +
			'</div>' +
			'<div class="datepicker-years">' +
				'<table class="table-condensed">' + dpGlobal.headTemplate + dpGlobal.contTemplate + '</table>' +
			'</div>';

		tpGlobal.getTemplate = function () {
			return (
				'<div class="timepicker-picker">' +
					'<table class="table-condensed">' +
						'<tr>' +
							'<td><a href="#" class="btn" data-action="incrementHours"><i class="' + picker.options.icons.up + '"></i></a></td>' +
							'<td class="separator"></td>' +
							'<td>' + (picker.options.useMinutes ? '<a href="#" class="btn" data-action="incrementMinutes"><i class="' + picker.options.icons.up + '"></i></a>' : '') + '</td>' +
							(picker.options.useSeconds ?
								'<td class="separator"></td><td><a href="#" class="btn" data-action="incrementSeconds"><i class="' + picker.options.icons.up + '"></i></a></td>' : '') +
							(picker.use24hours ? '' : '<td class="separator"></td>') +
						'</tr>' +
						'<tr>' +
							'<td>' + tpGlobal.hourTemplate + '</td> ' +
							'<td class="separator">:</td>' +
							'<td>' + (picker.options.useMinutes ? tpGlobal.minuteTemplate : '<span class="timepicker-minute">00</span>') + '</td> ' +
							(picker.options.useSeconds ?
								'<td class="separator">:</td><td>' + tpGlobal.secondTemplate + '</td>' : '') +
							(picker.use24hours ? '' : '<td class="separator"></td>' +
							'<td><button type="button" class="btn btn-primary" data-action="togglePeriod"></button></td>') +
						'</tr>' +
						'<tr>' +
							'<td><a href="#" class="btn" data-action="decrementHours"><i class="' + picker.options.icons.down + '"></i></a></td>' +
							'<td class="separator"></td>' +
							'<td>' + (picker.options.useMinutes ? '<a href="#" class="btn" data-action="decrementMinutes"><i class="' + picker.options.icons.down + '"></i></a>' : '') + '</td>' +
							(picker.options.useSeconds ?
								'<td class="separator"></td><td><a href="#" class="btn" data-action="decrementSeconds"><i class="' + picker.options.icons.down + '"></i></a></td>' : '') +
							(picker.use24hours ? '' : '<td class="separator"></td>') +
						'</tr>' +
					'</table>' +
				'</div>' +
				'<div class="timepicker-hours" data-action="selectHour">' +
					'<table class="table-condensed"></table>' +
				'</div>' +
				'<div class="timepicker-minutes" data-action="selectMinute">' +
					'<table class="table-condensed"></table>' +
				'</div>' +
				(picker.options.useSeconds ?
					'<div class="timepicker-seconds" data-action="selectSecond"><table class="table-condensed"></table></div>' : '')
			);
		};

		picker.destroy = function () {
			detachDatePickerEvents();
			detachDatePickerGlobalEvents();
			picker.widget.remove();
			picker.element.removeData('DateTimePicker');
			if (picker.component)
				picker.component.removeData('DateTimePicker');
		};

		picker.show = function (e) {
			if (picker.options.useCurrent) {
				if (getPickerInput().val() == '') {
					if (picker.options.minuteStepping !== 1) {
						var mDate = pMoment(),
						rInterval = picker.options.minuteStepping;
						mDate.minutes((Math.round(mDate.minutes() / rInterval) * rInterval) % 60)
							.seconds(0);
						picker.setValue(mDate.format(picker.format))
					} else {
						picker.setValue(pMoment().format(picker.format))
					}
				};
			}
			if (picker.widget.hasClass("picker-open")) {
				picker.widget.hide();
				picker.widget.removeClass("picker-open");
			}
			else {
				picker.widget.show();
				picker.widget.addClass("picker-open");
			}
			picker.height = picker.component ? picker.component.outerHeight() : picker.element.outerHeight();
			place();
			picker.element.trigger({
				type: 'dp.show',
				date: pMoment(picker.date)
			});
			attachDatePickerGlobalEvents();
			if (e) {
				stopEvent(e);
			}
		},

		picker.disable = function () {
			var input = picker.element.find('input');
			if (input.prop('disabled')) return;

			input.prop('disabled', true);
			detachDatePickerEvents();
		},

		picker.enable = function () {
			var input = picker.element.find('input');
			if (!input.prop('disabled')) return;

			input.prop('disabled', false);
			attachDatePickerEvents();
		},

		picker.hide = function (event) {
			if (event && $(event.target).is(picker.element.attr("id")))
				return;
			// Ignore event if in the middle of a picker transition
			var collapse = picker.widget.find('.collapse'), i, collapseData;
			for (i = 0; i < collapse.length; i++) {
				collapseData = collapse.eq(i).data('collapse');
				if (collapseData && collapseData.date - transitioning)
					return;
			}
			picker.widget.hide();
			picker.widget.removeClass("picker-open");
			picker.viewMode = picker.startViewMode;
			showMode();
			picker.element.trigger({
				type: 'dp.hide',
				date: pMoment(picker.date)
			});
			detachDatePickerGlobalEvents();
		},

		picker.setValue = function (newDate) {
			pMoment.lang(picker.options.language);
			if (!newDate) {
				picker.unset = true;
				set();
			} else {
				picker.unset = false;
			}
			if (!pMoment.isMoment(newDate)) newDate = pMoment(newDate, picker.format);
			if (newDate.isValid()) {
				picker.date = newDate;
				set();
				picker.viewDate = pMoment({ y: picker.date.year(), M: picker.date.month() });
				fillDate();
				fillTime();
			}
			else {
				notifyError(newDate);
			}
		},

		picker.getDate = function () {
			if (picker.unset) return null;
			return picker.date;
		},

		picker.setDate = function (date) {
			var oldDate = pMoment(picker.date);
			if (!date) {
				picker.setValue(null);
			} else {
				picker.setValue(date);
			}
			notifyChange(oldDate, "function");
		},

		picker.setDisabledDates = function (dates) {
			picker.options.disabledDates = indexGivenDates(dates);
			if (picker.viewDate) update();
		},
		picker.setEnabledDates = function (dates) {
			picker.options.enabledDates = indexGivenDates(dates);
			if (picker.viewDate) update();
		},

		picker.setMaxDate = function (date) {
			if (date == undefined) return;
			picker.options.maxDate = pMoment(date);
			if (picker.viewDate) update();
		},

		picker.setMinDate = function (date) {
			if (date == undefined) return;
			picker.options.minDate = pMoment(date);
			if (picker.viewDate) update();
		};

		init();
	};

	$.fn._datetimepicker = function (options) {
		return this.each(function () {
			var $this = $(this), data = $this.data('DateTimePicker');
			if (!data) $this.data('DateTimePicker', new DateTimePicker(this, options));
		});
	};

}; 

exports(); 
module.resolveWith(exports); 

}); 
// module body: end

}; 
// module factory: end

FD40.module("datetimepicker", moduleFactory);

}());			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var jQuery = $; 
var exports = function() {

var dialogHtml = '<div id="es" class="es-dialog"> <div class="es-dialog-modal"> <div class="es-dialog-header"> <div class="es-dialog-header__grid"> <div class="es-dialog-back-button t-hidden"><i class="fa fa-chevron-left"></i></div> <div class="es-dialog-header__cell"><span class="es-dialog-title"></span></div> <div class="es-dialog-close-button"><i class="fa fa-times"></i></div> </div> </div> <div class="es-dialog-body"> <div class="es-dialog-container"> <div class="es-dialog-content"></div> <div class="o-loader"></div> <div class="o-empty"> <div class="o-empty__content"><i class="o-empty__icon fa fa-exclamation-triangle"></i> <div class="o-empty__text"><span class="es-dialog-error-message"></span></div> </div> </div> </div> </div> <div class="es-dialog-footer"> <div class=""> <div class="es-dialog-footer-content"></div> </div> </div> </div></div>';
var dialog_ = ".es-dialog";
var dialogModal_ = ".es-dialog-modal";
var dialogContent_ = ".es-dialog-content";
var dialogHeader_ = ".es-dialog-header";
var dialogFooter_ = ".es-dialog-footer";
var dialogFooterContent_ = ".es-dialog-footer-content";
var dialogCloseButton_ = ".es-dialog-close-button";
var dialogTitle_ = ".es-dialog-title";
var dialogErrorMessage_ = ".es-dialog-error-message";

var isFailed = "is-failed";
var isLoading = "is-loading";
var rxBraces = /\{|\}/gi;

var self = EasySocial.dialog = function(options) {

	// For places calling EasySocial.dialog().close();
	if (options === undefined) {
		return self;
	}

	// Normalize options
	if ($.isString(options)) {
		options = {content: options};
	}

	var method = self.open;

	method.apply(self, [options]);

	return self;
}

$.extend(self, {

	defaultOptions: {
		title: "",
		content: "",
		buttons: "",
		classname: "",
		width: "auto",
		height: "auto",
		escapeKey: true
	},

	open: function(options) {

		// Get dialog
		var dialog = $(dialog_);
		if (dialog.length < 1) {
			dialog = $(dialogHtml).appendTo("body");
		}

		// Normalize options
		var options = $.extend({}, self.defaultOptions, options);

		// Set title
		var dialogTitle = $(dialogTitle_);
		dialogTitle.text(options.title);

		// Set buttons
		var dialogFooterContent = $(dialogFooterContent_);
		dialogFooterContent.html(options.buttons);
		dialog.toggleClass("has-footer", !!options.buttons)

		// Set bindings
		self.setBindings(options);

		// Set content
		var dialogContent = $(dialogContent_).empty();
		var content = options.content;
		var contentType = self.getContentType(content);
		dialog.switchClass("type-" + contentType)

		if (window.es.mobile) {
			dialog.addClass('is-mobile');
		}
		
		// Set width & height
		var dialogModal = $(dialogModal_);
		var dialogWidth = options.width;
		var dialogHeight = options.height;

		if ($.isNumeric(dialogHeight)) {
			var dialogHeader = $(dialogHeader_);
			var dialogFooter = $(dialogFooter_);
			dialogHeight += dialogHeader.height() + dialogFooter.height();
		}

		dialogModal.css({
			width: dialogWidth,
			height: dialogHeight
		});

		dialog.addClassAfter("active");

		// HTML
		switch (contentType) {

			case "html":
				dialogContent.html(content);
				dialog.trigger('init');
				break;

			case "iframe":
				var iframe = $("<iframe>");
				var iframeUrl = content;
				iframe
					.appendTo(dialogContent)
					.one("load", function(){

					})
					.attr("src", iframeUrl);
				break;

			case "deferred":
				dialog.switchClass(isLoading);
				content
					.done(function(content) {
						// Options
						if ($.isPlainObject(content)) {
							self.reopen($.extend(true, options, content));
						// Content
						} else if ($.isString(content)) {
							options.content = content;
							self.reopen(options);
						// Unknown
						} else {
							dialog.switchClass(isFailed);
						}
					})
					.fail(function(exception){
						dialog.switchClass(isFailed);

						var dialogErrorMessage = $(dialogErrorMessage_);

						// Error message
						if ($.isString(exception)) {
							dialogErrorMessage.html(exception);
						}

						// Exception object
						if ($.isPlainObject(exception) && exception.message) {
							dialogErrorMessage.html(exception.message);
						}
					});
				return;
				break;

			case "dialog":
				var xmlOptions = self.parseXMLOptions(content);
				self.open($.extend(true, options, xmlOptions));
				return;
				break;
		}
	},

	reopen: function(options) {
		self.close();
		self.open(options);
	},

	close: function() {

		// Unset bindings
		self.unsetBindings();

		// Remove dialog
		var dialog = $(dialog_);
		dialog.remove();
	},

	getContentType: function(content) {

		if (/<dialog>(.*?)/.test(content)) {
			return "dialog";
		}

		if ($.isUrl(content)) {
			return "iframe";
		}

		if ($.isDeferred(content)) {
			return "deferred";
		}

		return "html";
	},

	parseXMLOptions: function(xml) {

		var xmlOptions = $.buildHTML(xml);
		var newOptions = {};

		$.each(xmlOptions.children(), function(i, node){

			var node = $(node);
			var key  = $.String.camelize(this.nodeName.toLowerCase());
			var val  = node.html();
			var type = node.attr("type");

			switch (type) {
				case "json":
					try {
						val = $.parseJSON(val);
					} catch(e) {};
					break;

				case "javascript":
					try {
						val = eval('(function($){ return ' + $.trim(val) + ' })(' + $.globalNamespace + ')');
					} catch(e) {};
					break;

				case "text":
					val = node.text();
					break;
			}

			// Automatically convert numerical values
			if ($.isNumeric(val)) {
				val = parseFloat(val);
			}

			newOptions[key] = val;
		});

		return newOptions;
	},

	bindings: {},

	setBindings: function(options) {

		// Remove previous bindings
		self.unsetBindings();

		// Create new bindings
		var selectors = options.selectors;
		var bindings  = options.bindings;
		var dialog = $(dialog_);

		if (selectors && bindings) {

			// Simulate a controller instance
			var controller = {parent: self};
			
			$.each(selectors, function(element, selector){

				var element = element.replace(rxBraces, "");

				// Create selector fn
				var selectorFn = controller[element] = function() {
					return dialog.find(selector);
				};
				selectorFn.selector = selector;
			});

			// Simulate mvc here
			controller["parent"] = self;
			controller["element"] = dialog;
			controller["self"] = function() {
									return dialog;
								};

			// Make the caller available to the dialog if a caller is provided
			if (options.caller) {
				controller["caller"] = options.caller;
			}
			// controller["self"].selector = dialog.selector;

			$.each(bindings, function(binder, eventHandler){

				// Get element and event name
				var parts = binder.split(" ");
				var element = parts[0].replace(rxBraces, "");
				var eventName = parts[1] + ".es.dialog";

				// Get selector fn
				var selectorFn = controller[element];

				// Custom way of simulating a controller's init method
				if (element == 'init') {
					dialog.on(element, function() {

						var args = [this].concat(arguments);

						eventHandler.apply(controller, args);
					});
				}

				// No binding if selector fn is not found
				if (!selectorFn) {

					// These items could be 
					controller[element] = eventHandler;

					return;
				}

				// Bind event handler
				var selector = selectorFn.selector;

				dialog.on(eventName, selector, function(){
					// Convert the argument object into an array first.
					var args = [].slice.call(arguments);
					
					eventHandler.apply(controller, [$(this)].concat(args));
				});

				// Add to bindings
				self.bindings[eventName] = eventHandler;
			});
		}

		if (options.escapeKey) {
			$(document).on("keydown.es.dialog", function(event){
				if (event.keyCode==27) {
					self.close();
				}
			});
		}
	},

	setMessage: function(response) {
		var element = $('<div class="o-alert o-alert--' + response.type + '"><button type="button" class="close" data-bs-dismiss="alert">×</button></div>');
		var content = $(dialogContent_);

		element.append(response.message);
		element.prependTo(content);
	},

	unsetBindings: function() {

		// Get dialog
		var dialog = $(dialog_);

		// Unbind bindings
		$.each(self.bindings, function(eventName, eventHandler){
			dialog.off(eventName);
		});

		// Unbind escape
		$(document).off("keydown.es.dialog");
	}
});

$(document)
	.on("click", dialogCloseButton_, function(){
		self.close();
	})
	.on("click", dialog_, function(event){
		var dialog = $(dialog_);

		if (event.target==dialog[0]) {
			self.close();
		}
	});


};

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("dialog", moduleFactory);

}());			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var exports = function() { 

// Expanding Textareas
// https://github.com/bgrins/ExpandingTextareas

    $.expandingTextarea = $.extend({
        autoInitialize: true,
        initialSelector: "textarea.expanding",
        opts: {
            resize: function() { }
        }
    }, $.expandingTextarea || {});
    
    var cloneCSSProperties = [
        'lineHeight', 'textDecoration', 'letterSpacing',
        'fontSize', 'fontFamily', 'fontStyle', 
        'fontWeight', 'textTransform', 'textAlign', 
        'direction', 'wordSpacing', 'fontSizeAdjust', 
        'wordWrap', 'word-break',
        'borderLeftWidth', 'borderRightWidth',
        'borderTopWidth','borderBottomWidth',
        'paddingLeft', 'paddingRight',
        'paddingTop','paddingBottom',
        'marginLeft', 'marginRight',
        'marginTop','marginBottom',
        'boxSizing', 'webkitBoxSizing', 'mozBoxSizing', 'msBoxSizing'
    ];
    
    var textareaCSS = {
        position: "absolute",
        height: "100%",
        resize: "none"
    };
    
    var preCSS = {
        visibility: "hidden",
        border: "0 solid",
        whiteSpace: "pre-wrap" 
    };
    
    var containerCSS = {
        position: "relative"
    };
    
    function resize() {

        var clone = $(this).data("textareaClone");
        clone.find("div").text(this.value.replace(/\r\n/g, "\n") + ' ');
        $(this).trigger("resize.expanding");
    }
    
    $.fn.expandingTextarea = function(o) {
        
        var opts = $.extend({ }, $.expandingTextarea.opts, o);
        
        if (o === "resize") {
            return this.trigger("input.expanding");
        }
        
        if (o === "destroy") {
            this.filter(".expanding-init").each(function() {
                // TODO: Restore container position value
                var textarea = $(this).removeClass('expanding-init');
                textarea
                    .attr('style', textarea.data('expanding-styles') || '')
                    .removeData('expanding-styles');
            });
            
            return this;
        }
        
        this.filter("textarea").not(".expanding-init").addClass("expanding-init").each(function() {

            var textarea  = $(this),
                container = textarea.parent(),
                clone     = $($.parseHTML("<pre class='textareaClone'><div></div></pre>"));

            textarea
                .after(clone)
                .data("textareaClone", clone);

            // Container
            container.css(containerCSS);
            
            // Store the original styles in case of destroying.
            textarea.data('expanding-styles', textarea.attr('style'));
            textarea.css(textareaCSS);

            // Clone
            clone.css(preCSS);
            
            $.each(cloneCSSProperties, function(i, p) {
                var val = textarea.css(p);
                
                // Only set if different to prevent overriding percentage css values.
                if (clone.css(p) !== val) {
                    clone.css(p, val);
                }
            });
            
            textarea.bind("input.expanding propertychange.expanding keyup.expanding", resize);
            resize.apply(this);
            
            if (opts.resize) {
                textarea.bind("resize.expanding", opts.resize);
            }
        });
        
        return this;
    };
    
    $(function () {
        if ($.expandingTextarea.autoInitialize) {
            $($.expandingTextarea.initialSelector).expandingTextarea();
        }
    });


}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("expanding", moduleFactory);

}());			
(function(){
// module factory: start


var moduleFactory = function($) {
// module body: start

var module = this;

if (!window.es.requireGmaps) {
	module.resolve();
}

var callbackId = $.callback(function(){/*!
 * GMaps.js v0.3.1
 * http://hpneo.github.com/gmaps/
 *
 * Copyright 2012, Gustavo Leon
 * Released under the MIT License.
 */


  if(!window.google && !window.google.maps){
	module.reject("Google Maps API is required. Please register the following JavaScript library http://maps.google.com/maps/api/js?sensor=true.");
  }

  var GMaps = (function(global) {
	"use strict";

	var doc = document;
	var getElementById = function(id, context) {
	  return $("#"+id.replace('#', ''), context)[0];
	};

	var GMaps = function(options) {
	  var self = this;

	  var events_that_hide_context_menu = ['bounds_changed', 'center_changed', 'click', 'dblclick', 'drag', 'dragend', 'dragstart', 'idle', 'maptypeid_changed', 'projection_changed', 'resize', 'tilesloaded', 'zoom_changed'];
	  var events_that_doesnt_hide_context_menu = ['mousemove', 'mouseout', 'mouseover'];

	  window.context_menu = {};

	  if (typeof(options.el) === 'string' || typeof(options.div) === 'string') {
		this.el = getElementById(options.el || options.div, options.context);
	  } else {
		this.el = options.el || options.div;
	  };

	  if (typeof(this.el) === 'undefined' || this.el === null) {
		throw 'No element defined.';
	  }

	  this.el.style.width = options.width || this.el.scrollWidth || this.el.offsetWidth;
	  this.el.style.height = options.height || this.el.scrollHeight || this.el.offsetHeight;

	  this.controls = [];
	  this.overlays = [];
	  this.layers = []; // array with kml and ft layers, can be as many
	  this.singleLayers = {}; // object with the other layers, only one per layer
	  this.markers = [];
	  this.polylines = [];
	  this.routes = [];
	  this.polygons = [];
	  this.infoWindow = null;
	  this.overlay_el = null;
	  this.zoom = options.zoom || 15;
	  this.registered_events = {};

	  var markerClusterer = options.markerClusterer;

	  //'Hybrid', 'Roadmap', 'Satellite' or 'Terrain'
	  var mapType;

	  if (options.mapType) {
		mapType = google.maps.MapTypeId[options.mapType.toUpperCase()];
	  }
	  else {
		mapType = google.maps.MapTypeId.ROADMAP;
	  }

	  var map_center = new google.maps.LatLng(options.lat, options.lng);

	  delete options.el;
	  delete options.lat;
	  delete options.lng;
	  delete options.mapType;
	  delete options.width;
	  delete options.height;
	  delete options.markerClusterer;

	  var zoomControlOpt = options.zoomControlOpt || {
		style: 'DEFAULT',
		position: 'TOP_LEFT'
	  };

	  var zoomControl = options.zoomControl || true,
		  zoomControlStyle = zoomControlOpt.style || 'DEFAULT',
		  zoomControlPosition = zoomControlOpt.position || 'TOP_LEFT',
		  panControl = options.panControl || true,
		  mapTypeControl = options.mapTypeControl || true,
		  scaleControl = options.scaleControl || true,
		  streetViewControl = options.streetViewControl || true,
		  overviewMapControl = overviewMapControl || true;

	  var map_options = {};

	  var map_base_options = {
		zoom: this.zoom,
		center: map_center,
		mapTypeId: mapType
	  };

	  var map_controls_options = {
		panControl: panControl,
		zoomControl: zoomControl,
		zoomControlOptions: {
		  style: google.maps.ZoomControlStyle[zoomControlStyle], // DEFAULT LARGE SMALL
		  position: google.maps.ControlPosition[zoomControlPosition]
		},
		mapTypeControl: mapTypeControl,
		scaleControl: scaleControl,
		streetViewControl: streetViewControl,
		overviewMapControl: overviewMapControl
	  }

	  if(options.disableDefaultUI != true)
		map_base_options = extend_object(map_base_options, map_controls_options);

	  map_options = extend_object(map_base_options, options);

	  for(var i = 0; i < events_that_hide_context_menu.length; i++) {
		delete map_options[events_that_hide_context_menu[i]];
	  }

	  for(var i = 0; i < events_that_doesnt_hide_context_menu.length; i++) {
		delete map_options[events_that_doesnt_hide_context_menu[i]];
	  }

	  this.map = new google.maps.Map(this.el, map_options);

	  if(markerClusterer) {
		this.markerClusterer = markerClusterer.apply(this, [this.map]);
	  }

	  // finds absolute position of an element
	  var findAbsolutePosition = function(obj)  {
		var curleft = 0;
		var curtop = 0;
		if (obj.offsetParent) {
		  do {
			curleft += obj.offsetLeft;
			curtop += obj.offsetTop;
		  } while (obj = obj.offsetParent);
		}
		return [curleft,curtop];
	  //returns an array
	  }


	  // Context menus
	  var buildContextMenuHTML = function(control, e) {
		var html = '';
		var options = window.context_menu[control];
		for (var i in options){
		  if (options.hasOwnProperty(i)){
			var option = options[i];
			html += '<li><a id="' + control + '_' + i + '" href="#">' +
			  option.title + '</a></li>';
		  }
		}

		if(!getElementById('gmaps_context_menu')) return;

		var context_menu_element = getElementById('gmaps_context_menu');
		context_menu_element.innerHTML = html;

		var context_menu_items = context_menu_element.getElementsByTagName('a');

		var context_menu_items_count = context_menu_items.length;

		for(var i = 0; i < context_menu_items_count; i++){
		  var context_menu_item = context_menu_items[i];

		  var assign_menu_item_action = function(ev){
			ev.preventDefault();

			options[this.id.replace(control + '_', '')].action.apply(self, [e]);
			self.hideContextMenu();
		  };

		  google.maps.event.clearListeners(context_menu_item, 'click');
		  google.maps.event.addDomListenerOnce(context_menu_item, 'click', assign_menu_item_action, false);
		}

		var position = findAbsolutePosition.apply(this, [self.el]);
		var left = position[0] + e.pixel.x - 15;
		var top = position[1] + e.pixel.y- 15;

		context_menu_element.style.left = left + "px";
		context_menu_element.style.top = top + "px";

		context_menu_element.style.display = 'block';
	  };

	  var buildContextMenu = function(control, e) {
		if (control === 'marker') {
		  e.pixel = {};
		  var overlay = new google.maps.OverlayView();
		  overlay.setMap(self.map);
		  overlay.draw = function() {
			var projection = overlay.getProjection();
			var position = e.marker.getPosition();
			e.pixel = projection.fromLatLngToContainerPixel(position);

			buildContextMenuHTML(control, e);
		  };
		}
		else {
		  buildContextMenuHTML(control, e);
		}
	  };

	  this.setContextMenu = function(options) {
		window.context_menu[options.control] = {};

		for (var i in options.options){
		  if (options.options.hasOwnProperty(i)){
			var option = options.options[i];
			window.context_menu[options.control][option.name] = {
			  title: option.title,
			  action: option.action
			};
		  }
		}

		var ul = doc.createElement('ul');

		ul.id = 'gmaps_context_menu';
		ul.style.display = 'none';
		ul.style.position = 'absolute';
		ul.style.minWidth = '100px';
		ul.style.background = 'white';
		ul.style.listStyle = 'none';
		ul.style.padding = '8px';
		ul.style.boxShadow = '2px 2px 6px #ccc';

		doc.body.appendChild(ul);

		var context_menu_element = getElementById('gmaps_context_menu');

		google.maps.event.addDomListener(context_menu_element, 'mouseout', function(ev) {
		  if(!ev.relatedTarget || !this.contains(ev.relatedTarget)){
			window.setTimeout(function(){
			  context_menu_element.style.display = 'none';
			}, 400);
		  }
		}, false);
	  };

	  this.hideContextMenu = function() {
		var context_menu_element = getElementById('gmaps_context_menu');
		if(context_menu_element)
		  context_menu_element.style.display = 'none';
	  };

	  //Events

	  var setupListener = function(object, name) {
		google.maps.event.addListener(object, name, function(e){
		  if(e == undefined) {
			e = this;
		  }

		  options[name].apply(this, [e]);

		  self.hideContextMenu();
		});
	  }

	  for (var ev = 0; ev < events_that_hide_context_menu.length; ev++) {
		var name = events_that_hide_context_menu[ev];

		if (name in options) {
		  setupListener(this.map, name);
		}
	  }

	  for (var ev = 0; ev < events_that_doesnt_hide_context_menu.length; ev++) {
		var name = events_that_doesnt_hide_context_menu[ev];

		if (name in options) {
		  setupListener(this.map, name);
		}
	  }

	  google.maps.event.addListener(this.map, 'rightclick', function(e) {
		if (options.rightclick) {
		  options.rightclick.apply(this, [e]);
		}

		if(window.context_menu['map'] != undefined) {
		  buildContextMenu('map', e);
		}
	  });

	  this.refresh = function() {
		google.maps.event.trigger(this.map, 'resize');
	  };

	  this.fitZoom = function() {
		var latLngs = [];
		var markers_length = this.markers.length;

		for(var i=0; i < markers_length; i++) {
		  latLngs.push(this.markers[i].getPosition());
		}

		this.fitLatLngBounds(latLngs);
	  };

	  this.fitLatLngBounds = function(latLngs) {
		var total = latLngs.length;
		var bounds = new google.maps.LatLngBounds();

		for(var i=0; i < total; i++) {
		  bounds.extend(latLngs[i]);
		}

		this.map.fitBounds(bounds);
	  };

	  // Map methods
	  this.setCenter = function(lat, lng, callback) {
		this.map.panTo(new google.maps.LatLng(lat, lng));
		if (callback) {
		  callback();
		}
	  };

	  this.getElement = function() {
		return this.el;
	  };

	  this.zoomIn = function(value) {
		value = value || 1;
		this.zoom = this.map.getZoom() + value;
		this.map.setZoom(this.zoom);
	  };

	  this.zoomOut = function(value) {
		value = value || 1;
		this.zoom = this.map.getZoom() - value;
		this.map.setZoom(this.zoom);
	  };

	  var native_methods = [];

	  for(var method in this.map){
		if(typeof(this.map[method]) == 'function' && !this[method]){
		  native_methods.push(method);
		}
	  }

	  for(var i=0; i < native_methods.length; i++){
		(function(gmaps, scope, method_name) {
		  gmaps[method_name] = function(){
			return scope[method_name].apply(scope, arguments);
		  };
		})(this, this.map, native_methods[i]);
	  }

	  this.createControl = function(options) {
		var control = doc.createElement('div');

		control.style.cursor = 'pointer';
		control.style.fontFamily = 'Arial, sans-serif';
		control.style.fontSize = '13px';
		control.style.boxShadow = 'rgba(0, 0, 0, 0.398438) 0px 2px 4px';

		for(var option in options.style)
		  control.style[option] = options.style[option];

		if(options.id) {
		  control.id = options.id;
		}

		if(options.classes) {
		  control.className = options.classes;
		}

		if(options.content) {
		  control.innerHTML = options.content;
		}

		for (var ev in options.events) {
		  (function(object, name) {
			google.maps.event.addDomListener(object, name, function(){
			  options.events[name].apply(this, [this]);
			});
		  })(control, ev);
		}

		control.index = 1;

		return control;
	  };

	  this.addControl = function(options) {
		var position = google.maps.ControlPosition[options.position.toUpperCase()];

		delete options.position;

		var control = this.createControl(options);
		this.controls.push(control);
		this.map.controls[position].push(control);

		return control;
	  };

	  // Markers
	  this.createMarker = function(options) {
		if ((options.hasOwnProperty('lat') && options.hasOwnProperty('lng')) || options.position) {
		  var self = this;
		  var details = options.details;
		  var fences = options.fences;
		  var outside = options.outside;

		  var base_options = {
			position: new google.maps.LatLng(options.lat, options.lng),
			map: null
		  };

		  delete options.lat;
		  delete options.lng;
		  delete options.fences;
		  delete options.outside;

		  var marker_options = extend_object(base_options, options);

		  var marker = new google.maps.Marker(marker_options);

		  marker.fences = fences;

		  if (options.infoWindow) {
			marker.infoWindow = new google.maps.InfoWindow(options.infoWindow);

			var info_window_events = ['closeclick', 'content_changed', 'domready', 'position_changed', 'zindex_changed'];

			for (var ev = 0; ev < info_window_events.length; ev++) {
			  (function(object, name) {
				if (options.infoWindow[name]) {
				  google.maps.event.addListener(object, name, function(e){
					options.infoWindow[name].apply(this, [e]);
				  });
				}
			  })(marker.infoWindow, info_window_events[ev]);
			}
		  }

		  var marker_events = ['animation_changed', 'clickable_changed', 'cursor_changed', 'draggable_changed', 'flat_changed', 'icon_changed', 'position_changed', 'shadow_changed', 'shape_changed', 'title_changed', 'visible_changed', 'zindex_changed'];

		  var marker_events_with_mouse = ['dblclick', 'drag', 'dragend', 'dragstart', 'mousedown', 'mouseout', 'mouseover', 'mouseup'];

		  for (var ev = 0; ev < marker_events.length; ev++) {
			(function(object, name) {
			  if (options[name]) {
				google.maps.event.addListener(object, name, function(){
				  options[name].apply(this, [this]);
				});
			  }
			})(marker, marker_events[ev]);
		  }

		  for (var ev = 0; ev < marker_events_with_mouse.length; ev++) {
			(function(map, object, name) {
			  if (options[name]) {
				google.maps.event.addListener(object, name, function(me){
				  if(!me.pixel){
					me.pixel = map.getProjection().fromLatLngToPoint(me.latLng)
				  }

				  options[name].apply(this, [me]);
				});
			  }
			})(this.map, marker, marker_events_with_mouse[ev]);
		  }

		  google.maps.event.addListener(marker, 'click', function() {
			this.details = details;

			if (options.click) {
			  options.click.apply(this, [this]);
			}

			if (marker.infoWindow) {
			  self.hideInfoWindows();
			  marker.infoWindow.open(self.map, marker);
			}
		  });

		  google.maps.event.addListener(marker, 'rightclick', function(e) {
			e.marker = this;

			if (options.rightclick) {
			  options.rightclick.apply(this, [e]);
			}

			if (window.context_menu['marker'] != undefined) {
			  buildContextMenu('marker', e);
			}
		  });

		  if (marker.fences) {
			google.maps.event.addListener(marker, 'dragend', function() {
			  self.checkMarkerGeofence(marker, function(m, f) {
				outside(m, f);
			  });
			});
		  }

		  return marker;
		}
		else {
		  throw 'No latitude or longitude defined.';
		}
	  };

	  this.addMarker = function(options) {
		var marker;
		if(options.hasOwnProperty('gm_accessors_')) {
		  // Native google.maps.Marker object
		  marker = options;
		}
		else {
		  if ((options.hasOwnProperty('lat') && options.hasOwnProperty('lng')) || options.position) {
			marker = this.createMarker(options);
		  }
		  else {
			throw 'No latitude or longitude defined.';
		  }
		}

		marker.setMap(this.map);

		if(this.markerClusterer) {
		  this.markerClusterer.addMarker(marker);
		}

		this.markers.push(marker);

		GMaps.fire('marker_added', marker, this);

		return marker;
	  };

	  this.addMarkers = function(array) {
		for (var i=0, marker; marker=array[i]; i++) {
		  this.addMarker(marker);
		}
		return this.markers;
	  };

	  this.hideInfoWindows = function() {
		for (var i=0, marker; marker=this.markers[i]; i++){
		  if (marker.infoWindow){
			marker.infoWindow.close();
		  }
		}
	  };

	  this.removeMarker = function(marker) {
		for(var i = 0; i < this.markers.length; i++) {
		  if(this.markers[i] === marker) {
			this.markers[i].setMap(null);
			this.markers.splice(i, 1);

			GMaps.fire('marker_removed', marker, this);

			break;
		  }
		}

		return marker;
	  };

	  this.removeMarkers = function(collection) {
		var collection = (collection || this.markers);

		for(var i=0;i < this.markers.length; i++){
		  if(this.markers[i] === collection[i])
			this.markers[i].setMap(null);
		}

		var new_markers = [];

		for(var i=0;i < this.markers.length; i++){
		  if(this.markers[i].getMap() != null)
			new_markers.push(this.markers[i]);
		}

		this.markers = new_markers;
	  };

	  // Overlays

	  this.drawOverlay = function(options) {
		var overlay = new google.maps.OverlayView();
		overlay.setMap(self.map);

		var auto_show = true;

		if(options.auto_show != null)
		  auto_show = options.auto_show;

		overlay.onAdd = function() {
		  var el = doc.createElement('div');
		  el.style.borderStyle = "none";
		  el.style.borderWidth = "0px";
		  el.style.position = "absolute";
		  el.style.zIndex = 100;
		  el.innerHTML = options.content;

		  overlay.el = el;

		  var panes = this.getPanes();
		  if (!options.layer) {
			options.layer = 'overlayLayer';
		  }
		  var overlayLayer = panes[options.layer];
		  overlayLayer.appendChild(el);

		  var stop_overlay_events = ['contextmenu', 'DOMMouseScroll', 'dblclick', 'mousedown'];

		  for (var ev = 0; ev < stop_overlay_events.length; ev++) {
			(function(object, name) {
			  google.maps.event.addDomListener(object, name, function(e){
				if(navigator.userAgent.toLowerCase().indexOf('msie') != -1 && document.all) {
				  e.cancelBubble = true;
				  e.returnValue = false;
				}
				else {
				  e.stopPropagation();
				}
			  });
			})(el, stop_overlay_events[ev]);
		  }

		  google.maps.event.trigger(this, 'ready');
		};

		overlay.draw = function() {
		  var projection = this.getProjection();
		  var pixel = projection.fromLatLngToDivPixel(new google.maps.LatLng(options.lat, options.lng));

		  options.horizontalOffset = options.horizontalOffset || 0;
		  options.verticalOffset = options.verticalOffset || 0;

		  var el = overlay.el;
		  var content = el.children[0];

		  var content_height = content.clientHeight;
		  var content_width = content.clientWidth;

		  switch (options.verticalAlign) {
			case 'top':
			  el.style.top = (pixel.y - content_height + options.verticalOffset) + 'px';
			  break;
			default:
			case 'middle':
			  el.style.top = (pixel.y - (content_height / 2) + options.verticalOffset) + 'px';
			  break;
			case 'bottom':
			  el.style.top = (pixel.y + options.verticalOffset) + 'px';
			  break;
		  }

		  switch (options.horizontalAlign) {
			case 'left':
			  el.style.left = (pixel.x - content_width + options.horizontalOffset) + 'px';
			  break;
			default:
			case 'center':
			  el.style.left = (pixel.x - (content_width / 2) + options.horizontalOffset) + 'px';
			  break;
			case 'right':
			  el.style.left = (pixel.x + options.horizontalOffset) + 'px';
			  break;
		  }

		  el.style.display = auto_show ? 'block' : 'none';

		  if(!auto_show){
			options.show.apply(this, [el]);
		  }
		};

		overlay.onRemove = function() {
		  var el = overlay.el;

		  if(options.remove){
			options.remove.apply(this, [el]);
		  }
		  else {
			overlay.el.parentNode.removeChild(overlay.el);
			overlay.el = null;
		  }
		};

		self.overlays.push(overlay);
		return overlay;
	  };

	  this.removeOverlay = function(overlay) {
		for(var i = 0; i < this.overlays.length; i++) {
		  if(this.overlays[i] === overlay) {
			this.overlays[i].setMap(null);
			this.overlays.splice(i, 1);

			break;
		  }
		}
	  };

	  this.removeOverlays = function() {
		for (var i=0, item; item=self.overlays[i]; i++){
		  item.setMap(null);
		}
		self.overlays = [];
	  };

	  // Geometry

	  this.drawPolyline = function(options) {
		var path = [];
		var points = options.path;

		if (points.length){
		  if (points[0][0] === undefined){
			path = points;
		  }
		  else {
			for (var i=0, latlng; latlng=points[i]; i++){
			  path.push(new google.maps.LatLng(latlng[0], latlng[1]));
			}
		  }
		}

		var polyline_options = {
		  map: this.map,
		  path: path,
		  strokeColor: options.strokeColor,
		  strokeOpacity: options.strokeOpacity,
		  strokeWeight: options.strokeWeight,
		  geodesic: options.geodesic,
		  clickable: true,
		  editable: false,
		  visible: true
		};

		if(options.hasOwnProperty("clickable"))
		  polyline_options.clickable = options.clickable;

		if(options.hasOwnProperty("editable"))
		  polyline_options.editable = options.editable;

		if(options.hasOwnProperty("icons"))
		  polyline_options.icons = options.icons;

		if(options.hasOwnProperty("zIndex"))
		  polyline_options.zIndex = options.zIndex;

		var polyline = new google.maps.Polyline(polyline_options);

		var polyline_events = ['click', 'dblclick', 'mousedown', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'rightclick'];

		for (var ev = 0; ev < polyline_events.length; ev++) {
		  (function(object, name) {
			if (options[name]) {
			  google.maps.event.addListener(object, name, function(e){
				options[name].apply(this, [e]);
			  });
			}
		  })(polyline, polyline_events[ev]);
		}

		this.polylines.push(polyline);

		GMaps.fire('polyline_added', polyline, this);

		return polyline;
	  };

	  this.removePolyline = function(polyline) {
		for(var i = 0; i < this.polylines.length; i++) {
		  if(this.polylines[i] === polyline) {
			this.polylines[i].setMap(null);
			this.polylines.splice(i, 1);

			GMaps.fire('polyline_removed', polyline, this);

			break;
		  }
		}
	  };

	  this.removePolylines = function() {
		for (var i=0, item; item=self.polylines[i]; i++){
		  item.setMap(null);
		}
		self.polylines = [];
	  };

	  this.drawCircle = function(options) {
		options =  extend_object({
		  map: this.map,
		  center: new google.maps.LatLng(options.lat, options.lng)
		}, options);

		delete options.lat;
		delete options.lng;
		var polygon = new google.maps.Circle(options);

		var polygon_events = ['click', 'dblclick', 'mousedown', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'rightclick'];

		for (var ev = 0; ev < polygon_events.length; ev++) {
		  (function(object, name) {
			if (options[name]) {
			  google.maps.event.addListener(object, name, function(e){
				options[name].apply(this, [e]);
			  });
			}
		  })(polygon, polygon_events[ev]);
		}

		this.polygons.push(polygon);

		return polygon;
	  };

	  this.drawRectangle = function(options) {
		options = extend_object({
		  map: this.map
		}, options);

		var latLngBounds = new google.maps.LatLngBounds(
		  new google.maps.LatLng(options.bounds[0][0], options.bounds[0][1]),
		  new google.maps.LatLng(options.bounds[1][0], options.bounds[1][1])
		);

		options.bounds = latLngBounds;

		var polygon = new google.maps.Rectangle(options);

		var polygon_events = ['click', 'dblclick', 'mousedown', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'rightclick'];

		for (var ev = 0; ev < polygon_events.length; ev++) {
		  (function(object, name) {
			if (options[name]) {
			  google.maps.event.addListener(object, name, function(e){
				options[name].apply(this, [e]);
			  });
			}
		  })(polygon, polygon_events[ev]);
		}

		this.polygons.push(polygon);

		return polygon;
	  };

	  this.drawPolygon = function(options) {
		var useGeoJSON = false;
		if(options.hasOwnProperty("useGeoJSON"))
		  useGeoJSON = options.useGeoJSON;

		delete options.useGeoJSON;

		options = extend_object({
		  map: this.map
		}, options);

		if(useGeoJSON == false)
		  options.paths = [options.paths.slice(0)];

		if(options.paths.length > 0) {
		  if(options.paths[0].length > 0) {
			options.paths = array_flat(array_map(options.paths, arrayToLatLng, useGeoJSON));
		  }
		}

		var polygon = new google.maps.Polygon(options);

		var polygon_events = ['click', 'dblclick', 'mousedown', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'rightclick'];

		for (var ev = 0; ev < polygon_events.length; ev++) {
		  (function(object, name) {
			if (options[name]) {
			  google.maps.event.addListener(object, name, function(e){
				options[name].apply(this, [e]);
			  });
			}
		  })(polygon, polygon_events[ev]);
		}

		this.polygons.push(polygon);

		GMaps.fire('polygon_added', polygon, this);

		return polygon;
	  };

	  this.removePolygon = function(polygon) {
		for(var i = 0; i < this.polygons.length; i++) {
		  if(this.polygons[i] === polygon) {
			this.polygons[i].setMap(null);
			this.polygons.splice(i, 1);

			GMaps.fire('polygon_removed', polygon, this);

			break;
		  }
		}
	  };

	  this.removePolygons = function() {
		for (var i=0, item; item=self.polygons[i]; i++){
		  item.setMap(null);
		}
		self.polygons = [];
	  };

	  // Fusion Tables

	  this.getFromFusionTables = function(options) {
		var events = options.events;

		delete options.events;

		var fusion_tables_options = options;

		var layer = new google.maps.FusionTablesLayer(fusion_tables_options);

		for (var ev in events) {
		  (function(object, name) {
			google.maps.event.addListener(object, name, function(e){
			  events[name].apply(this, [e]);
			});
		  })(layer, ev);
		}

		this.layers.push(layer);

		return layer;
	  };

	  this.loadFromFusionTables = function(options) {
		var layer = this.getFromFusionTables(options);
		layer.setMap(this.map);

		return layer;
	  };

	  // KML

	  this.getFromKML = function(options) {
		var url = options.url;
		var events = options.events;

		delete options.url;
		delete options.events;

		var kml_options = options;

		var layer = new google.maps.KmlLayer(url, kml_options);

		for (var ev in events) {
		  (function(object, name) {
			google.maps.event.addListener(object, name, function(e){
			  events[name].apply(this, [e]);
			});
		  })(layer, ev);
		}

		this.layers.push(layer);

		return layer;
	  };

	  this.loadFromKML = function(options) {
		var layer = this.getFromKML(options);
		layer.setMap(this.map);

		return layer;
	  };

	  // Routes

	  var travelMode, unitSystem;
	  this.getRoutes = function(options) {
		switch (options.travelMode) {
		case 'bicycling':
		  travelMode = google.maps.TravelMode.BICYCLING;
		  break;
		case 'transit':
		  travelMode = google.maps.TravelMode.TRANSIT;
		  break;
		case 'driving':
		  travelMode = google.maps.TravelMode.DRIVING;
		  break;
		// case 'walking':
		default:
		  travelMode = google.maps.TravelMode.WALKING;
		  break;
		}

		if (options.unitSystem === 'imperial') {
		  unitSystem = google.maps.UnitSystem.IMPERIAL;
		}
		else {
		  unitSystem = google.maps.UnitSystem.METRIC;
		}

		var base_options = {
		  avoidHighways: false,
		  avoidTolls: false,
		  optimizeWaypoints: false,
		  waypoints: []
		};

		var request_options =  extend_object(base_options, options);

		request_options.origin = /string/.test(typeof options.origin) ? options.origin : new google.maps.LatLng(options.origin[0], options.origin[1]);
		request_options.destination = new google.maps.LatLng(options.destination[0], options.destination[1]);
		request_options.travelMode = travelMode;
		request_options.unitSystem = unitSystem;

		delete request_options.callback;

		var self = this;
		var service = new google.maps.DirectionsService();

		service.route(request_options, function(result, status) {
		  if (status === google.maps.DirectionsStatus.OK) {
			for (var r in result.routes) {
			  if (result.routes.hasOwnProperty(r)) {
				self.routes.push(result.routes[r]);
			  }
			}
		  }
		  if (options.callback) {
			options.callback(self.routes);
		  }
		});
	  };

	  this.removeRoutes = function() {
		this.routes = [];
	  };

	  this.getElevations = function(options) {
		options = extend_object({
		  locations: [],
		  path : false,
		  samples : 256
		}, options);

		if(options.locations.length > 0) {
		  if(options.locations[0].length > 0) {
			options.locations = array_flat(array_map([options.locations], arrayToLatLng,  false));
		  }
		}

		var callback = options.callback;
		delete options.callback;

		var service = new google.maps.ElevationService();

		//location request
		if (!options.path) {
		  delete options.path;
		  delete options.samples;
		  service.getElevationForLocations(options, function(result, status){
			if (callback && typeof(callback) === "function") {
			  callback(result, status);
			}
		  });
		//path request
		} else {
		  var pathRequest = {
			path : options.locations,
			samples : options.samples
		  };

		  service.getElevationAlongPath(pathRequest, function(result, status){
		   if (callback && typeof(callback) === "function") {
			  callback(result, status);
			}
		  });
		}
	  };

	  // Alias for the method "drawRoute"
	  this.cleanRoute = this.removePolylines;

	  this.drawRoute = function(options) {
		var self = this;
		this.getRoutes({
		  origin: options.origin,
		  destination: options.destination,
		  travelMode: options.travelMode,
		  waypoints: options.waypoints,
		  unitSystem: options.unitSystem,
		  callback: function(e) {
			if (e.length > 0) {
			  self.drawPolyline({
				path: e[e.length - 1].overview_path,
				strokeColor: options.strokeColor,
				strokeOpacity: options.strokeOpacity,
				strokeWeight: options.strokeWeight
			  });
			  if (options.callback) {
				options.callback(e[e.length - 1]);
			  }
			}
		  }
		});
	  };

	  this.travelRoute = function(options) {
		if (options.origin && options.destination) {
		  this.getRoutes({
			origin: options.origin,
			destination: options.destination,
			travelMode: options.travelMode,
			waypoints : options.waypoints,
			callback: function(e) {
			  //start callback
			  if (e.length > 0 && options.start) {
				options.start(e[e.length - 1]);
			  }

			  //step callback
			  if (e.length > 0 && options.step) {
				var route = e[e.length - 1];
				if (route.legs.length > 0) {
				  var steps = route.legs[0].steps;
				  for (var i=0, step; step=steps[i]; i++) {
					step.step_number = i;
					options.step(step, (route.legs[0].steps.length - 1));
				  }
				}
			  }

			  //end callback
			  if (e.length > 0 && options.end) {
				 options.end(e[e.length - 1]);
			  }
			}
		  });
		}
		else if (options.route) {
		  if (options.route.legs.length > 0) {
			var steps = options.route.legs[0].steps;
			for (var i=0, step; step=steps[i]; i++) {
			  step.step_number = i;
			  options.step(step);
			}
		  }
		}
	  };

	  this.drawSteppedRoute = function(options) {
		if (options.origin && options.destination) {
		  this.getRoutes({
			origin: options.origin,
			destination: options.destination,
			travelMode: options.travelMode,
			waypoints : options.waypoints,
			callback: function(e) {
			  //start callback
			  if (e.length > 0 && options.start) {
				options.start(e[e.length - 1]);
			  }

			  //step callback
			  if (e.length > 0 && options.step) {
				var route = e[e.length - 1];
				if (route.legs.length > 0) {
				  var steps = route.legs[0].steps;
				  for (var i=0, step; step=steps[i]; i++) {
					step.step_number = i;
					self.drawPolyline({
					  path: step.path,
					  strokeColor: options.strokeColor,
					  strokeOpacity: options.strokeOpacity,
					  strokeWeight: options.strokeWeight
					});
					options.step(step, (route.legs[0].steps.length - 1));
				  }
				}
			  }

			  //end callback
			  if (e.length > 0 && options.end) {
				 options.end(e[e.length - 1]);
			  }
			}
		  });
		}
		else if (options.route) {
		  if (options.route.legs.length > 0) {
			var steps = options.route.legs[0].steps;
			for (var i=0, step; step=steps[i]; i++) {
			  step.step_number = i;
			  self.drawPolyline({
				path: step.path,
				strokeColor: options.strokeColor,
				strokeOpacity: options.strokeOpacity,
				strokeWeight: options.strokeWeight
			  });
			  options.step(step);
			}
		  }
		}
	  };

	  // Geofence

	  this.checkGeofence = function(lat, lng, fence) {
		return fence.containsLatLng(new google.maps.LatLng(lat, lng));
	  };

	  this.checkMarkerGeofence = function(marker, outside_callback) {
		if (marker.fences) {
		  for (var i=0, fence; fence=marker.fences[i]; i++) {
			var pos = marker.getPosition();
			if (!self.checkGeofence(pos.lat(), pos.lng(), fence)) {
			  outside_callback(marker, fence);
			}
		  }
		}
	  };

	  // Layers

	  this.addLayer = function(layerName, options) {
		//var default_layers = ['weather', 'clouds', 'traffic', 'transit', 'bicycling', 'panoramio', 'places'];
		options = options || {};
		var layer;

		switch(layerName) {
		  case 'weather': this.singleLayers.weather = layer = new google.maps.weather.WeatherLayer();
			break;
		  case 'clouds': this.singleLayers.clouds = layer = new google.maps.weather.CloudLayer();
			break;
		  case 'traffic': this.singleLayers.traffic = layer = new google.maps.TrafficLayer();
			break;
		  case 'transit': this.singleLayers.transit = layer = new google.maps.TransitLayer();
			break;
		  case 'bicycling': this.singleLayers.bicycling = layer = new google.maps.BicyclingLayer();
			break;
		  case 'panoramio':
			  this.singleLayers.panoramio = layer = new google.maps.panoramio.PanoramioLayer();
			  layer.setTag(options.filter);
			  delete options.filter;

			  //click event
			  if(options.click) {
				google.maps.event.addListener(layer, 'click', function(event) {
				  options.click(event);
				  delete options.click;
				});
			  }
			break;
			case 'places':
			  this.singleLayers.places = layer = new google.maps.places.PlacesService(this.map);

			  //search and  nearbySearch callback, Both are the same
			  if(options.search || options.nearbySearch) {
				var placeSearchRequest  = {
				  bounds : options.bounds || null,
				  keyword : options.keyword || null,
				  location : options.location || null,
				  name : options.name || null,
				  radius : options.radius || null,
				  rankBy : options.rankBy || null,
				  types : options.types || null
				};

				if(options.search) {
				  layer.search(placeSearchRequest, options.search);
				}

				if(options.nearbySearch) {
				  layer.nearbySearch(placeSearchRequest, options.nearbySearch);
				}
			  }

			  //textSearch callback
			  if(options.textSearch) {
				var textSearchRequest  = {
				  bounds : options.bounds || null,
				  location : options.location || null,
				  query : options.query || null,
				  radius : options.radius || null
				};

				layer.textSearch(textSearchRequest, options.textSearch);
			  }
			break;
		}

		if(layer !== undefined) {
		  if(typeof layer.setOptions == 'function') {
			layer.setOptions(options);
		  }
		  if(typeof layer.setMap == 'function') {
			layer.setMap(this.map);
		  }

		  return layer;
		}
	  };

	  this.removeLayer = function(layerName) {
		if(this.singleLayers[layerName] !== undefined) {
		   this.singleLayers[layerName].setMap(null);
		   delete this.singleLayers[layerName];
		}
	  };

	  // Static Maps

	  this.toImage = function(options) {
		var options = options || {};
		var static_map_options = {};
		static_map_options['size'] = options['size'] || [this.el.clientWidth, this.el.clientHeight];
		static_map_options['lat'] = this.getCenter().lat();
		static_map_options['lng'] = this.getCenter().lng();

		if(this.markers.length > 0) {
		  static_map_options['markers'] = [];
		  for(var i=0; i < this.markers.length; i++) {
			static_map_options['markers'].push({
			  lat: this.markers[i].getPosition().lat(),
			  lng: this.markers[i].getPosition().lng()
			});
		  }
		}

		if(this.polylines.length > 0) {
		  var polyline = this.polylines[0];
		  static_map_options['polyline'] = {};
		  static_map_options['polyline']['path'] = google.maps.geometry.encoding.encodePath(polyline.getPath());
		  static_map_options['polyline']['strokeColor'] = polyline.strokeColor
		  static_map_options['polyline']['strokeOpacity'] = polyline.strokeOpacity
		  static_map_options['polyline']['strokeWeight'] = polyline.strokeWeight
		}

		return GMaps.staticMapURL(static_map_options);
	  };

	  // Map Types

	  this.addMapType = function(mapTypeId, options) {
		if(options.hasOwnProperty("getTileUrl") && typeof(options["getTileUrl"]) == "function") {
		  options.tileSize = options.tileSize || new google.maps.Size(256, 256);

		  var mapType = new google.maps.ImageMapType(options);

		  this.map.mapTypes.set(mapTypeId, mapType);
		}
		else {
		  throw "'getTileUrl' function required.";
		}
	  };

	  this.addOverlayMapType = function(options) {
		if(options.hasOwnProperty("getTile") && typeof(options["getTile"]) == "function") {
		  var overlayMapTypeIndex = options.index;

		  delete options.index;

		  this.map.overlayMapTypes.insertAt(overlayMapTypeIndex, options);
		}
		else {
		  throw "'getTile' function required.";
		}
	  };

	  this.removeOverlayMapType = function(overlayMapTypeIndex) {
		this.map.overlayMapTypes.removeAt(overlayMapTypeIndex);
	  };

	  // Styles

	  this.addStyle = function(options) {
		var styledMapType = new google.maps.StyledMapType(options.styles, options.styledMapName);

		this.map.mapTypes.set(options.mapTypeId, styledMapType);
	  };

	  this.setStyle = function(mapTypeId) {
		this.map.setMapTypeId(mapTypeId);
	  };

	  // StreetView

	  this.createPanorama = function(streetview_options) {
		if (!streetview_options.hasOwnProperty('lat') || !streetview_options.hasOwnProperty('lng')) {
		  streetview_options.lat = this.getCenter().lat();
		  streetview_options.lng = this.getCenter().lng();
		}

		this.panorama = GMaps.createPanorama(streetview_options);

		this.map.setStreetView(this.panorama);

		return this.panorama;
	  };

	  // Events

	  this.on = function(event_name, handler) {
		return GMaps.on(event_name, this, handler);
	  };

	  this.off = function(event_name) {
		GMaps.off(event_name, this);
	  };
	};

	GMaps.createPanorama = function(options) {
	  var el = getElementById(options.el, options.context);

	  options.position = new google.maps.LatLng(options.lat, options.lng);

	  delete options.el;
	  delete options.context;
	  delete options.lat;
	  delete options.lng;

	  var streetview_events = ['closeclick', 'links_changed', 'pano_changed', 'position_changed', 'pov_changed', 'resize', 'visible_changed'];

	  var streetview_options = extend_object({visible : true}, options);

	  for(var i = 0; i < streetview_events.length; i++) {
		delete streetview_options[streetview_events[i]];
	  }

	  var panorama = new google.maps.StreetViewPanorama(el, streetview_options);

	  for(var i = 0; i < streetview_events.length; i++) {
		(function(object, name) {
		  if (options[name]) {
			google.maps.event.addListener(object, name, function(){
			  options[name].apply(this);
			});
		  }
		})(panorama, streetview_events[i]);
	  }

	  return panorama;
	};

	GMaps.Route = function(options) {
	  this.map = options.map;
	  this.route = options.route;
	  this.step_count = 0;
	  this.steps = this.route.legs[0].steps;
	  this.steps_length = this.steps.length;

	  this.polyline = this.map.drawPolyline({
		path: new google.maps.MVCArray(),
		strokeColor: options.strokeColor,
		strokeOpacity: options.strokeOpacity,
		strokeWeight: options.strokeWeight
	  }).getPath();

	  this.back = function() {
		if (this.step_count > 0) {
		  this.step_count--;
		  var path = this.route.legs[0].steps[this.step_count].path;
		  for (var p in path){
			if (path.hasOwnProperty(p)){
			  this.polyline.pop();
			}
		  }
		}
	  };

	  this.forward = function() {
		if (this.step_count < this.steps_length) {
		  var path = this.route.legs[0].steps[this.step_count].path;
		  for (var p in path){
			if (path.hasOwnProperty(p)){
			  this.polyline.push(path[p]);
			}
		  }
		  this.step_count++;
		}
	  };
	};

	// Geolocation (Modern browsers only)

	GMaps.geolocate = function(options) {
	  var complete_callback = options.always || options.complete;

	  if (navigator.geolocation) {
		navigator.geolocation.getCurrentPosition(function(position) {
		  options.success(position);

		  if (complete_callback) {
			complete_callback();
		  }
		}, function(error) {
		  options.error(error);

		  if (complete_callback) {
			complete_callback();
		  }
		}, options.options);
	  }
	  else {
		options.not_supported();

		if (complete_callback) {
		  complete_callback();
		}
	  }
	};

	// Geocoding

	GMaps.geocode = function(options) {
	  this.geocoder = new google.maps.Geocoder();
	  var callback = options.callback;
	  if (options.hasOwnProperty('lat') && options.hasOwnProperty('lng')) {
		options.latLng = new google.maps.LatLng(options.lat, options.lng);
	  }

	  delete options.lat;
	  delete options.lng;
	  delete options.callback;
	  this.geocoder.geocode(options, function(results, status) {
		callback(results, status);
	  });
	};

	// Static maps

	GMaps.staticMapURL = function(options){
	  var parameters = [];
	  var data;

	  var static_root = 'https://maps.googleapis.com/maps/api/staticmap';
	  if (options.url){
		static_root = options.url;
		delete options.url;
	  }
	  static_root += '?';

	  var markers = options.markers;
	  delete options.markers;
	  if (!markers && options.marker){
		markers = [options.marker];
		delete options.marker;
	  }

	  var polyline = options.polyline;
	  delete options.polyline;

	  // Retrieve API key
	  var apiKey = window.es.gmapsApiKey;

	  if (apiKey) {
		parameters.push('key=' + apiKey);
	  }

	  // Retrieve language
	  var language = window.es.locationLanguage;

	  if (language) {
		parameters.push('language=' + language)
	  }

	  /** Map options **/
	  if (options.center){
		parameters.push('center=' + options.center);
		delete options.center;
	  }
	  else if (options.address){
		parameters.push('center=' + options.address);
		delete options.address;
	  }
	  else if (options.lat){
		parameters.push(['center=', options.lat, ',', options.lng].join(''));
		delete options.lat;
		delete options.lng;
	  }
	  else if (options.visible){
		var visible = encodeURI(options.visible.join('|'));
		parameters.push('visible=' + visible);
	  }

	  var size = options.size;
	  if (size){
		if (size.join){
		  size = size.join('x');
		}
		delete options.size;
	  }
	  else {
		size = '630x300';
	  }
	  parameters.push('size=' + size);

	  if (!options.zoom){
		options.zoom = 15;
	  }

	  var sensor = options.hasOwnProperty('sensor') ? !!options.sensor : true;
	  delete options.sensor;
	  parameters.push('sensor=' + sensor);

	  for (var param in options){
		if (options.hasOwnProperty(param)){
		  parameters.push(param + '=' + options[param]);
		}
	  }

	  /** Markers **/
	  if (markers){
		var marker, loc;

		for (var i=0; data=markers[i]; i++){
		  marker = [];

		  if (data.size && data.size !== 'normal'){
			marker.push('size:' + data.size);
		  }
		  else if (data.icon){
			marker.push('icon:' + encodeURI(data.icon));
		  }

		  if (data.color){
			marker.push('color:' + data.color.replace('#', '0x'));
		  }

		  if (data.label){
			marker.push('label:' + data.label[0].toUpperCase());
		  }

		  loc = (data.address ? data.address : data.lat + ',' + data.lng);

		  if (marker.length || i === 0){
			marker.push(loc);
			marker = marker.join('|');
			parameters.push('markers=' + encodeURI(marker));
		  }
		  // New marker without styles
		  else {
			marker = parameters.pop() + encodeURI('|' + loc);
			parameters.push(marker);
		  }
		}
	  }

	  /** Polylines **/
	  function parseColor(color, opacity){
		if (color[0] === '#'){
		  color = color.replace('#', '0x');

		  if (opacity){
			opacity = parseFloat(opacity);
			opacity = Math.min(1, Math.max(opacity, 0));
			if (opacity === 0){
			  return '0x00000000';
			}
			opacity = (opacity * 255).toString(16);
			if (opacity.length === 1){
			  opacity += opacity;
			}

			color = color.slice(0,8) + opacity;
		  }
		}
		return color;
	  }

	  if (polyline){
		data = polyline;
		polyline = [];

		if (data.strokeWeight){
		  polyline.push('weight:' + parseInt(data.strokeWeight, 10));
		}

		if (data.strokeColor){
		  var color = parseColor(data.strokeColor, data.strokeOpacity);
		  polyline.push('color:' + color);
		}

		if (data.fillColor){
		  var fillcolor = parseColor(data.fillColor, data.fillOpacity);
		  polyline.push('fillcolor:' + fillcolor);
		}

		var path = data.path;
		if (path.join){
		  for (var j=0, pos; pos=path[j]; j++){
			polyline.push(pos.join(','));
		  }
		}
		else {
		  polyline.push('enc:' + path);
		}

		polyline = polyline.join('|');
		parameters.push('path=' + encodeURI(polyline));
	  }

	  parameters = parameters.join('&');
	  return static_root + parameters;
	};

	// Events

	GMaps.custom_events = ['marker_added', 'marker_removed', 'polyline_added', 'polyline_removed', 'polygon_added', 'polygon_removed', 'geolocated', 'geolocation_failed'];

	GMaps.on = function(event_name, object, handler) {
	  if (GMaps.custom_events.indexOf(event_name) == -1) {
		return google.maps.event.addListener(object, event_name, handler);
	  }
	  else {
		var registered_event = {
		  handler : handler,
		  eventName : event_name
		};

		object.registered_events[event_name] = object.registered_events[event_name] || [];
		object.registered_events[event_name].push(registered_event);

		return registered_event;
	  }
	};

	GMaps.off = function(event_name, object) {
	  if (GMaps.custom_events.indexOf(event_name) == -1) {
		google.maps.event.clearListeners(object, event_name);
	  }
	  else {
		object.registered_events[event_name] = [];
	  }
	};

	GMaps.fire = function(event_name, object, scope) {
	  if (GMaps.custom_events.indexOf(event_name) == -1) {
		google.maps.event.trigger(object, event_name, Array.prototype.slice.apply(arguments).slice(2));
	  }
	  else {
		if(event_name in scope.registered_events) {
		  var firing_events = scope.registered_events[event_name];

		  for(var i = 0; i < firing_events.length; i++) {
			(function(handler, scope, object) {
			  handler.apply(scope, [object]);
			})(firing_events[i]['handler'], scope, object);
		  }
		}
	  }
	};

	//==========================
	// Polygon containsLatLng
	// https://github.com/tparkin/Google-Maps-Point-in-Polygon
	// Poygon getBounds extension - google-maps-extensions
	// http://code.google.com/p/google-maps-extensions/source/browse/google.maps.Polygon.getBounds.js
	if (!google.maps.Polygon.prototype.getBounds) {
	  google.maps.Polygon.prototype.getBounds = function(latLng) {
		var bounds = new google.maps.LatLngBounds();
		var paths = this.getPaths();
		var path;

		for (var p = 0; p < paths.getLength(); p++) {
		  path = paths.getAt(p);
		  for (var i = 0; i < path.getLength(); i++) {
			bounds.extend(path.getAt(i));
		  }
		}

		return bounds;
	  };
	}

	if (!google.maps.Polygon.prototype.containsLatLng) {
	  // Polygon containsLatLng - method to determine if a latLng is within a polygon
	  google.maps.Polygon.prototype.containsLatLng = function(latLng) {
		// Exclude points outside of bounds as there is no way they are in the poly
		var bounds = this.getBounds();

		if (bounds !== null && !bounds.contains(latLng)) {
		  return false;
		}

		// Raycast point in polygon method
		var inPoly = false;

		var numPaths = this.getPaths().getLength();
		for (var p = 0; p < numPaths; p++) {
		  var path = this.getPaths().getAt(p);
		  var numPoints = path.getLength();
		  var j = numPoints - 1;

		  for (var i = 0; i < numPoints; i++) {
			var vertex1 = path.getAt(i);
			var vertex2 = path.getAt(j);

			if (vertex1.lng() < latLng.lng() && vertex2.lng() >= latLng.lng() || vertex2.lng() < latLng.lng() && vertex1.lng() >= latLng.lng()) {
			  if (vertex1.lat() + (latLng.lng() - vertex1.lng()) / (vertex2.lng() - vertex1.lng()) * (vertex2.lat() - vertex1.lat()) < latLng.lat()) {
				inPoly = !inPoly;
			  }
			}

			j = i;
		  }
		}

		return inPoly;
	  };
	}

	google.maps.LatLngBounds.prototype.containsLatLng = function(latLng) {
	  return this.contains(latLng);
	};

	google.maps.Marker.prototype.setFences = function(fences) {
	  this.fences = fences;
	};

	google.maps.Marker.prototype.addFence = function(fence) {
	  this.fences.push(fence);
	};

	return GMaps;
  }(this));

  var coordsToLatLngs = function(coords, useGeoJSON) {
	var first_coord = coords[0];
	var second_coord = coords[1];

	if(useGeoJSON) {
	  first_coord = coords[1];
	  second_coord = coords[0];
	}

	return new google.maps.LatLng(first_coord, second_coord);
  };

  var arrayToLatLng = function(coords, useGeoJSON) {
	for(var i=0; i < coords.length; i++) {
	  if(coords[i].length > 0 && typeof(coords[i][0]) != "number") {
		coords[i] = arrayToLatLng(coords[i], useGeoJSON);
	  }
	  else {
		coords[i] = coordsToLatLngs(coords[i], useGeoJSON);
	  }
	}

	return coords;
  };

  var extend_object = function(obj, new_obj) {
	if(obj === new_obj) return obj;

	for(var name in new_obj) {
	  obj[name] = new_obj[name];
	}

	return obj;
  };

  var replace_object = function(obj, replace) {
	if(obj === replace) return obj;

	for(var name in replace) {
	  if(obj[name] != undefined)
		obj[name] = replace[name];
	}

	return obj;
  };

  var array_map = function(array, callback) {
	var original_callback_params = Array.prototype.slice.call(arguments, 2);

	if (Array.prototype.map && array.map === Array.prototype.map) {
	  return Array.prototype.map.call(array, function(item) {
		callback_params = original_callback_params;
		callback_params.splice(0, 0, item);

		return callback.apply(this, callback_params);
	  });
	}
	else {
	  var array_return = [];
	  var array_length = array.length;

	  for(var i = 0; i < array_length; i++) {
		callback_params = original_callback_params;
		callback_params = callback_params.splice(0, 0, array[i]);
		array_return.push(callback.apply(this, callback_params));
	  }

	  return array_return;
	}
  };

  var array_flat = function(array) {
	new_array = [];

	for(var i=0; i < array.length; i++) {
	  new_array = new_array.concat(array[i]);
	}

	return new_array;
  };
// Class
$.GMaps = GMaps;

$.GMaps.mapEvents = [
  "bounds_changed",
  "center_changed",
  "click",
  "dblclick",
  "drag",
  "dragend",
  "dragstart",
  "heading_changed",
  "idle",
  "maptypeid_changed",
  "mousemove",
  "mouseout",
  "mouseover",
  "projection_changed",
  "resize",
  "rightclick",
  "tilesloaded",
  "tilt_changed",
  "zoom_changed"
];

// jQuery Plugin
$.fn.gmaps = function(options) {

  // No element found, skip.
  if (this.length < 1) return;

  // Only the first element
  var el          = $(this[0]),
	  map         = el.data("gmaps"),
	  newInstance = (map===undefined),
	  autodetect  = (options===undefined);

  // Normalize options
  if ($.isString(options)) {
	options = {
	  address: options
	};
  }

  // New instance
  if (newInstance) {

	var id = $.uid("gmaps-"),

		defaultOptions = {
		  lat: 0,
		  lng: 0
		};

	if ($.isPlainObject(options)) {
	  options = $.extend({}, defaultOptions, options);
	}

	// Set id
	el.attr("id", id);
	options.div = '#' + id;

	// Override events
	$.each($.GMaps.mapEvents, function(i, eventName){

	  var originalEvent =
			($.isFunction(options[eventName])) ?
			  options[eventName] :
			  $.noop;

	  options[eventName] = function(){

		var args = $.makeArray(arguments);

		// Trigger original event
		originalEvent.apply(map, arguments);

		// Trigger jQuery event
		el.trigger.apply(el, ["map_" + eventName].concat(args));
	  }
	});

	// Instantiate gmaps
	map = new GMaps(options);
	el.data("gmaps", map);

	// Extend with go method
	map.go = function(lat, lng) {
	  map.setCenter(lat, lng);
	  map.addMarker({lat: lat, lng: lng});
	}

	// Auto-detect location
	if (autodetect) {
	  GMaps.geolocate({
		success: function(position) {
		  map.go(position.coords.latitude, position.coords.longitude);
		}
	  });
	}

	return map;

  // Existing instance
  } else {

	var lat = options.lat,
		lng = options.lng;

	// Update location
	if ($.isNumber(lat) || $.isNumber(lng)) {
	  map.go(lat, lng);
	}

	return map;
  }

  // Resolve lat/lng from address
  if (options.address) {

	GMaps.geocode({
	  address: options.address,
	  callback: function(results, status) {
		if (status=="OK") {
		  var coords = results[0].geometry.location;
		  map.go(coords.lat(), coords.lng());
		}
	  }
	});

	return map;
  }
};

  module.resolveWith(GMaps);

});

var language = window.es.locationLanguage;
var apiKey = window.es.gmapsApiKey;
var requireGmaps = window.es.requireGmaps;
var key = '';

if (apiKey) {
	key = "key=" + apiKey + "&";
}

if (requireGmaps) {

	if (window.google && window.google.maps){
		window[callbackId]();

	} else {
		// Load google maps api
		$.require()
			.script($.uri(window.location).protocol() + "://maps.google.com/maps/api/js?" + key + "callback=" + callbackId + "&language=" + language)
			.done()
	}
}


};
// module factory: end

FD40.module("gmaps", moduleFactory);

}());
			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this;
var jQuery = $;
var exports = function() {

/**
 * History.js jQuery Adapter
 * @author Benjamin Arthur Lupton <contact@balupton.com>
 * @copyright 2010-2011 Benjamin Arthur Lupton <contact@balupton.com>
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */

// Closure
(function(window,undefined){
	"use strict";

	// Localise Globals
	var History = window.History = window.History||{};

	// Check Existence
	if ( typeof History.Adapter !== 'undefined' ) {
		throw new Error('History.js Adapter has already been loaded...');
	}

	// Add the Adapter
	History.Adapter = {
		/**
		 * History.Adapter.bind(el,event,callback)
		 * @param {Element|string} el
		 * @param {string} event - custom and standard events
		 * @param {function} callback
		 * @return {void}
		 */
		bind: function(el,event,callback){
			jQuery(el).bind(event,callback);
		},

		/**
		 * History.Adapter.trigger(el,event)
		 * @param {Element|string} el
		 * @param {string} event - custom and standard events
		 * @param {Object=} extra - a object of extra event data (optional)
		 * @return {void}
		 */
		trigger: function(el,event,extra){
			jQuery(el).trigger(event,extra);
		},

		/**
		 * History.Adapter.extractEventData(key,event,extra)
		 * @param {string} key - key for the event data to extract
		 * @param {string} event - custom and standard events
		 * @param {Object=} extra - a object of extra event data (optional)
		 * @return {mixed}
		 */
		extractEventData: function(key,event,extra){
			// jQuery Native then jQuery Custom
			var result = (event && event.originalEvent && event.originalEvent[key]) || (extra && extra[key]) || undefined;

			// Return
			return result;
		},

		/**
		 * History.Adapter.onDomLoad(callback)
		 * @param {function} callback
		 * @return {void}
		 */
		onDomLoad: function(callback) {
			jQuery(callback);
		}
	};

	// Try and Initialise History
	if ( typeof History.init !== 'undefined' ) {
		History.init();
	}

})(window);

/**
 * History.js HTML4 Support
 * Depends on the HTML5 Support
 * @author Benjamin Arthur Lupton <contact@balupton.com>
 * @copyright 2010-2011 Benjamin Arthur Lupton <contact@balupton.com>
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */

(function(window,undefined){
	"use strict";

	// ========================================================================
	// Initialise

	// Localise Globals
	var
		document = window.document, // Make sure we are using the correct document
		setTimeout = window.setTimeout||setTimeout,
		clearTimeout = window.clearTimeout||clearTimeout,
		setInterval = window.setInterval||setInterval,
		History = window.History = window.History||{}; // Public History Object

	// Check Existence
	if ( typeof History.initHtml4 !== 'undefined' ) {
		throw new Error('History.js HTML4 Support has already been loaded...');
	}


	// ========================================================================
	// Initialise HTML4 Support

	// Initialise HTML4 Support
	History.initHtml4 = function(){
		// Initialise
		if ( typeof History.initHtml4.initialized !== 'undefined' ) {
			// Already Loaded
			return false;
		}
		else {
			History.initHtml4.initialized = true;
		}


		// ====================================================================
		// Properties

		/**
		 * History.enabled
		 * Is History enabled?
		 */
		History.enabled = true;


		// ====================================================================
		// Hash Storage

		/**
		 * History.savedHashes
		 * Store the hashes in an array
		 */
		History.savedHashes = [];

		/**
		 * History.isLastHash(newHash)
		 * Checks if the hash is the last hash
		 * @param {string} newHash
		 * @return {boolean} true
		 */
		History.isLastHash = function(newHash){
			// Prepare
			var oldHash = History.getHashByIndex(),
				isLast;

			// Check
			isLast = newHash === oldHash;

			// Return isLast
			return isLast;
		};

		/**
		 * History.saveHash(newHash)
		 * Push a Hash
		 * @param {string} newHash
		 * @return {boolean} true
		 */
		History.saveHash = function(newHash){
			// Check Hash
			if ( History.isLastHash(newHash) ) {
				return false;
			}

			// Push the Hash
			History.savedHashes.push(newHash);

			// Return true
			return true;
		};

		/**
		 * History.getHashByIndex()
		 * Gets a hash by the index
		 * @param {integer} index
		 * @return {string}
		 */
		History.getHashByIndex = function(index){
			// Prepare
			var hash = null;

			// Handle
			if ( typeof index === 'undefined' ) {
				// Get the last inserted
				hash = History.savedHashes[History.savedHashes.length-1];
			}
			else if ( index < 0 ) {
				// Get from the end
				hash = History.savedHashes[History.savedHashes.length+index];
			}
			else {
				// Get from the beginning
				hash = History.savedHashes[index];
			}

			// Return hash
			return hash;
		};


		// ====================================================================
		// Discarded States

		/**
		 * History.discardedHashes
		 * A hashed array of discarded hashes
		 */
		History.discardedHashes = {};

		/**
		 * History.discardedStates
		 * A hashed array of discarded states
		 */
		History.discardedStates = {};

		/**
		 * History.discardState(State)
		 * Discards the state by ignoring it through History
		 * @param {object} State
		 * @return {true}
		 */
		History.discardState = function(discardedState,forwardState,backState){
			//History.debug('History.discardState', arguments);
			// Prepare
			var discardedStateHash = History.getHashByState(discardedState),
				discardObject;

			// Create Discard Object
			discardObject = {
				'discardedState': discardedState,
				'backState': backState,
				'forwardState': forwardState
			};

			// Add to DiscardedStates
			History.discardedStates[discardedStateHash] = discardObject;

			// Return true
			return true;
		};

		/**
		 * History.discardHash(hash)
		 * Discards the hash by ignoring it through History
		 * @param {string} hash
		 * @return {true}
		 */
		History.discardHash = function(discardedHash,forwardState,backState){
			//History.debug('History.discardState', arguments);
			// Create Discard Object
			var discardObject = {
				'discardedHash': discardedHash,
				'backState': backState,
				'forwardState': forwardState
			};

			// Add to discardedHash
			History.discardedHashes[discardedHash] = discardObject;

			// Return true
			return true;
		};

		/**
		 * History.discardState(State)
		 * Checks to see if the state is discarded
		 * @param {object} State
		 * @return {bool}
		 */
		History.discardedState = function(State){
			// Prepare
			var StateHash = History.getHashByState(State),
				discarded;

			// Check
			discarded = History.discardedStates[StateHash]||false;

			// Return true
			return discarded;
		};

		/**
		 * History.discardedHash(hash)
		 * Checks to see if the state is discarded
		 * @param {string} State
		 * @return {bool}
		 */
		History.discardedHash = function(hash){
			// Check
			var discarded = History.discardedHashes[hash]||false;

			// Return true
			return discarded;
		};

		/**
		 * History.recycleState(State)
		 * Allows a discarded state to be used again
		 * @param {object} data
		 * @param {string} title
		 * @param {string} url
		 * @return {true}
		 */
		History.recycleState = function(State){
			//History.debug('History.recycleState', arguments);
			// Prepare
			var StateHash = History.getHashByState(State);

			// Remove from DiscardedStates
			if ( History.discardedState(State) ) {
				delete History.discardedStates[StateHash];
			}

			// Return true
			return true;
		};


		// ====================================================================
		// HTML4 HashChange Support

		if ( History.emulated.hashChange ) {
			/*
			 * We must emulate the HTML4 HashChange Support by manually checking for hash changes
			 */

			/**
			 * History.hashChangeInit()
			 * Init the HashChange Emulation
			 */
			History.hashChangeInit = function(){
				// Define our Checker Function
				History.checkerFunction = null;

				// Define some variables that will help in our checker function
				var lastDocumentHash = '',
					iframeId, iframe,
					lastIframeHash, checkerRunning;

				// Handle depending on the browser
				if ( History.isInternetExplorer() ) {
					// IE6 and IE7
					// We need to use an iframe to emulate the back and forward buttons

					// Create iFrame
					iframeId = 'historyjs-iframe';
					iframe = document.createElement('iframe');

					// Adjust iFarme
					iframe.setAttribute('id', iframeId);
					iframe.style.display = 'none';

					// Append iFrame
					document.body.appendChild(iframe);

					// Create initial history entry
					iframe.contentWindow.document.open();
					iframe.contentWindow.document.close();

					// Define some variables that will help in our checker function
					lastIframeHash = '';
					checkerRunning = false;

					// Define the checker function
					History.checkerFunction = function(){
						// Check Running
						if ( checkerRunning ) {
							return false;
						}

						// Update Running
						checkerRunning = true;

						// Fetch
						var documentHash = History.getHash()||'',
							iframeHash = History.unescapeHash(iframe.contentWindow.document.location.hash)||'';

						// The Document Hash has changed (application caused)
						if ( documentHash !== lastDocumentHash ) {
							// Equalise
							lastDocumentHash = documentHash;

							// Create a history entry in the iframe
							if ( iframeHash !== documentHash ) {
								//History.debug('hashchange.checker: iframe hash change', 'documentHash (new):', documentHash, 'iframeHash (old):', iframeHash);

								// Equalise
								lastIframeHash = iframeHash = documentHash;

								// Create History Entry
								iframe.contentWindow.document.open();
								iframe.contentWindow.document.close();

								// Update the iframe's hash
								iframe.contentWindow.document.location.hash = History.escapeHash(documentHash);
							}

							// Trigger Hashchange Event
							History.Adapter.trigger(window,'hashchange');
						}

						// The iFrame Hash has changed (back button caused)
						else if ( iframeHash !== lastIframeHash ) {
							//History.debug('hashchange.checker: iframe hash out of sync', 'iframeHash (new):', iframeHash, 'documentHash (old):', documentHash);

							// Equalise
							lastIframeHash = iframeHash;

							// Update the Hash
							History.setHash(iframeHash,false);
						}

						// Reset Running
						checkerRunning = false;

						// Return true
						return true;
					};
				}
				else {
					// We are not IE
					// Firefox 1 or 2, Opera

					// Define the checker function
					History.checkerFunction = function(){
						// Prepare
						var documentHash = History.getHash();

						// The Document Hash has changed (application caused)
						if ( documentHash !== lastDocumentHash ) {
							// Equalise
							lastDocumentHash = documentHash;

							// Trigger Hashchange Event
							History.Adapter.trigger(window,'hashchange');
						}

						// Return true
						return true;
					};
				}

				// Apply the checker function
				History.intervalList.push(setInterval(History.checkerFunction, History.options.hashChangeInterval));

				// Done
				return true;
			}; // History.hashChangeInit

			// Bind hashChangeInit
			History.Adapter.onDomLoad(History.hashChangeInit);

		} // History.emulated.hashChange


		// ====================================================================
		// HTML5 State Support

		// Non-Native pushState Implementation
		if ( History.emulated.pushState ) {
			/*
			 * We must emulate the HTML5 State Management by using HTML4 HashChange
			 */

			/**
			 * History.onHashChange(event)
			 * Trigger HTML5's window.onpopstate via HTML4 HashChange Support
			 */
			History.onHashChange = function(event){
				//History.debug('History.onHashChange', arguments);

				// Prepare
				var currentUrl = ((event && event.newURL) || document.location.href),
					currentHash = History.getHashByUrl(currentUrl),
					currentState = null,
					currentStateHash = null,
					currentStateHashExits = null,
					discardObject;

				// Check if we are the same state
				if ( History.isLastHash(currentHash) ) {
					// There has been no change (just the page's hash has finally propagated)
					//History.debug('History.onHashChange: no change');
					History.busy(false);
					return false;
				}

				// Reset the double check
				History.doubleCheckComplete();

				// Store our location for use in detecting back/forward direction
				History.saveHash(currentHash);

				// Expand Hash
				if ( currentHash && History.isTraditionalAnchor(currentHash) ) {
					//History.debug('History.onHashChange: traditional anchor', currentHash);
					// Traditional Anchor Hash
					History.Adapter.trigger(window,'anchorchange');
					History.busy(false);
					return false;
				}

				// Create State
				currentState = History.extractState(History.getFullUrl(currentHash||document.location.href,false),true);

				// Check if we are the same state
				if ( History.isLastSavedState(currentState) ) {
					//History.debug('History.onHashChange: no change');
					// There has been no change (just the page's hash has finally propagated)
					History.busy(false);
					return false;
				}

				// Create the state Hash
				currentStateHash = History.getHashByState(currentState);

				// Check if we are DiscardedState
				discardObject = History.discardedState(currentState);
				if ( discardObject ) {
					// Ignore this state as it has been discarded and go back to the state before it
					if ( History.getHashByIndex(-2) === History.getHashByState(discardObject.forwardState) ) {
						// We are going backwards
						//History.debug('History.onHashChange: go backwards');
						History.back(false);
					} else {
						// We are going forwards
						//History.debug('History.onHashChange: go forwards');
						History.forward(false);
					}
					return false;
				}

				// Push the new HTML5 State
				//History.debug('History.onHashChange: success hashchange');
				History.pushState(currentState.data,currentState.title,currentState.url,false);

				// End onHashChange closure
				return true;
			};
			History.Adapter.bind(window,'hashchange',History.onHashChange);

			/**
			 * History.pushState(data,title,url)
			 * Add a new State to the history object, become it, and trigger onpopstate
			 * We have to trigger for HTML4 compatibility
			 * @param {object} data
			 * @param {string} title
			 * @param {string} url
			 * @return {true}
			 */
			History.pushState = function(data,title,url,queue){
				//History.debug('History.pushState: called', arguments);

				// Check the State
				if ( History.getHashByUrl(url) ) {
					throw new Error('History.js does not support states with fragement-identifiers (hashes/anchors).');
				}

				// Handle Queueing
				if ( queue !== false && History.busy() ) {
					// Wait + Push to Queue
					//History.debug('History.pushState: we must wait', arguments);
					History.pushQueue({
						scope: History,
						callback: History.pushState,
						args: arguments,
						queue: queue
					});
					return false;
				}

				// Make Busy
				History.busy(true);

				// Fetch the State Object
				var newState = History.createStateObject(data,title,url),
					newStateHash = History.getHashByState(newState),
					oldState = History.getState(false),
					oldStateHash = History.getHashByState(oldState),
					html4Hash = History.getHash();

				// Store the newState
				History.storeState(newState);
				History.expectedStateId = newState.id;

				// Recycle the State
				History.recycleState(newState);

				// Force update of the title
				History.setTitle(newState);

				// Check if we are the same State
				if ( newStateHash === oldStateHash ) {
					//History.debug('History.pushState: no change', newStateHash);
					History.busy(false);
					return false;
				}

				// Update HTML4 Hash
				if ( newStateHash !== html4Hash && newStateHash !== History.getShortUrl(document.location.href) ) {
					//History.debug('History.pushState: update hash', newStateHash, html4Hash);
					History.setHash(newStateHash,false);
					return false;
				}

				// Update HTML5 State
				History.saveState(newState);

				// Fire HTML5 Event
				//History.debug('History.pushState: trigger popstate');
				History.Adapter.trigger(window,'statechange');
				History.busy(false);

				// End pushState closure
				return true;
			};

			/**
			 * History.replaceState(data,title,url)
			 * Replace the State and trigger onpopstate
			 * We have to trigger for HTML4 compatibility
			 * @param {object} data
			 * @param {string} title
			 * @param {string} url
			 * @return {true}
			 */
			History.replaceState = function(data,title,url,queue){
				//History.debug('History.replaceState: called', arguments);

				// Check the State
				if ( History.getHashByUrl(url) ) {
					throw new Error('History.js does not support states with fragement-identifiers (hashes/anchors).');
				}

				// Handle Queueing
				if ( queue !== false && History.busy() ) {
					// Wait + Push to Queue
					//History.debug('History.replaceState: we must wait', arguments);
					History.pushQueue({
						scope: History,
						callback: History.replaceState,
						args: arguments,
						queue: queue
					});
					return false;
				}

				// Make Busy
				History.busy(true);

				// Fetch the State Objects
				var newState        = History.createStateObject(data,title,url),
					oldState        = History.getState(false),
					previousState   = History.getStateByIndex(-2);

				// Discard Old State
				History.discardState(oldState,newState,previousState);

				// Alias to PushState
				History.pushState(newState.data,newState.title,newState.url,false);

				// End replaceState closure
				return true;
			};

		} // History.emulated.pushState



		// ====================================================================
		// Initialise

		// Non-Native pushState Implementation
		if ( History.emulated.pushState ) {
			/**
			 * Ensure initial state is handled correctly
			 */
			if ( History.getHash() && !History.emulated.hashChange ) {
				History.Adapter.onDomLoad(function(){
					History.Adapter.trigger(window,'hashchange');
				});
			}

		} // History.emulated.pushState

	}; // History.initHtml4

	// Try and Initialise History
	if ( typeof History.init !== 'undefined' ) {
		History.init();
	}

})(window);
/**
 * History.js Core
 * @author Benjamin Arthur Lupton <contact@balupton.com>
 * @copyright 2010-2011 Benjamin Arthur Lupton <contact@balupton.com>
 * @license New BSD License <http://creativecommons.org/licenses/BSD/>
 */

(function(window,undefined){
	"use strict";

	// ========================================================================
	// Initialise

	// Localise Globals
	var
		console = window.console||undefined, // Prevent a JSLint complain
		document = window.document, // Make sure we are using the correct document
		navigator = window.navigator, // Make sure we are using the correct navigator
		sessionStorage = window.sessionStorage||false, // sessionStorage
		setTimeout = window.setTimeout,
		clearTimeout = window.clearTimeout,
		setInterval = window.setInterval,
		clearInterval = window.clearInterval,
		JSON = window.JSON,
		alert = window.alert,
		History = window.History = window.History||{}, // Public History Object
		history = window.history; // Old History Object

	// MooTools Compatibility
	JSON.stringify = JSON.stringify||JSON.encode;
	JSON.parse = JSON.parse||JSON.decode;

	// Check Existence
	if ( typeof History.init !== 'undefined' ) {
		throw new Error('History.js Core has already been loaded...');
	}

	// Initialise History
	History.init = function(){
		// Check Load Status of Adapter
		if ( typeof History.Adapter === 'undefined' ) {
			return false;
		}

		// Check Load Status of Core
		if ( typeof History.initCore !== 'undefined' ) {
			History.initCore();
		}

		// Check Load Status of HTML4 Support
		if ( typeof History.initHtml4 !== 'undefined' ) {
			History.initHtml4();
		}

		// Return true
		return true;
	};


	// ========================================================================
	// Initialise Core

	// Initialise Core
	History.initCore = function(){
		// Initialise
		if ( typeof History.initCore.initialized !== 'undefined' ) {
			// Already Loaded
			return false;
		}
		else {
			History.initCore.initialized = true;
		}


		// ====================================================================
		// Options

		/**
		 * History.options
		 * Configurable options
		 */
		History.options = History.options||{};

		/**
		 * History.options.hashChangeInterval
		 * How long should the interval be before hashchange checks
		 */
		History.options.hashChangeInterval = History.options.hashChangeInterval || 100;

		/**
		 * History.options.safariPollInterval
		 * How long should the interval be before safari poll checks
		 */
		History.options.safariPollInterval = History.options.safariPollInterval || 500;

		/**
		 * History.options.doubleCheckInterval
		 * How long should the interval be before we perform a double check
		 */
		History.options.doubleCheckInterval = History.options.doubleCheckInterval || 500;

		/**
		 * History.options.storeInterval
		 * How long should we wait between store calls
		 */
		History.options.storeInterval = History.options.storeInterval || 1000;

		/**
		 * History.options.busyDelay
		 * How long should we wait between busy events
		 */
		History.options.busyDelay = History.options.busyDelay || 250;

		/**
		 * History.options.debug
		 * If true will enable debug messages to be logged
		 */
		History.options.debug = History.options.debug || false;

		/**
		 * History.options.initialTitle
		 * What is the title of the initial state
		 */
		History.options.initialTitle = History.options.initialTitle || document.title;


		// ====================================================================
		// Interval record

		/**
		 * History.intervalList
		 * List of intervals set, to be cleared when document is unloaded.
		 */
		History.intervalList = [];

		/**
		 * History.clearAllIntervals
		 * Clears all setInterval instances.
		 */
		History.clearAllIntervals = function(){
			var i, il = History.intervalList;
			if (typeof il !== "undefined" && il !== null) {
				for (i = 0; i < il.length; i++) {
					clearInterval(il[i]);
				}
				History.intervalList = null;
			}
		};


		// ====================================================================
		// Debug

		/**
		 * History.debug(message,...)
		 * Logs the passed arguments if debug enabled
		 */
		History.debug = function(){
			if ( (History.options.debug||false) ) {
				History.log.apply(History,arguments);
			}
		};

		/**
		 * History.log(message,...)
		 * Logs the passed arguments
		 */
		History.log = function(){
			// Prepare
			var
				consoleExists = !(typeof console === 'undefined' || typeof console.log === 'undefined' || typeof console.log.apply === 'undefined'),
				textarea = document.getElementById('log'),
				message,
				i,n,
				args,arg
				;

			// Write to Console
			if ( consoleExists ) {
				args = Array.prototype.slice.call(arguments);
				message = args.shift();
				if ( typeof console.debug !== 'undefined' ) {
					console.debug.apply(console,[message,args]);
				}
				else {
					console.log.apply(console,[message,args]);
				}
			}
			else {
				message = ("\n"+arguments[0]+"\n");
			}

			// Write to log
			for ( i=1,n=arguments.length; i<n; ++i ) {
				arg = arguments[i];
				if ( typeof arg === 'object' && typeof JSON !== 'undefined' ) {
					try {
						arg = JSON.stringify(arg);
					}
					catch ( Exception ) {
						// Recursive Object
					}
				}
				message += "\n"+arg+"\n";
			}

			// Textarea
			if ( textarea ) {
				textarea.value += message+"\n-----\n";
				textarea.scrollTop = textarea.scrollHeight - textarea.clientHeight;
			}
			// No Textarea, No Console
			else if ( !consoleExists ) {
				alert(message);
			}

			// Return true
			return true;
		};


		// ====================================================================
		// Emulated Status

		/**
		 * History.getInternetExplorerMajorVersion()
		 * Get's the major version of Internet Explorer
		 * @return {integer}
		 * @license Public Domain
		 * @author Benjamin Arthur Lupton <contact@balupton.com>
		 * @author James Padolsey <https://gist.github.com/527683>
		 */
		History.getInternetExplorerMajorVersion = function(){
			var result = History.getInternetExplorerMajorVersion.cached =
					(typeof History.getInternetExplorerMajorVersion.cached !== 'undefined')
				?	History.getInternetExplorerMajorVersion.cached
				:	(function(){
						var v = 3,
								div = document.createElement('div'),
								all = div.getElementsByTagName('i');
						while ( (div.innerHTML = '<!--[if gt IE ' + (++v) + ']><i></i><![endif]-->') && all[0] ) {}
						return (v > 4) ? v : false;
					})()
				;
			return result;
		};

		/**
		 * History.isInternetExplorer()
		 * Are we using Internet Explorer?
		 * @return {boolean}
		 * @license Public Domain
		 * @author Benjamin Arthur Lupton <contact@balupton.com>
		 */
		History.isInternetExplorer = function(){
			var result =
				History.isInternetExplorer.cached =
				(typeof History.isInternetExplorer.cached !== 'undefined')
					?	History.isInternetExplorer.cached
					:	Boolean(History.getInternetExplorerMajorVersion())
				;
			return result;
		};

		/**
		 * History.emulated
		 * Which features require emulating?
		 */
		History.emulated = {
			pushState: !Boolean(
				window.history && window.history.pushState && window.history.replaceState
				&& !(
					(/ Mobile\/([1-7][a-z]|(8([abcde]|f(1[0-8]))))/i).test(navigator.userAgent) /* disable for versions of iOS before version 4.3 (8F190) */
					|| (/AppleWebKit\/5([0-2]|3[0-2])/i).test(navigator.userAgent) /* disable for the mercury iOS browser, or at least older versions of the webkit engine */
				)
			),
			hashChange: Boolean(
				!(('onhashchange' in window) || ('onhashchange' in document))
				||
				(History.isInternetExplorer() && History.getInternetExplorerMajorVersion() < 8)
			)
		};

		/**
		 * History.enabled
		 * Is History enabled?
		 */
		History.enabled = !History.emulated.pushState;

		/**
		 * History.bugs
		 * Which bugs are present
		 */
		History.bugs = {
			/**
			 * Safari 5 and Safari iOS 4 fail to return to the correct state once a hash is replaced by a `replaceState` call
			 * https://bugs.webkit.org/show_bug.cgi?id=56249
			 */
			setHash: Boolean(!History.emulated.pushState && navigator.vendor === 'Apple Computer, Inc.' && /AppleWebKit\/5([0-2]|3[0-3])/.test(navigator.userAgent)),

			/**
			 * Safari 5 and Safari iOS 4 sometimes fail to apply the state change under busy conditions
			 * https://bugs.webkit.org/show_bug.cgi?id=42940
			 */
			safariPoll: Boolean(!History.emulated.pushState && navigator.vendor === 'Apple Computer, Inc.' && /AppleWebKit\/5([0-2]|3[0-3])/.test(navigator.userAgent)),

			/**
			 * MSIE 6 and 7 sometimes do not apply a hash even it was told to (requiring a second call to the apply function)
			 */
			ieDoubleCheck: Boolean(History.isInternetExplorer() && History.getInternetExplorerMajorVersion() < 8),

			/**
			 * MSIE 6 requires the entire hash to be encoded for the hashes to trigger the onHashChange event
			 */
			hashEscape: Boolean(History.isInternetExplorer() && History.getInternetExplorerMajorVersion() < 7)
		};

		/**
		 * History.isEmptyObject(obj)
		 * Checks to see if the Object is Empty
		 * @param {Object} obj
		 * @return {boolean}
		 */
		History.isEmptyObject = function(obj) {
			for ( var name in obj ) {
				return false;
			}
			return true;
		};

		/**
		 * History.cloneObject(obj)
		 * Clones a object and eliminate all references to the original contexts
		 * @param {Object} obj
		 * @return {Object}
		 */
		History.cloneObject = function(obj) {
			var hash,newObj;
			if ( obj ) {
				hash = JSON.stringify(obj);
				newObj = JSON.parse(hash);
			}
			else {
				newObj = {};
			}
			return newObj;
		};


		// ====================================================================
		// URL Helpers

		/**
		 * History.getRootUrl()
		 * Turns "http://mysite.com/dir/page.html?asd" into "http://mysite.com"
		 * @return {String} rootUrl
		 */
		History.getRootUrl = function(){
			// Create
			var rootUrl = document.location.protocol+'//'+(document.location.hostname||document.location.host);
			if ( document.location.port||false ) {
				rootUrl += ':'+document.location.port;
			}
			rootUrl += '/';

			// Return
			return rootUrl;
		};

		/**
		 * History.getBaseHref()
		 * Fetches the `href` attribute of the `<base href="...">` element if it exists
		 * @return {String} baseHref
		 */
		History.getBaseHref = function(){
			// Create
			var
				baseElements = document.getElementsByTagName('base'),
				baseElement = null,
				baseHref = '';

			// Test for Base Element
			if ( baseElements.length === 1 ) {
				// Prepare for Base Element
				baseElement = baseElements[0];
				baseHref = baseElement.href.replace(/[^\/]+$/,'');
			}

			// Adjust trailing slash
			baseHref = baseHref.replace(/\/+$/,'');
			if ( baseHref ) baseHref += '/';

			// Return
			return baseHref;
		};

		/**
		 * History.getBaseUrl()
		 * Fetches the baseHref or basePageUrl or rootUrl (whichever one exists first)
		 * @return {String} baseUrl
		 */
		History.getBaseUrl = function(){
			// Create
			var baseUrl = History.getBaseHref()||History.getBasePageUrl()||History.getRootUrl();

			// Return
			return baseUrl;
		};

		/**
		 * History.getPageUrl()
		 * Fetches the URL of the current page
		 * @return {String} pageUrl
		 */
		History.getPageUrl = function(){
			// Fetch
			var
				State = History.getState(false,false),
				stateUrl = (State||{}).url||document.location.href,
				pageUrl;

			// Create
			pageUrl = stateUrl.replace(/\/+$/,'').replace(/[^\/]+$/,function(part,index,string){
				return (/\./).test(part) ? part : part+'/';
			});

			// Return
			return pageUrl;
		};

		/**
		 * History.getBasePageUrl()
		 * Fetches the Url of the directory of the current page
		 * @return {String} basePageUrl
		 */
		History.getBasePageUrl = function(){
			// Create
			var basePageUrl = document.location.href.replace(/[#\?].*/,'').replace(/[^\/]+$/,function(part,index,string){
				return (/[^\/]$/).test(part) ? '' : part;
			}).replace(/\/+$/,'')+'/';

			// Return
			return basePageUrl;
		};

		/**
		 * History.getFullUrl(url)
		 * Ensures that we have an absolute URL and not a relative URL
		 * @param {string} url
		 * @param {Boolean} allowBaseHref
		 * @return {string} fullUrl
		 */
		History.getFullUrl = function(url,allowBaseHref){
			// Prepare
			var fullUrl = url, firstChar = url.substring(0,1);
			allowBaseHref = (typeof allowBaseHref === 'undefined') ? true : allowBaseHref;

			// Check
			if ( /[a-z]+\:\/\//.test(url) ) {
				// Full URL
			}
			else if ( firstChar === '/' ) {
				// Root URL
				fullUrl = History.getRootUrl()+url.replace(/^\/+/,'');
			}
			else if ( firstChar === '#' ) {
				// Anchor URL
				fullUrl = History.getPageUrl().replace(/#.*/,'')+url;
			}
			else if ( firstChar === '?' ) {
				// Query URL
				fullUrl = History.getPageUrl().replace(/[\?#].*/,'')+url;
			}
			else {
				// Relative URL
				if ( allowBaseHref ) {
					fullUrl = History.getBaseUrl()+url.replace(/^(\.\/)+/,'');
				} else {
					fullUrl = History.getBasePageUrl()+url.replace(/^(\.\/)+/,'');
				}
				// We have an if condition above as we do not want hashes
				// which are relative to the baseHref in our URLs
				// as if the baseHref changes, then all our bookmarks
				// would now point to different locations
				// whereas the basePageUrl will always stay the same
			}

			// Return
			return fullUrl.replace(/\#$/,'');
		};

		/**
		 * History.getShortUrl(url)
		 * Ensures that we have a relative URL and not a absolute URL
		 * @param {string} url
		 * @return {string} url
		 */
		History.getShortUrl = function(url){
			// Prepare
			var shortUrl = url, baseUrl = History.getBaseUrl(), rootUrl = History.getRootUrl();

			// Trim baseUrl
			if ( History.emulated.pushState ) {
				// We are in a if statement as when pushState is not emulated
				// The actual url these short urls are relative to can change
				// So within the same session, we the url may end up somewhere different
				shortUrl = shortUrl.replace(baseUrl,'');
			}

			// Trim rootUrl
			shortUrl = shortUrl.replace(rootUrl,'/');

			// Ensure we can still detect it as a state
			if ( History.isTraditionalAnchor(shortUrl) ) {
				shortUrl = './'+shortUrl;
			}

			// Clean It
			shortUrl = shortUrl.replace(/^(\.\/)+/g,'./').replace(/\#$/,'');

			// Return
			return shortUrl;
		};


		// ====================================================================
		// State Storage

		/**
		 * History.store
		 * The store for all session specific data
		 */
		History.store = {};

		/**
		 * History.idToState
		 * 1-1: State ID to State Object
		 */
		History.idToState = History.idToState||{};

		/**
		 * History.stateToId
		 * 1-1: State String to State ID
		 */
		History.stateToId = History.stateToId||{};

		/**
		 * History.urlToId
		 * 1-1: State URL to State ID
		 */
		History.urlToId = History.urlToId||{};

		/**
		 * History.storedStates
		 * Store the states in an array
		 */
		History.storedStates = History.storedStates||[];

		/**
		 * History.savedStates
		 * Saved the states in an array
		 */
		History.savedStates = History.savedStates||[];

		/**
		 * History.noramlizeStore()
		 * Noramlize the store by adding necessary values
		 */
		History.normalizeStore = function(){
			History.store.idToState = History.store.idToState||{};
			History.store.urlToId = History.store.urlToId||{};
			History.store.stateToId = History.store.stateToId||{};
		};

		/**
		 * History.getState()
		 * Get an object containing the data, title and url of the current state
		 * @param {Boolean} friendly
		 * @param {Boolean} create
		 * @return {Object} State
		 */
		History.getState = function(friendly,create){
			// Prepare
			if ( typeof friendly === 'undefined' ) { friendly = true; }
			if ( typeof create === 'undefined' ) { create = true; }

			// Fetch
			var State = History.getLastSavedState();

			// Create
			if ( !State && create ) {
				State = History.createStateObject();
			}

			// Adjust
			if ( friendly ) {
				State = History.cloneObject(State);
				State.url = State.cleanUrl||State.url;
			}

			// Return
			return State;
		};

		/**
		 * History.getIdByState(State)
		 * Gets a ID for a State
		 * @param {State} newState
		 * @return {String} id
		 */
		History.getIdByState = function(newState){

			// Fetch ID
			var id = History.extractId(newState.url),
				str;

			if ( !id ) {
				// Find ID via State String
				str = History.getStateString(newState);
				if ( typeof History.stateToId[str] !== 'undefined' ) {
					id = History.stateToId[str];
				}
				else if ( typeof History.store.stateToId[str] !== 'undefined' ) {
					id = History.store.stateToId[str];
				}
				else {
					// Generate a new ID
					while ( true ) {
						id = (new Date()).getTime() + String(Math.random()).replace(/\D/g,'');
						if ( typeof History.idToState[id] === 'undefined' && typeof History.store.idToState[id] === 'undefined' ) {
							break;
						}
					}

					// Apply the new State to the ID
					History.stateToId[str] = id;
					History.idToState[id] = newState;
				}
			}

			// Return ID
			return id;
		};

		/**
		 * History.normalizeState(State)
		 * Expands a State Object
		 * @param {object} State
		 * @return {object}
		 */
		History.normalizeState = function(oldState){
			// Variables
			var newState, dataNotEmpty;

			// Prepare
			if ( !oldState || (typeof oldState !== 'object') ) {
				oldState = {};
			}

			// Check
			if ( typeof oldState.normalized !== 'undefined' ) {
				return oldState;
			}

			// Adjust
			if ( !oldState.data || (typeof oldState.data !== 'object') ) {
				oldState.data = {};
			}

			// ----------------------------------------------------------------

			// Create
			newState = {};
			newState.normalized = true;
			newState.title = oldState.title||'';
			newState.url = History.getFullUrl(History.unescapeString(oldState.url||document.location.href));
			newState.hash = History.getShortUrl(newState.url);
			newState.data = History.cloneObject(oldState.data);

			// Fetch ID
			newState.id = History.getIdByState(newState);

			// ----------------------------------------------------------------

			// Clean the URL
			newState.cleanUrl = newState.url.replace(/\??\&_suid.*/,'');
			newState.url = newState.cleanUrl;

			// Check to see if we have more than just a url
			dataNotEmpty = !History.isEmptyObject(newState.data);

			// Apply
			if ( newState.title || dataNotEmpty ) {
				// Add ID to Hash
				newState.hash = History.getShortUrl(newState.url).replace(/\??\&_suid.*/,'');
				if ( !/\?/.test(newState.hash) ) {
					newState.hash += '?';
				}
				newState.hash += '&_suid='+newState.id;
			}

			// Create the Hashed URL
			newState.hashedUrl = History.getFullUrl(newState.hash);

			// ----------------------------------------------------------------

			// Update the URL if we have a duplicate
			if ( (History.emulated.pushState || History.bugs.safariPoll) && History.hasUrlDuplicate(newState) ) {
				newState.url = newState.hashedUrl;
			}

			// ----------------------------------------------------------------

			// Return
			return newState;
		};

		/**
		 * History.createStateObject(data,title,url)
		 * Creates a object based on the data, title and url state params
		 * @param {object} data
		 * @param {string} title
		 * @param {string} url
		 * @return {object}
		 */
		History.createStateObject = function(data,title,url){
			// Hashify
			var State = {
				'data': data,
				'title': title,
				'url': url
			};

			// Expand the State
			State = History.normalizeState(State);

			// Return object
			return State;
		};

		/**
		 * History.getStateById(id)
		 * Get a state by it's UID
		 * @param {String} id
		 */
		History.getStateById = function(id){
			// Prepare
			id = String(id);

			// Retrieve
			var State = History.idToState[id] || History.store.idToState[id] || undefined;

			// Return State
			return State;
		};

		/**
		 * Get a State's String
		 * @param {State} passedState
		 */
		History.getStateString = function(passedState){
			// Prepare
			var State, cleanedState, str;

			// Fetch
			State = History.normalizeState(passedState);

			// Clean
			cleanedState = {
				data: State.data,
				title: passedState.title,
				url: passedState.url
			};

			// Fetch
			str = JSON.stringify(cleanedState);

			// Return
			return str;
		};

		/**
		 * Get a State's ID
		 * @param {State} passedState
		 * @return {String} id
		 */
		History.getStateId = function(passedState){
			// Prepare
			var State, id;

			// Fetch
			State = History.normalizeState(passedState);

			// Fetch
			id = State.id;

			// Return
			return id;
		};

		/**
		 * History.getHashByState(State)
		 * Creates a Hash for the State Object
		 * @param {State} passedState
		 * @return {String} hash
		 */
		History.getHashByState = function(passedState){
			// Prepare
			var State, hash;

			// Fetch
			State = History.normalizeState(passedState);

			// Hash
			hash = State.hash;

			// Return
			return hash;
		};

		/**
		 * History.extractId(url_or_hash)
		 * Get a State ID by it's URL or Hash
		 * @param {string} url_or_hash
		 * @return {string} id
		 */
		History.extractId = function ( url_or_hash ) {
			// Prepare
			var id,parts,url;

			// Extract
			parts = /(.*)\&_suid=([0-9]+)$/.exec(url_or_hash);
			url = parts ? (parts[1]||url_or_hash) : url_or_hash;
			id = parts ? String(parts[2]||'') : '';

			// Return
			return id||false;
		};

		/**
		 * History.isTraditionalAnchor
		 * Checks to see if the url is a traditional anchor or not
		 * @param {String} url_or_hash
		 * @return {Boolean}
		 */
		History.isTraditionalAnchor = function(url_or_hash){
			// Check
			var isTraditional = !(/[\/\?\.]/.test(url_or_hash));

			// Return
			return isTraditional;
		};

		/**
		 * History.extractState
		 * Get a State by it's URL or Hash
		 * @param {String} url_or_hash
		 * @return {State|null}
		 */
		History.extractState = function(url_or_hash,create){
			// Prepare
			var State = null, id, url;
			create = create||false;

			// Fetch SUID
			id = History.extractId(url_or_hash);
			if ( id ) {
				State = History.getStateById(id);
			}

			// Fetch SUID returned no State
			if ( !State ) {
				// Fetch URL
				url = History.getFullUrl(url_or_hash);

				// Check URL
				id = History.getIdByUrl(url)||false;
				if ( id ) {
					State = History.getStateById(id);
				}

				// Create State
				if ( !State && create && !History.isTraditionalAnchor(url_or_hash) ) {
					State = History.createStateObject(null,null,url);
				}
			}

			// Return
			return State;
		};

		/**
		 * History.getIdByUrl()
		 * Get a State ID by a State URL
		 */
		History.getIdByUrl = function(url){
			// Fetch
			var id = History.urlToId[url] || History.store.urlToId[url] || undefined;

			// Return
			return id;
		};

		/**
		 * History.getLastSavedState()
		 * Get an object containing the data, title and url of the current state
		 * @return {Object} State
		 */
		History.getLastSavedState = function(){
			return History.savedStates[History.savedStates.length-1]||undefined;
		};

		/**
		 * History.getLastStoredState()
		 * Get an object containing the data, title and url of the current state
		 * @return {Object} State
		 */
		History.getLastStoredState = function(){
			return History.storedStates[History.storedStates.length-1]||undefined;
		};

		/**
		 * History.hasUrlDuplicate
		 * Checks if a Url will have a url conflict
		 * @param {Object} newState
		 * @return {Boolean} hasDuplicate
		 */
		History.hasUrlDuplicate = function(newState) {
			// Prepare
			var hasDuplicate = false,
				oldState;

			// Fetch
			oldState = History.extractState(newState.url);

			// Check
			hasDuplicate = oldState && oldState.id !== newState.id;

			// Return
			return hasDuplicate;
		};

		/**
		 * History.storeState
		 * Store a State
		 * @param {Object} newState
		 * @return {Object} newState
		 */
		History.storeState = function(newState){
			// Store the State
			History.urlToId[newState.url] = newState.id;

			// Push the State
			History.storedStates.push(History.cloneObject(newState));

			// Return newState
			return newState;
		};

		/**
		 * History.isLastSavedState(newState)
		 * Tests to see if the state is the last state
		 * @param {Object} newState
		 * @return {boolean} isLast
		 */
		History.isLastSavedState = function(newState){
			// Prepare
			var isLast = false,
				newId, oldState, oldId;

			// Check
			if ( History.savedStates.length ) {
				newId = newState.id;
				oldState = History.getLastSavedState();
				oldId = oldState.id;

				// Check
				isLast = (newId === oldId);
			}

			// Return
			return isLast;
		};

		/**
		 * History.saveState
		 * Push a State
		 * @param {Object} newState
		 * @return {boolean} changed
		 */
		History.saveState = function(newState){
			// Check Hash
			if ( History.isLastSavedState(newState) ) {
				return false;
			}

			// Push the State
			History.savedStates.push(History.cloneObject(newState));

			// Return true
			return true;
		};

		/**
		 * History.getStateByIndex()
		 * Gets a state by the index
		 * @param {integer} index
		 * @return {Object}
		 */
		History.getStateByIndex = function(index){
			// Prepare
			var State = null;

			// Handle
			if ( typeof index === 'undefined' ) {
				// Get the last inserted
				State = History.savedStates[History.savedStates.length-1];
			}
			else if ( index < 0 ) {
				// Get from the end
				State = History.savedStates[History.savedStates.length+index];
			}
			else {
				// Get from the beginning
				State = History.savedStates[index];
			}

			// Return State
			return State;
		};


		// ====================================================================
		// Hash Helpers

		/**
		 * History.getHash()
		 * Gets the current document hash
		 * @return {string}
		 */
		History.getHash = function(){
			var hash = History.unescapeHash(document.location.hash);
			return hash;
		};

		/**
		 * History.unescapeString()
		 * Unescape a string
		 * @param {String} str
		 * @return {string}
		 */
		History.unescapeString = function(str){
			// Prepare
			var result = str,
				tmp;

			// Unescape hash
			while ( true ) {
				tmp = window.unescape(result);
				if ( tmp === result ) {
					break;
				}
				result = tmp;
			}

			// Return result
			return result;
		};

		/**
		 * History.unescapeHash()
		 * normalize and Unescape a Hash
		 * @param {String} hash
		 * @return {string}
		 */
		History.unescapeHash = function(hash){
			// Prepare
			var result = History.normalizeHash(hash);

			// Unescape hash
			result = History.unescapeString(result);

			// Return result
			return result;
		};

		/**
		 * History.normalizeHash()
		 * normalize a hash across browsers
		 * @return {string}
		 */
		History.normalizeHash = function(hash){
			// Prepare
			var result = hash.replace(/[^#]*#/,'').replace(/#.*/, '');

			// Return result
			return result;
		};

		/**
		 * History.setHash(hash)
		 * Sets the document hash
		 * @param {string} hash
		 * @return {History}
		 */
		History.setHash = function(hash,queue){
			// Prepare
			var adjustedHash, State, pageUrl;

			// Handle Queueing
			if ( queue !== false && History.busy() ) {
				// Wait + Push to Queue
				//History.debug('History.setHash: we must wait', arguments);
				History.pushQueue({
					scope: History,
					callback: History.setHash,
					args: arguments,
					queue: queue
				});
				return false;
			}

			// Log
			//History.debug('History.setHash: called',hash);

			// Prepare
			adjustedHash = History.escapeHash(hash);

			// Make Busy + Continue
			History.busy(true);

			// Check if hash is a state
			State = History.extractState(hash,true);
			if ( State && !History.emulated.pushState ) {
				// Hash is a state so skip the setHash
				//History.debug('History.setHash: Hash is a state so skipping the hash set with a direct pushState call',arguments);

				// PushState
				History.pushState(State.data,State.title,State.url,false);
			}
			else if ( document.location.hash !== adjustedHash ) {
				// Hash is a proper hash, so apply it

				// Handle browser bugs
				if ( History.bugs.setHash ) {
					// Fix Safari Bug https://bugs.webkit.org/show_bug.cgi?id=56249

					// Fetch the base page
					pageUrl = History.getPageUrl();

					// Safari hash apply
					History.pushState(null,null,pageUrl+'#'+adjustedHash,false);
				}
				else {
					// Normal hash apply
					document.location.hash = adjustedHash;
				}
			}

			// Chain
			return History;
		};

		/**
		 * History.escape()
		 * normalize and Escape a Hash
		 * @return {string}
		 */
		History.escapeHash = function(hash){
			// Prepare
			var result = History.normalizeHash(hash);

			// Escape hash
			result = window.escape(result);

			// IE6 Escape Bug
			if ( !History.bugs.hashEscape ) {
				// Restore common parts
				result = result
					.replace(/\%21/g,'!')
					.replace(/\%26/g,'&')
					.replace(/\%3D/g,'=')
					.replace(/\%3F/g,'?');
			}

			// Return result
			return result;
		};

		/**
		 * History.getHashByUrl(url)
		 * Extracts the Hash from a URL
		 * @param {string} url
		 * @return {string} url
		 */
		History.getHashByUrl = function(url){
			// Extract the hash
			var hash = String(url)
				.replace(/([^#]*)#?([^#]*)#?(.*)/, '$2')
				;

			// Unescape hash
			hash = History.unescapeHash(hash);

			// Return hash
			return hash;
		};

		/**
		 * History.setTitle(title)
		 * Applies the title to the document
		 * @param {State} newState
		 * @return {Boolean}
		 */
		History.setTitle = function(newState){
			// Prepare
			var title = newState.title,
				firstState;

			// Initial
			if ( !title ) {
				firstState = History.getStateByIndex(0);
				if ( firstState && firstState.url === newState.url ) {
					title = firstState.title||History.options.initialTitle;
				}
			}

			// Apply
			try {
				document.getElementsByTagName('title')[0].innerHTML = title.replace('<','&lt;').replace('>','&gt;').replace(' & ',' &amp; ');
			}
			catch ( Exception ) { }
			document.title = title;

			// Chain
			return History;
		};


		// ====================================================================
		// Queueing

		/**
		 * History.queues
		 * The list of queues to use
		 * First In, First Out
		 */
		History.queues = [];

		/**
		 * History.busy(value)
		 * @param {boolean} value [optional]
		 * @return {boolean} busy
		 */
		History.busy = function(value){
			// Apply
			if ( typeof value !== 'undefined' ) {
				//History.debug('History.busy: changing ['+(History.busy.flag||false)+'] to ['+(value||false)+']', History.queues.length);
				History.busy.flag = value;
			}
			// Default
			else if ( typeof History.busy.flag === 'undefined' ) {
				History.busy.flag = false;
			}

			// Queue
			if ( !History.busy.flag ) {
				// Execute the next item in the queue
				clearTimeout(History.busy.timeout);
				var fireNext = function(){
					var i, queue, item;
					if ( History.busy.flag ) return;
					for ( i=History.queues.length-1; i >= 0; --i ) {
						queue = History.queues[i];
						if ( queue.length === 0 ) continue;
						item = queue.shift();
						History.fireQueueItem(item);
						History.busy.timeout = setTimeout(fireNext,History.options.busyDelay);
					}
				};
				History.busy.timeout = setTimeout(fireNext,History.options.busyDelay);
			}

			// Return
			return History.busy.flag;
		};

		/**
		 * History.busy.flag
		 */
		History.busy.flag = false;

		/**
		 * History.fireQueueItem(item)
		 * Fire a Queue Item
		 * @param {Object} item
		 * @return {Mixed} result
		 */
		History.fireQueueItem = function(item){
			return item.callback.apply(item.scope||History,item.args||[]);
		};

		/**
		 * History.pushQueue(callback,args)
		 * Add an item to the queue
		 * @param {Object} item [scope,callback,args,queue]
		 */
		History.pushQueue = function(item){
			// Prepare the queue
			History.queues[item.queue||0] = History.queues[item.queue||0]||[];

			// Add to the queue
			History.queues[item.queue||0].push(item);

			// Chain
			return History;
		};

		/**
		 * History.queue (item,queue), (func,queue), (func), (item)
		 * Either firs the item now if not busy, or adds it to the queue
		 */
		History.queue = function(item,queue){
			// Prepare
			if ( typeof item === 'function' ) {
				item = {
					callback: item
				};
			}
			if ( typeof queue !== 'undefined' ) {
				item.queue = queue;
			}

			// Handle
			if ( History.busy() ) {
				History.pushQueue(item);
			} else {
				History.fireQueueItem(item);
			}

			// Chain
			return History;
		};

		/**
		 * History.clearQueue()
		 * Clears the Queue
		 */
		History.clearQueue = function(){
			History.busy.flag = false;
			History.queues = [];
			return History;
		};


		// ====================================================================
		// IE Bug Fix

		/**
		 * History.stateChanged
		 * States whether or not the state has changed since the last double check was initialised
		 */
		History.stateChanged = false;

		/**
		 * History.doubleChecker
		 * Contains the timeout used for the double checks
		 */
		History.doubleChecker = false;

		/**
		 * History.doubleCheckComplete()
		 * Complete a double check
		 * @return {History}
		 */
		History.doubleCheckComplete = function(){
			// Update
			History.stateChanged = true;

			// Clear
			History.doubleCheckClear();

			// Chain
			return History;
		};

		/**
		 * History.doubleCheckClear()
		 * Clear a double check
		 * @return {History}
		 */
		History.doubleCheckClear = function(){
			// Clear
			if ( History.doubleChecker ) {
				clearTimeout(History.doubleChecker);
				History.doubleChecker = false;
			}

			// Chain
			return History;
		};

		/**
		 * History.doubleCheck()
		 * Create a double check
		 * @return {History}
		 */
		History.doubleCheck = function(tryAgain){
			// Reset
			History.stateChanged = false;
			History.doubleCheckClear();

			// Fix IE6,IE7 bug where calling history.back or history.forward does not actually change the hash (whereas doing it manually does)
			// Fix Safari 5 bug where sometimes the state does not change: https://bugs.webkit.org/show_bug.cgi?id=42940
			if ( History.bugs.ieDoubleCheck ) {
				// Apply Check
				History.doubleChecker = setTimeout(
					function(){
						History.doubleCheckClear();
						if ( !History.stateChanged ) {
							//History.debug('History.doubleCheck: State has not yet changed, trying again', arguments);
							// Re-Attempt
							tryAgain();
						}
						return true;
					},
					History.options.doubleCheckInterval
				);
			}

			// Chain
			return History;
		};


		// ====================================================================
		// Safari Bug Fix

		/**
		 * History.safariStatePoll()
		 * Poll the current state
		 * @return {History}
		 */
		History.safariStatePoll = function(){
			// Poll the URL

			// Get the Last State which has the new URL
			var
				urlState = History.extractState(document.location.href),
				newState;

			// Check for a difference
			if ( !History.isLastSavedState(urlState) ) {
				newState = urlState;
			}
			else {
				return;
			}

			// Check if we have a state with that url
			// If not create it
			if ( !newState ) {
				//History.debug('History.safariStatePoll: new');
				newState = History.createStateObject();
			}

			// Apply the New State
			//History.debug('History.safariStatePoll: trigger');
			History.Adapter.trigger(window,'popstate');

			// Chain
			return History;
		};


		// ====================================================================
		// State Aliases

		/**
		 * History.back(queue)
		 * Send the browser history back one item
		 * @param {Integer} queue [optional]
		 */
		History.back = function(queue){
			//History.debug('History.back: called', arguments);

			// Handle Queueing
			if ( queue !== false && History.busy() ) {
				// Wait + Push to Queue
				//History.debug('History.back: we must wait', arguments);
				History.pushQueue({
					scope: History,
					callback: History.back,
					args: arguments,
					queue: queue
				});
				return false;
			}

			// Make Busy + Continue
			History.busy(true);

			// Fix certain browser bugs that prevent the state from changing
			History.doubleCheck(function(){
				History.back(false);
			});

			// Go back
			history.go(-1);

			// End back closure
			return true;
		};

		/**
		 * History.forward(queue)
		 * Send the browser history forward one item
		 * @param {Integer} queue [optional]
		 */
		History.forward = function(queue){
			//History.debug('History.forward: called', arguments);

			// Handle Queueing
			if ( queue !== false && History.busy() ) {
				// Wait + Push to Queue
				//History.debug('History.forward: we must wait', arguments);
				History.pushQueue({
					scope: History,
					callback: History.forward,
					args: arguments,
					queue: queue
				});
				return false;
			}

			// Make Busy + Continue
			History.busy(true);

			// Fix certain browser bugs that prevent the state from changing
			History.doubleCheck(function(){
				History.forward(false);
			});

			// Go forward
			history.go(1);

			// End forward closure
			return true;
		};

		/**
		 * History.go(index,queue)
		 * Send the browser history back or forward index times
		 * @param {Integer} queue [optional]
		 */
		History.go = function(index,queue){
			//History.debug('History.go: called', arguments);

			// Prepare
			var i;

			// Handle
			if ( index > 0 ) {
				// Forward
				for ( i=1; i<=index; ++i ) {
					History.forward(queue);
				}
			}
			else if ( index < 0 ) {
				// Backward
				for ( i=-1; i>=index; --i ) {
					History.back(queue);
				}
			}
			else {
				throw new Error('History.go: History.go requires a positive or negative integer passed.');
			}

			// Chain
			return History;
		};


		// ====================================================================
		// HTML5 State Support

		// Non-Native pushState Implementation
		if ( History.emulated.pushState ) {
			/*
			 * Provide Skeleton for HTML4 Browsers
			 */

			// Prepare
			var emptyFunction = function(){};
			History.pushState = History.pushState||emptyFunction;
			History.replaceState = History.replaceState||emptyFunction;
		} // History.emulated.pushState

		// Native pushState Implementation
		else {
			/*
			 * Use native HTML5 History API Implementation
			 */

			/**
			 * History.onPopState(event,extra)
			 * Refresh the Current State
			 */
			History.onPopState = function(event,extra){
				// Prepare
				var stateId = false, newState = false, currentHash, currentState;

				// Reset the double check
				History.doubleCheckComplete();

				// Check for a Hash, and handle apporiatly
				currentHash	= History.getHash();
				if ( currentHash ) {
					// Expand Hash
					currentState = History.extractState(currentHash||document.location.href,true);
					if ( currentState ) {
						// We were able to parse it, it must be a State!
						// Let's forward to replaceState
						//History.debug('History.onPopState: state anchor', currentHash, currentState);
						History.replaceState(currentState.data, currentState.title, currentState.url, false);
					}
					else {
						// Traditional Anchor
						//History.debug('History.onPopState: traditional anchor', currentHash);
						History.Adapter.trigger(window,'anchorchange');
						History.busy(false);
					}

					// We don't care for hashes
					History.expectedStateId = false;
					return false;
				}

				// Ensure
				stateId = History.Adapter.extractEventData('state',event,extra) || false;

				// Fetch State
				if ( stateId ) {
					// Vanilla: Back/forward button was used
					newState = History.getStateById(stateId);
				}
				else if ( History.expectedStateId ) {
					// Vanilla: A new state was pushed, and popstate was called manually
					newState = History.getStateById(History.expectedStateId);
				}
				else {
					// Initial State
					newState = History.extractState(document.location.href);
				}

				// The State did not exist in our store
				if ( !newState ) {
					// Regenerate the State
					newState = History.createStateObject(null,null,document.location.href);
				}

				// Clean
				History.expectedStateId = false;

				// Check if we are the same state
				if ( History.isLastSavedState(newState) ) {
					// There has been no change (just the page's hash has finally propagated)
					//History.debug('History.onPopState: no change', newState, History.savedStates);
					History.busy(false);
					return false;
				}

				// Store the State
				History.storeState(newState);
				History.saveState(newState);

				// Force update of the title
				History.setTitle(newState);

				// Fire Our Event
				History.Adapter.trigger(window,'statechange');
				History.busy(false);

				// Return true
				return true;
			};
			History.Adapter.bind(window,'popstate',History.onPopState);

			/**
			 * History.pushState(data,title,url)
			 * Add a new State to the history object, become it, and trigger onpopstate
			 * We have to trigger for HTML4 compatibility
			 * @param {object} data
			 * @param {string} title
			 * @param {string} url
			 * @return {true}
			 */
			History.pushState = function(data,title,url,queue){
				//History.debug('History.pushState: called', arguments);

				// Check the State
				if ( History.getHashByUrl(url) && History.emulated.pushState ) {
					throw new Error('History.js does not support states with fragement-identifiers (hashes/anchors).');
				}

				// Handle Queueing
				if ( queue !== false && History.busy() ) {
					// Wait + Push to Queue
					//History.debug('History.pushState: we must wait', arguments);
					History.pushQueue({
						scope: History,
						callback: History.pushState,
						args: arguments,
						queue: queue
					});
					return false;
				}

				// Make Busy + Continue
				History.busy(true);

				// Create the newState
				var newState = History.createStateObject(data,title,url);

				// Check it
				if ( History.isLastSavedState(newState) ) {
					// Won't be a change
					History.busy(false);
				}
				else {
					// Store the newState
					History.storeState(newState);
					History.expectedStateId = newState.id;

					// Push the newState
					history.pushState(newState.id,newState.title,newState.url);

					// Fire HTML5 Event
					History.Adapter.trigger(window,'popstate');
				}

				// End pushState closure
				return true;
			};

			/**
			 * History.replaceState(data,title,url)
			 * Replace the State and trigger onpopstate
			 * We have to trigger for HTML4 compatibility
			 * @param {object} data
			 * @param {string} title
			 * @param {string} url
			 * @return {true}
			 */
			History.replaceState = function(data,title,url,queue){
				//History.debug('History.replaceState: called', arguments);

				// Check the State
				if ( History.getHashByUrl(url) && History.emulated.pushState ) {
					throw new Error('History.js does not support states with fragement-identifiers (hashes/anchors).');
				}

				// Handle Queueing
				if ( queue !== false && History.busy() ) {
					// Wait + Push to Queue
					//History.debug('History.replaceState: we must wait', arguments);
					History.pushQueue({
						scope: History,
						callback: History.replaceState,
						args: arguments,
						queue: queue
					});
					return false;
				}

				// Make Busy + Continue
				History.busy(true);

				// Create the newState
				var newState = History.createStateObject(data,title,url);

				// Check it
				if ( History.isLastSavedState(newState) ) {
					// Won't be a change
					History.busy(false);
				}
				else {
					// Store the newState
					History.storeState(newState);
					History.expectedStateId = newState.id;

					// Push the newState
					history.replaceState(newState.id,newState.title,newState.url);

					// Fire HTML5 Event
					History.Adapter.trigger(window,'popstate');
				}

				// End replaceState closure
				return true;
			};

		} // !History.emulated.pushState


		// ====================================================================
		// Initialise

		/**
		 * Load the Store
		 */
		if ( sessionStorage ) {
			// Fetch
			try {
				History.store = JSON.parse(sessionStorage.getItem('History.store'))||{};
			}
			catch ( err ) {
				History.store = {};
			}

			// Normalize
			History.normalizeStore();
		}
		else {
			// Default Load
			History.store = {};
			History.normalizeStore();
		}

		/**
		 * Clear Intervals on exit to prevent memory leaks
		 */
		History.Adapter.bind(window,"beforeunload",History.clearAllIntervals);
		History.Adapter.bind(window,"unload",History.clearAllIntervals);

		/**
		 * Create the initial State
		 */
		History.saveState(History.storeState(History.extractState(document.location.href,true)));

		/**
		 * Bind for Saving Store
		 */
		if ( sessionStorage ) {
			// When the page is closed
			History.onUnload = function(){
				// Prepare
				var	currentStore, item;

				// Fetch
				try {
					currentStore = JSON.parse(sessionStorage.getItem('History.store'))||{};
				}
				catch ( err ) {
					currentStore = {};
				}

				// Ensure
				currentStore.idToState = currentStore.idToState || {};
				currentStore.urlToId = currentStore.urlToId || {};
				currentStore.stateToId = currentStore.stateToId || {};

				// Sync
				for ( item in History.idToState ) {
					if ( !History.idToState.hasOwnProperty(item) ) {
						continue;
					}
					currentStore.idToState[item] = History.idToState[item];
				}
				for ( item in History.urlToId ) {
					if ( !History.urlToId.hasOwnProperty(item) ) {
						continue;
					}
					currentStore.urlToId[item] = History.urlToId[item];
				}
				for ( item in History.stateToId ) {
					if ( !History.stateToId.hasOwnProperty(item) ) {
						continue;
					}
					currentStore.stateToId[item] = History.stateToId[item];
				}

				// Update
				History.store = currentStore;
				History.normalizeStore();

				// Store
				sessionStorage.setItem('History.store',JSON.stringify(currentStore));
			};

			// For Internet Explorer
			History.intervalList.push(setInterval(History.onUnload,History.options.storeInterval));

			// For Other Browsers
			History.Adapter.bind(window,'beforeunload',History.onUnload);
			History.Adapter.bind(window,'unload',History.onUnload);

			// Both are enabled for consistency
		}

		// Non-Native pushState Implementation
		if ( !History.emulated.pushState ) {
			// Be aware, the following is only for native pushState implementations
			// If you are wanting to include something for all browsers
			// Then include it above this if block

			/**
			 * Setup Safari Fix
			 */
			if ( History.bugs.safariPoll ) {
				History.intervalList.push(setInterval(History.safariStatePoll, History.options.safariPollInterval));
			}

			/**
			 * Ensure Cross Browser Compatibility
			 */
			if ( navigator.vendor === 'Apple Computer, Inc.' || (navigator.appCodeName||'') === 'Mozilla' ) {
				/**
				 * Fix Safari HashChange Issue
				 */

				// Setup Alias
				History.Adapter.bind(window,'hashchange',function(){
					History.Adapter.trigger(window,'popstate');
				});

				// Initialise Alias
				if ( History.getHash() ) {
					History.Adapter.onDomLoad(function(){
						History.Adapter.trigger(window,'hashchange');
					});
				}
			}

		} // !History.emulated.pushState


	}; // History.initCore

	// Try and Initialise History
	History.init();

})(window);
var timestamps = []; // Array of unique timestamps.

$.fn.route = function(options) {

	if (this.is("a")) {

		var customTitle = this.attr('custom-title');
		var title = this.attr('title');

		// Override title
		if (customTitle) {
			title = customTitle;
		}

		if (title) {
			var appendTitle = $.joomla.appendTitle;

			if (appendTitle === "before") {
				title = $.joomla.sitename + ((title) ? " - " + title : "");
			}

			if (appendTitle === "after") {
				title = ((title) ? title + " - " : "") + $.joomla.sitename;
			}
		} else {

			// Try to get the page title from document
			title = $(document).find('title').text();
		}

		// Creating a unique timestamp that will be associated with the state.
		var t = new Date().getTime();
		timestamps[t] = t;

		History.pushState($.extend({timestamp: t, refresh: true}, options), title , this.attr("href"));
	}

	return this;
}

History.Adapter.bind(window,'statechange',function(){

	var state = History.getState();

	// Fixed back button not refreshing when
	// state is in the first state in navigation history.
	if (state.id===History.savedStates[0].id) {
		window.location = state.url;
	}

	if(state.data.timestamp in timestamps) {
		// Deleting the unique timestamp associated with the state
		delete timestamps[state.data.timestamp];
	}
	else{
		if (state.data.refresh) {
			window.location = state.url;
		}
	}
});
};

exports();
module.resolveWith(exports);

// module body: end

};
// module factory: end

FD40.module("history", moduleFactory);

}());
			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var exports = function() { 

/**
* jquery.Image
* Image helper for jQuery.
* https://github.com/jstonne/jquery.Image
*
* Copyright (c) 2012 Jensen Tonne
* www.jstonne.com
*
* Dual licensed under the MIT and GPL licenses:
* http://www.opensource.org/licenses/mit-license.php
* http://www.gnu.org/licenses/gpl.html
*
*/

$.fn.image = function(method) {
	var method = $.Image[method];
	return method && method.apply(this[0], $.makeArray(arguments).slice(1));
}

$.Image = {

	get: function(url) {

		var existingImage = this.nodeName==="IMG";

		var image = $(existingImage ? this : new Image()),
			imageLoader = $.Deferred();

		image
			.load(function() {

				var w, h, r, o;

				if (!existingImage) { image.appendTo("body"); }

				var data = {
					width: w = image.width(),
					height: h = image.height(),
					aspectRatio: r = w / h,
					orientation: o = (r===1) ? "square" : (r<1) ? "tall" : "wide"
				}	

				image
					.css({
						position: "absolute",
						left: "-99999px"
					})
					.data(data)
					.addClass("orientation-" + o)
					.removeAttr("style");

				if (!existingImage) {
					image.detach();
				}

				imageLoader.resolve(image, data);
			})
			.error(function(){

				imageLoader.reject();
			})
			.attr("src", url);

		return imageLoader;
	},

	aspectRatio: function(width, height) {

		// Normalize values
		if ($.isPlainObject(width)) {
			width  = width.width;
			height = width.height;
		}

		return width / height;
	},

	orientation: function(width, height) {

		// Normalize values
		if ($.isPlainObject(width)) {
			width  = width.width;
			height = width.height;
		}

		if (width===height) return "square";

		if (width > height) return "wide";

		return "tall";
	},

	resizeProportionate: function(sourceWidth, sourceHeight, maxWidth, maxHeight, mode) {

		var targetWidth = sourceWidth,
			targetHeight = sourceHeight;

		// Resize the width first
		var ratio        = maxWidth / sourceWidth;
			targetWidth  = sourceWidth  * ratio;
			targetHeight = sourceHeight * ratio;


		// inner resize (default)
		var condition = targetHeight > maxHeight;

		// outer resize
		if (mode=="outer") {
			condition = targetHeight < maxHeight;
		}

		if (condition) {
			ratio        = maxHeight / sourceHeight;
			targetWidth  = sourceWidth  * ratio;
			targetHeight = sourceHeight * ratio;
		}

		return {
			top   : (maxHeight - targetHeight) / 2,
			left  : (maxWidth - targetWidth) / 2,
			width : targetWidth,
			height: targetHeight
		};
	},

	resizeWithin: function(sourceWidth, sourceHeight, maxWidth, maxHeight) {

		return $.Image.resizeProportionate(
			sourceWidth,
			sourceHeight,
			maxWidth,
			maxHeight,
			"inner"
		);
	},

	resizeToFill: function(sourceWidth, sourceHeight, maxWidth, maxHeight) {

		return $.Image.resizeProportionate(
			sourceWidth,
			sourceHeight,
			maxWidth,
			maxHeight,
			"outer"
		);
	}
};

}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("image", moduleFactory);

}());			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this;
var jQuery = $;
var exports = function() {

/* @preserve
 * Leaflet 1.4.0+Detached: 3337f36d2a2d2b33946779057619b31f674ff5dc.3337f36, a JS library for interactive maps. http://leafletjs.com
 * (c) 2010-2018 Vladimir Agafonkin, (c) 2010-2011 CloudMade
 */

(function (root, factory) {
	if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['leaflet'], factory);
	} else if (typeof modules === 'object' && module.exports) {
		// define a Common JS module that relies on 'leaflet'
		module.exports = factory(require('leaflet'));
	} else {
		// Assume Leaflet is loaded into global object L already
		factory(L);
	}
}(this, function (L) {
	'use strict';

	L.TileLayer.Provider = L.TileLayer.extend({
		initialize: function (arg, options) {
			var providers = L.TileLayer.Provider.providers;

			var parts = arg.split('.');

			var providerName = parts[0];
			var variantName = parts[1];

			if (!providers[providerName]) {
				throw 'No such provider (' + providerName + ')';
			}

			var provider = {
				url: providers[providerName].url,
				options: providers[providerName].options
			};

			// overwrite values in provider from variant.
			if (variantName && 'variants' in providers[providerName]) {
				if (!(variantName in providers[providerName].variants)) {
					throw 'No such variant of ' + providerName + ' (' + variantName + ')';
				}
				var variant = providers[providerName].variants[variantName];
				var variantOptions;
				if (typeof variant === 'string') {
					variantOptions = {
						variant: variant
					};
				} else {
					variantOptions = variant.options;
				}
				provider = {
					url: variant.url || provider.url,
					options: L.Util.extend({}, provider.options, variantOptions)
				};
			}

			// replace attribution placeholders with their values from toplevel provider attribution,
			// recursively
			var attributionReplacer = function (attr) {
				if (attr.indexOf('{attribution.') === -1) {
					return attr;
				}
				return attr.replace(/\{attribution.(\w*)\}/,
					function (match, attributionName) {
						return attributionReplacer(providers[attributionName].options.attribution);
					}
				);
			};
			provider.options.attribution = attributionReplacer(provider.options.attribution);

			// Compute final options combining provider options with any user overrides
			var layerOpts = L.Util.extend({}, provider.options, options);
			L.TileLayer.prototype.initialize.call(this, provider.url, layerOpts);
		}
	});

	/**
	 * Definition of providers.
	 * see http://leafletjs.com/reference.html#tilelayer for options in the options map.
	 */

	L.TileLayer.Provider.providers = {
		OpenStreetMap: {
			url: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
			options: {
				maxZoom: 19,
				attribution:
					'&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
			},
			variants: {
				Mapnik: {},
				BlackAndWhite: {
					url: 'https://tiles.wmflabs.org/bw-mapnik/{z}/{x}/{y}.png',
					options: {
						maxZoom: 18
					}
				},
				DE: {
					url: 'https://{s}.tile.openstreetmap.de/tiles/osmde/{z}/{x}/{y}.png',
					options: {
						maxZoom: 18
					}
				},
				CH: {
					url: 'https://tile.osm.ch/switzerland/{z}/{x}/{y}.png',
					options: {
						maxZoom: 18,
						bounds: [[45, 5], [48, 11]]
					}
				},
				France: {
					url: 'https://{s}.tile.openstreetmap.fr/osmfr/{z}/{x}/{y}.png',
					options: {
						maxZoom: 20,
						attribution: '&copy; Openstreetmap France | {attribution.OpenStreetMap}'
					}
				},
				HOT: {
					url: 'https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png',
					options: {
						attribution:
							'{attribution.OpenStreetMap}, ' +
							'Tiles style by <a href="https://www.hotosm.org/" target="_blank">Humanitarian OpenStreetMap Team</a> ' +
							'hosted by <a href="https://openstreetmap.fr/" target="_blank">OpenStreetMap France</a>'
					}
				},
				BZH: {
					url: 'https://tile.openstreetmap.bzh/br/{z}/{x}/{y}.png',
					options: {
						attribution: '{attribution.OpenStreetMap}, Tiles courtesy of <a href="http://www.openstreetmap.bzh/" target="_blank">Breton OpenStreetMap Team</a>',
						bounds: [[46.2, -5.5], [50, 0.7]]
					}
				}
			}
		},
		OpenSeaMap: {
			url: 'https://tiles.openseamap.org/seamark/{z}/{x}/{y}.png',
			options: {
				attribution: 'Map data: &copy; <a href="http://www.openseamap.org">OpenSeaMap</a> contributors'
			}
		},
		OpenPtMap: {
			url: 'http://openptmap.org/tiles/{z}/{x}/{y}.png',
			options: {
				maxZoom: 17,
				attribution: 'Map data: &copy; <a href="http://www.openptmap.org">OpenPtMap</a> contributors'
			}
		},
		OpenTopoMap: {
			url: 'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',
			options: {
				maxZoom: 17,
				attribution: 'Map data: {attribution.OpenStreetMap}, <a href="http://viewfinderpanoramas.org">SRTM</a> | Map style: &copy; <a href="https://opentopomap.org">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
			}
		},
		OpenRailwayMap: {
			url: 'https://{s}.tiles.openrailwaymap.org/standard/{z}/{x}/{y}.png',
			options: {
				maxZoom: 19,
				attribution: 'Map data: {attribution.OpenStreetMap} | Map style: &copy; <a href="https://www.OpenRailwayMap.org">OpenRailwayMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
			}
		},
		OpenFireMap: {
			url: 'http://openfiremap.org/hytiles/{z}/{x}/{y}.png',
			options: {
				maxZoom: 19,
				attribution: 'Map data: {attribution.OpenStreetMap} | Map style: &copy; <a href="http://www.openfiremap.org">OpenFireMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
			}
		},
		SafeCast: {
			url: 'https://s3.amazonaws.com/te512.safecast.org/{z}/{x}/{y}.png',
			options: {
				maxZoom: 16,
				attribution: 'Map data: {attribution.OpenStreetMap} | Map style: &copy; <a href="https://blog.safecast.org/about/">SafeCast</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
			}
		},
		Thunderforest: {
			url: 'https://{s}.tile.thunderforest.com/{variant}/{z}/{x}/{y}.png?apikey={apikey}',
			options: {
				attribution:
					'&copy; <a href="http://www.thunderforest.com/">Thunderforest</a>, {attribution.OpenStreetMap}',
				variant: 'cycle',
				apikey: '<insert your api key here>',
				maxZoom: 22
			},
			variants: {
				OpenCycleMap: 'cycle',
				Transport: {
					options: {
						variant: 'transport'
					}
				},
				TransportDark: {
					options: {
						variant: 'transport-dark'
					}
				},
				SpinalMap: {
					options: {
						variant: 'spinal-map'
					}
				},
				Landscape: 'landscape',
				Outdoors: 'outdoors',
				Pioneer: 'pioneer'
			}
		},
		OpenMapSurfer: {
			url: 'https://maps.heigit.org/openmapsurfer/tiles/{variant}/webmercator/{z}/{x}/{y}.png',
			options: {
				maxZoom: 19,
				variant: 'roads',
				attribution: 'Imagery from <a href="http://giscience.uni-hd.de/">GIScience Research Group @ University of Heidelberg</a> &mdash; Map data {attribution.OpenStreetMap}'
			},
			variants: {
				Roads: 'roads',
				AdminBounds: {
					options: {
						variant: 'adminb',
						maxZoom: 18
					}
				}
			}
		},
		Hydda: {
			url: 'https://{s}.tile.openstreetmap.se/hydda/{variant}/{z}/{x}/{y}.png',
			options: {
				maxZoom: 18,
				variant: 'full',
				attribution: 'Tiles courtesy of <a href="http://openstreetmap.se/" target="_blank">OpenStreetMap Sweden</a> &mdash; Map data {attribution.OpenStreetMap}'
			},
			variants: {
				Full: 'full',
				Base: 'base',
				RoadsAndLabels: 'roads_and_labels'
			}
		},
		MapBox: {
			url: 'https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}{r}.png?access_token={accessToken}',
			options: {
				attribution:
					'<a href="https://www.mapbox.com/about/maps/" target="_blank">&copy; Mapbox</a> ' +
					'{attribution.OpenStreetMap} ' +
					'<a href="https://www.mapbox.com/map-feedback/" target="_blank">Improve this map</a>',
				subdomains: 'abcd',
				id: 'mapbox.streets',
				accessToken: '<insert your access token here>',
			}
		},
		Stamen: {
			url: 'https://stamen-tiles-{s}.a.ssl.fastly.net/{variant}/{z}/{x}/{y}{r}.{ext}',
			options: {
				attribution:
					'Map tiles by <a href="http://stamen.com">Stamen Design</a>, ' +
					'<a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a> &mdash; ' +
					'Map data {attribution.OpenStreetMap}',
				subdomains: 'abcd',
				minZoom: 0,
				maxZoom: 20,
				variant: 'toner',
				ext: 'png'
			},
			variants: {
				Toner: 'toner',
				TonerBackground: 'toner-background',
				TonerHybrid: 'toner-hybrid',
				TonerLines: 'toner-lines',
				TonerLabels: 'toner-labels',
				TonerLite: 'toner-lite',
				Watercolor: {
					url: 'https://stamen-tiles-{s}.a.ssl.fastly.net/{variant}/{z}/{x}/{y}.{ext}',
					options: {
						variant: 'watercolor',
						ext: 'jpg',
						minZoom: 1,
						maxZoom: 16
					}
				},
				Terrain: {
					options: {
						variant: 'terrain',
						minZoom: 0,
						maxZoom: 18
					}
				},
				TerrainBackground: {
					options: {
						variant: 'terrain-background',
						minZoom: 0,
						maxZoom: 18
					}
				},
				TopOSMRelief: {
					url: 'https://stamen-tiles-{s}.a.ssl.fastly.net/{variant}/{z}/{x}/{y}.{ext}',
					options: {
						variant: 'toposm-color-relief',
						ext: 'jpg',
						bounds: [[22, -132], [51, -56]]
					}
				},
				TopOSMFeatures: {
					options: {
						variant: 'toposm-features',
						bounds: [[22, -132], [51, -56]],
						opacity: 0.9
					}
				}
			}
		},
		Esri: {
			url: 'https://server.arcgisonline.com/ArcGIS/rest/services/{variant}/MapServer/tile/{z}/{y}/{x}',
			options: {
				variant: 'World_Street_Map',
				attribution: 'Tiles &copy; Esri'
			},
			variants: {
				WorldStreetMap: {
					options: {
						attribution:
							'{attribution.Esri} &mdash; ' +
							'Source: Esri, DeLorme, NAVTEQ, USGS, Intermap, iPC, NRCAN, Esri Japan, METI, Esri China (Hong Kong), Esri (Thailand), TomTom, 2012'
					}
				},
				DeLorme: {
					options: {
						variant: 'Specialty/DeLorme_World_Base_Map',
						minZoom: 1,
						maxZoom: 11,
						attribution: '{attribution.Esri} &mdash; Copyright: &copy;2012 DeLorme'
					}
				},
				WorldTopoMap: {
					options: {
						variant: 'World_Topo_Map',
						attribution:
							'{attribution.Esri} &mdash; ' +
							'Esri, DeLorme, NAVTEQ, TomTom, Intermap, iPC, USGS, FAO, NPS, NRCAN, GeoBase, Kadaster NL, Ordnance Survey, Esri Japan, METI, Esri China (Hong Kong), and the GIS User Community'
					}
				},
				WorldImagery: {
					options: {
						variant: 'World_Imagery',
						attribution:
							'{attribution.Esri} &mdash; ' +
							'Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
					}
				},
				WorldTerrain: {
					options: {
						variant: 'World_Terrain_Base',
						maxZoom: 13,
						attribution:
							'{attribution.Esri} &mdash; ' +
							'Source: USGS, Esri, TANA, DeLorme, and NPS'
					}
				},
				WorldShadedRelief: {
					options: {
						variant: 'World_Shaded_Relief',
						maxZoom: 13,
						attribution: '{attribution.Esri} &mdash; Source: Esri'
					}
				},
				WorldPhysical: {
					options: {
						variant: 'World_Physical_Map',
						maxZoom: 8,
						attribution: '{attribution.Esri} &mdash; Source: US National Park Service'
					}
				},
				OceanBasemap: {
					options: {
						variant: 'Ocean_Basemap',
						maxZoom: 13,
						attribution: '{attribution.Esri} &mdash; Sources: GEBCO, NOAA, CHS, OSU, UNH, CSUMB, National Geographic, DeLorme, NAVTEQ, and Esri'
					}
				},
				NatGeoWorldMap: {
					options: {
						variant: 'NatGeo_World_Map',
						maxZoom: 16,
						attribution: '{attribution.Esri} &mdash; National Geographic, Esri, DeLorme, NAVTEQ, UNEP-WCMC, USGS, NASA, ESA, METI, NRCAN, GEBCO, NOAA, iPC'
					}
				},
				WorldGrayCanvas: {
					options: {
						variant: 'Canvas/World_Light_Gray_Base',
						maxZoom: 16,
						attribution: '{attribution.Esri} &mdash; Esri, DeLorme, NAVTEQ'
					}
				}
			}
		},
		OpenWeatherMap: {
			url: 'http://{s}.tile.openweathermap.org/map/{variant}/{z}/{x}/{y}.png?appid={apiKey}',
			options: {
				maxZoom: 19,
				attribution: 'Map data &copy; <a href="http://openweathermap.org">OpenWeatherMap</a>',
				apiKey:'<insert your api key here>',
				opacity: 0.5
			},
			variants: {
				Clouds: 'clouds',
				CloudsClassic: 'clouds_cls',
				Precipitation: 'precipitation',
				PrecipitationClassic: 'precipitation_cls',
				Rain: 'rain',
				RainClassic: 'rain_cls',
				Pressure: 'pressure',
				PressureContour: 'pressure_cntr',
				Wind: 'wind',
				Temperature: 'temp',
				Snow: 'snow'
			}
		},
		HERE: {
			/*
			 * HERE maps, formerly Nokia maps.
			 * These basemaps are free, but you need an API key. Please sign up at
			 * https://developer.here.com/plans
			 */
			url:
				'https://{s}.{base}.maps.api.here.com/maptile/2.1/' +
				'{type}/{mapID}/{variant}/{z}/{x}/{y}/{size}/{format}?' +
				'app_id={app_id}&app_code={app_code}&lg={language}',
			options: {
				attribution:
					'Map &copy; 1987-' + new Date().getFullYear() + ' <a href="http://developer.here.com">HERE</a>',
				subdomains: '1234',
				mapID: 'newest',
				'app_id': '<insert your app_id here>',
				'app_code': '<insert your app_code here>',
				base: 'base',
				variant: 'normal.day',
				maxZoom: 20,
				type: 'maptile',
				language: 'eng',
				format: 'png8',
				size: '256'
			},
			variants: {
				normalDay: 'normal.day',
				normalDayCustom: 'normal.day.custom',
				normalDayGrey: 'normal.day.grey',
				normalDayMobile: 'normal.day.mobile',
				normalDayGreyMobile: 'normal.day.grey.mobile',
				normalDayTransit: 'normal.day.transit',
				normalDayTransitMobile: 'normal.day.transit.mobile',
				normalNight: 'normal.night',
				normalNightMobile: 'normal.night.mobile',
				normalNightGrey: 'normal.night.grey',
				normalNightGreyMobile: 'normal.night.grey.mobile',
				normalNightTransit: 'normal.night.transit',
				normalNightTransitMobile: 'normal.night.transit.mobile',
				reducedDay: 'reduced.day',
				reducedNight: 'reduced.night',
				basicMap: {
					options: {
						type: 'basetile'
					}
				},
				mapLabels: {
					options: {
						type: 'labeltile',
						format: 'png'
					}
				},
				trafficFlow: {
					options: {
						base: 'traffic',
						type: 'flowtile'
					}
				},
				carnavDayGrey: 'carnav.day.grey',
				hybridDay: {
					options: {
						base: 'aerial',
						variant: 'hybrid.day'
					}
				},
				hybridDayMobile: {
					options: {
						base: 'aerial',
						variant: 'hybrid.day.mobile'
					}
				},
				hybridDayTransit: {
					options: {
						base: 'aerial',
						variant: 'hybrid.day.transit'
					}
				},
				hybridDayGrey: {
					options: {
						base: 'aerial',
						variant: 'hybrid.grey.day'
					}
				},
				pedestrianDay: 'pedestrian.day',
				pedestrianNight: 'pedestrian.night',
				satelliteDay: {
					options: {
						base: 'aerial',
						variant: 'satellite.day'
					}
				},
				terrainDay: {
					options: {
						base: 'aerial',
						variant: 'terrain.day'
					}
				},
				terrainDayMobile: {
					options: {
						base: 'aerial',
						variant: 'terrain.day.mobile'
					}
				}
			}
		},
		FreeMapSK: {
			url: 'http://t{s}.freemap.sk/T/{z}/{x}/{y}.jpeg',
			options: {
				minZoom: 8,
				maxZoom: 16,
				subdomains: '1234',
				bounds: [[47.204642, 15.996093], [49.830896, 22.576904]],
				attribution:
					'{attribution.OpenStreetMap}, vizualization CC-By-SA 2.0 <a href="http://freemap.sk">Freemap.sk</a>'
			}
		},
		MtbMap: {
			url: 'http://tile.mtbmap.cz/mtbmap_tiles/{z}/{x}/{y}.png',
			options: {
				attribution:
					'{attribution.OpenStreetMap} &amp; USGS'
			}
		},
		CartoDB: {
			url: 'https://{s}.basemaps.cartocdn.com/{variant}/{z}/{x}/{y}{r}.png',
			options: {
				attribution: '{attribution.OpenStreetMap} &copy; <a href="https://carto.com/attributions">CARTO</a>',
				subdomains: 'abcd',
				maxZoom: 19,
				variant: 'light_all'
			},
			variants: {
				Positron: 'light_all',
				PositronNoLabels: 'light_nolabels',
				PositronOnlyLabels: 'light_only_labels',
				DarkMatter: 'dark_all',
				DarkMatterNoLabels: 'dark_nolabels',
				DarkMatterOnlyLabels: 'dark_only_labels',
				Voyager: 'rastertiles/voyager',
				VoyagerNoLabels: 'rastertiles/voyager_nolabels',
				VoyagerOnlyLabels: 'rastertiles/voyager_only_labels',
				VoyagerLabelsUnder: 'rastertiles/voyager_labels_under'
			}
		},
		HikeBike: {
			url: 'https://tiles.wmflabs.org/{variant}/{z}/{x}/{y}.png',
			options: {
				maxZoom: 19,
				attribution: '{attribution.OpenStreetMap}',
				variant: 'hikebike'
			},
			variants: {
				HikeBike: {},
				HillShading: {
					options: {
						maxZoom: 15,
						variant: 'hillshading'
					}
				}
			}
		},
		BasemapAT: {
			url: 'https://maps{s}.wien.gv.at/basemap/{variant}/normal/google3857/{z}/{y}/{x}.{format}',
			options: {
				maxZoom: 19,
				attribution: 'Datenquelle: <a href="https://www.basemap.at">basemap.at</a>',
				subdomains: ['', '1', '2', '3', '4'],
				format: 'png',
				bounds: [[46.358770, 8.782379], [49.037872, 17.189532]],
				variant: 'geolandbasemap'
			},
			variants: {
				basemap: {
					options: {
						maxZoom: 20, // currently only in Vienna
						variant: 'geolandbasemap'
					}
				},
				grau: 'bmapgrau',
				overlay: 'bmapoverlay',
				highdpi: {
					options: {
						variant: 'bmaphidpi',
						format: 'jpeg'
					}
				},
				orthofoto: {
					options: {
						maxZoom: 20, // currently only in Vienna
						variant: 'bmaporthofoto30cm',
						format: 'jpeg'
					}
				}
			}
		},
		nlmaps: {
			url: 'https://geodata.nationaalgeoregister.nl/tiles/service/wmts/{variant}/EPSG:3857/{z}/{x}/{y}.png',
			options: {
				minZoom: 6,
				maxZoom: 19,
				bounds: [[50.5, 3.25], [54, 7.6]],
				attribution: 'Kaartgegevens &copy; <a href="kadaster.nl">Kadaster</a>'
			},
			variants: {
				'standaard': 'brtachtergrondkaart',
				'pastel': 'brtachtergrondkaartpastel',
				'grijs': 'brtachtergrondkaartgrijs',
				'luchtfoto': {
					'url': 'https://geodata.nationaalgeoregister.nl/luchtfoto/rgb/wmts/1.0.0/2016_ortho25/EPSG:3857/{z}/{x}/{y}.png',
				}
			}
		},
		NASAGIBS: {
			url: 'https://map1.vis.earthdata.nasa.gov/wmts-webmerc/{variant}/default/{time}/{tilematrixset}{maxZoom}/{z}/{y}/{x}.{format}',
			options: {
				attribution:
					'Imagery provided by services from the Global Imagery Browse Services (GIBS), operated by the NASA/GSFC/Earth Science Data and Information System ' +
					'(<a href="https://earthdata.nasa.gov">ESDIS</a>) with funding provided by NASA/HQ.',
				bounds: [[-85.0511287776, -179.999999975], [85.0511287776, 179.999999975]],
				minZoom: 1,
				maxZoom: 9,
				format: 'jpg',
				time: '',
				tilematrixset: 'GoogleMapsCompatible_Level'
			},
			variants: {
				ModisTerraTrueColorCR: 'MODIS_Terra_CorrectedReflectance_TrueColor',
				ModisTerraBands367CR: 'MODIS_Terra_CorrectedReflectance_Bands367',
				ViirsEarthAtNight2012: {
					options: {
						variant: 'VIIRS_CityLights_2012',
						maxZoom: 8
					}
				},
				ModisTerraLSTDay: {
					options: {
						variant: 'MODIS_Terra_Land_Surface_Temp_Day',
						format: 'png',
						maxZoom: 7,
						opacity: 0.75
					}
				},
				ModisTerraSnowCover: {
					options: {
						variant: 'MODIS_Terra_Snow_Cover',
						format: 'png',
						maxZoom: 8,
						opacity: 0.75
					}
				},
				ModisTerraAOD: {
					options: {
						variant: 'MODIS_Terra_Aerosol',
						format: 'png',
						maxZoom: 6,
						opacity: 0.75
					}
				},
				ModisTerraChlorophyll: {
					options: {
						variant: 'MODIS_Terra_Chlorophyll_A',
						format: 'png',
						maxZoom: 7,
						opacity: 0.75
					}
				}
			}
		},
		NLS: {
			// NLS maps are copyright National library of Scotland.
			// http://maps.nls.uk/projects/api/index.html
			// Please contact NLS for anything other than non-commercial low volume usage
			//
			// Map sources: Ordnance Survey 1:1m to 1:63K, 1920s-1940s
			//   z0-9  - 1:1m
			//  z10-11 - quarter inch (1:253440)
			//  z12-18 - one inch (1:63360)
			url: 'https://nls-{s}.tileserver.com/nls/{z}/{x}/{y}.jpg',
			options: {
				attribution: '<a href="http://geo.nls.uk/maps/">National Library of Scotland Historic Maps</a>',
				bounds: [[49.6, -12], [61.7, 3]],
				minZoom: 1,
				maxZoom: 18,
				subdomains: '0123',
			}
		},
		JusticeMap: {
			// Justice Map (http://www.justicemap.org/)
			// Visualize race and income data for your community, county and country.
			// Includes tools for data journalists, bloggers and community activists.
			url: 'http://www.justicemap.org/tile/{size}/{variant}/{z}/{x}/{y}.png',
			options: {
				attribution: '<a href="http://www.justicemap.org/terms.php">Justice Map</a>',
				// one of 'county', 'tract', 'block'
				size: 'county',
				// Bounds for USA, including Alaska and Hawaii
				bounds: [[14, -180], [72, -56]]
			},
			variants: {
				income: 'income',
				americanIndian: 'indian',
				asian: 'asian',
				black: 'black',
				hispanic: 'hispanic',
				multi: 'multi',
				nonWhite: 'nonwhite',
				white: 'white',
				plurality: 'plural'
			}
		},
		Wikimedia: {
			url: 'https://maps.wikimedia.org/osm-intl/{z}/{x}/{y}{r}.png',
			options: {
				attribution: '<a href="https://wikimediafoundation.org/wiki/Maps_Terms_of_Use">Wikimedia</a>',
				minZoom: 1,
				maxZoom: 19
			}
		},
		GeoportailFrance: {
			url: 'https://wxs.ign.fr/{apikey}/geoportail/wmts?REQUEST=GetTile&SERVICE=WMTS&VERSION=1.0.0&STYLE={style}&TILEMATRIXSET=PM&FORMAT={format}&LAYER={variant}&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}',
			options: {
				attribution: '<a target="_blank" href="https://www.geoportail.gouv.fr/">Geoportail France</a>',
				bounds: [[-75, -180], [81, 180]],
				minZoom: 2,
				maxZoom: 18,
				// Get your own geoportail apikey here : http://professionnels.ign.fr/ign/contrats/
				// NB : 'choisirgeoportail' is a demonstration key that comes with no guarantee
				apikey: 'choisirgeoportail',
				format: 'image/jpeg',
				style : 'normal',
				variant: 'GEOGRAPHICALGRIDSYSTEMS.MAPS.SCAN-EXPRESS.STANDARD'
			},
			variants: {
				parcels: {
					options : {
						variant: 'CADASTRALPARCELS.PARCELS',
						maxZoom: 20,
						style : 'bdparcellaire',
						format: 'image/png'
					}
				},
				ignMaps: 'GEOGRAPHICALGRIDSYSTEMS.MAPS',
				maps: 'GEOGRAPHICALGRIDSYSTEMS.MAPS.SCAN-EXPRESS.STANDARD',
				orthos: {
					options: {
						maxZoom: 19,
						variant: 'ORTHOIMAGERY.ORTHOPHOTOS'
					}
				}
			}
		},
		OneMapSG: {
			url: 'https://maps-{s}.onemap.sg/v3/{variant}/{z}/{x}/{y}.png',
			options: {
				variant: 'Default',
				minZoom: 11,
				maxZoom: 18,
				bounds: [[1.56073, 104.11475], [1.16, 103.502]],
				attribution: '<img src="https://docs.onemap.sg/maps/images/oneMap64-01.png" style="height:20px;width:20px;"/> New OneMap | Map data &copy; contributors, <a href="http://SLA.gov.sg">Singapore Land Authority</a>'
			},
			variants: {
				Default: 'Default',
				Night: 'Night',
				Original: 'Original',
				Grey: 'Grey',
				LandLot: 'LandLot'
			}
		}
	};

	L.tileLayer.provider = function (provider, options) {
		return new L.TileLayer.Provider(provider, options);
	};

	return L;
}));

};

exports();
module.resolveWith(exports);
};
// module factory: end

FD40.module("leaflet-providers", moduleFactory);

}());
			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this;
var jQuery = $;
var exports = function() {

/* @preserve
 * Leaflet 1.4.0+Detached: 3337f36d2a2d2b33946779057619b31f674ff5dc.3337f36, a JS library for interactive maps. http://leafletjs.com
 * (c) 2010-2018 Vladimir Agafonkin, (c) 2010-2011 CloudMade
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.L = {})));
}(this, (function (exports) { 'use strict';

var version = "1.4.0+HEAD.3337f36";

/*
 * @namespace Util
 *
 * Various utility functions, used by Leaflet internally.
 */

var freeze = Object.freeze;
Object.freeze = function (obj) { return obj; };

// @function extend(dest: Object, src?: Object): Object
// Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut.
function extend(dest) {
	var i, j, len, src;

	for (j = 1, len = arguments.length; j < len; j++) {
		src = arguments[j];
		for (i in src) {
			dest[i] = src[i];
		}
	}
	return dest;
}

// @function create(proto: Object, properties?: Object): Object
// Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)
var create = Object.create || (function () {
	function F() {}
	return function (proto) {
		F.prototype = proto;
		return new F();
	};
})();

// @function bind(fn: Function, …): Function
// Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
// Has a `L.bind()` shortcut.
function bind(fn, obj) {
	var slice = Array.prototype.slice;

	if (fn.bind) {
		return fn.bind.apply(fn, slice.call(arguments, 1));
	}

	var args = slice.call(arguments, 2);

	return function () {
		return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
	};
}

// @property lastId: Number
// Last unique ID used by [`stamp()`](#util-stamp)
var lastId = 0;

// @function stamp(obj: Object): Number
// Returns the unique ID of an object, assigning it one if it doesn't have it.
function stamp(obj) {
	/*eslint-disable */
	obj._leaflet_id = obj._leaflet_id || ++lastId;
	return obj._leaflet_id;
	/* eslint-enable */
}

// @function throttle(fn: Function, time: Number, context: Object): Function
// Returns a function which executes function `fn` with the given scope `context`
// (so that the `this` keyword refers to `context` inside `fn`'s code). The function
// `fn` will be called no more than one time per given amount of `time`. The arguments
// received by the bound function will be any arguments passed when binding the
// function, followed by any arguments passed when invoking the bound function.
// Has an `L.throttle` shortcut.
function throttle(fn, time, context) {
	var lock, args, wrapperFn, later;

	later = function () {
		// reset lock and call if queued
		lock = false;
		if (args) {
			wrapperFn.apply(context, args);
			args = false;
		}
	};

	wrapperFn = function () {
		if (lock) {
			// called too soon, queue to call later
			args = arguments;

		} else {
			// call and lock until later
			fn.apply(context, arguments);
			setTimeout(later, time);
			lock = true;
		}
	};

	return wrapperFn;
}

// @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number
// Returns the number `num` modulo `range` in such a way so it lies within
// `range[0]` and `range[1]`. The returned value will be always smaller than
// `range[1]` unless `includeMax` is set to `true`.
function wrapNum(x, range, includeMax) {
	var max = range[1],
		min = range[0],
		d = max - min;
	return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
}

// @function falseFn(): Function
// Returns a function which always returns `false`.
function falseFn() { return false; }

// @function formatNum(num: Number, digits?: Number): Number
// Returns the number `num` rounded to `digits` decimals, or to 6 decimals by default.
function formatNum(num, digits) {
	var pow = Math.pow(10, (digits === undefined ? 6 : digits));
	return Math.round(num * pow) / pow;
}

// @function trim(str: String): String
// Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)
function trim(str) {
	return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}

// @function splitWords(str: String): String[]
// Trims and splits the string on whitespace and returns the array of parts.
function splitWords(str) {
	return trim(str).split(/\s+/);
}

// @function setOptions(obj: Object, options: Object): Object
// Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `L.setOptions` shortcut.
function setOptions(obj, options) {
	if (!obj.hasOwnProperty('options')) {
		obj.options = obj.options ? create(obj.options) : {};
	}
	for (var i in options) {
		obj.options[i] = options[i];
	}
	return obj.options;
}

// @function getParamString(obj: Object, existingUrl?: String, uppercase?: Boolean): String
// Converts an object into a parameter URL string, e.g. `{a: "foo", b: "bar"}`
// translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will
// be appended at the end. If `uppercase` is `true`, the parameter names will
// be uppercased (e.g. `'?A=foo&B=bar'`)
function getParamString(obj, existingUrl, uppercase) {
	var params = [];
	for (var i in obj) {
		params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
	}
	return ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');
}

var templateRe = /\{ *([\w_-]+) *\}/g;

// @function template(str: String, data: Object): String
// Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`
// and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string
// `('Hello foo, bar')`. You can also specify functions instead of strings for
// data values — they will be evaluated passing `data` as an argument.
function template(str, data) {
	return str.replace(templateRe, function (str, key) {
		var value = data[key];

		if (value === undefined) {
			throw new Error('No value provided for variable ' + str);

		} else if (typeof value === 'function') {
			value = value(data);
		}
		return value;
	});
}

// @function isArray(obj): Boolean
// Compatibility polyfill for [Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)
var isArray = Array.isArray || function (obj) {
	return (Object.prototype.toString.call(obj) === '[object Array]');
};

// @function indexOf(array: Array, el: Object): Number
// Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)
function indexOf(array, el) {
	for (var i = 0; i < array.length; i++) {
		if (array[i] === el) { return i; }
	}
	return -1;
}

// @property emptyImageUrl: String
// Data URI string containing a base64-encoded empty GIF image.
// Used as a hack to free memory from unused images on WebKit-powered
// mobile devices (by setting image `src` to this string).
var emptyImageUrl = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';

// inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/

function getPrefixed(name) {
	return window['webkit' + name] || window['moz' + name] || window['ms' + name];
}

var lastTime = 0;

// fallback for IE 7-8
function timeoutDefer(fn) {
	var time = +new Date(),
		timeToCall = Math.max(0, 16 - (time - lastTime));

	lastTime = time + timeToCall;
	return window.setTimeout(fn, timeToCall);
}

var requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer;
var cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') ||
		getPrefixed('CancelRequestAnimationFrame') || function (id) { window.clearTimeout(id); };

// @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number
// Schedules `fn` to be executed when the browser repaints. `fn` is bound to
// `context` if given. When `immediate` is set, `fn` is called immediately if
// the browser doesn't have native support for
// [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),
// otherwise it's delayed. Returns a request ID that can be used to cancel the request.
function requestAnimFrame(fn, context, immediate) {
	if (immediate && requestFn === timeoutDefer) {
		fn.call(context);
	} else {
		return requestFn.call(window, bind(fn, context));
	}
}

// @function cancelAnimFrame(id: Number): undefined
// Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).
function cancelAnimFrame(id) {
	if (id) {
		cancelFn.call(window, id);
	}
}


var Util = (Object.freeze || Object)({
	freeze: freeze,
	extend: extend,
	create: create,
	bind: bind,
	lastId: lastId,
	stamp: stamp,
	throttle: throttle,
	wrapNum: wrapNum,
	falseFn: falseFn,
	formatNum: formatNum,
	trim: trim,
	splitWords: splitWords,
	setOptions: setOptions,
	getParamString: getParamString,
	template: template,
	isArray: isArray,
	indexOf: indexOf,
	emptyImageUrl: emptyImageUrl,
	requestFn: requestFn,
	cancelFn: cancelFn,
	requestAnimFrame: requestAnimFrame,
	cancelAnimFrame: cancelAnimFrame
});

// @class Class
// @aka L.Class

// @section
// @uninheritable

// Thanks to John Resig and Dean Edwards for inspiration!

function Class() {}

Class.extend = function (props) {

	// @function extend(props: Object): Function
	// [Extends the current class](#class-inheritance) given the properties to be included.
	// Returns a Javascript function that is a class constructor (to be called with `new`).
	var NewClass = function () {

		// call the constructor
		if (this.initialize) {
			this.initialize.apply(this, arguments);
		}

		// call all constructor hooks
		this.callInitHooks();
	};

	var parentProto = NewClass.__super__ = this.prototype;

	var proto = create(parentProto);
	proto.constructor = NewClass;

	NewClass.prototype = proto;

	// inherit parent's statics
	for (var i in this) {
		if (this.hasOwnProperty(i) && i !== 'prototype' && i !== '__super__') {
			NewClass[i] = this[i];
		}
	}

	// mix static properties into the class
	if (props.statics) {
		extend(NewClass, props.statics);
		delete props.statics;
	}

	// mix includes into the prototype
	if (props.includes) {
		checkDeprecatedMixinEvents(props.includes);
		extend.apply(null, [proto].concat(props.includes));
		delete props.includes;
	}

	// merge options
	if (proto.options) {
		props.options = extend(create(proto.options), props.options);
	}

	// mix given properties into the prototype
	extend(proto, props);

	proto._initHooks = [];

	// add method for calling all hooks
	proto.callInitHooks = function () {

		if (this._initHooksCalled) { return; }

		if (parentProto.callInitHooks) {
			parentProto.callInitHooks.call(this);
		}

		this._initHooksCalled = true;

		for (var i = 0, len = proto._initHooks.length; i < len; i++) {
			proto._initHooks[i].call(this);
		}
	};

	return NewClass;
};


// @function include(properties: Object): this
// [Includes a mixin](#class-includes) into the current class.
Class.include = function (props) {
	extend(this.prototype, props);
	return this;
};

// @function mergeOptions(options: Object): this
// [Merges `options`](#class-options) into the defaults of the class.
Class.mergeOptions = function (options) {
	extend(this.prototype.options, options);
	return this;
};

// @function addInitHook(fn: Function): this
// Adds a [constructor hook](#class-constructor-hooks) to the class.
Class.addInitHook = function (fn) { // (Function) || (String, args...)
	var args = Array.prototype.slice.call(arguments, 1);

	var init = typeof fn === 'function' ? fn : function () {
		this[fn].apply(this, args);
	};

	this.prototype._initHooks = this.prototype._initHooks || [];
	this.prototype._initHooks.push(init);
	return this;
};

function checkDeprecatedMixinEvents(includes) {
	if (typeof L === 'undefined' || !L || !L.Mixin) { return; }

	includes = isArray(includes) ? includes : [includes];

	for (var i = 0; i < includes.length; i++) {
		if (includes[i] === L.Mixin.Events) {
			console.warn('Deprecated include of L.Mixin.Events: ' +
				'this property will be removed in future releases, ' +
				'please inherit from L.Evented instead.', new Error().stack);
		}
	}
}

/*
 * @class Evented
 * @aka L.Evented
 * @inherits Class
 *
 * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).
 *
 * @example
 *
 * ```js
 * map.on('click', function(e) {
 * 	alert(e.latlng);
 * } );
 * ```
 *
 * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:
 *
 * ```js
 * function onClick(e) { ... }
 *
 * map.on('click', onClick);
 * map.off('click', onClick);
 * ```
 */

var Events = {
	/* @method on(type: String, fn: Function, context?: Object): this
	 * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
	 *
	 * @alternative
	 * @method on(eventMap: Object): this
	 * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
	 */
	on: function (types, fn, context) {

		// types can be a map of types/handlers
		if (typeof types === 'object') {
			for (var type in types) {
				// we don't process space-separated events here for performance;
				// it's a hot path since Layer uses the on(obj) syntax
				this._on(type, types[type], fn);
			}

		} else {
			// types can be a string of space-separated words
			types = splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._on(types[i], fn, context);
			}
		}

		return this;
	},

	/* @method off(type: String, fn?: Function, context?: Object): this
	 * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
	 *
	 * @alternative
	 * @method off(eventMap: Object): this
	 * Removes a set of type/listener pairs.
	 *
	 * @alternative
	 * @method off: this
	 * Removes all listeners to all events on the object.
	 */
	off: function (types, fn, context) {

		if (!types) {
			// clear all listeners if called without arguments
			delete this._events;

		} else if (typeof types === 'object') {
			for (var type in types) {
				this._off(type, types[type], fn);
			}

		} else {
			types = splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._off(types[i], fn, context);
			}
		}

		return this;
	},

	// attach listener (without syntactic sugar now)
	_on: function (type, fn, context) {
		this._events = this._events || {};

		/* get/init listeners for type */
		var typeListeners = this._events[type];
		if (!typeListeners) {
			typeListeners = [];
			this._events[type] = typeListeners;
		}

		if (context === this) {
			// Less memory footprint.
			context = undefined;
		}
		var newListener = {fn: fn, ctx: context},
			listeners = typeListeners;

		// check if fn already there
		for (var i = 0, len = listeners.length; i < len; i++) {
			if (listeners[i].fn === fn && listeners[i].ctx === context) {
				return;
			}
		}

		listeners.push(newListener);
	},

	_off: function (type, fn, context) {
		var listeners,
			i,
			len;

		if (!this._events) { return; }

		listeners = this._events[type];

		if (!listeners) {
			return;
		}

		if (!fn) {
			// Set all removed listeners to noop so they are not called if remove happens in fire
			for (i = 0, len = listeners.length; i < len; i++) {
				listeners[i].fn = falseFn;
			}
			// clear all listeners for a type if function isn't specified
			delete this._events[type];
			return;
		}

		if (context === this) {
			context = undefined;
		}

		if (listeners) {

			// find fn and remove it
			for (i = 0, len = listeners.length; i < len; i++) {
				var l = listeners[i];
				if (l.ctx !== context) { continue; }
				if (l.fn === fn) {

					// set the removed listener to noop so that's not called if remove happens in fire
					l.fn = falseFn;

					if (this._firingCount) {
						/* copy array in case events are being fired */
						this._events[type] = listeners = listeners.slice();
					}
					listeners.splice(i, 1);

					return;
				}
			}
		}
	},

	// @method fire(type: String, data?: Object, propagate?: Boolean): this
	// Fires an event of the specified type. You can optionally provide an data
	// object — the first argument of the listener function will contain its
	// properties. The event can optionally be propagated to event parents.
	fire: function (type, data, propagate) {
		if (!this.listens(type, propagate)) { return this; }

		var event = extend({}, data, {
			type: type,
			target: this,
			sourceTarget: data && data.sourceTarget || this
		});

		if (this._events) {
			var listeners = this._events[type];

			if (listeners) {
				this._firingCount = (this._firingCount + 1) || 1;
				for (var i = 0, len = listeners.length; i < len; i++) {
					var l = listeners[i];
					l.fn.call(l.ctx || this, event);
				}

				this._firingCount--;
			}
		}

		if (propagate) {
			// propagate the event to parents (set with addEventParent)
			this._propagateEvent(event);
		}

		return this;
	},

	// @method listens(type: String): Boolean
	// Returns `true` if a particular event type has any listeners attached to it.
	listens: function (type, propagate) {
		var listeners = this._events && this._events[type];
		if (listeners && listeners.length) { return true; }

		if (propagate) {
			// also check parents for listeners if event propagates
			for (var id in this._eventParents) {
				if (this._eventParents[id].listens(type, propagate)) { return true; }
			}
		}
		return false;
	},

	// @method once(…): this
	// Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.
	once: function (types, fn, context) {

		if (typeof types === 'object') {
			for (var type in types) {
				this.once(type, types[type], fn);
			}
			return this;
		}

		var handler = bind(function () {
			this
				.off(types, fn, context)
				.off(types, handler, context);
		}, this);

		// add a listener that's executed once and removed after that
		return this
			.on(types, fn, context)
			.on(types, handler, context);
	},

	// @method addEventParent(obj: Evented): this
	// Adds an event parent - an `Evented` that will receive propagated events
	addEventParent: function (obj) {
		this._eventParents = this._eventParents || {};
		this._eventParents[stamp(obj)] = obj;
		return this;
	},

	// @method removeEventParent(obj: Evented): this
	// Removes an event parent, so it will stop receiving propagated events
	removeEventParent: function (obj) {
		if (this._eventParents) {
			delete this._eventParents[stamp(obj)];
		}
		return this;
	},

	_propagateEvent: function (e) {
		for (var id in this._eventParents) {
			this._eventParents[id].fire(e.type, extend({
				layer: e.target,
				propagatedFrom: e.target
			}, e), true);
		}
	}
};

// aliases; we should ditch those eventually

// @method addEventListener(…): this
// Alias to [`on(…)`](#evented-on)
Events.addEventListener = Events.on;

// @method removeEventListener(…): this
// Alias to [`off(…)`](#evented-off)

// @method clearAllEventListeners(…): this
// Alias to [`off()`](#evented-off)
Events.removeEventListener = Events.clearAllEventListeners = Events.off;

// @method addOneTimeEventListener(…): this
// Alias to [`once(…)`](#evented-once)
Events.addOneTimeEventListener = Events.once;

// @method fireEvent(…): this
// Alias to [`fire(…)`](#evented-fire)
Events.fireEvent = Events.fire;

// @method hasEventListeners(…): Boolean
// Alias to [`listens(…)`](#evented-listens)
Events.hasEventListeners = Events.listens;

var Evented = Class.extend(Events);

/*
 * @class Point
 * @aka L.Point
 *
 * Represents a point with `x` and `y` coordinates in pixels.
 *
 * @example
 *
 * ```js
 * var point = L.point(200, 300);
 * ```
 *
 * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:
 *
 * ```js
 * map.panBy([200, 300]);
 * map.panBy(L.point(200, 300));
 * ```
 *
 * Note that `Point` does not inherit from Leafet's `Class` object,
 * which means new classes can't inherit from it, and new methods
 * can't be added to it with the `include` function.
 */

function Point(x, y, round) {
	// @property x: Number; The `x` coordinate of the point
	this.x = (round ? Math.round(x) : x);
	// @property y: Number; The `y` coordinate of the point
	this.y = (round ? Math.round(y) : y);
}

var trunc = Math.trunc || function (v) {
	return v > 0 ? Math.floor(v) : Math.ceil(v);
};

Point.prototype = {

	// @method clone(): Point
	// Returns a copy of the current point.
	clone: function () {
		return new Point(this.x, this.y);
	},

	// @method add(otherPoint: Point): Point
	// Returns the result of addition of the current and the given points.
	add: function (point) {
		// non-destructive, returns a new point
		return this.clone()._add(toPoint(point));
	},

	_add: function (point) {
		// destructive, used directly for performance in situations where it's safe to modify existing point
		this.x += point.x;
		this.y += point.y;
		return this;
	},

	// @method subtract(otherPoint: Point): Point
	// Returns the result of subtraction of the given point from the current.
	subtract: function (point) {
		return this.clone()._subtract(toPoint(point));
	},

	_subtract: function (point) {
		this.x -= point.x;
		this.y -= point.y;
		return this;
	},

	// @method divideBy(num: Number): Point
	// Returns the result of division of the current point by the given number.
	divideBy: function (num) {
		return this.clone()._divideBy(num);
	},

	_divideBy: function (num) {
		this.x /= num;
		this.y /= num;
		return this;
	},

	// @method multiplyBy(num: Number): Point
	// Returns the result of multiplication of the current point by the given number.
	multiplyBy: function (num) {
		return this.clone()._multiplyBy(num);
	},

	_multiplyBy: function (num) {
		this.x *= num;
		this.y *= num;
		return this;
	},

	// @method scaleBy(scale: Point): Point
	// Multiply each coordinate of the current point by each coordinate of
	// `scale`. In linear algebra terms, multiply the point by the
	// [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
	// defined by `scale`.
	scaleBy: function (point) {
		return new Point(this.x * point.x, this.y * point.y);
	},

	// @method unscaleBy(scale: Point): Point
	// Inverse of `scaleBy`. Divide each coordinate of the current point by
	// each coordinate of `scale`.
	unscaleBy: function (point) {
		return new Point(this.x / point.x, this.y / point.y);
	},

	// @method round(): Point
	// Returns a copy of the current point with rounded coordinates.
	round: function () {
		return this.clone()._round();
	},

	_round: function () {
		this.x = Math.round(this.x);
		this.y = Math.round(this.y);
		return this;
	},

	// @method floor(): Point
	// Returns a copy of the current point with floored coordinates (rounded down).
	floor: function () {
		return this.clone()._floor();
	},

	_floor: function () {
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		return this;
	},

	// @method ceil(): Point
	// Returns a copy of the current point with ceiled coordinates (rounded up).
	ceil: function () {
		return this.clone()._ceil();
	},

	_ceil: function () {
		this.x = Math.ceil(this.x);
		this.y = Math.ceil(this.y);
		return this;
	},

	// @method trunc(): Point
	// Returns a copy of the current point with truncated coordinates (rounded towards zero).
	trunc: function () {
		return this.clone()._trunc();
	},

	_trunc: function () {
		this.x = trunc(this.x);
		this.y = trunc(this.y);
		return this;
	},

	// @method distanceTo(otherPoint: Point): Number
	// Returns the cartesian distance between the current and the given points.
	distanceTo: function (point) {
		point = toPoint(point);

		var x = point.x - this.x,
			y = point.y - this.y;

		return Math.sqrt(x * x + y * y);
	},

	// @method equals(otherPoint: Point): Boolean
	// Returns `true` if the given point has the same coordinates.
	equals: function (point) {
		point = toPoint(point);

		return point.x === this.x &&
			   point.y === this.y;
	},

	// @method contains(otherPoint: Point): Boolean
	// Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
	contains: function (point) {
		point = toPoint(point);

		return Math.abs(point.x) <= Math.abs(this.x) &&
			   Math.abs(point.y) <= Math.abs(this.y);
	},

	// @method toString(): String
	// Returns a string representation of the point for debugging purposes.
	toString: function () {
		return 'Point(' +
				formatNum(this.x) + ', ' +
				formatNum(this.y) + ')';
	}
};

// @factory L.point(x: Number, y: Number, round?: Boolean)
// Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.

// @alternative
// @factory L.point(coords: Number[])
// Expects an array of the form `[x, y]` instead.

// @alternative
// @factory L.point(coords: Object)
// Expects a plain object of the form `{x: Number, y: Number}` instead.
function toPoint(x, y, round) {
	if (x instanceof Point) {
		return x;
	}
	if (isArray(x)) {
		return new Point(x[0], x[1]);
	}
	if (x === undefined || x === null) {
		return x;
	}
	if (typeof x === 'object' && 'x' in x && 'y' in x) {
		return new Point(x.x, x.y);
	}
	return new Point(x, y, round);
}

/*
 * @class Bounds
 * @aka L.Bounds
 *
 * Represents a rectangular area in pixel coordinates.
 *
 * @example
 *
 * ```js
 * var p1 = L.point(10, 10),
 * p2 = L.point(40, 60),
 * bounds = L.bounds(p1, p2);
 * ```
 *
 * All Leaflet methods that accept `Bounds` objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
 *
 * ```js
 * otherBounds.intersects([[10, 10], [40, 60]]);
 * ```
 *
 * Note that `Bounds` does not inherit from Leafet's `Class` object,
 * which means new classes can't inherit from it, and new methods
 * can't be added to it with the `include` function.
 */

function Bounds(a, b) {
	if (!a) { return; }

	var points = b ? [a, b] : a;

	for (var i = 0, len = points.length; i < len; i++) {
		this.extend(points[i]);
	}
}

Bounds.prototype = {
	// @method extend(point: Point): this
	// Extends the bounds to contain the given point.
	extend: function (point) { // (Point)
		point = toPoint(point);

		// @property min: Point
		// The top left corner of the rectangle.
		// @property max: Point
		// The bottom right corner of the rectangle.
		if (!this.min && !this.max) {
			this.min = point.clone();
			this.max = point.clone();
		} else {
			this.min.x = Math.min(point.x, this.min.x);
			this.max.x = Math.max(point.x, this.max.x);
			this.min.y = Math.min(point.y, this.min.y);
			this.max.y = Math.max(point.y, this.max.y);
		}
		return this;
	},

	// @method getCenter(round?: Boolean): Point
	// Returns the center point of the bounds.
	getCenter: function (round) {
		return new Point(
				(this.min.x + this.max.x) / 2,
				(this.min.y + this.max.y) / 2, round);
	},

	// @method getBottomLeft(): Point
	// Returns the bottom-left point of the bounds.
	getBottomLeft: function () {
		return new Point(this.min.x, this.max.y);
	},

	// @method getTopRight(): Point
	// Returns the top-right point of the bounds.
	getTopRight: function () { // -> Point
		return new Point(this.max.x, this.min.y);
	},

	// @method getTopLeft(): Point
	// Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).
	getTopLeft: function () {
		return this.min; // left, top
	},

	// @method getBottomRight(): Point
	// Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).
	getBottomRight: function () {
		return this.max; // right, bottom
	},

	// @method getSize(): Point
	// Returns the size of the given bounds
	getSize: function () {
		return this.max.subtract(this.min);
	},

	// @method contains(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle contains the given one.
	// @alternative
	// @method contains(point: Point): Boolean
	// Returns `true` if the rectangle contains the given point.
	contains: function (obj) {
		var min, max;

		if (typeof obj[0] === 'number' || obj instanceof Point) {
			obj = toPoint(obj);
		} else {
			obj = toBounds(obj);
		}

		if (obj instanceof Bounds) {
			min = obj.min;
			max = obj.max;
		} else {
			min = max = obj;
		}

		return (min.x >= this.min.x) &&
			   (max.x <= this.max.x) &&
			   (min.y >= this.min.y) &&
			   (max.y <= this.max.y);
	},

	// @method intersects(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle intersects the given bounds. Two bounds
	// intersect if they have at least one point in common.
	intersects: function (bounds) { // (Bounds) -> Boolean
		bounds = toBounds(bounds);

		var min = this.min,
			max = this.max,
			min2 = bounds.min,
			max2 = bounds.max,
			xIntersects = (max2.x >= min.x) && (min2.x <= max.x),
			yIntersects = (max2.y >= min.y) && (min2.y <= max.y);

		return xIntersects && yIntersects;
	},

	// @method overlaps(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle overlaps the given bounds. Two bounds
	// overlap if their intersection is an area.
	overlaps: function (bounds) { // (Bounds) -> Boolean
		bounds = toBounds(bounds);

		var min = this.min,
			max = this.max,
			min2 = bounds.min,
			max2 = bounds.max,
			xOverlaps = (max2.x > min.x) && (min2.x < max.x),
			yOverlaps = (max2.y > min.y) && (min2.y < max.y);

		return xOverlaps && yOverlaps;
	},

	isValid: function () {
		return !!(this.min && this.max);
	}
};


// @factory L.bounds(corner1: Point, corner2: Point)
// Creates a Bounds object from two corners coordinate pairs.
// @alternative
// @factory L.bounds(points: Point[])
// Creates a Bounds object from the given array of points.
function toBounds(a, b) {
	if (!a || a instanceof Bounds) {
		return a;
	}
	return new Bounds(a, b);
}

/*
 * @class LatLngBounds
 * @aka L.LatLngBounds
 *
 * Represents a rectangular geographical area on a map.
 *
 * @example
 *
 * ```js
 * var corner1 = L.latLng(40.712, -74.227),
 * corner2 = L.latLng(40.774, -74.125),
 * bounds = L.latLngBounds(corner1, corner2);
 * ```
 *
 * All Leaflet methods that accept LatLngBounds objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
 *
 * ```js
 * map.fitBounds([
 * 	[40.712, -74.227],
 * 	[40.774, -74.125]
 * ]);
 * ```
 *
 * Caution: if the area crosses the antimeridian (often confused with the International Date Line), you must specify corners _outside_ the [-180, 180] degrees longitude range.
 *
 * Note that `LatLngBounds` does not inherit from Leafet's `Class` object,
 * which means new classes can't inherit from it, and new methods
 * can't be added to it with the `include` function.
 */

function LatLngBounds(corner1, corner2) { // (LatLng, LatLng) or (LatLng[])
	if (!corner1) { return; }

	var latlngs = corner2 ? [corner1, corner2] : corner1;

	for (var i = 0, len = latlngs.length; i < len; i++) {
		this.extend(latlngs[i]);
	}
}

LatLngBounds.prototype = {

	// @method extend(latlng: LatLng): this
	// Extend the bounds to contain the given point

	// @alternative
	// @method extend(otherBounds: LatLngBounds): this
	// Extend the bounds to contain the given bounds
	extend: function (obj) {
		var sw = this._southWest,
			ne = this._northEast,
			sw2, ne2;

		if (obj instanceof LatLng) {
			sw2 = obj;
			ne2 = obj;

		} else if (obj instanceof LatLngBounds) {
			sw2 = obj._southWest;
			ne2 = obj._northEast;

			if (!sw2 || !ne2) { return this; }

		} else {
			return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;
		}

		if (!sw && !ne) {
			this._southWest = new LatLng(sw2.lat, sw2.lng);
			this._northEast = new LatLng(ne2.lat, ne2.lng);
		} else {
			sw.lat = Math.min(sw2.lat, sw.lat);
			sw.lng = Math.min(sw2.lng, sw.lng);
			ne.lat = Math.max(ne2.lat, ne.lat);
			ne.lng = Math.max(ne2.lng, ne.lng);
		}

		return this;
	},

	// @method pad(bufferRatio: Number): LatLngBounds
	// Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
	// For example, a ratio of 0.5 extends the bounds by 50% in each direction.
	// Negative values will retract the bounds.
	pad: function (bufferRatio) {
		var sw = this._southWest,
			ne = this._northEast,
			heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,
			widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;

		return new LatLngBounds(
				new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),
				new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
	},

	// @method getCenter(): LatLng
	// Returns the center point of the bounds.
	getCenter: function () {
		return new LatLng(
				(this._southWest.lat + this._northEast.lat) / 2,
				(this._southWest.lng + this._northEast.lng) / 2);
	},

	// @method getSouthWest(): LatLng
	// Returns the south-west point of the bounds.
	getSouthWest: function () {
		return this._southWest;
	},

	// @method getNorthEast(): LatLng
	// Returns the north-east point of the bounds.
	getNorthEast: function () {
		return this._northEast;
	},

	// @method getNorthWest(): LatLng
	// Returns the north-west point of the bounds.
	getNorthWest: function () {
		return new LatLng(this.getNorth(), this.getWest());
	},

	// @method getSouthEast(): LatLng
	// Returns the south-east point of the bounds.
	getSouthEast: function () {
		return new LatLng(this.getSouth(), this.getEast());
	},

	// @method getWest(): Number
	// Returns the west longitude of the bounds
	getWest: function () {
		return this._southWest.lng;
	},

	// @method getSouth(): Number
	// Returns the south latitude of the bounds
	getSouth: function () {
		return this._southWest.lat;
	},

	// @method getEast(): Number
	// Returns the east longitude of the bounds
	getEast: function () {
		return this._northEast.lng;
	},

	// @method getNorth(): Number
	// Returns the north latitude of the bounds
	getNorth: function () {
		return this._northEast.lat;
	},

	// @method contains(otherBounds: LatLngBounds): Boolean
	// Returns `true` if the rectangle contains the given one.

	// @alternative
	// @method contains (latlng: LatLng): Boolean
	// Returns `true` if the rectangle contains the given point.
	contains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean
		if (typeof obj[0] === 'number' || obj instanceof LatLng || 'lat' in obj) {
			obj = toLatLng(obj);
		} else {
			obj = toLatLngBounds(obj);
		}

		var sw = this._southWest,
			ne = this._northEast,
			sw2, ne2;

		if (obj instanceof LatLngBounds) {
			sw2 = obj.getSouthWest();
			ne2 = obj.getNorthEast();
		} else {
			sw2 = ne2 = obj;
		}

		return (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&
			   (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);
	},

	// @method intersects(otherBounds: LatLngBounds): Boolean
	// Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
	intersects: function (bounds) {
		bounds = toLatLngBounds(bounds);

		var sw = this._southWest,
			ne = this._northEast,
			sw2 = bounds.getSouthWest(),
			ne2 = bounds.getNorthEast(),

			latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),
			lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);

		return latIntersects && lngIntersects;
	},

	// @method overlaps(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
	overlaps: function (bounds) {
		bounds = toLatLngBounds(bounds);

		var sw = this._southWest,
			ne = this._northEast,
			sw2 = bounds.getSouthWest(),
			ne2 = bounds.getNorthEast(),

			latOverlaps = (ne2.lat > sw.lat) && (sw2.lat < ne.lat),
			lngOverlaps = (ne2.lng > sw.lng) && (sw2.lng < ne.lng);

		return latOverlaps && lngOverlaps;
	},

	// @method toBBoxString(): String
	// Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
	toBBoxString: function () {
		return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');
	},

	// @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean
	// Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.
	equals: function (bounds, maxMargin) {
		if (!bounds) { return false; }

		bounds = toLatLngBounds(bounds);

		return this._southWest.equals(bounds.getSouthWest(), maxMargin) &&
			   this._northEast.equals(bounds.getNorthEast(), maxMargin);
	},

	// @method isValid(): Boolean
	// Returns `true` if the bounds are properly initialized.
	isValid: function () {
		return !!(this._southWest && this._northEast);
	}
};

// TODO International date line?

// @factory L.latLngBounds(corner1: LatLng, corner2: LatLng)
// Creates a `LatLngBounds` object by defining two diagonally opposite corners of the rectangle.

// @alternative
// @factory L.latLngBounds(latlngs: LatLng[])
// Creates a `LatLngBounds` object defined by the geographical points it contains. Very useful for zooming the map to fit a particular set of locations with [`fitBounds`](#map-fitbounds).
function toLatLngBounds(a, b) {
	if (a instanceof LatLngBounds) {
		return a;
	}
	return new LatLngBounds(a, b);
}

/* @class LatLng
 * @aka L.LatLng
 *
 * Represents a geographical point with a certain latitude and longitude.
 *
 * @example
 *
 * ```
 * var latlng = L.latLng(50.5, 30.5);
 * ```
 *
 * All Leaflet methods that accept LatLng objects also accept them in a simple Array form and simple object form (unless noted otherwise), so these lines are equivalent:
 *
 * ```
 * map.panTo([50, 30]);
 * map.panTo({lon: 30, lat: 50});
 * map.panTo({lat: 50, lng: 30});
 * map.panTo(L.latLng(50, 30));
 * ```
 *
 * Note that `LatLng` does not inherit from Leaflet's `Class` object,
 * which means new classes can't inherit from it, and new methods
 * can't be added to it with the `include` function.
 */

function LatLng(lat, lng, alt) {
	if (isNaN(lat) || isNaN(lng)) {
		throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
	}

	// @property lat: Number
	// Latitude in degrees
	this.lat = +lat;

	// @property lng: Number
	// Longitude in degrees
	this.lng = +lng;

	// @property alt: Number
	// Altitude in meters (optional)
	if (alt !== undefined) {
		this.alt = +alt;
	}
}

LatLng.prototype = {
	// @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
	// Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.
	equals: function (obj, maxMargin) {
		if (!obj) { return false; }

		obj = toLatLng(obj);

		var margin = Math.max(
				Math.abs(this.lat - obj.lat),
				Math.abs(this.lng - obj.lng));

		return margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);
	},

	// @method toString(): String
	// Returns a string representation of the point (for debugging purposes).
	toString: function (precision) {
		return 'LatLng(' +
				formatNum(this.lat, precision) + ', ' +
				formatNum(this.lng, precision) + ')';
	},

	// @method distanceTo(otherLatLng: LatLng): Number
	// Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).
	distanceTo: function (other) {
		return Earth.distance(this, toLatLng(other));
	},

	// @method wrap(): LatLng
	// Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
	wrap: function () {
		return Earth.wrapLatLng(this);
	},

	// @method toBounds(sizeInMeters: Number): LatLngBounds
	// Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.
	toBounds: function (sizeInMeters) {
		var latAccuracy = 180 * sizeInMeters / 40075017,
			lngAccuracy = latAccuracy / Math.cos((Math.PI / 180) * this.lat);

		return toLatLngBounds(
				[this.lat - latAccuracy, this.lng - lngAccuracy],
				[this.lat + latAccuracy, this.lng + lngAccuracy]);
	},

	clone: function () {
		return new LatLng(this.lat, this.lng, this.alt);
	}
};



// @factory L.latLng(latitude: Number, longitude: Number, altitude?: Number): LatLng
// Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).

// @alternative
// @factory L.latLng(coords: Array): LatLng
// Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.

// @alternative
// @factory L.latLng(coords: Object): LatLng
// Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.

function toLatLng(a, b, c) {
	if (a instanceof LatLng) {
		return a;
	}
	if (isArray(a) && typeof a[0] !== 'object') {
		if (a.length === 3) {
			return new LatLng(a[0], a[1], a[2]);
		}
		if (a.length === 2) {
			return new LatLng(a[0], a[1]);
		}
		return null;
	}
	if (a === undefined || a === null) {
		return a;
	}
	if (typeof a === 'object' && 'lat' in a) {
		return new LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt);
	}
	if (b === undefined) {
		return null;
	}
	return new LatLng(a, b, c);
}

/*
 * @namespace CRS
 * @crs L.CRS.Base
 * Object that defines coordinate reference systems for projecting
 * geographical points into pixel (screen) coordinates and back (and to
 * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See
 * [spatial reference system](http://en.wikipedia.org/wiki/Coordinate_reference_system).
 *
 * Leaflet defines the most usual CRSs by default. If you want to use a
 * CRS not defined by default, take a look at the
 * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.
 *
 * Note that the CRS instances do not inherit from Leafet's `Class` object,
 * and can't be instantiated. Also, new classes can't inherit from them,
 * and methods can't be added to them with the `include` function.
 */

var CRS = {
	// @method latLngToPoint(latlng: LatLng, zoom: Number): Point
	// Projects geographical coordinates into pixel coordinates for a given zoom.
	latLngToPoint: function (latlng, zoom) {
		var projectedPoint = this.projection.project(latlng),
			scale = this.scale(zoom);

		return this.transformation._transform(projectedPoint, scale);
	},

	// @method pointToLatLng(point: Point, zoom: Number): LatLng
	// The inverse of `latLngToPoint`. Projects pixel coordinates on a given
	// zoom into geographical coordinates.
	pointToLatLng: function (point, zoom) {
		var scale = this.scale(zoom),
			untransformedPoint = this.transformation.untransform(point, scale);

		return this.projection.unproject(untransformedPoint);
	},

	// @method project(latlng: LatLng): Point
	// Projects geographical coordinates into coordinates in units accepted for
	// this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
	project: function (latlng) {
		return this.projection.project(latlng);
	},

	// @method unproject(point: Point): LatLng
	// Given a projected coordinate returns the corresponding LatLng.
	// The inverse of `project`.
	unproject: function (point) {
		return this.projection.unproject(point);
	},

	// @method scale(zoom: Number): Number
	// Returns the scale used when transforming projected coordinates into
	// pixel coordinates for a particular zoom. For example, it returns
	// `256 * 2^zoom` for Mercator-based CRS.
	scale: function (zoom) {
		return 256 * Math.pow(2, zoom);
	},

	// @method zoom(scale: Number): Number
	// Inverse of `scale()`, returns the zoom level corresponding to a scale
	// factor of `scale`.
	zoom: function (scale) {
		return Math.log(scale / 256) / Math.LN2;
	},

	// @method getProjectedBounds(zoom: Number): Bounds
	// Returns the projection's bounds scaled and transformed for the provided `zoom`.
	getProjectedBounds: function (zoom) {
		if (this.infinite) { return null; }

		var b = this.projection.bounds,
			s = this.scale(zoom),
			min = this.transformation.transform(b.min, s),
			max = this.transformation.transform(b.max, s);

		return new Bounds(min, max);
	},

	// @method distance(latlng1: LatLng, latlng2: LatLng): Number
	// Returns the distance between two geographical coordinates.

	// @property code: String
	// Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
	//
	// @property wrapLng: Number[]
	// An array of two numbers defining whether the longitude (horizontal) coordinate
	// axis wraps around a given range and how. Defaults to `[-180, 180]` in most
	// geographical CRSs. If `undefined`, the longitude axis does not wrap around.
	//
	// @property wrapLat: Number[]
	// Like `wrapLng`, but for the latitude (vertical) axis.

	// wrapLng: [min, max],
	// wrapLat: [min, max],

	// @property infinite: Boolean
	// If true, the coordinate space will be unbounded (infinite in both axes)
	infinite: false,

	// @method wrapLatLng(latlng: LatLng): LatLng
	// Returns a `LatLng` where lat and lng has been wrapped according to the
	// CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
	wrapLatLng: function (latlng) {
		var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,
			lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,
			alt = latlng.alt;

		return new LatLng(lat, lng, alt);
	},

	// @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
	// Returns a `LatLngBounds` with the same size as the given one, ensuring
	// that its center is within the CRS's bounds.
	// Only accepts actual `L.LatLngBounds` instances, not arrays.
	wrapLatLngBounds: function (bounds) {
		var center = bounds.getCenter(),
			newCenter = this.wrapLatLng(center),
			latShift = center.lat - newCenter.lat,
			lngShift = center.lng - newCenter.lng;

		if (latShift === 0 && lngShift === 0) {
			return bounds;
		}

		var sw = bounds.getSouthWest(),
			ne = bounds.getNorthEast(),
			newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift),
			newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);

		return new LatLngBounds(newSw, newNe);
	}
};

/*
 * @namespace CRS
 * @crs L.CRS.Earth
 *
 * Serves as the base for CRS that are global such that they cover the earth.
 * Can only be used as the base for other CRS and cannot be used directly,
 * since it does not have a `code`, `projection` or `transformation`. `distance()` returns
 * meters.
 */

var Earth = extend({}, CRS, {
	wrapLng: [-180, 180],

	// Mean Earth Radius, as recommended for use by
	// the International Union of Geodesy and Geophysics,
	// see http://rosettacode.org/wiki/Haversine_formula
	R: 6371000,

	// distance between two geographical points using spherical law of cosines approximation
	distance: function (latlng1, latlng2) {
		var rad = Math.PI / 180,
			lat1 = latlng1.lat * rad,
			lat2 = latlng2.lat * rad,
			sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2),
			sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2),
			a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon,
			c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
		return this.R * c;
	}
});

/*
 * @namespace Projection
 * @projection L.Projection.SphericalMercator
 *
 * Spherical Mercator projection — the most common projection for online maps,
 * used by almost all free and commercial tile providers. Assumes that Earth is
 * a sphere. Used by the `EPSG:3857` CRS.
 */

var SphericalMercator = {

	R: 6378137,
	MAX_LATITUDE: 85.0511287798,

	project: function (latlng) {
		var d = Math.PI / 180,
			max = this.MAX_LATITUDE,
			lat = Math.max(Math.min(max, latlng.lat), -max),
			sin = Math.sin(lat * d);

		return new Point(
			this.R * latlng.lng * d,
			this.R * Math.log((1 + sin) / (1 - sin)) / 2);
	},

	unproject: function (point) {
		var d = 180 / Math.PI;

		return new LatLng(
			(2 * Math.atan(Math.exp(point.y / this.R)) - (Math.PI / 2)) * d,
			point.x * d / this.R);
	},

	bounds: (function () {
		var d = 6378137 * Math.PI;
		return new Bounds([-d, -d], [d, d]);
	})()
};

/*
 * @class Transformation
 * @aka L.Transformation
 *
 * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`
 * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing
 * the reverse. Used by Leaflet in its projections code.
 *
 * @example
 *
 * ```js
 * var transformation = L.transformation(2, 5, -1, 10),
 * 	p = L.point(1, 2),
 * 	p2 = transformation.transform(p), //  L.point(7, 8)
 * 	p3 = transformation.untransform(p2); //  L.point(1, 2)
 * ```
 */


// factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)
// Creates a `Transformation` object with the given coefficients.
function Transformation(a, b, c, d) {
	if (isArray(a)) {
		// use array properties
		this._a = a[0];
		this._b = a[1];
		this._c = a[2];
		this._d = a[3];
		return;
	}
	this._a = a;
	this._b = b;
	this._c = c;
	this._d = d;
}

Transformation.prototype = {
	// @method transform(point: Point, scale?: Number): Point
	// Returns a transformed point, optionally multiplied by the given scale.
	// Only accepts actual `L.Point` instances, not arrays.
	transform: function (point, scale) { // (Point, Number) -> Point
		return this._transform(point.clone(), scale);
	},

	// destructive transform (faster)
	_transform: function (point, scale) {
		scale = scale || 1;
		point.x = scale * (this._a * point.x + this._b);
		point.y = scale * (this._c * point.y + this._d);
		return point;
	},

	// @method untransform(point: Point, scale?: Number): Point
	// Returns the reverse transformation of the given point, optionally divided
	// by the given scale. Only accepts actual `L.Point` instances, not arrays.
	untransform: function (point, scale) {
		scale = scale || 1;
		return new Point(
				(point.x / scale - this._b) / this._a,
				(point.y / scale - this._d) / this._c);
	}
};

// factory L.transformation(a: Number, b: Number, c: Number, d: Number)

// @factory L.transformation(a: Number, b: Number, c: Number, d: Number)
// Instantiates a Transformation object with the given coefficients.

// @alternative
// @factory L.transformation(coefficients: Array): Transformation
// Expects an coefficients array of the form
// `[a: Number, b: Number, c: Number, d: Number]`.

function toTransformation(a, b, c, d) {
	return new Transformation(a, b, c, d);
}

/*
 * @namespace CRS
 * @crs L.CRS.EPSG3857
 *
 * The most common CRS for online maps, used by almost all free and commercial
 * tile providers. Uses Spherical Mercator projection. Set in by default in
 * Map's `crs` option.
 */

var EPSG3857 = extend({}, Earth, {
	code: 'EPSG:3857',
	projection: SphericalMercator,

	transformation: (function () {
		var scale = 0.5 / (Math.PI * SphericalMercator.R);
		return toTransformation(scale, 0.5, -scale, 0.5);
	}())
});

var EPSG900913 = extend({}, EPSG3857, {
	code: 'EPSG:900913'
});

// @namespace SVG; @section
// There are several static functions which can be called without instantiating L.SVG:

// @function create(name: String): SVGElement
// Returns a instance of [SVGElement](https://developer.mozilla.org/docs/Web/API/SVGElement),
// corresponding to the class name passed. For example, using 'line' will return
// an instance of [SVGLineElement](https://developer.mozilla.org/docs/Web/API/SVGLineElement).
function svgCreate(name) {
	return document.createElementNS('http://www.w3.org/2000/svg', name);
}

// @function pointsToPath(rings: Point[], closed: Boolean): String
// Generates a SVG path string for multiple rings, with each ring turning
// into "M..L..L.." instructions
function pointsToPath(rings, closed) {
	var str = '',
	i, j, len, len2, points, p;

	for (i = 0, len = rings.length; i < len; i++) {
		points = rings[i];

		for (j = 0, len2 = points.length; j < len2; j++) {
			p = points[j];
			str += (j ? 'L' : 'M') + p.x + ' ' + p.y;
		}

		// closes the ring for polygons; "x" is VML syntax
		str += closed ? (svg ? 'z' : 'x') : '';
	}

	// SVG complains about empty path strings
	return str || 'M0 0';
}

/*
 * @namespace Browser
 * @aka L.Browser
 *
 * A namespace with static properties for browser/feature detection used by Leaflet internally.
 *
 * @example
 *
 * ```js
 * if (L.Browser.ielt9) {
 *   alert('Upgrade your browser, dude!');
 * }
 * ```
 */

var style$1 = document.documentElement.style;

// @property ie: Boolean; `true` for all Internet Explorer versions (not Edge).
var ie = 'ActiveXObject' in window;

// @property ielt9: Boolean; `true` for Internet Explorer versions less than 9.
var ielt9 = ie && !document.addEventListener;

// @property edge: Boolean; `true` for the Edge web browser.
var edge = 'msLaunchUri' in navigator && !('documentMode' in document);

// @property webkit: Boolean;
// `true` for webkit-based browsers like Chrome and Safari (including mobile versions).
var webkit = userAgentContains('webkit');

// @property android: Boolean
// `true` for any browser running on an Android platform.
var android = userAgentContains('android');

// @property android23: Boolean; `true` for browsers running on Android 2 or Android 3.
var android23 = userAgentContains('android 2') || userAgentContains('android 3');

/* See https://stackoverflow.com/a/17961266 for details on detecting stock Android */
var webkitVer = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10); // also matches AppleWebKit
// @property androidStock: Boolean; `true` for the Android stock browser (i.e. not Chrome)
var androidStock = android && userAgentContains('Google') && webkitVer < 537 && !('AudioNode' in window);

// @property opera: Boolean; `true` for the Opera browser
var opera = !!window.opera;

// @property chrome: Boolean; `true` for the Chrome browser.
var chrome = userAgentContains('chrome');

// @property gecko: Boolean; `true` for gecko-based browsers like Firefox.
var gecko = userAgentContains('gecko') && !webkit && !opera && !ie;

// @property safari: Boolean; `true` for the Safari browser.
var safari = !chrome && userAgentContains('safari');

var phantom = userAgentContains('phantom');

// @property opera12: Boolean
// `true` for the Opera browser supporting CSS transforms (version 12 or later).
var opera12 = 'OTransition' in style$1;

// @property win: Boolean; `true` when the browser is running in a Windows platform
var win = navigator.platform.indexOf('Win') === 0;

// @property ie3d: Boolean; `true` for all Internet Explorer versions supporting CSS transforms.
var ie3d = ie && ('transition' in style$1);

// @property webkit3d: Boolean; `true` for webkit-based browsers supporting CSS transforms.
var webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23;

// @property gecko3d: Boolean; `true` for gecko-based browsers supporting CSS transforms.
var gecko3d = 'MozPerspective' in style$1;

// @property any3d: Boolean
// `true` for all browsers supporting CSS transforms.
var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;

// @property mobile: Boolean; `true` for all browsers running in a mobile device.
var mobile = typeof orientation !== 'undefined' || userAgentContains('mobile');

// @property mobileWebkit: Boolean; `true` for all webkit-based browsers in a mobile device.
var mobileWebkit = mobile && webkit;

// @property mobileWebkit3d: Boolean
// `true` for all webkit-based browsers in a mobile device supporting CSS transforms.
var mobileWebkit3d = mobile && webkit3d;

// @property msPointer: Boolean
// `true` for browsers implementing the Microsoft touch events model (notably IE10).
var msPointer = !window.PointerEvent && window.MSPointerEvent;

// @property pointer: Boolean
// `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).
var pointer = !!(window.PointerEvent || msPointer);

// @property touch: Boolean
// `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).
// This does not necessarily mean that the browser is running in a computer with
// a touchscreen, it only means that the browser is capable of understanding
// touch events.
var touch = !window.L_NO_TOUCH && (pointer || 'ontouchstart' in window ||
		(window.DocumentTouch && document instanceof window.DocumentTouch));

// @property mobileOpera: Boolean; `true` for the Opera browser in a mobile device.
var mobileOpera = mobile && opera;

// @property mobileGecko: Boolean
// `true` for gecko-based browsers running in a mobile device.
var mobileGecko = mobile && gecko;

// @property retina: Boolean
// `true` for browsers on a high-resolution "retina" screen or on any screen when browser's display zoom is more than 100%.
var retina = (window.devicePixelRatio || (window.screen.deviceXDPI / window.screen.logicalXDPI)) > 1;


// @property canvas: Boolean
// `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
var canvas = (function () {
	return !!document.createElement('canvas').getContext;
}());

// @property svg: Boolean
// `true` when the browser supports [SVG](https://developer.mozilla.org/docs/Web/SVG).
var svg = !!(document.createElementNS && svgCreate('svg').createSVGRect);

// @property vml: Boolean
// `true` if the browser supports [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language).
var vml = !svg && (function () {
	try {
		var div = document.createElement('div');
		div.innerHTML = '<v:shape adj="1"/>';

		var shape = div.firstChild;
		shape.style.behavior = 'url(#default#VML)';

		return shape && (typeof shape.adj === 'object');

	} catch (e) {
		return false;
	}
}());


function userAgentContains(str) {
	return navigator.userAgent.toLowerCase().indexOf(str) >= 0;
}


var Browser = (Object.freeze || Object)({
	ie: ie,
	ielt9: ielt9,
	edge: edge,
	webkit: webkit,
	android: android,
	android23: android23,
	androidStock: androidStock,
	opera: opera,
	chrome: chrome,
	gecko: gecko,
	safari: safari,
	phantom: phantom,
	opera12: opera12,
	win: win,
	ie3d: ie3d,
	webkit3d: webkit3d,
	gecko3d: gecko3d,
	any3d: any3d,
	mobile: mobile,
	mobileWebkit: mobileWebkit,
	mobileWebkit3d: mobileWebkit3d,
	msPointer: msPointer,
	pointer: pointer,
	touch: touch,
	mobileOpera: mobileOpera,
	mobileGecko: mobileGecko,
	retina: retina,
	canvas: canvas,
	svg: svg,
	vml: vml
});

/*
 * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.
 */


var POINTER_DOWN =   msPointer ? 'MSPointerDown'   : 'pointerdown';
var POINTER_MOVE =   msPointer ? 'MSPointerMove'   : 'pointermove';
var POINTER_UP =     msPointer ? 'MSPointerUp'     : 'pointerup';
var POINTER_CANCEL = msPointer ? 'MSPointerCancel' : 'pointercancel';
var TAG_WHITE_LIST = ['INPUT', 'SELECT', 'OPTION'];

var _pointers = {};
var _pointerDocListener = false;

// DomEvent.DoubleTap needs to know about this
var _pointersCount = 0;

// Provides a touch events wrapper for (ms)pointer events.
// ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890

function addPointerListener(obj, type, handler, id) {
	if (type === 'touchstart') {
		_addPointerStart(obj, handler, id);

	} else if (type === 'touchmove') {
		_addPointerMove(obj, handler, id);

	} else if (type === 'touchend') {
		_addPointerEnd(obj, handler, id);
	}

	return this;
}

function removePointerListener(obj, type, id) {
	var handler = obj['_leaflet_' + type + id];

	if (type === 'touchstart') {
		obj.removeEventListener(POINTER_DOWN, handler, false);

	} else if (type === 'touchmove') {
		obj.removeEventListener(POINTER_MOVE, handler, false);

	} else if (type === 'touchend') {
		obj.removeEventListener(POINTER_UP, handler, false);
		obj.removeEventListener(POINTER_CANCEL, handler, false);
	}

	return this;
}

function _addPointerStart(obj, handler, id) {
	var onDown = bind(function (e) {
		if (e.pointerType !== 'mouse' && e.MSPOINTER_TYPE_MOUSE && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {
			// In IE11, some touch events needs to fire for form controls, or
			// the controls will stop working. We keep a whitelist of tag names that
			// need these events. For other target tags, we prevent default on the event.
			if (TAG_WHITE_LIST.indexOf(e.target.tagName) < 0) {
				preventDefault(e);
			} else {
				return;
			}
		}

		_handlePointer(e, handler);
	});

	obj['_leaflet_touchstart' + id] = onDown;
	obj.addEventListener(POINTER_DOWN, onDown, false);

	// need to keep track of what pointers and how many are active to provide e.touches emulation
	if (!_pointerDocListener) {
		// we listen documentElement as any drags that end by moving the touch off the screen get fired there
		document.documentElement.addEventListener(POINTER_DOWN, _globalPointerDown, true);
		document.documentElement.addEventListener(POINTER_MOVE, _globalPointerMove, true);
		document.documentElement.addEventListener(POINTER_UP, _globalPointerUp, true);
		document.documentElement.addEventListener(POINTER_CANCEL, _globalPointerUp, true);

		_pointerDocListener = true;
	}
}

function _globalPointerDown(e) {
	_pointers[e.pointerId] = e;
	_pointersCount++;
}

function _globalPointerMove(e) {
	if (_pointers[e.pointerId]) {
		_pointers[e.pointerId] = e;
	}
}

function _globalPointerUp(e) {
	delete _pointers[e.pointerId];
	_pointersCount--;
}

function _handlePointer(e, handler) {
	e.touches = [];
	for (var i in _pointers) {
		e.touches.push(_pointers[i]);
	}
	e.changedTouches = [e];

	handler(e);
}

function _addPointerMove(obj, handler, id) {
	var onMove = function (e) {
		// don't fire touch moves when mouse isn't down
		if ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) { return; }

		_handlePointer(e, handler);
	};

	obj['_leaflet_touchmove' + id] = onMove;
	obj.addEventListener(POINTER_MOVE, onMove, false);
}

function _addPointerEnd(obj, handler, id) {
	var onUp = function (e) {
		_handlePointer(e, handler);
	};

	obj['_leaflet_touchend' + id] = onUp;
	obj.addEventListener(POINTER_UP, onUp, false);
	obj.addEventListener(POINTER_CANCEL, onUp, false);
}

/*
 * Extends the event handling code with double tap support for mobile browsers.
 */

var _touchstart = msPointer ? 'MSPointerDown' : pointer ? 'pointerdown' : 'touchstart';
var _touchend = msPointer ? 'MSPointerUp' : pointer ? 'pointerup' : 'touchend';
var _pre = '_leaflet_';

// inspired by Zepto touch code by Thomas Fuchs
function addDoubleTapListener(obj, handler, id) {
	var last, touch$$1,
		doubleTap = false,
		delay = 250;

	function onTouchStart(e) {
		var count;

		if (pointer) {
			if ((!edge) || e.pointerType === 'mouse') { return; }
			count = _pointersCount;
		} else {
			count = e.touches.length;
		}

		if (count > 1) { return; }

		var now = Date.now(),
			delta = now - (last || now);

		touch$$1 = e.touches ? e.touches[0] : e;
		doubleTap = (delta > 0 && delta <= delay);
		last = now;
	}

	function onTouchEnd(e) {
		if (doubleTap && !touch$$1.cancelBubble) {
			if (pointer) {
				if ((!edge) || e.pointerType === 'mouse') { return; }
				// work around .type being readonly with MSPointer* events
				var newTouch = {},
					prop, i;

				for (i in touch$$1) {
					prop = touch$$1[i];
					newTouch[i] = prop && prop.bind ? prop.bind(touch$$1) : prop;
				}
				touch$$1 = newTouch;
			}
			touch$$1.type = 'dblclick';
			handler(touch$$1);
			last = null;
		}
	}

	obj[_pre + _touchstart + id] = onTouchStart;
	obj[_pre + _touchend + id] = onTouchEnd;
	obj[_pre + 'dblclick' + id] = handler;

	obj.addEventListener(_touchstart, onTouchStart, false);
	obj.addEventListener(_touchend, onTouchEnd, false);

	// On some platforms (notably, chrome<55 on win10 + touchscreen + mouse),
	// the browser doesn't fire touchend/pointerup events but does fire
	// native dblclicks. See #4127.
	// Edge 14 also fires native dblclicks, but only for pointerType mouse, see #5180.
	obj.addEventListener('dblclick', handler, false);

	return this;
}

function removeDoubleTapListener(obj, id) {
	var touchstart = obj[_pre + _touchstart + id],
		touchend = obj[_pre + _touchend + id],
		dblclick = obj[_pre + 'dblclick' + id];

	obj.removeEventListener(_touchstart, touchstart, false);
	obj.removeEventListener(_touchend, touchend, false);
	if (!edge) {
		obj.removeEventListener('dblclick', dblclick, false);
	}

	return this;
}

/*
 * @namespace DomUtil
 *
 * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model)
 * tree, used by Leaflet internally.
 *
 * Most functions expecting or returning a `HTMLElement` also work for
 * SVG elements. The only difference is that classes refer to CSS classes
 * in HTML and SVG classes in SVG.
 */


// @property TRANSFORM: String
// Vendor-prefixed transform style name (e.g. `'webkitTransform'` for WebKit).
var TRANSFORM = testProp(
	['transform', 'webkitTransform', 'OTransform', 'MozTransform', 'msTransform']);

// webkitTransition comes first because some browser versions that drop vendor prefix don't do
// the same for the transitionend event, in particular the Android 4.1 stock browser

// @property TRANSITION: String
// Vendor-prefixed transition style name.
var TRANSITION = testProp(
	['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);

// @property TRANSITION_END: String
// Vendor-prefixed transitionend event name.
var TRANSITION_END =
	TRANSITION === 'webkitTransition' || TRANSITION === 'OTransition' ? TRANSITION + 'End' : 'transitionend';


// @function get(id: String|HTMLElement): HTMLElement
// Returns an element given its DOM id, or returns the element itself
// if it was passed directly.
function get(id) {
	return typeof id === 'string' ? document.getElementById(id) : id;
}

// @function getStyle(el: HTMLElement, styleAttrib: String): String
// Returns the value for a certain style attribute on an element,
// including computed values or values set through CSS.
function getStyle(el, style) {
	var value = el.style[style] || (el.currentStyle && el.currentStyle[style]);

	if ((!value || value === 'auto') && document.defaultView) {
		var css = document.defaultView.getComputedStyle(el, null);
		value = css ? css[style] : null;
	}
	return value === 'auto' ? null : value;
}

// @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement
// Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.
function create$1(tagName, className, container) {
	var el = document.createElement(tagName);
	el.className = className || '';

	if (container) {
		container.appendChild(el);
	}
	return el;
}

// @function remove(el: HTMLElement)
// Removes `el` from its parent element
function remove(el) {
	var parent = el.parentNode;
	if (parent) {
		parent.removeChild(el);
	}
}

// @function empty(el: HTMLElement)
// Removes all of `el`'s children elements from `el`
function empty(el) {
	while (el.firstChild) {
		el.removeChild(el.firstChild);
	}
}

// @function toFront(el: HTMLElement)
// Makes `el` the last child of its parent, so it renders in front of the other children.
function toFront(el) {
	var parent = el.parentNode;
	if (parent && parent.lastChild !== el) {
		parent.appendChild(el);
	}
}

// @function toBack(el: HTMLElement)
// Makes `el` the first child of its parent, so it renders behind the other children.
function toBack(el) {
	var parent = el.parentNode;
	if (parent && parent.firstChild !== el) {
		parent.insertBefore(el, parent.firstChild);
	}
}

// @function hasClass(el: HTMLElement, name: String): Boolean
// Returns `true` if the element's class attribute contains `name`.
function hasClass(el, name) {
	if (el.classList !== undefined) {
		return el.classList.contains(name);
	}
	var className = getClass(el);
	return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
}

// @function addClass(el: HTMLElement, name: String)
// Adds `name` to the element's class attribute.
function addClass(el, name) {
	if (el.classList !== undefined) {
		var classes = splitWords(name);
		for (var i = 0, len = classes.length; i < len; i++) {
			el.classList.add(classes[i]);
		}
	} else if (!hasClass(el, name)) {
		var className = getClass(el);
		setClass(el, (className ? className + ' ' : '') + name);
	}
}

// @function removeClass(el: HTMLElement, name: String)
// Removes `name` from the element's class attribute.
function removeClass(el, name) {
	if (el.classList !== undefined) {
		el.classList.remove(name);
	} else {
		setClass(el, trim((' ' + getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
	}
}

// @function setClass(el: HTMLElement, name: String)
// Sets the element's class.
function setClass(el, name) {
	if (el.className.baseVal === undefined) {
		el.className = name;
	} else {
		// in case of SVG element
		el.className.baseVal = name;
	}
}

// @function getClass(el: HTMLElement): String
// Returns the element's class.
function getClass(el) {
	// Check if the element is an SVGElementInstance and use the correspondingElement instead
	// (Required for linked SVG elements in IE11.)
	if (el.correspondingElement) {
		el = el.correspondingElement;
	}
	return el.className.baseVal === undefined ? el.className : el.className.baseVal;
}

// @function setOpacity(el: HTMLElement, opacity: Number)
// Set the opacity of an element (including old IE support).
// `opacity` must be a number from `0` to `1`.
function setOpacity(el, value) {
	if ('opacity' in el.style) {
		el.style.opacity = value;
	} else if ('filter' in el.style) {
		_setOpacityIE(el, value);
	}
}

function _setOpacityIE(el, value) {
	var filter = false,
		filterName = 'DXImageTransform.Microsoft.Alpha';

	// filters collection throws an error if we try to retrieve a filter that doesn't exist
	try {
		filter = el.filters.item(filterName);
	} catch (e) {
		// don't set opacity to 1 if we haven't already set an opacity,
		// it isn't needed and breaks transparent pngs.
		if (value === 1) { return; }
	}

	value = Math.round(value * 100);

	if (filter) {
		filter.Enabled = (value !== 100);
		filter.Opacity = value;
	} else {
		el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';
	}
}

// @function testProp(props: String[]): String|false
// Goes through the array of style names and returns the first name
// that is a valid style name for an element. If no such name is found,
// it returns false. Useful for vendor-prefixed styles like `transform`.
function testProp(props) {
	var style = document.documentElement.style;

	for (var i = 0; i < props.length; i++) {
		if (props[i] in style) {
			return props[i];
		}
	}
	return false;
}

// @function setTransform(el: HTMLElement, offset: Point, scale?: Number)
// Resets the 3D CSS transform of `el` so it is translated by `offset` pixels
// and optionally scaled by `scale`. Does not have an effect if the
// browser doesn't support 3D CSS transforms.
function setTransform(el, offset, scale) {
	var pos = offset || new Point(0, 0);

	el.style[TRANSFORM] =
		(ie3d ?
			'translate(' + pos.x + 'px,' + pos.y + 'px)' :
			'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') +
		(scale ? ' scale(' + scale + ')' : '');
}

// @function setPosition(el: HTMLElement, position: Point)
// Sets the position of `el` to coordinates specified by `position`,
// using CSS translate or top/left positioning depending on the browser
// (used by Leaflet internally to position its layers).
function setPosition(el, point) {

	/*eslint-disable */
	el._leaflet_pos = point;
	/* eslint-enable */

	if (any3d) {
		setTransform(el, point);
	} else {
		el.style.left = point.x + 'px';
		el.style.top = point.y + 'px';
	}
}

// @function getPosition(el: HTMLElement): Point
// Returns the coordinates of an element previously positioned with setPosition.
function getPosition(el) {
	// this method is only used for elements previously positioned using setPosition,
	// so it's safe to cache the position for performance

	return el._leaflet_pos || new Point(0, 0);
}

// @function disableTextSelection()
// Prevents the user from generating `selectstart` DOM events, usually generated
// when the user drags the mouse through a page with text. Used internally
// by Leaflet to override the behaviour of any click-and-drag interaction on
// the map. Affects drag interactions on the whole document.

// @function enableTextSelection()
// Cancels the effects of a previous [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection).
var disableTextSelection;
var enableTextSelection;
var _userSelect;
if ('onselectstart' in document) {
	disableTextSelection = function () {
		on(window, 'selectstart', preventDefault);
	};
	enableTextSelection = function () {
		off(window, 'selectstart', preventDefault);
	};
} else {
	var userSelectProperty = testProp(
		['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);

	disableTextSelection = function () {
		if (userSelectProperty) {
			var style = document.documentElement.style;
			_userSelect = style[userSelectProperty];
			style[userSelectProperty] = 'none';
		}
	};
	enableTextSelection = function () {
		if (userSelectProperty) {
			document.documentElement.style[userSelectProperty] = _userSelect;
			_userSelect = undefined;
		}
	};
}

// @function disableImageDrag()
// As [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection), but
// for `dragstart` DOM events, usually generated when the user drags an image.
function disableImageDrag() {
	on(window, 'dragstart', preventDefault);
}

// @function enableImageDrag()
// Cancels the effects of a previous [`L.DomUtil.disableImageDrag`](#domutil-disabletextselection).
function enableImageDrag() {
	off(window, 'dragstart', preventDefault);
}

var _outlineElement;
var _outlineStyle;
// @function preventOutline(el: HTMLElement)
// Makes the [outline](https://developer.mozilla.org/docs/Web/CSS/outline)
// of the element `el` invisible. Used internally by Leaflet to prevent
// focusable elements from displaying an outline when the user performs a
// drag interaction on them.
function preventOutline(element) {
	while (element.tabIndex === -1) {
		element = element.parentNode;
	}
	if (!element.style) { return; }
	restoreOutline();
	_outlineElement = element;
	_outlineStyle = element.style.outline;
	element.style.outline = 'none';
	on(window, 'keydown', restoreOutline);
}

// @function restoreOutline()
// Cancels the effects of a previous [`L.DomUtil.preventOutline`]().
function restoreOutline() {
	if (!_outlineElement) { return; }
	_outlineElement.style.outline = _outlineStyle;
	_outlineElement = undefined;
	_outlineStyle = undefined;
	off(window, 'keydown', restoreOutline);
}

// @function getSizedParentNode(el: HTMLElement): HTMLElement
// Finds the closest parent node which size (width and height) is not null.
function getSizedParentNode(element) {
	do {
		element = element.parentNode;
	} while ((!element.offsetWidth || !element.offsetHeight) && element !== document.body);
	return element;
}

// @function getScale(el: HTMLElement): Object
// Computes the CSS scale currently applied on the element.
// Returns an object with `x` and `y` members as horizontal and vertical scales respectively,
// and `boundingClientRect` as the result of [`getBoundingClientRect()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect).
function getScale(element) {
	var rect = element.getBoundingClientRect(); // Read-only in old browsers.

	return {
		x: rect.width / element.offsetWidth || 1,
		y: rect.height / element.offsetHeight || 1,
		boundingClientRect: rect
	};
}


var DomUtil = (Object.freeze || Object)({
	TRANSFORM: TRANSFORM,
	TRANSITION: TRANSITION,
	TRANSITION_END: TRANSITION_END,
	get: get,
	getStyle: getStyle,
	create: create$1,
	remove: remove,
	empty: empty,
	toFront: toFront,
	toBack: toBack,
	hasClass: hasClass,
	addClass: addClass,
	removeClass: removeClass,
	setClass: setClass,
	getClass: getClass,
	setOpacity: setOpacity,
	testProp: testProp,
	setTransform: setTransform,
	setPosition: setPosition,
	getPosition: getPosition,
	disableTextSelection: disableTextSelection,
	enableTextSelection: enableTextSelection,
	disableImageDrag: disableImageDrag,
	enableImageDrag: enableImageDrag,
	preventOutline: preventOutline,
	restoreOutline: restoreOutline,
	getSizedParentNode: getSizedParentNode,
	getScale: getScale
});

/*
 * @namespace DomEvent
 * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally.
 */

// Inspired by John Resig, Dean Edwards and YUI addEvent implementations.

// @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this
// Adds a listener function (`fn`) to a particular DOM event type of the
// element `el`. You can optionally specify the context of the listener
// (object the `this` keyword will point to). You can also pass several
// space-separated types (e.g. `'click dblclick'`).

// @alternative
// @function on(el: HTMLElement, eventMap: Object, context?: Object): this
// Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
function on(obj, types, fn, context) {

	if (typeof types === 'object') {
		for (var type in types) {
			addOne(obj, type, types[type], fn);
		}
	} else {
		types = splitWords(types);

		for (var i = 0, len = types.length; i < len; i++) {
			addOne(obj, types[i], fn, context);
		}
	}

	return this;
}

var eventsKey = '_leaflet_events';

// @function off(el: HTMLElement, types: String, fn: Function, context?: Object): this
// Removes a previously added listener function.
// Note that if you passed a custom context to on, you must pass the same
// context to `off` in order to remove the listener.

// @alternative
// @function off(el: HTMLElement, eventMap: Object, context?: Object): this
// Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
function off(obj, types, fn, context) {

	if (typeof types === 'object') {
		for (var type in types) {
			removeOne(obj, type, types[type], fn);
		}
	} else if (types) {
		types = splitWords(types);

		for (var i = 0, len = types.length; i < len; i++) {
			removeOne(obj, types[i], fn, context);
		}
	} else {
		for (var j in obj[eventsKey]) {
			removeOne(obj, j, obj[eventsKey][j]);
		}
		delete obj[eventsKey];
	}

	return this;
}

function addOne(obj, type, fn, context) {
	var id = type + stamp(fn) + (context ? '_' + stamp(context) : '');

	if (obj[eventsKey] && obj[eventsKey][id]) { return this; }

	var handler = function (e) {
		return fn.call(context || obj, e || window.event);
	};

	var originalHandler = handler;

	if (pointer && type.indexOf('touch') === 0) {
		// Needs DomEvent.Pointer.js
		addPointerListener(obj, type, handler, id);

	} else if (touch && (type === 'dblclick') && addDoubleTapListener &&
			   !(pointer && chrome)) {
		// Chrome >55 does not need the synthetic dblclicks from addDoubleTapListener
		// See #5180
		addDoubleTapListener(obj, handler, id);

	} else if ('addEventListener' in obj) {

		if (type === 'mousewheel') {
			obj.addEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, false);

		} else if ((type === 'mouseenter') || (type === 'mouseleave')) {
			handler = function (e) {
				e = e || window.event;
				if (isExternalTarget(obj, e)) {
					originalHandler(e);
				}
			};
			obj.addEventListener(type === 'mouseenter' ? 'mouseover' : 'mouseout', handler, false);

		} else {
			if (type === 'click' && android) {
				handler = function (e) {
					filterClick(e, originalHandler);
				};
			}
			obj.addEventListener(type, handler, false);
		}

	} else if ('attachEvent' in obj) {
		obj.attachEvent('on' + type, handler);
	}

	obj[eventsKey] = obj[eventsKey] || {};
	obj[eventsKey][id] = handler;
}

function removeOne(obj, type, fn, context) {

	var id = type + stamp(fn) + (context ? '_' + stamp(context) : ''),
		handler = obj[eventsKey] && obj[eventsKey][id];

	if (!handler) { return this; }

	if (pointer && type.indexOf('touch') === 0) {
		removePointerListener(obj, type, id);

	} else if (touch && (type === 'dblclick') && removeDoubleTapListener &&
			   !(pointer && chrome)) {
		removeDoubleTapListener(obj, id);

	} else if ('removeEventListener' in obj) {

		if (type === 'mousewheel') {
			obj.removeEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, false);

		} else {
			obj.removeEventListener(
				type === 'mouseenter' ? 'mouseover' :
				type === 'mouseleave' ? 'mouseout' : type, handler, false);
		}

	} else if ('detachEvent' in obj) {
		obj.detachEvent('on' + type, handler);
	}

	obj[eventsKey][id] = null;
}

// @function stopPropagation(ev: DOMEvent): this
// Stop the given event from propagation to parent elements. Used inside the listener functions:
// ```js
// L.DomEvent.on(div, 'click', function (ev) {
// 	L.DomEvent.stopPropagation(ev);
// });
// ```
function stopPropagation(e) {

	if (e.stopPropagation) {
		e.stopPropagation();
	} else if (e.originalEvent) {  // In case of Leaflet event.
		e.originalEvent._stopped = true;
	} else {
		e.cancelBubble = true;
	}
	skipped(e);

	return this;
}

// @function disableScrollPropagation(el: HTMLElement): this
// Adds `stopPropagation` to the element's `'mousewheel'` events (plus browser variants).
function disableScrollPropagation(el) {
	addOne(el, 'mousewheel', stopPropagation);
	return this;
}

// @function disableClickPropagation(el: HTMLElement): this
// Adds `stopPropagation` to the element's `'click'`, `'doubleclick'`,
// `'mousedown'` and `'touchstart'` events (plus browser variants).
function disableClickPropagation(el) {
	on(el, 'mousedown touchstart dblclick', stopPropagation);
	addOne(el, 'click', fakeStop);
	return this;
}

// @function preventDefault(ev: DOMEvent): this
// Prevents the default action of the DOM Event `ev` from happening (such as
// following a link in the href of the a element, or doing a POST request
// with page reload when a `<form>` is submitted).
// Use it inside listener functions.
function preventDefault(e) {
	if (e.preventDefault) {
		e.preventDefault();
	} else {
		e.returnValue = false;
	}
	return this;
}

// @function stop(ev: DOMEvent): this
// Does `stopPropagation` and `preventDefault` at the same time.
function stop(e) {
	preventDefault(e);
	stopPropagation(e);
	return this;
}

// @function getMousePosition(ev: DOMEvent, container?: HTMLElement): Point
// Gets normalized mouse position from a DOM event relative to the
// `container` (border excluded) or to the whole page if not specified.
function getMousePosition(e, container) {
	if (!container) {
		return new Point(e.clientX, e.clientY);
	}

	var scale = getScale(container),
		offset = scale.boundingClientRect; // left and top  values are in page scale (like the event clientX/Y)

	return new Point(
		// offset.left/top values are in page scale (like clientX/Y),
		// whereas clientLeft/Top (border width) values are the original values (before CSS scale applies).
		(e.clientX - offset.left) / scale.x - container.clientLeft,
		(e.clientY - offset.top) / scale.y - container.clientTop
	);
}

// Chrome on Win scrolls double the pixels as in other platforms (see #4538),
// and Firefox scrolls device pixels, not CSS pixels
var wheelPxFactor =
	(win && chrome) ? 2 * window.devicePixelRatio :
	gecko ? window.devicePixelRatio : 1;

// @function getWheelDelta(ev: DOMEvent): Number
// Gets normalized wheel delta from a mousewheel DOM event, in vertical
// pixels scrolled (negative if scrolling down).
// Events from pointing devices without precise scrolling are mapped to
// a best guess of 60 pixels.
function getWheelDelta(e) {
	return (edge) ? e.wheelDeltaY / 2 : // Don't trust window-geometry-based delta
		   (e.deltaY && e.deltaMode === 0) ? -e.deltaY / wheelPxFactor : // Pixels
		   (e.deltaY && e.deltaMode === 1) ? -e.deltaY * 20 : // Lines
		   (e.deltaY && e.deltaMode === 2) ? -e.deltaY * 60 : // Pages
		   (e.deltaX || e.deltaZ) ? 0 :	// Skip horizontal/depth wheel events
		   e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : // Legacy IE pixels
		   (e.detail && Math.abs(e.detail) < 32765) ? -e.detail * 20 : // Legacy Moz lines
		   e.detail ? e.detail / -32765 * 60 : // Legacy Moz pages
		   0;
}

var skipEvents = {};

function fakeStop(e) {
	// fakes stopPropagation by setting a special event flag, checked/reset with skipped(e)
	skipEvents[e.type] = true;
}

function skipped(e) {
	var events = skipEvents[e.type];
	// reset when checking, as it's only used in map container and propagates outside of the map
	skipEvents[e.type] = false;
	return events;
}

// check if element really left/entered the event target (for mouseenter/mouseleave)
function isExternalTarget(el, e) {

	var related = e.relatedTarget;

	if (!related) { return true; }

	try {
		while (related && (related !== el)) {
			related = related.parentNode;
		}
	} catch (err) {
		return false;
	}
	return (related !== el);
}

var lastClick;

// this is a horrible workaround for a bug in Android where a single touch triggers two click events
function filterClick(e, handler) {
	var timeStamp = (e.timeStamp || (e.originalEvent && e.originalEvent.timeStamp)),
		elapsed = lastClick && (timeStamp - lastClick);

	// are they closer together than 500ms yet more than 100ms?
	// Android typically triggers them ~300ms apart while multiple listeners
	// on the same event should be triggered far faster;
	// or check if click is simulated on the element, and if it is, reject any non-simulated events

	if ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {
		stop(e);
		return;
	}
	lastClick = timeStamp;

	handler(e);
}




var DomEvent = (Object.freeze || Object)({
	on: on,
	off: off,
	stopPropagation: stopPropagation,
	disableScrollPropagation: disableScrollPropagation,
	disableClickPropagation: disableClickPropagation,
	preventDefault: preventDefault,
	stop: stop,
	getMousePosition: getMousePosition,
	getWheelDelta: getWheelDelta,
	fakeStop: fakeStop,
	skipped: skipped,
	isExternalTarget: isExternalTarget,
	addListener: on,
	removeListener: off
});

/*
 * @class PosAnimation
 * @aka L.PosAnimation
 * @inherits Evented
 * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9.
 *
 * @example
 * ```js
 * var fx = new L.PosAnimation();
 * fx.run(el, [300, 500], 0.5);
 * ```
 *
 * @constructor L.PosAnimation()
 * Creates a `PosAnimation` object.
 *
 */

var PosAnimation = Evented.extend({

	// @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
	// Run an animation of a given element to a new position, optionally setting
	// duration in seconds (`0.25` by default) and easing linearity factor (3rd
	// argument of the [cubic bezier curve](http://cubic-bezier.com/#0,0,.5,1),
	// `0.5` by default).
	run: function (el, newPos, duration, easeLinearity) {
		this.stop();

		this._el = el;
		this._inProgress = true;
		this._duration = duration || 0.25;
		this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);

		this._startPos = getPosition(el);
		this._offset = newPos.subtract(this._startPos);
		this._startTime = +new Date();

		// @event start: Event
		// Fired when the animation starts
		this.fire('start');

		this._animate();
	},

	// @method stop()
	// Stops the animation (if currently running).
	stop: function () {
		if (!this._inProgress) { return; }

		this._step(true);
		this._complete();
	},

	_animate: function () {
		// animation loop
		this._animId = requestAnimFrame(this._animate, this);
		this._step();
	},

	_step: function (round) {
		var elapsed = (+new Date()) - this._startTime,
			duration = this._duration * 1000;

		if (elapsed < duration) {
			this._runFrame(this._easeOut(elapsed / duration), round);
		} else {
			this._runFrame(1);
			this._complete();
		}
	},

	_runFrame: function (progress, round) {
		var pos = this._startPos.add(this._offset.multiplyBy(progress));
		if (round) {
			pos._round();
		}
		setPosition(this._el, pos);

		// @event step: Event
		// Fired continuously during the animation.
		this.fire('step');
	},

	_complete: function () {
		cancelAnimFrame(this._animId);

		this._inProgress = false;
		// @event end: Event
		// Fired when the animation ends.
		this.fire('end');
	},

	_easeOut: function (t) {
		return 1 - Math.pow(1 - t, this._easeOutPower);
	}
});

/*
 * @class Map
 * @aka L.Map
 * @inherits Evented
 *
 * The central class of the API — it is used to create a map on a page and manipulate it.
 *
 * @example
 *
 * ```js
 * // initialize the map on the "map" div with a given center and zoom
 * var map = L.map('map', {
 * 	center: [51.505, -0.09],
 * 	zoom: 13
 * });
 * ```
 *
 */

var Map = Evented.extend({

	options: {
		// @section Map State Options
		// @option crs: CRS = L.CRS.EPSG3857
		// The [Coordinate Reference System](#crs) to use. Don't change this if you're not
		// sure what it means.
		crs: EPSG3857,

		// @option center: LatLng = undefined
		// Initial geographic center of the map
		center: undefined,

		// @option zoom: Number = undefined
		// Initial map zoom level
		zoom: undefined,

		// @option minZoom: Number = *
		// Minimum zoom level of the map.
		// If not specified and at least one `GridLayer` or `TileLayer` is in the map,
		// the lowest of their `minZoom` options will be used instead.
		minZoom: undefined,

		// @option maxZoom: Number = *
		// Maximum zoom level of the map.
		// If not specified and at least one `GridLayer` or `TileLayer` is in the map,
		// the highest of their `maxZoom` options will be used instead.
		maxZoom: undefined,

		// @option layers: Layer[] = []
		// Array of layers that will be added to the map initially
		layers: [],

		// @option maxBounds: LatLngBounds = null
		// When this option is set, the map restricts the view to the given
		// geographical bounds, bouncing the user back if the user tries to pan
		// outside the view. To set the restriction dynamically, use
		// [`setMaxBounds`](#map-setmaxbounds) method.
		maxBounds: undefined,

		// @option renderer: Renderer = *
		// The default method for drawing vector layers on the map. `L.SVG`
		// or `L.Canvas` by default depending on browser support.
		renderer: undefined,


		// @section Animation Options
		// @option zoomAnimation: Boolean = true
		// Whether the map zoom animation is enabled. By default it's enabled
		// in all browsers that support CSS3 Transitions except Android.
		zoomAnimation: true,

		// @option zoomAnimationThreshold: Number = 4
		// Won't animate zoom if the zoom difference exceeds this value.
		zoomAnimationThreshold: 4,

		// @option fadeAnimation: Boolean = true
		// Whether the tile fade animation is enabled. By default it's enabled
		// in all browsers that support CSS3 Transitions except Android.
		fadeAnimation: true,

		// @option markerZoomAnimation: Boolean = true
		// Whether markers animate their zoom with the zoom animation, if disabled
		// they will disappear for the length of the animation. By default it's
		// enabled in all browsers that support CSS3 Transitions except Android.
		markerZoomAnimation: true,

		// @option transform3DLimit: Number = 2^23
		// Defines the maximum size of a CSS translation transform. The default
		// value should not be changed unless a web browser positions layers in
		// the wrong place after doing a large `panBy`.
		transform3DLimit: 8388608, // Precision limit of a 32-bit float

		// @section Interaction Options
		// @option zoomSnap: Number = 1
		// Forces the map's zoom level to always be a multiple of this, particularly
		// right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
		// By default, the zoom level snaps to the nearest integer; lower values
		// (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
		// means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
		zoomSnap: 1,

		// @option zoomDelta: Number = 1
		// Controls how much the map's zoom level will change after a
		// [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
		// or `-` on the keyboard, or using the [zoom controls](#control-zoom).
		// Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
		zoomDelta: 1,

		// @option trackResize: Boolean = true
		// Whether the map automatically handles browser window resize to update itself.
		trackResize: true
	},

	initialize: function (id, options) { // (HTMLElement or String, Object)
		options = setOptions(this, options);

		// Make sure to assign internal flags at the beginning,
		// to avoid inconsistent state in some edge cases.
		this._handlers = [];
		this._layers = {};
		this._zoomBoundLayers = {};
		this._sizeChanged = true;

		this._initContainer(id);
		this._initLayout();

		// hack for https://github.com/Leaflet/Leaflet/issues/1980
		this._onResize = bind(this._onResize, this);

		this._initEvents();

		if (options.maxBounds) {
			this.setMaxBounds(options.maxBounds);
		}

		if (options.zoom !== undefined) {
			this._zoom = this._limitZoom(options.zoom);
		}

		if (options.center && options.zoom !== undefined) {
			this.setView(toLatLng(options.center), options.zoom, {reset: true});
		}

		this.callInitHooks();

		// don't animate on browsers without hardware-accelerated transitions or old Android/Opera
		this._zoomAnimated = TRANSITION && any3d && !mobileOpera &&
				this.options.zoomAnimation;

		// zoom transitions run with the same duration for all layers, so if one of transitionend events
		// happens after starting zoom animation (propagating to the map pane), we know that it ended globally
		if (this._zoomAnimated) {
			this._createAnimProxy();
			on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);
		}

		this._addLayers(this.options.layers);
	},


	// @section Methods for modifying map state

	// @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
	// Sets the view of the map (geographical center and zoom) with the given
	// animation options.
	setView: function (center, zoom, options) {

		zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
		center = this._limitCenter(toLatLng(center), zoom, this.options.maxBounds);
		options = options || {};

		this._stop();

		if (this._loaded && !options.reset && options !== true) {

			if (options.animate !== undefined) {
				options.zoom = extend({animate: options.animate}, options.zoom);
				options.pan = extend({animate: options.animate, duration: options.duration}, options.pan);
			}

			// try animating pan or zoom
			var moved = (this._zoom !== zoom) ?
				this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :
				this._tryAnimatedPan(center, options.pan);

			if (moved) {
				// prevent resize handler call, the view will refresh after animation anyway
				clearTimeout(this._sizeTimer);
				return this;
			}
		}

		// animation didn't start, just reset the map view
		this._resetView(center, zoom);

		return this;
	},

	// @method setZoom(zoom: Number, options?: Zoom/pan options): this
	// Sets the zoom of the map.
	setZoom: function (zoom, options) {
		if (!this._loaded) {
			this._zoom = zoom;
			return this;
		}
		return this.setView(this.getCenter(), zoom, {zoom: options});
	},

	// @method zoomIn(delta?: Number, options?: Zoom options): this
	// Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
	zoomIn: function (delta, options) {
		delta = delta || (any3d ? this.options.zoomDelta : 1);
		return this.setZoom(this._zoom + delta, options);
	},

	// @method zoomOut(delta?: Number, options?: Zoom options): this
	// Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
	zoomOut: function (delta, options) {
		delta = delta || (any3d ? this.options.zoomDelta : 1);
		return this.setZoom(this._zoom - delta, options);
	},

	// @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
	// Zooms the map while keeping a specified geographical point on the map
	// stationary (e.g. used internally for scroll zoom and double-click zoom).
	// @alternative
	// @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
	// Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
	setZoomAround: function (latlng, zoom, options) {
		var scale = this.getZoomScale(zoom),
			viewHalf = this.getSize().divideBy(2),
			containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng),

			centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),
			newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));

		return this.setView(newCenter, zoom, {zoom: options});
	},

	_getBoundsCenterZoom: function (bounds, options) {

		options = options || {};
		bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);

		var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),
			paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),

			zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));

		zoom = (typeof options.maxZoom === 'number') ? Math.min(options.maxZoom, zoom) : zoom;

		if (zoom === Infinity) {
			return {
				center: bounds.getCenter(),
				zoom: zoom
			};
		}

		var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),

			swPoint = this.project(bounds.getSouthWest(), zoom),
			nePoint = this.project(bounds.getNorthEast(), zoom),
			center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);

		return {
			center: center,
			zoom: zoom
		};
	},

	// @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this
	// Sets a map view that contains the given geographical bounds with the
	// maximum zoom level possible.
	fitBounds: function (bounds, options) {

		bounds = toLatLngBounds(bounds);

		if (!bounds.isValid()) {
			throw new Error('Bounds are not valid.');
		}

		var target = this._getBoundsCenterZoom(bounds, options);
		return this.setView(target.center, target.zoom, options);
	},

	// @method fitWorld(options?: fitBounds options): this
	// Sets a map view that mostly contains the whole world with the maximum
	// zoom level possible.
	fitWorld: function (options) {
		return this.fitBounds([[-90, -180], [90, 180]], options);
	},

	// @method panTo(latlng: LatLng, options?: Pan options): this
	// Pans the map to a given center.
	panTo: function (center, options) { // (LatLng)
		return this.setView(center, this._zoom, {pan: options});
	},

	// @method panBy(offset: Point, options?: Pan options): this
	// Pans the map by a given number of pixels (animated).
	panBy: function (offset, options) {
		offset = toPoint(offset).round();
		options = options || {};

		if (!offset.x && !offset.y) {
			return this.fire('moveend');
		}
		// If we pan too far, Chrome gets issues with tiles
		// and makes them disappear or appear in the wrong place (slightly offset) #2602
		if (options.animate !== true && !this.getSize().contains(offset)) {
			this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
			return this;
		}

		if (!this._panAnim) {
			this._panAnim = new PosAnimation();

			this._panAnim.on({
				'step': this._onPanTransitionStep,
				'end': this._onPanTransitionEnd
			}, this);
		}

		// don't fire movestart if animating inertia
		if (!options.noMoveStart) {
			this.fire('movestart');
		}

		// animate pan unless animate: false specified
		if (options.animate !== false) {
			addClass(this._mapPane, 'leaflet-pan-anim');

			var newPos = this._getMapPanePos().subtract(offset).round();
			this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
		} else {
			this._rawPanBy(offset);
			this.fire('move').fire('moveend');
		}

		return this;
	},

	// @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
	// Sets the view of the map (geographical center and zoom) performing a smooth
	// pan-zoom animation.
	flyTo: function (targetCenter, targetZoom, options) {

		options = options || {};
		if (options.animate === false || !any3d) {
			return this.setView(targetCenter, targetZoom, options);
		}

		this._stop();

		var from = this.project(this.getCenter()),
			to = this.project(targetCenter),
			size = this.getSize(),
			startZoom = this._zoom;

		targetCenter = toLatLng(targetCenter);
		targetZoom = targetZoom === undefined ? startZoom : targetZoom;

		var w0 = Math.max(size.x, size.y),
			w1 = w0 * this.getZoomScale(startZoom, targetZoom),
			u1 = (to.distanceTo(from)) || 1,
			rho = 1.42,
			rho2 = rho * rho;

		function r(i) {
			var s1 = i ? -1 : 1,
				s2 = i ? w1 : w0,
				t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1,
				b1 = 2 * s2 * rho2 * u1,
				b = t1 / b1,
				sq = Math.sqrt(b * b + 1) - b;

				// workaround for floating point precision bug when sq = 0, log = -Infinite,
				// thus triggering an infinite loop in flyTo
				var log = sq < 0.000000001 ? -18 : Math.log(sq);

			return log;
		}

		function sinh(n) { return (Math.exp(n) - Math.exp(-n)) / 2; }
		function cosh(n) { return (Math.exp(n) + Math.exp(-n)) / 2; }
		function tanh(n) { return sinh(n) / cosh(n); }

		var r0 = r(0);

		function w(s) { return w0 * (cosh(r0) / cosh(r0 + rho * s)); }
		function u(s) { return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2; }

		function easeOut(t) { return 1 - Math.pow(1 - t, 1.5); }

		var start = Date.now(),
			S = (r(1) - r0) / rho,
			duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;

		function frame() {
			var t = (Date.now() - start) / duration,
				s = easeOut(t) * S;

			if (t <= 1) {
				this._flyToFrame = requestAnimFrame(frame, this);

				this._move(
					this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom),
					this.getScaleZoom(w0 / w(s), startZoom),
					{flyTo: true});

			} else {
				this
					._move(targetCenter, targetZoom)
					._moveEnd(true);
			}
		}

		this._moveStart(true, options.noMoveStart);

		frame.call(this);
		return this;
	},

	// @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
	// Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
	// but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
	flyToBounds: function (bounds, options) {
		var target = this._getBoundsCenterZoom(bounds, options);
		return this.flyTo(target.center, target.zoom, options);
	},

	// @method setMaxBounds(bounds: Bounds): this
	// Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
	setMaxBounds: function (bounds) {
		bounds = toLatLngBounds(bounds);

		if (!bounds.isValid()) {
			this.options.maxBounds = null;
			return this.off('moveend', this._panInsideMaxBounds);
		} else if (this.options.maxBounds) {
			this.off('moveend', this._panInsideMaxBounds);
		}

		this.options.maxBounds = bounds;

		if (this._loaded) {
			this._panInsideMaxBounds();
		}

		return this.on('moveend', this._panInsideMaxBounds);
	},

	// @method setMinZoom(zoom: Number): this
	// Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
	setMinZoom: function (zoom) {
		var oldZoom = this.options.minZoom;
		this.options.minZoom = zoom;

		if (this._loaded && oldZoom !== zoom) {
			this.fire('zoomlevelschange');

			if (this.getZoom() < this.options.minZoom) {
				return this.setZoom(zoom);
			}
		}

		return this;
	},

	// @method setMaxZoom(zoom: Number): this
	// Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
	setMaxZoom: function (zoom) {
		var oldZoom = this.options.maxZoom;
		this.options.maxZoom = zoom;

		if (this._loaded && oldZoom !== zoom) {
			this.fire('zoomlevelschange');

			if (this.getZoom() > this.options.maxZoom) {
				return this.setZoom(zoom);
			}
		}

		return this;
	},

	// @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
	// Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
	panInsideBounds: function (bounds, options) {
		this._enforcingBounds = true;
		var center = this.getCenter(),
			newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));

		if (!center.equals(newCenter)) {
			this.panTo(newCenter, options);
		}

		this._enforcingBounds = false;
		return this;
	},

	// @method panInside(latlng: LatLng, options?: options): this
	// Pans the map the minimum amount to make the `latlng` visible. Use
	// `padding`, `paddingTopLeft` and `paddingTopRight` options to fit
	// the display to more restricted bounds, like [`fitBounds`](#map-fitbounds).
	// If `latlng` is already within the (optionally padded) display bounds,
	// the map will not be panned.
	panInside: function (latlng, options) {
		options = options || {};

		var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),
			paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),
			center = this.getCenter(),
			pixelCenter = this.project(center),
			pixelPoint = this.project(latlng),
			pixelBounds = this.getPixelBounds(),
			halfPixelBounds = pixelBounds.getSize().divideBy(2),
			paddedBounds = toBounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]);

		if (!paddedBounds.contains(pixelPoint)) {
			this._enforcingBounds = true;
			var diff = pixelCenter.subtract(pixelPoint),
				newCenter = toPoint(pixelPoint.x + diff.x, pixelPoint.y + diff.y);

			if (pixelPoint.x < paddedBounds.min.x || pixelPoint.x > paddedBounds.max.x) {
				newCenter.x = pixelCenter.x - diff.x;
				if (diff.x > 0) {
					newCenter.x += halfPixelBounds.x - paddingTL.x;
				} else {
					newCenter.x -= halfPixelBounds.x - paddingBR.x;
				}
			}
			if (pixelPoint.y < paddedBounds.min.y || pixelPoint.y > paddedBounds.max.y) {
				newCenter.y = pixelCenter.y - diff.y;
				if (diff.y > 0) {
					newCenter.y += halfPixelBounds.y - paddingTL.y;
				} else {
					newCenter.y -= halfPixelBounds.y - paddingBR.y;
				}
			}
			this.panTo(this.unproject(newCenter), options);
			this._enforcingBounds = false;
		}
		return this;
	},

	// @method invalidateSize(options: Zoom/pan options): this
	// Checks if the map container size changed and updates the map if so —
	// call it after you've changed the map size dynamically, also animating
	// pan by default. If `options.pan` is `false`, panning will not occur.
	// If `options.debounceMoveend` is `true`, it will delay `moveend` event so
	// that it doesn't happen often even if the method is called many
	// times in a row.

	// @alternative
	// @method invalidateSize(animate: Boolean): this
	// Checks if the map container size changed and updates the map if so —
	// call it after you've changed the map size dynamically, also animating
	// pan by default.
	invalidateSize: function (options) {
		if (!this._loaded) { return this; }

		options = extend({
			animate: false,
			pan: true
		}, options === true ? {animate: true} : options);

		var oldSize = this.getSize();
		this._sizeChanged = true;
		this._lastCenter = null;

		var newSize = this.getSize(),
			oldCenter = oldSize.divideBy(2).round(),
			newCenter = newSize.divideBy(2).round(),
			offset = oldCenter.subtract(newCenter);

		if (!offset.x && !offset.y) { return this; }

		if (options.animate && options.pan) {
			this.panBy(offset);

		} else {
			if (options.pan) {
				this._rawPanBy(offset);
			}

			this.fire('move');

			if (options.debounceMoveend) {
				clearTimeout(this._sizeTimer);
				this._sizeTimer = setTimeout(bind(this.fire, this, 'moveend'), 200);
			} else {
				this.fire('moveend');
			}
		}

		// @section Map state change events
		// @event resize: ResizeEvent
		// Fired when the map is resized.
		return this.fire('resize', {
			oldSize: oldSize,
			newSize: newSize
		});
	},

	// @section Methods for modifying map state
	// @method stop(): this
	// Stops the currently running `panTo` or `flyTo` animation, if any.
	stop: function () {
		this.setZoom(this._limitZoom(this._zoom));
		if (!this.options.zoomSnap) {
			this.fire('viewreset');
		}
		return this._stop();
	},

	// @section Geolocation methods
	// @method locate(options?: Locate options): this
	// Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
	// event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
	// and optionally sets the map view to the user's location with respect to
	// detection accuracy (or to the world view if geolocation failed).
	// Note that, if your page doesn't use HTTPS, this method will fail in
	// modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
	// See `Locate options` for more details.
	locate: function (options) {

		options = this._locateOptions = extend({
			timeout: 10000,
			watch: false
			// setView: false
			// maxZoom: <Number>
			// maximumAge: 0
			// enableHighAccuracy: false
		}, options);

		if (!('geolocation' in navigator)) {
			this._handleGeolocationError({
				code: 0,
				message: 'Geolocation not supported.'
			});
			return this;
		}

		var onResponse = bind(this._handleGeolocationResponse, this),
			onError = bind(this._handleGeolocationError, this);

		if (options.watch) {
			this._locationWatchId =
					navigator.geolocation.watchPosition(onResponse, onError, options);
		} else {
			navigator.geolocation.getCurrentPosition(onResponse, onError, options);
		}
		return this;
	},

	// @method stopLocate(): this
	// Stops watching location previously initiated by `map.locate({watch: true})`
	// and aborts resetting the map view if map.locate was called with
	// `{setView: true}`.
	stopLocate: function () {
		if (navigator.geolocation && navigator.geolocation.clearWatch) {
			navigator.geolocation.clearWatch(this._locationWatchId);
		}
		if (this._locateOptions) {
			this._locateOptions.setView = false;
		}
		return this;
	},

	_handleGeolocationError: function (error) {
		var c = error.code,
			message = error.message ||
					(c === 1 ? 'permission denied' :
					(c === 2 ? 'position unavailable' : 'timeout'));

		if (this._locateOptions.setView && !this._loaded) {
			this.fitWorld();
		}

		// @section Location events
		// @event locationerror: ErrorEvent
		// Fired when geolocation (using the [`locate`](#map-locate) method) failed.
		this.fire('locationerror', {
			code: c,
			message: 'Geolocation error: ' + message + '.'
		});
	},

	_handleGeolocationResponse: function (pos) {
		var lat = pos.coords.latitude,
			lng = pos.coords.longitude,
			latlng = new LatLng(lat, lng),
			bounds = latlng.toBounds(pos.coords.accuracy * 2),
			options = this._locateOptions;

		if (options.setView) {
			var zoom = this.getBoundsZoom(bounds);
			this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);
		}

		var data = {
			latlng: latlng,
			bounds: bounds,
			timestamp: pos.timestamp
		};

		for (var i in pos.coords) {
			if (typeof pos.coords[i] === 'number') {
				data[i] = pos.coords[i];
			}
		}

		// @event locationfound: LocationEvent
		// Fired when geolocation (using the [`locate`](#map-locate) method)
		// went successfully.
		this.fire('locationfound', data);
	},

	// TODO Appropriate docs section?
	// @section Other Methods
	// @method addHandler(name: String, HandlerClass: Function): this
	// Adds a new `Handler` to the map, given its name and constructor function.
	addHandler: function (name, HandlerClass) {
		if (!HandlerClass) { return this; }

		var handler = this[name] = new HandlerClass(this);

		this._handlers.push(handler);

		if (this.options[name]) {
			handler.enable();
		}

		return this;
	},

	// @method remove(): this
	// Destroys the map and clears all related event listeners.
	remove: function () {

		this._initEvents(true);

		if (this._containerId !== this._container._leaflet_id) {
			throw new Error('Map container is being reused by another instance');
		}

		try {
			// throws error in IE6-8
			delete this._container._leaflet_id;
			delete this._containerId;
		} catch (e) {
			/*eslint-disable */
			this._container._leaflet_id = undefined;
			/* eslint-enable */
			this._containerId = undefined;
		}

		if (this._locationWatchId !== undefined) {
			this.stopLocate();
		}

		this._stop();

		remove(this._mapPane);

		if (this._clearControlPos) {
			this._clearControlPos();
		}
		if (this._resizeRequest) {
			cancelAnimFrame(this._resizeRequest);
			this._resizeRequest = null;
		}

		this._clearHandlers();

		if (this._loaded) {
			// @section Map state change events
			// @event unload: Event
			// Fired when the map is destroyed with [remove](#map-remove) method.
			this.fire('unload');
		}

		var i;
		for (i in this._layers) {
			this._layers[i].remove();
		}
		for (i in this._panes) {
			remove(this._panes[i]);
		}

		this._layers = [];
		this._panes = [];
		delete this._mapPane;
		delete this._renderer;

		return this;
	},

	// @section Other Methods
	// @method createPane(name: String, container?: HTMLElement): HTMLElement
	// Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
	// then returns it. The pane is created as a child of `container`, or
	// as a child of the main map pane if not set.
	createPane: function (name, container) {
		var className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),
			pane = create$1('div', className, container || this._mapPane);

		if (name) {
			this._panes[name] = pane;
		}
		return pane;
	},

	// @section Methods for Getting Map State

	// @method getCenter(): LatLng
	// Returns the geographical center of the map view
	getCenter: function () {
		this._checkIfLoaded();

		if (this._lastCenter && !this._moved()) {
			return this._lastCenter;
		}
		return this.layerPointToLatLng(this._getCenterLayerPoint());
	},

	// @method getZoom(): Number
	// Returns the current zoom level of the map view
	getZoom: function () {
		return this._zoom;
	},

	// @method getBounds(): LatLngBounds
	// Returns the geographical bounds visible in the current map view
	getBounds: function () {
		var bounds = this.getPixelBounds(),
			sw = this.unproject(bounds.getBottomLeft()),
			ne = this.unproject(bounds.getTopRight());

		return new LatLngBounds(sw, ne);
	},

	// @method getMinZoom(): Number
	// Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
	getMinZoom: function () {
		return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;
	},

	// @method getMaxZoom(): Number
	// Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
	getMaxZoom: function () {
		return this.options.maxZoom === undefined ?
			(this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :
			this.options.maxZoom;
	},

	// @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean, padding?: Point): Number
	// Returns the maximum zoom level on which the given bounds fit to the map
	// view in its entirety. If `inside` (optional) is set to `true`, the method
	// instead returns the minimum zoom level on which the map view fits into
	// the given bounds in its entirety.
	getBoundsZoom: function (bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number
		bounds = toLatLngBounds(bounds);
		padding = toPoint(padding || [0, 0]);

		var zoom = this.getZoom() || 0,
			min = this.getMinZoom(),
			max = this.getMaxZoom(),
			nw = bounds.getNorthWest(),
			se = bounds.getSouthEast(),
			size = this.getSize().subtract(padding),
			boundsSize = toBounds(this.project(se, zoom), this.project(nw, zoom)).getSize(),
			snap = any3d ? this.options.zoomSnap : 1,
			scalex = size.x / boundsSize.x,
			scaley = size.y / boundsSize.y,
			scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);

		zoom = this.getScaleZoom(scale, zoom);

		if (snap) {
			zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level
			zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;
		}

		return Math.max(min, Math.min(max, zoom));
	},

	// @method getSize(): Point
	// Returns the current size of the map container (in pixels).
	getSize: function () {
		if (!this._size || this._sizeChanged) {
			this._size = new Point(
				this._container.clientWidth || 0,
				this._container.clientHeight || 0);

			this._sizeChanged = false;
		}
		return this._size.clone();
	},

	// @method getPixelBounds(): Bounds
	// Returns the bounds of the current map view in projected pixel
	// coordinates (sometimes useful in layer and overlay implementations).
	getPixelBounds: function (center, zoom) {
		var topLeftPoint = this._getTopLeftPoint(center, zoom);
		return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
	},

	// TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
	// the map pane? "left point of the map layer" can be confusing, specially
	// since there can be negative offsets.
	// @method getPixelOrigin(): Point
	// Returns the projected pixel coordinates of the top left point of
	// the map layer (useful in custom layer and overlay implementations).
	getPixelOrigin: function () {
		this._checkIfLoaded();
		return this._pixelOrigin;
	},

	// @method getPixelWorldBounds(zoom?: Number): Bounds
	// Returns the world's bounds in pixel coordinates for zoom level `zoom`.
	// If `zoom` is omitted, the map's current zoom level is used.
	getPixelWorldBounds: function (zoom) {
		return this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);
	},

	// @section Other Methods

	// @method getPane(pane: String|HTMLElement): HTMLElement
	// Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
	getPane: function (pane) {
		return typeof pane === 'string' ? this._panes[pane] : pane;
	},

	// @method getPanes(): Object
	// Returns a plain object containing the names of all [panes](#map-pane) as keys and
	// the panes as values.
	getPanes: function () {
		return this._panes;
	},

	// @method getContainer: HTMLElement
	// Returns the HTML element that contains the map.
	getContainer: function () {
		return this._container;
	},


	// @section Conversion Methods

	// @method getZoomScale(toZoom: Number, fromZoom: Number): Number
	// Returns the scale factor to be applied to a map transition from zoom level
	// `fromZoom` to `toZoom`. Used internally to help with zoom animations.
	getZoomScale: function (toZoom, fromZoom) {
		// TODO replace with universal implementation after refactoring projections
		var crs = this.options.crs;
		fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
		return crs.scale(toZoom) / crs.scale(fromZoom);
	},

	// @method getScaleZoom(scale: Number, fromZoom: Number): Number
	// Returns the zoom level that the map would end up at, if it is at `fromZoom`
	// level and everything is scaled by a factor of `scale`. Inverse of
	// [`getZoomScale`](#map-getZoomScale).
	getScaleZoom: function (scale, fromZoom) {
		var crs = this.options.crs;
		fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
		var zoom = crs.zoom(scale * crs.scale(fromZoom));
		return isNaN(zoom) ? Infinity : zoom;
	},

	// @method project(latlng: LatLng, zoom: Number): Point
	// Projects a geographical coordinate `LatLng` according to the projection
	// of the map's CRS, then scales it according to `zoom` and the CRS's
	// `Transformation`. The result is pixel coordinate relative to
	// the CRS origin.
	project: function (latlng, zoom) {
		zoom = zoom === undefined ? this._zoom : zoom;
		return this.options.crs.latLngToPoint(toLatLng(latlng), zoom);
	},

	// @method unproject(point: Point, zoom: Number): LatLng
	// Inverse of [`project`](#map-project).
	unproject: function (point, zoom) {
		zoom = zoom === undefined ? this._zoom : zoom;
		return this.options.crs.pointToLatLng(toPoint(point), zoom);
	},

	// @method layerPointToLatLng(point: Point): LatLng
	// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
	// returns the corresponding geographical coordinate (for the current zoom level).
	layerPointToLatLng: function (point) {
		var projectedPoint = toPoint(point).add(this.getPixelOrigin());
		return this.unproject(projectedPoint);
	},

	// @method latLngToLayerPoint(latlng: LatLng): Point
	// Given a geographical coordinate, returns the corresponding pixel coordinate
	// relative to the [origin pixel](#map-getpixelorigin).
	latLngToLayerPoint: function (latlng) {
		var projectedPoint = this.project(toLatLng(latlng))._round();
		return projectedPoint._subtract(this.getPixelOrigin());
	},

	// @method wrapLatLng(latlng: LatLng): LatLng
	// Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
	// map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
	// CRS's bounds.
	// By default this means longitude is wrapped around the dateline so its
	// value is between -180 and +180 degrees.
	wrapLatLng: function (latlng) {
		return this.options.crs.wrapLatLng(toLatLng(latlng));
	},

	// @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
	// Returns a `LatLngBounds` with the same size as the given one, ensuring that
	// its center is within the CRS's bounds.
	// By default this means the center longitude is wrapped around the dateline so its
	// value is between -180 and +180 degrees, and the majority of the bounds
	// overlaps the CRS's bounds.
	wrapLatLngBounds: function (latlng) {
		return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));
	},

	// @method distance(latlng1: LatLng, latlng2: LatLng): Number
	// Returns the distance between two geographical coordinates according to
	// the map's CRS. By default this measures distance in meters.
	distance: function (latlng1, latlng2) {
		return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));
	},

	// @method containerPointToLayerPoint(point: Point): Point
	// Given a pixel coordinate relative to the map container, returns the corresponding
	// pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
	containerPointToLayerPoint: function (point) { // (Point)
		return toPoint(point).subtract(this._getMapPanePos());
	},

	// @method layerPointToContainerPoint(point: Point): Point
	// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
	// returns the corresponding pixel coordinate relative to the map container.
	layerPointToContainerPoint: function (point) { // (Point)
		return toPoint(point).add(this._getMapPanePos());
	},

	// @method containerPointToLatLng(point: Point): LatLng
	// Given a pixel coordinate relative to the map container, returns
	// the corresponding geographical coordinate (for the current zoom level).
	containerPointToLatLng: function (point) {
		var layerPoint = this.containerPointToLayerPoint(toPoint(point));
		return this.layerPointToLatLng(layerPoint);
	},

	// @method latLngToContainerPoint(latlng: LatLng): Point
	// Given a geographical coordinate, returns the corresponding pixel coordinate
	// relative to the map container.
	latLngToContainerPoint: function (latlng) {
		return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));
	},

	// @method mouseEventToContainerPoint(ev: MouseEvent): Point
	// Given a MouseEvent object, returns the pixel coordinate relative to the
	// map container where the event took place.
	mouseEventToContainerPoint: function (e) {
		return getMousePosition(e, this._container);
	},

	// @method mouseEventToLayerPoint(ev: MouseEvent): Point
	// Given a MouseEvent object, returns the pixel coordinate relative to
	// the [origin pixel](#map-getpixelorigin) where the event took place.
	mouseEventToLayerPoint: function (e) {
		return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
	},

	// @method mouseEventToLatLng(ev: MouseEvent): LatLng
	// Given a MouseEvent object, returns geographical coordinate where the
	// event took place.
	mouseEventToLatLng: function (e) { // (MouseEvent)
		return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
	},


	// map initialization methods

	_initContainer: function (id) {
		var container = this._container = get(id);

		if (!container) {
			throw new Error('Map container not found.');
		} else if (container._leaflet_id) {
			throw new Error('Map container is already initialized.');
		}

		on(container, 'scroll', this._onScroll, this);
		this._containerId = stamp(container);
	},

	_initLayout: function () {
		var container = this._container;

		this._fadeAnimated = this.options.fadeAnimation && any3d;

		addClass(container, 'leaflet-container' +
			(touch ? ' leaflet-touch' : '') +
			(retina ? ' leaflet-retina' : '') +
			(ielt9 ? ' leaflet-oldie' : '') +
			(safari ? ' leaflet-safari' : '') +
			(this._fadeAnimated ? ' leaflet-fade-anim' : ''));

		var position = getStyle(container, 'position');

		if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {
			container.style.position = 'relative';
		}

		this._initPanes();

		if (this._initControlPos) {
			this._initControlPos();
		}
	},

	_initPanes: function () {
		var panes = this._panes = {};
		this._paneRenderers = {};

		// @section
		//
		// Panes are DOM elements used to control the ordering of layers on the map. You
		// can access panes with [`map.getPane`](#map-getpane) or
		// [`map.getPanes`](#map-getpanes) methods. New panes can be created with the
		// [`map.createPane`](#map-createpane) method.
		//
		// Every map has the following default panes that differ only in zIndex.
		//
		// @pane mapPane: HTMLElement = 'auto'
		// Pane that contains all other map panes

		this._mapPane = this.createPane('mapPane', this._container);
		setPosition(this._mapPane, new Point(0, 0));

		// @pane tilePane: HTMLElement = 200
		// Pane for `GridLayer`s and `TileLayer`s
		this.createPane('tilePane');
		// @pane overlayPane: HTMLElement = 400
		// Pane for vectors (`Path`s, like `Polyline`s and `Polygon`s), `ImageOverlay`s and `VideoOverlay`s
		this.createPane('shadowPane');
		// @pane shadowPane: HTMLElement = 500
		// Pane for overlay shadows (e.g. `Marker` shadows)
		this.createPane('overlayPane');
		// @pane markerPane: HTMLElement = 600
		// Pane for `Icon`s of `Marker`s
		this.createPane('markerPane');
		// @pane tooltipPane: HTMLElement = 650
		// Pane for `Tooltip`s.
		this.createPane('tooltipPane');
		// @pane popupPane: HTMLElement = 700
		// Pane for `Popup`s.
		this.createPane('popupPane');

		if (!this.options.markerZoomAnimation) {
			addClass(panes.markerPane, 'leaflet-zoom-hide');
			addClass(panes.shadowPane, 'leaflet-zoom-hide');
		}
	},


	// private methods that modify map state

	// @section Map state change events
	_resetView: function (center, zoom) {
		setPosition(this._mapPane, new Point(0, 0));

		var loading = !this._loaded;
		this._loaded = true;
		zoom = this._limitZoom(zoom);

		this.fire('viewprereset');

		var zoomChanged = this._zoom !== zoom;
		this
			._moveStart(zoomChanged, false)
			._move(center, zoom)
			._moveEnd(zoomChanged);

		// @event viewreset: Event
		// Fired when the map needs to redraw its content (this usually happens
		// on map zoom or load). Very useful for creating custom overlays.
		this.fire('viewreset');

		// @event load: Event
		// Fired when the map is initialized (when its center and zoom are set
		// for the first time).
		if (loading) {
			this.fire('load');
		}
	},

	_moveStart: function (zoomChanged, noMoveStart) {
		// @event zoomstart: Event
		// Fired when the map zoom is about to change (e.g. before zoom animation).
		// @event movestart: Event
		// Fired when the view of the map starts changing (e.g. user starts dragging the map).
		if (zoomChanged) {
			this.fire('zoomstart');
		}
		if (!noMoveStart) {
			this.fire('movestart');
		}
		return this;
	},

	_move: function (center, zoom, data) {
		if (zoom === undefined) {
			zoom = this._zoom;
		}
		var zoomChanged = this._zoom !== zoom;

		this._zoom = zoom;
		this._lastCenter = center;
		this._pixelOrigin = this._getNewPixelOrigin(center);

		// @event zoom: Event
		// Fired repeatedly during any change in zoom level, including zoom
		// and fly animations.
		if (zoomChanged || (data && data.pinch)) {	// Always fire 'zoom' if pinching because #3530
			this.fire('zoom', data);
		}

		// @event move: Event
		// Fired repeatedly during any movement of the map, including pan and
		// fly animations.
		return this.fire('move', data);
	},

	_moveEnd: function (zoomChanged) {
		// @event zoomend: Event
		// Fired when the map has changed, after any animations.
		if (zoomChanged) {
			this.fire('zoomend');
		}

		// @event moveend: Event
		// Fired when the center of the map stops changing (e.g. user stopped
		// dragging the map).
		return this.fire('moveend');
	},

	_stop: function () {
		cancelAnimFrame(this._flyToFrame);
		if (this._panAnim) {
			this._panAnim.stop();
		}
		return this;
	},

	_rawPanBy: function (offset) {
		setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
	},

	_getZoomSpan: function () {
		return this.getMaxZoom() - this.getMinZoom();
	},

	_panInsideMaxBounds: function () {
		if (!this._enforcingBounds) {
			this.panInsideBounds(this.options.maxBounds);
		}
	},

	_checkIfLoaded: function () {
		if (!this._loaded) {
			throw new Error('Set map center and zoom first.');
		}
	},

	// DOM event handling

	// @section Interaction events
	_initEvents: function (remove$$1) {
		this._targets = {};
		this._targets[stamp(this._container)] = this;

		var onOff = remove$$1 ? off : on;

		// @event click: MouseEvent
		// Fired when the user clicks (or taps) the map.
		// @event dblclick: MouseEvent
		// Fired when the user double-clicks (or double-taps) the map.
		// @event mousedown: MouseEvent
		// Fired when the user pushes the mouse button on the map.
		// @event mouseup: MouseEvent
		// Fired when the user releases the mouse button on the map.
		// @event mouseover: MouseEvent
		// Fired when the mouse enters the map.
		// @event mouseout: MouseEvent
		// Fired when the mouse leaves the map.
		// @event mousemove: MouseEvent
		// Fired while the mouse moves over the map.
		// @event contextmenu: MouseEvent
		// Fired when the user pushes the right mouse button on the map, prevents
		// default browser context menu from showing if there are listeners on
		// this event. Also fired on mobile when the user holds a single touch
		// for a second (also called long press).
		// @event keypress: KeyboardEvent
		// Fired when the user presses a key from the keyboard while the map is focused.
		onOff(this._container, 'click dblclick mousedown mouseup ' +
			'mouseover mouseout mousemove contextmenu keypress', this._handleDOMEvent, this);

		if (this.options.trackResize) {
			onOff(window, 'resize', this._onResize, this);
		}

		if (any3d && this.options.transform3DLimit) {
			(remove$$1 ? this.off : this.on).call(this, 'moveend', this._onMoveEnd);
		}
	},

	_onResize: function () {
		cancelAnimFrame(this._resizeRequest);
		this._resizeRequest = requestAnimFrame(
				function () { this.invalidateSize({debounceMoveend: true}); }, this);
	},

	_onScroll: function () {
		this._container.scrollTop  = 0;
		this._container.scrollLeft = 0;
	},

	_onMoveEnd: function () {
		var pos = this._getMapPanePos();
		if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
			// https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have
			// a pixel offset on very high values, see: http://jsfiddle.net/dg6r5hhb/
			this._resetView(this.getCenter(), this.getZoom());
		}
	},

	_findEventTargets: function (e, type) {
		var targets = [],
			target,
			isHover = type === 'mouseout' || type === 'mouseover',
			src = e.target || e.srcElement,
			dragging = false;

		while (src) {
			target = this._targets[stamp(src)];
			if (target && (type === 'click' || type === 'preclick') && !e._simulated && this._draggableMoved(target)) {
				// Prevent firing click after you just dragged an object.
				dragging = true;
				break;
			}
			if (target && target.listens(type, true)) {
				if (isHover && !isExternalTarget(src, e)) { break; }
				targets.push(target);
				if (isHover) { break; }
			}
			if (src === this._container) { break; }
			src = src.parentNode;
		}
		if (!targets.length && !dragging && !isHover && isExternalTarget(src, e)) {
			targets = [this];
		}
		return targets;
	},

	_handleDOMEvent: function (e) {
		if (!this._loaded || skipped(e)) { return; }

		var type = e.type;

		if (type === 'mousedown' || type === 'keypress') {
			// prevents outline when clicking on keyboard-focusable element
			preventOutline(e.target || e.srcElement);
		}

		this._fireDOMEvent(e, type);
	},

	_mouseEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu'],

	_fireDOMEvent: function (e, type, targets) {

		if (e.type === 'click') {
			// Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).
			// @event preclick: MouseEvent
			// Fired before mouse click on the map (sometimes useful when you
			// want something to happen on click before any existing click
			// handlers start running).
			var synth = extend({}, e);
			synth.type = 'preclick';
			this._fireDOMEvent(synth, synth.type, targets);
		}

		if (e._stopped) { return; }

		// Find the layer the event is propagating from and its parents.
		targets = (targets || []).concat(this._findEventTargets(e, type));

		if (!targets.length) { return; }

		var target = targets[0];
		if (type === 'contextmenu' && target.listens(type, true)) {
			preventDefault(e);
		}

		var data = {
			originalEvent: e
		};

		if (e.type !== 'keypress') {
			var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);
			data.containerPoint = isMarker ?
				this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
			data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
			data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
		}

		for (var i = 0; i < targets.length; i++) {
			targets[i].fire(type, data, true);
			if (data.originalEvent._stopped ||
				(targets[i].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1)) { return; }
		}
	},

	_draggableMoved: function (obj) {
		obj = obj.dragging && obj.dragging.enabled() ? obj : this;
		return (obj.dragging && obj.dragging.moved()) || (this.boxZoom && this.boxZoom.moved());
	},

	_clearHandlers: function () {
		for (var i = 0, len = this._handlers.length; i < len; i++) {
			this._handlers[i].disable();
		}
	},

	// @section Other Methods

	// @method whenReady(fn: Function, context?: Object): this
	// Runs the given function `fn` when the map gets initialized with
	// a view (center and zoom) and at least one layer, or immediately
	// if it's already initialized, optionally passing a function context.
	whenReady: function (callback, context) {
		if (this._loaded) {
			callback.call(context || this, {target: this});
		} else {
			this.on('load', callback, context);
		}
		return this;
	},


	// private methods for getting map state

	_getMapPanePos: function () {
		return getPosition(this._mapPane) || new Point(0, 0);
	},

	_moved: function () {
		var pos = this._getMapPanePos();
		return pos && !pos.equals([0, 0]);
	},

	_getTopLeftPoint: function (center, zoom) {
		var pixelOrigin = center && zoom !== undefined ?
			this._getNewPixelOrigin(center, zoom) :
			this.getPixelOrigin();
		return pixelOrigin.subtract(this._getMapPanePos());
	},

	_getNewPixelOrigin: function (center, zoom) {
		var viewHalf = this.getSize()._divideBy(2);
		return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();
	},

	_latLngToNewLayerPoint: function (latlng, zoom, center) {
		var topLeft = this._getNewPixelOrigin(center, zoom);
		return this.project(latlng, zoom)._subtract(topLeft);
	},

	_latLngBoundsToNewLayerBounds: function (latLngBounds, zoom, center) {
		var topLeft = this._getNewPixelOrigin(center, zoom);
		return toBounds([
			this.project(latLngBounds.getSouthWest(), zoom)._subtract(topLeft),
			this.project(latLngBounds.getNorthWest(), zoom)._subtract(topLeft),
			this.project(latLngBounds.getSouthEast(), zoom)._subtract(topLeft),
			this.project(latLngBounds.getNorthEast(), zoom)._subtract(topLeft)
		]);
	},

	// layer point of the current center
	_getCenterLayerPoint: function () {
		return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
	},

	// offset of the specified place to the current center in pixels
	_getCenterOffset: function (latlng) {
		return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
	},

	// adjust center for view to get inside bounds
	_limitCenter: function (center, zoom, bounds) {

		if (!bounds) { return center; }

		var centerPoint = this.project(center, zoom),
			viewHalf = this.getSize().divideBy(2),
			viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),
			offset = this._getBoundsOffset(viewBounds, bounds, zoom);

		// If offset is less than a pixel, ignore.
		// This prevents unstable projections from getting into
		// an infinite loop of tiny offsets.
		if (offset.round().equals([0, 0])) {
			return center;
		}

		return this.unproject(centerPoint.add(offset), zoom);
	},

	// adjust offset for view to get inside bounds
	_limitOffset: function (offset, bounds) {
		if (!bounds) { return offset; }

		var viewBounds = this.getPixelBounds(),
			newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));

		return offset.add(this._getBoundsOffset(newBounds, bounds));
	},

	// returns offset needed for pxBounds to get inside maxBounds at a specified zoom
	_getBoundsOffset: function (pxBounds, maxBounds, zoom) {
		var projectedMaxBounds = toBounds(
				this.project(maxBounds.getNorthEast(), zoom),
				this.project(maxBounds.getSouthWest(), zoom)
			),
			minOffset = projectedMaxBounds.min.subtract(pxBounds.min),
			maxOffset = projectedMaxBounds.max.subtract(pxBounds.max),

			dx = this._rebound(minOffset.x, -maxOffset.x),
			dy = this._rebound(minOffset.y, -maxOffset.y);

		return new Point(dx, dy);
	},

	_rebound: function (left, right) {
		return left + right > 0 ?
			Math.round(left - right) / 2 :
			Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
	},

	_limitZoom: function (zoom) {
		var min = this.getMinZoom(),
			max = this.getMaxZoom(),
			snap = any3d ? this.options.zoomSnap : 1;
		if (snap) {
			zoom = Math.round(zoom / snap) * snap;
		}
		return Math.max(min, Math.min(max, zoom));
	},

	_onPanTransitionStep: function () {
		this.fire('move');
	},

	_onPanTransitionEnd: function () {
		removeClass(this._mapPane, 'leaflet-pan-anim');
		this.fire('moveend');
	},

	_tryAnimatedPan: function (center, options) {
		// difference between the new and current centers in pixels
		var offset = this._getCenterOffset(center)._trunc();

		// don't animate too far unless animate: true specified in options
		if ((options && options.animate) !== true && !this.getSize().contains(offset)) { return false; }

		this.panBy(offset, options);

		return true;
	},

	_createAnimProxy: function () {

		var proxy = this._proxy = create$1('div', 'leaflet-proxy leaflet-zoom-animated');
		this._panes.mapPane.appendChild(proxy);

		this.on('zoomanim', function (e) {
			var prop = TRANSFORM,
				transform = this._proxy.style[prop];

			setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));

			// workaround for case when transform is the same and so transitionend event is not fired
			if (transform === this._proxy.style[prop] && this._animatingZoom) {
				this._onZoomTransitionEnd();
			}
		}, this);

		this.on('load moveend', function () {
			var c = this.getCenter(),
				z = this.getZoom();
			setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));
		}, this);

		this._on('unload', this._destroyAnimProxy, this);
	},

	_destroyAnimProxy: function () {
		remove(this._proxy);
		delete this._proxy;
	},

	_catchTransitionEnd: function (e) {
		if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {
			this._onZoomTransitionEnd();
		}
	},

	_nothingToAnimate: function () {
		return !this._container.getElementsByClassName('leaflet-zoom-animated').length;
	},

	_tryAnimatedZoom: function (center, zoom, options) {

		if (this._animatingZoom) { return true; }

		options = options || {};

		// don't animate if disabled, not supported or zoom difference is too large
		if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||
				Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) { return false; }

		// offset is the pixel coords of the zoom origin relative to the current center
		var scale = this.getZoomScale(zoom),
			offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);

		// don't animate if the zoom origin isn't within one screen from the current center, unless forced
		if (options.animate !== true && !this.getSize().contains(offset)) { return false; }

		requestAnimFrame(function () {
			this
				._moveStart(true, false)
				._animateZoom(center, zoom, true);
		}, this);

		return true;
	},

	_animateZoom: function (center, zoom, startAnim, noUpdate) {
		if (!this._mapPane) { return; }

		if (startAnim) {
			this._animatingZoom = true;

			// remember what center/zoom to set after animation
			this._animateToCenter = center;
			this._animateToZoom = zoom;

			addClass(this._mapPane, 'leaflet-zoom-anim');
		}

		// @event zoomanim: ZoomAnimEvent
		// Fired at least once per zoom animation. For continous zoom, like pinch zooming, fired once per frame during zoom.
		this.fire('zoomanim', {
			center: center,
			zoom: zoom,
			noUpdate: noUpdate
		});

		// Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693
		setTimeout(bind(this._onZoomTransitionEnd, this), 250);
	},

	_onZoomTransitionEnd: function () {
		if (!this._animatingZoom) { return; }

		if (this._mapPane) {
			removeClass(this._mapPane, 'leaflet-zoom-anim');
		}

		this._animatingZoom = false;

		this._move(this._animateToCenter, this._animateToZoom);

		// This anim frame should prevent an obscure iOS webkit tile loading race condition.
		requestAnimFrame(function () {
			this._moveEnd(true);
		}, this);
	}
});

// @section

// @factory L.map(id: String, options?: Map options)
// Instantiates a map object given the DOM ID of a `<div>` element
// and optionally an object literal with `Map options`.
//
// @alternative
// @factory L.map(el: HTMLElement, options?: Map options)
// Instantiates a map object given an instance of a `<div>` HTML element
// and optionally an object literal with `Map options`.
function createMap(id, options) {
	return new Map(id, options);
}

/*
 * @class Control
 * @aka L.Control
 * @inherits Class
 *
 * L.Control is a base class for implementing map controls. Handles positioning.
 * All other controls extend from this class.
 */

var Control = Class.extend({
	// @section
	// @aka Control options
	options: {
		// @option position: String = 'topright'
		// The position of the control (one of the map corners). Possible values are `'topleft'`,
		// `'topright'`, `'bottomleft'` or `'bottomright'`
		position: 'topright'
	},

	initialize: function (options) {
		setOptions(this, options);
	},

	/* @section
	 * Classes extending L.Control will inherit the following methods:
	 *
	 * @method getPosition: string
	 * Returns the position of the control.
	 */
	getPosition: function () {
		return this.options.position;
	},

	// @method setPosition(position: string): this
	// Sets the position of the control.
	setPosition: function (position) {
		var map = this._map;

		if (map) {
			map.removeControl(this);
		}

		this.options.position = position;

		if (map) {
			map.addControl(this);
		}

		return this;
	},

	// @method getContainer: HTMLElement
	// Returns the HTMLElement that contains the control.
	getContainer: function () {
		return this._container;
	},

	// @method addTo(map: Map): this
	// Adds the control to the given map.
	addTo: function (map) {
		this.remove();
		this._map = map;

		var container = this._container = this.onAdd(map),
			pos = this.getPosition(),
			corner = map._controlCorners[pos];

		addClass(container, 'leaflet-control');

		if (pos.indexOf('bottom') !== -1) {
			corner.insertBefore(container, corner.firstChild);
		} else {
			corner.appendChild(container);
		}

		return this;
	},

	// @method remove: this
	// Removes the control from the map it is currently active on.
	remove: function () {
		if (!this._map) {
			return this;
		}

		remove(this._container);

		if (this.onRemove) {
			this.onRemove(this._map);
		}

		this._map = null;

		return this;
	},

	_refocusOnMap: function (e) {
		// if map exists and event is not a keyboard event
		if (this._map && e && e.screenX > 0 && e.screenY > 0) {
			this._map.getContainer().focus();
		}
	}
});

var control = function (options) {
	return new Control(options);
};

/* @section Extension methods
 * @uninheritable
 *
 * Every control should extend from `L.Control` and (re-)implement the following methods.
 *
 * @method onAdd(map: Map): HTMLElement
 * Should return the container DOM element for the control and add listeners on relevant map events. Called on [`control.addTo(map)`](#control-addTo).
 *
 * @method onRemove(map: Map)
 * Optional method. Should contain all clean up code that removes the listeners previously added in [`onAdd`](#control-onadd). Called on [`control.remove()`](#control-remove).
 */

/* @namespace Map
 * @section Methods for Layers and Controls
 */
Map.include({
	// @method addControl(control: Control): this
	// Adds the given control to the map
	addControl: function (control) {
		control.addTo(this);
		return this;
	},

	// @method removeControl(control: Control): this
	// Removes the given control from the map
	removeControl: function (control) {
		control.remove();
		return this;
	},

	_initControlPos: function () {
		var corners = this._controlCorners = {},
			l = 'leaflet-',
			container = this._controlContainer =
					create$1('div', l + 'control-container', this._container);

		function createCorner(vSide, hSide) {
			var className = l + vSide + ' ' + l + hSide;

			corners[vSide + hSide] = create$1('div', className, container);
		}

		createCorner('top', 'left');
		createCorner('top', 'right');
		createCorner('bottom', 'left');
		createCorner('bottom', 'right');
	},

	_clearControlPos: function () {
		for (var i in this._controlCorners) {
			remove(this._controlCorners[i]);
		}
		remove(this._controlContainer);
		delete this._controlCorners;
		delete this._controlContainer;
	}
});

/*
 * @class Control.Layers
 * @aka L.Control.Layers
 * @inherits Control
 *
 * The layers control gives users the ability to switch between different base layers and switch overlays on/off (check out the [detailed example](http://leafletjs.com/examples/layers-control/)). Extends `Control`.
 *
 * @example
 *
 * ```js
 * var baseLayers = {
 * 	"Mapbox": mapbox,
 * 	"OpenStreetMap": osm
 * };
 *
 * var overlays = {
 * 	"Marker": marker,
 * 	"Roads": roadsLayer
 * };
 *
 * L.control.layers(baseLayers, overlays).addTo(map);
 * ```
 *
 * The `baseLayers` and `overlays` parameters are object literals with layer names as keys and `Layer` objects as values:
 *
 * ```js
 * {
 *     "<someName1>": layer1,
 *     "<someName2>": layer2
 * }
 * ```
 *
 * The layer names can contain HTML, which allows you to add additional styling to the items:
 *
 * ```js
 * {"<img src='my-layer-icon' /> <span class='my-layer-item'>My Layer</span>": myLayer}
 * ```
 */

var Layers = Control.extend({
	// @section
	// @aka Control.Layers options
	options: {
		// @option collapsed: Boolean = true
		// If `true`, the control will be collapsed into an icon and expanded on mouse hover or touch.
		collapsed: true,
		position: 'topright',

		// @option autoZIndex: Boolean = true
		// If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
		autoZIndex: true,

		// @option hideSingleBase: Boolean = false
		// If `true`, the base layers in the control will be hidden when there is only one.
		hideSingleBase: false,

		// @option sortLayers: Boolean = false
		// Whether to sort the layers. When `false`, layers will keep the order
		// in which they were added to the control.
		sortLayers: false,

		// @option sortFunction: Function = *
		// A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
		// that will be used for sorting the layers, when `sortLayers` is `true`.
		// The function receives both the `L.Layer` instances and their names, as in
		// `sortFunction(layerA, layerB, nameA, nameB)`.
		// By default, it sorts layers alphabetically by their name.
		sortFunction: function (layerA, layerB, nameA, nameB) {
			return nameA < nameB ? -1 : (nameB < nameA ? 1 : 0);
		}
	},

	initialize: function (baseLayers, overlays, options) {
		setOptions(this, options);

		this._layerControlInputs = [];
		this._layers = [];
		this._lastZIndex = 0;
		this._handlingClick = false;

		for (var i in baseLayers) {
			this._addLayer(baseLayers[i], i);
		}

		for (i in overlays) {
			this._addLayer(overlays[i], i, true);
		}
	},

	onAdd: function (map) {
		this._initLayout();
		this._update();

		this._map = map;
		map.on('zoomend', this._checkDisabledLayers, this);

		for (var i = 0; i < this._layers.length; i++) {
			this._layers[i].layer.on('add remove', this._onLayerChange, this);
		}

		return this._container;
	},

	addTo: function (map) {
		Control.prototype.addTo.call(this, map);
		// Trigger expand after Layers Control has been inserted into DOM so that is now has an actual height.
		return this._expandIfNotCollapsed();
	},

	onRemove: function () {
		this._map.off('zoomend', this._checkDisabledLayers, this);

		for (var i = 0; i < this._layers.length; i++) {
			this._layers[i].layer.off('add remove', this._onLayerChange, this);
		}
	},

	// @method addBaseLayer(layer: Layer, name: String): this
	// Adds a base layer (radio button entry) with the given name to the control.
	addBaseLayer: function (layer, name) {
		this._addLayer(layer, name);
		return (this._map) ? this._update() : this;
	},

	// @method addOverlay(layer: Layer, name: String): this
	// Adds an overlay (checkbox entry) with the given name to the control.
	addOverlay: function (layer, name) {
		this._addLayer(layer, name, true);
		return (this._map) ? this._update() : this;
	},

	// @method removeLayer(layer: Layer): this
	// Remove the given layer from the control.
	removeLayer: function (layer) {
		layer.off('add remove', this._onLayerChange, this);

		var obj = this._getLayer(stamp(layer));
		if (obj) {
			this._layers.splice(this._layers.indexOf(obj), 1);
		}
		return (this._map) ? this._update() : this;
	},

	// @method expand(): this
	// Expand the control container if collapsed.
	expand: function () {
		addClass(this._container, 'leaflet-control-layers-expanded');
		this._section.style.height = null;
		var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
		if (acceptableHeight < this._section.clientHeight) {
			addClass(this._section, 'leaflet-control-layers-scrollbar');
			this._section.style.height = acceptableHeight + 'px';
		} else {
			removeClass(this._section, 'leaflet-control-layers-scrollbar');
		}
		this._checkDisabledLayers();
		return this;
	},

	// @method collapse(): this
	// Collapse the control container if expanded.
	collapse: function () {
		removeClass(this._container, 'leaflet-control-layers-expanded');
		return this;
	},

	_initLayout: function () {
		var className = 'leaflet-control-layers',
			container = this._container = create$1('div', className),
			collapsed = this.options.collapsed;

		// makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released
		container.setAttribute('aria-haspopup', true);

		disableClickPropagation(container);
		disableScrollPropagation(container);

		var section = this._section = create$1('section', className + '-list');

		if (collapsed) {
			this._map.on('click', this.collapse, this);

			if (!android) {
				on(container, {
					mouseenter: this.expand,
					mouseleave: this.collapse
				}, this);
			}
		}

		var link = this._layersLink = create$1('a', className + '-toggle', container);
		link.href = '#';
		link.title = 'Layers';

		if (touch) {
			on(link, 'click', stop);
			on(link, 'click', this.expand, this);
		} else {
			on(link, 'focus', this.expand, this);
		}

		if (!collapsed) {
			this.expand();
		}

		this._baseLayersList = create$1('div', className + '-base', section);
		this._separator = create$1('div', className + '-separator', section);
		this._overlaysList = create$1('div', className + '-overlays', section);

		container.appendChild(section);
	},

	_getLayer: function (id) {
		for (var i = 0; i < this._layers.length; i++) {

			if (this._layers[i] && stamp(this._layers[i].layer) === id) {
				return this._layers[i];
			}
		}
	},

	_addLayer: function (layer, name, overlay) {
		if (this._map) {
			layer.on('add remove', this._onLayerChange, this);
		}

		this._layers.push({
			layer: layer,
			name: name,
			overlay: overlay
		});

		if (this.options.sortLayers) {
			this._layers.sort(bind(function (a, b) {
				return this.options.sortFunction(a.layer, b.layer, a.name, b.name);
			}, this));
		}

		if (this.options.autoZIndex && layer.setZIndex) {
			this._lastZIndex++;
			layer.setZIndex(this._lastZIndex);
		}

		this._expandIfNotCollapsed();
	},

	_update: function () {
		if (!this._container) { return this; }

		empty(this._baseLayersList);
		empty(this._overlaysList);

		this._layerControlInputs = [];
		var baseLayersPresent, overlaysPresent, i, obj, baseLayersCount = 0;

		for (i = 0; i < this._layers.length; i++) {
			obj = this._layers[i];
			this._addItem(obj);
			overlaysPresent = overlaysPresent || obj.overlay;
			baseLayersPresent = baseLayersPresent || !obj.overlay;
			baseLayersCount += !obj.overlay ? 1 : 0;
		}

		// Hide base layers section if there's only one layer.
		if (this.options.hideSingleBase) {
			baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
			this._baseLayersList.style.display = baseLayersPresent ? '' : 'none';
		}

		this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';

		return this;
	},

	_onLayerChange: function (e) {
		if (!this._handlingClick) {
			this._update();
		}

		var obj = this._getLayer(stamp(e.target));

		// @namespace Map
		// @section Layer events
		// @event baselayerchange: LayersControlEvent
		// Fired when the base layer is changed through the [layer control](#control-layers).
		// @event overlayadd: LayersControlEvent
		// Fired when an overlay is selected through the [layer control](#control-layers).
		// @event overlayremove: LayersControlEvent
		// Fired when an overlay is deselected through the [layer control](#control-layers).
		// @namespace Control.Layers
		var type = obj.overlay ?
			(e.type === 'add' ? 'overlayadd' : 'overlayremove') :
			(e.type === 'add' ? 'baselayerchange' : null);

		if (type) {
			this._map.fire(type, obj);
		}
	},

	// IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)
	_createRadioElement: function (name, checked) {

		var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' +
				name + '"' + (checked ? ' checked="checked"' : '') + '/>';

		var radioFragment = document.createElement('div');
		radioFragment.innerHTML = radioHtml;

		return radioFragment.firstChild;
	},

	_addItem: function (obj) {
		var label = document.createElement('label'),
			checked = this._map.hasLayer(obj.layer),
			input;

		if (obj.overlay) {
			input = document.createElement('input');
			input.type = 'checkbox';
			input.className = 'leaflet-control-layers-selector';
			input.defaultChecked = checked;
		} else {
			input = this._createRadioElement('leaflet-base-layers', checked);
		}

		this._layerControlInputs.push(input);
		input.layerId = stamp(obj.layer);

		on(input, 'click', this._onInputClick, this);

		var name = document.createElement('span');
		name.innerHTML = ' ' + obj.name;

		// Helps from preventing layer control flicker when checkboxes are disabled
		// https://github.com/Leaflet/Leaflet/issues/2771
		var holder = document.createElement('div');

		label.appendChild(holder);
		holder.appendChild(input);
		holder.appendChild(name);

		var container = obj.overlay ? this._overlaysList : this._baseLayersList;
		container.appendChild(label);

		this._checkDisabledLayers();
		return label;
	},

	_onInputClick: function () {
		var inputs = this._layerControlInputs,
			input, layer;
		var addedLayers = [],
			removedLayers = [];

		this._handlingClick = true;

		for (var i = inputs.length - 1; i >= 0; i--) {
			input = inputs[i];
			layer = this._getLayer(input.layerId).layer;

			if (input.checked) {
				addedLayers.push(layer);
			} else if (!input.checked) {
				removedLayers.push(layer);
			}
		}

		// Bugfix issue 2318: Should remove all old layers before readding new ones
		for (i = 0; i < removedLayers.length; i++) {
			if (this._map.hasLayer(removedLayers[i])) {
				this._map.removeLayer(removedLayers[i]);
			}
		}
		for (i = 0; i < addedLayers.length; i++) {
			if (!this._map.hasLayer(addedLayers[i])) {
				this._map.addLayer(addedLayers[i]);
			}
		}

		this._handlingClick = false;

		this._refocusOnMap();
	},

	_checkDisabledLayers: function () {
		var inputs = this._layerControlInputs,
			input,
			layer,
			zoom = this._map.getZoom();

		for (var i = inputs.length - 1; i >= 0; i--) {
			input = inputs[i];
			layer = this._getLayer(input.layerId).layer;
			input.disabled = (layer.options.minZoom !== undefined && zoom < layer.options.minZoom) ||
							 (layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom);

		}
	},

	_expandIfNotCollapsed: function () {
		if (this._map && !this.options.collapsed) {
			this.expand();
		}
		return this;
	},

	_expand: function () {
		// Backward compatibility, remove me in 1.1.
		return this.expand();
	},

	_collapse: function () {
		// Backward compatibility, remove me in 1.1.
		return this.collapse();
	}

});


// @factory L.control.layers(baselayers?: Object, overlays?: Object, options?: Control.Layers options)
// Creates an attribution control with the given layers. Base layers will be switched with radio buttons, while overlays will be switched with checkboxes. Note that all base layers should be passed in the base layers object, but only one should be added to the map during map instantiation.
var layers = function (baseLayers, overlays, options) {
	return new Layers(baseLayers, overlays, options);
};

/*
 * @class Control.Zoom
 * @aka L.Control.Zoom
 * @inherits Control
 *
 * A basic zoom control with two buttons (zoom in and zoom out). It is put on the map by default unless you set its [`zoomControl` option](#map-zoomcontrol) to `false`. Extends `Control`.
 */

var Zoom = Control.extend({
	// @section
	// @aka Control.Zoom options
	options: {
		position: 'topleft',

		// @option zoomInText: String = '+'
		// The text set on the 'zoom in' button.
		zoomInText: '+',

		// @option zoomInTitle: String = 'Zoom in'
		// The title set on the 'zoom in' button.
		zoomInTitle: 'Zoom in',

		// @option zoomOutText: String = '&#x2212;'
		// The text set on the 'zoom out' button.
		zoomOutText: '&#x2212;',

		// @option zoomOutTitle: String = 'Zoom out'
		// The title set on the 'zoom out' button.
		zoomOutTitle: 'Zoom out'
	},

	onAdd: function (map) {
		var zoomName = 'leaflet-control-zoom',
			container = create$1('div', zoomName + ' leaflet-bar'),
			options = this.options;

		this._zoomInButton  = this._createButton(options.zoomInText, options.zoomInTitle,
				zoomName + '-in',  container, this._zoomIn);
		this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle,
				zoomName + '-out', container, this._zoomOut);

		this._updateDisabled();
		map.on('zoomend zoomlevelschange', this._updateDisabled, this);

		return container;
	},

	onRemove: function (map) {
		map.off('zoomend zoomlevelschange', this._updateDisabled, this);
	},

	disable: function () {
		this._disabled = true;
		this._updateDisabled();
		return this;
	},

	enable: function () {
		this._disabled = false;
		this._updateDisabled();
		return this;
	},

	_zoomIn: function (e) {
		if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
			this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
		}
	},

	_zoomOut: function (e) {
		if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
			this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
		}
	},

	_createButton: function (html, title, className, container, fn) {
		var link = create$1('a', className, container);
		link.innerHTML = html;
		link.href = '#';
		link.title = title;

		/*
		 * Will force screen readers like VoiceOver to read this as "Zoom in - button"
		 */
		link.setAttribute('role', 'button');
		link.setAttribute('aria-label', title);

		disableClickPropagation(link);
		on(link, 'click', stop);
		on(link, 'click', fn, this);
		on(link, 'click', this._refocusOnMap, this);

		return link;
	},

	_updateDisabled: function () {
		var map = this._map,
			className = 'leaflet-disabled';

		removeClass(this._zoomInButton, className);
		removeClass(this._zoomOutButton, className);

		if (this._disabled || map._zoom === map.getMinZoom()) {
			addClass(this._zoomOutButton, className);
		}
		if (this._disabled || map._zoom === map.getMaxZoom()) {
			addClass(this._zoomInButton, className);
		}
	}
});

// @namespace Map
// @section Control options
// @option zoomControl: Boolean = true
// Whether a [zoom control](#control-zoom) is added to the map by default.
Map.mergeOptions({
	zoomControl: true
});

Map.addInitHook(function () {
	if (this.options.zoomControl) {
		// @section Controls
		// @property zoomControl: Control.Zoom
		// The default zoom control (only available if the
		// [`zoomControl` option](#map-zoomcontrol) was `true` when creating the map).
		this.zoomControl = new Zoom();
		this.addControl(this.zoomControl);
	}
});

// @namespace Control.Zoom
// @factory L.control.zoom(options: Control.Zoom options)
// Creates a zoom control
var zoom = function (options) {
	return new Zoom(options);
};

/*
 * @class Control.Scale
 * @aka L.Control.Scale
 * @inherits Control
 *
 * A simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems. Extends `Control`.
 *
 * @example
 *
 * ```js
 * L.control.scale().addTo(map);
 * ```
 */

var Scale = Control.extend({
	// @section
	// @aka Control.Scale options
	options: {
		position: 'bottomleft',

		// @option maxWidth: Number = 100
		// Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
		maxWidth: 100,

		// @option metric: Boolean = True
		// Whether to show the metric scale line (m/km).
		metric: true,

		// @option imperial: Boolean = True
		// Whether to show the imperial scale line (mi/ft).
		imperial: true

		// @option updateWhenIdle: Boolean = false
		// If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).
	},

	onAdd: function (map) {
		var className = 'leaflet-control-scale',
			container = create$1('div', className),
			options = this.options;

		this._addScales(options, className + '-line', container);

		map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
		map.whenReady(this._update, this);

		return container;
	},

	onRemove: function (map) {
		map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
	},

	_addScales: function (options, className, container) {
		if (options.metric) {
			this._mScale = create$1('div', className, container);
		}
		if (options.imperial) {
			this._iScale = create$1('div', className, container);
		}
	},

	_update: function () {
		var map = this._map,
			y = map.getSize().y / 2;

		var maxMeters = map.distance(
			map.containerPointToLatLng([0, y]),
			map.containerPointToLatLng([this.options.maxWidth, y]));

		this._updateScales(maxMeters);
	},

	_updateScales: function (maxMeters) {
		if (this.options.metric && maxMeters) {
			this._updateMetric(maxMeters);
		}
		if (this.options.imperial && maxMeters) {
			this._updateImperial(maxMeters);
		}
	},

	_updateMetric: function (maxMeters) {
		var meters = this._getRoundNum(maxMeters),
			label = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';

		this._updateScale(this._mScale, label, meters / maxMeters);
	},

	_updateImperial: function (maxMeters) {
		var maxFeet = maxMeters * 3.2808399,
			maxMiles, miles, feet;

		if (maxFeet > 5280) {
			maxMiles = maxFeet / 5280;
			miles = this._getRoundNum(maxMiles);
			this._updateScale(this._iScale, miles + ' mi', miles / maxMiles);

		} else {
			feet = this._getRoundNum(maxFeet);
			this._updateScale(this._iScale, feet + ' ft', feet / maxFeet);
		}
	},

	_updateScale: function (scale, text, ratio) {
		scale.style.width = Math.round(this.options.maxWidth * ratio) + 'px';
		scale.innerHTML = text;
	},

	_getRoundNum: function (num) {
		var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),
			d = num / pow10;

		d = d >= 10 ? 10 :
			d >= 5 ? 5 :
			d >= 3 ? 3 :
			d >= 2 ? 2 : 1;

		return pow10 * d;
	}
});


// @factory L.control.scale(options?: Control.Scale options)
// Creates an scale control with the given options.
var scale = function (options) {
	return new Scale(options);
};

/*
 * @class Control.Attribution
 * @aka L.Control.Attribution
 * @inherits Control
 *
 * The attribution control allows you to display attribution data in a small text box on a map. It is put on the map by default unless you set its [`attributionControl` option](#map-attributioncontrol) to `false`, and it fetches attribution texts from layers with the [`getAttribution` method](#layer-getattribution) automatically. Extends Control.
 */

var Attribution = Control.extend({
	// @section
	// @aka Control.Attribution options
	options: {
		position: 'bottomright',

		// @option prefix: String = 'Leaflet'
		// The HTML text shown before the attributions. Pass `false` to disable.
		prefix: '<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
	},

	initialize: function (options) {
		setOptions(this, options);

		this._attributions = {};
	},

	onAdd: function (map) {
		map.attributionControl = this;
		this._container = create$1('div', 'leaflet-control-attribution');
		disableClickPropagation(this._container);

		// TODO ugly, refactor
		for (var i in map._layers) {
			if (map._layers[i].getAttribution) {
				this.addAttribution(map._layers[i].getAttribution());
			}
		}

		this._update();

		return this._container;
	},

	// @method setPrefix(prefix: String): this
	// Sets the text before the attributions.
	setPrefix: function (prefix) {
		this.options.prefix = prefix;
		this._update();
		return this;
	},

	// @method addAttribution(text: String): this
	// Adds an attribution text (e.g. `'Vector data &copy; Mapbox'`).
	addAttribution: function (text) {
		if (!text) { return this; }

		if (!this._attributions[text]) {
			this._attributions[text] = 0;
		}
		this._attributions[text]++;

		this._update();

		return this;
	},

	// @method removeAttribution(text: String): this
	// Removes an attribution text.
	removeAttribution: function (text) {
		if (!text) { return this; }

		if (this._attributions[text]) {
			this._attributions[text]--;
			this._update();
		}

		return this;
	},

	_update: function () {
		if (!this._map) { return; }

		var attribs = [];

		for (var i in this._attributions) {
			if (this._attributions[i]) {
				attribs.push(i);
			}
		}

		var prefixAndAttribs = [];

		if (this.options.prefix) {
			prefixAndAttribs.push(this.options.prefix);
		}
		if (attribs.length) {
			prefixAndAttribs.push(attribs.join(', '));
		}

		this._container.innerHTML = prefixAndAttribs.join(' | ');
	}
});

// @namespace Map
// @section Control options
// @option attributionControl: Boolean = true
// Whether a [attribution control](#control-attribution) is added to the map by default.
Map.mergeOptions({
	attributionControl: true
});

Map.addInitHook(function () {
	if (this.options.attributionControl) {
		new Attribution().addTo(this);
	}
});

// @namespace Control.Attribution
// @factory L.control.attribution(options: Control.Attribution options)
// Creates an attribution control.
var attribution = function (options) {
	return new Attribution(options);
};

Control.Layers = Layers;
Control.Zoom = Zoom;
Control.Scale = Scale;
Control.Attribution = Attribution;

control.layers = layers;
control.zoom = zoom;
control.scale = scale;
control.attribution = attribution;

/*
	L.Handler is a base class for handler classes that are used internally to inject
	interaction features like dragging to classes like Map and Marker.
*/

// @class Handler
// @aka L.Handler
// Abstract class for map interaction handlers

var Handler = Class.extend({
	initialize: function (map) {
		this._map = map;
	},

	// @method enable(): this
	// Enables the handler
	enable: function () {
		if (this._enabled) { return this; }

		this._enabled = true;
		this.addHooks();
		return this;
	},

	// @method disable(): this
	// Disables the handler
	disable: function () {
		if (!this._enabled) { return this; }

		this._enabled = false;
		this.removeHooks();
		return this;
	},

	// @method enabled(): Boolean
	// Returns `true` if the handler is enabled
	enabled: function () {
		return !!this._enabled;
	}

	// @section Extension methods
	// Classes inheriting from `Handler` must implement the two following methods:
	// @method addHooks()
	// Called when the handler is enabled, should add event hooks.
	// @method removeHooks()
	// Called when the handler is disabled, should remove the event hooks added previously.
});

// @section There is static function which can be called without instantiating L.Handler:
// @function addTo(map: Map, name: String): this
// Adds a new Handler to the given map with the given name.
Handler.addTo = function (map, name) {
	map.addHandler(name, this);
	return this;
};

var Mixin = {Events: Events};

/*
 * @class Draggable
 * @aka L.Draggable
 * @inherits Evented
 *
 * A class for making DOM elements draggable (including touch support).
 * Used internally for map and marker dragging. Only works for elements
 * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).
 *
 * @example
 * ```js
 * var draggable = new L.Draggable(elementToDrag);
 * draggable.enable();
 * ```
 */

var START = touch ? 'touchstart mousedown' : 'mousedown';
var END = {
	mousedown: 'mouseup',
	touchstart: 'touchend',
	pointerdown: 'touchend',
	MSPointerDown: 'touchend'
};
var MOVE = {
	mousedown: 'mousemove',
	touchstart: 'touchmove',
	pointerdown: 'touchmove',
	MSPointerDown: 'touchmove'
};


var Draggable = Evented.extend({

	options: {
		// @section
		// @aka Draggable options
		// @option clickTolerance: Number = 3
		// The max number of pixels a user can shift the mouse pointer during a click
		// for it to be considered a valid click (as opposed to a mouse drag).
		clickTolerance: 3
	},

	// @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)
	// Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
	initialize: function (element, dragStartTarget, preventOutline$$1, options) {
		setOptions(this, options);

		this._element = element;
		this._dragStartTarget = dragStartTarget || element;
		this._preventOutline = preventOutline$$1;
	},

	// @method enable()
	// Enables the dragging ability
	enable: function () {
		if (this._enabled) { return; }

		on(this._dragStartTarget, START, this._onDown, this);

		this._enabled = true;
	},

	// @method disable()
	// Disables the dragging ability
	disable: function () {
		if (!this._enabled) { return; }

		// If we're currently dragging this draggable,
		// disabling it counts as first ending the drag.
		if (Draggable._dragging === this) {
			this.finishDrag();
		}

		off(this._dragStartTarget, START, this._onDown, this);

		this._enabled = false;
		this._moved = false;
	},

	_onDown: function (e) {
		// Ignore simulated events, since we handle both touch and
		// mouse explicitly; otherwise we risk getting duplicates of
		// touch events, see #4315.
		// Also ignore the event if disabled; this happens in IE11
		// under some circumstances, see #3666.
		if (e._simulated || !this._enabled) { return; }

		this._moved = false;

		if (hasClass(this._element, 'leaflet-zoom-anim')) { return; }

		if (Draggable._dragging || e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches)) { return; }
		Draggable._dragging = this;  // Prevent dragging multiple objects at once.

		if (this._preventOutline) {
			preventOutline(this._element);
		}

		disableImageDrag();
		disableTextSelection();

		if (this._moving) { return; }

		// @event down: Event
		// Fired when a drag is about to start.
		this.fire('down');

		var first = e.touches ? e.touches[0] : e,
			sizedParent = getSizedParentNode(this._element);

		this._startPoint = new Point(first.clientX, first.clientY);

		// Cache the scale, so that we can continuously compensate for it during drag (_onMove).
		this._parentScale = getScale(sizedParent);

		on(document, MOVE[e.type], this._onMove, this);
		on(document, END[e.type], this._onUp, this);
	},

	_onMove: function (e) {
		// Ignore simulated events, since we handle both touch and
		// mouse explicitly; otherwise we risk getting duplicates of
		// touch events, see #4315.
		// Also ignore the event if disabled; this happens in IE11
		// under some circumstances, see #3666.
		if (e._simulated || !this._enabled) { return; }

		if (e.touches && e.touches.length > 1) {
			this._moved = true;
			return;
		}

		var first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),
			offset = new Point(first.clientX, first.clientY)._subtract(this._startPoint);

		if (!offset.x && !offset.y) { return; }
		if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) { return; }

		// We assume that the parent container's position, border and scale do not change for the duration of the drag.
		// Therefore there is no need to account for the position and border (they are eliminated by the subtraction)
		// and we can use the cached value for the scale.
		offset.x /= this._parentScale.x;
		offset.y /= this._parentScale.y;

		preventDefault(e);

		if (!this._moved) {
			// @event dragstart: Event
			// Fired when a drag starts
			this.fire('dragstart');

			this._moved = true;
			this._startPos = getPosition(this._element).subtract(offset);

			addClass(document.body, 'leaflet-dragging');

			this._lastTarget = e.target || e.srcElement;
			// IE and Edge do not give the <use> element, so fetch it
			// if necessary
			if ((window.SVGElementInstance) && (this._lastTarget instanceof SVGElementInstance)) {
				this._lastTarget = this._lastTarget.correspondingUseElement;
			}
			addClass(this._lastTarget, 'leaflet-drag-target');
		}

		this._newPos = this._startPos.add(offset);
		this._moving = true;

		cancelAnimFrame(this._animRequest);
		this._lastEvent = e;
		this._animRequest = requestAnimFrame(this._updatePosition, this, true);
	},

	_updatePosition: function () {
		var e = {originalEvent: this._lastEvent};

		// @event predrag: Event
		// Fired continuously during dragging *before* each corresponding
		// update of the element's position.
		this.fire('predrag', e);
		setPosition(this._element, this._newPos);

		// @event drag: Event
		// Fired continuously during dragging.
		this.fire('drag', e);
	},

	_onUp: function (e) {
		// Ignore simulated events, since we handle both touch and
		// mouse explicitly; otherwise we risk getting duplicates of
		// touch events, see #4315.
		// Also ignore the event if disabled; this happens in IE11
		// under some circumstances, see #3666.
		if (e._simulated || !this._enabled) { return; }
		this.finishDrag();
	},

	finishDrag: function () {
		removeClass(document.body, 'leaflet-dragging');

		if (this._lastTarget) {
			removeClass(this._lastTarget, 'leaflet-drag-target');
			this._lastTarget = null;
		}

		for (var i in MOVE) {
			off(document, MOVE[i], this._onMove, this);
			off(document, END[i], this._onUp, this);
		}

		enableImageDrag();
		enableTextSelection();

		if (this._moved && this._moving) {
			// ensure drag is not fired after dragend
			cancelAnimFrame(this._animRequest);

			// @event dragend: DragEndEvent
			// Fired when the drag ends.
			this.fire('dragend', {
				distance: this._newPos.distanceTo(this._startPos)
			});
		}

		this._moving = false;
		Draggable._dragging = false;
	}

});

/*
 * @namespace LineUtil
 *
 * Various utility functions for polyline points processing, used by Leaflet internally to make polylines lightning-fast.
 */

// Simplify polyline with vertex reduction and Douglas-Peucker simplification.
// Improves rendering performance dramatically by lessening the number of points to draw.

// @function simplify(points: Point[], tolerance: Number): Point[]
// Dramatically reduces the number of points in a polyline while retaining
// its shape and returns a new array of simplified points, using the
// [Douglas-Peucker algorithm](http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm).
// Used for a huge performance boost when processing/displaying Leaflet polylines for
// each zoom level and also reducing visual noise. tolerance affects the amount of
// simplification (lesser value means higher quality but slower and with more points).
// Also released as a separated micro-library [Simplify.js](http://mourner.github.com/simplify-js/).
function simplify(points, tolerance) {
	if (!tolerance || !points.length) {
		return points.slice();
	}

	var sqTolerance = tolerance * tolerance;

		// stage 1: vertex reduction
		points = _reducePoints(points, sqTolerance);

		// stage 2: Douglas-Peucker simplification
		points = _simplifyDP(points, sqTolerance);

	return points;
}

// @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number
// Returns the distance between point `p` and segment `p1` to `p2`.
function pointToSegmentDistance(p, p1, p2) {
	return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));
}

// @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number
// Returns the closest point from a point `p` on a segment `p1` to `p2`.
function closestPointOnSegment(p, p1, p2) {
	return _sqClosestPointOnSegment(p, p1, p2);
}

// Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm
function _simplifyDP(points, sqTolerance) {

	var len = points.length,
		ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,
		markers = new ArrayConstructor(len);

		markers[0] = markers[len - 1] = 1;

	_simplifyDPStep(points, markers, sqTolerance, 0, len - 1);

	var i,
		newPoints = [];

	for (i = 0; i < len; i++) {
		if (markers[i]) {
			newPoints.push(points[i]);
		}
	}

	return newPoints;
}

function _simplifyDPStep(points, markers, sqTolerance, first, last) {

	var maxSqDist = 0,
	index, i, sqDist;

	for (i = first + 1; i <= last - 1; i++) {
		sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);

		if (sqDist > maxSqDist) {
			index = i;
			maxSqDist = sqDist;
		}
	}

	if (maxSqDist > sqTolerance) {
		markers[index] = 1;

		_simplifyDPStep(points, markers, sqTolerance, first, index);
		_simplifyDPStep(points, markers, sqTolerance, index, last);
	}
}

// reduce points that are too close to each other to a single point
function _reducePoints(points, sqTolerance) {
	var reducedPoints = [points[0]];

	for (var i = 1, prev = 0, len = points.length; i < len; i++) {
		if (_sqDist(points[i], points[prev]) > sqTolerance) {
			reducedPoints.push(points[i]);
			prev = i;
		}
	}
	if (prev < len - 1) {
		reducedPoints.push(points[len - 1]);
	}
	return reducedPoints;
}

var _lastCode;

// @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean
// Clips the segment a to b by rectangular bounds with the
// [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)
// (modifying the segment points directly!). Used by Leaflet to only show polyline
// points that are on the screen or near, increasing performance.
function clipSegment(a, b, bounds, useLastCode, round) {
	var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds),
		codeB = _getBitCode(b, bounds),

		codeOut, p, newCode;

		// save 2nd code to avoid calculating it on the next segment
		_lastCode = codeB;

	while (true) {
		// if a,b is inside the clip window (trivial accept)
		if (!(codeA | codeB)) {
			return [a, b];
		}

		// if a,b is outside the clip window (trivial reject)
		if (codeA & codeB) {
			return false;
		}

		// other cases
		codeOut = codeA || codeB;
		p = _getEdgeIntersection(a, b, codeOut, bounds, round);
		newCode = _getBitCode(p, bounds);

		if (codeOut === codeA) {
			a = p;
			codeA = newCode;
		} else {
			b = p;
			codeB = newCode;
		}
	}
}

function _getEdgeIntersection(a, b, code, bounds, round) {
	var dx = b.x - a.x,
		dy = b.y - a.y,
		min = bounds.min,
		max = bounds.max,
		x, y;

	if (code & 8) { // top
		x = a.x + dx * (max.y - a.y) / dy;
		y = max.y;

	} else if (code & 4) { // bottom
		x = a.x + dx * (min.y - a.y) / dy;
		y = min.y;

	} else if (code & 2) { // right
		x = max.x;
		y = a.y + dy * (max.x - a.x) / dx;

	} else if (code & 1) { // left
		x = min.x;
		y = a.y + dy * (min.x - a.x) / dx;
	}

	return new Point(x, y, round);
}

function _getBitCode(p, bounds) {
	var code = 0;

	if (p.x < bounds.min.x) { // left
		code |= 1;
	} else if (p.x > bounds.max.x) { // right
		code |= 2;
	}

	if (p.y < bounds.min.y) { // bottom
		code |= 4;
	} else if (p.y > bounds.max.y) { // top
		code |= 8;
	}

	return code;
}

// square distance (to avoid unnecessary Math.sqrt calls)
function _sqDist(p1, p2) {
	var dx = p2.x - p1.x,
		dy = p2.y - p1.y;
	return dx * dx + dy * dy;
}

// return closest point on segment or distance to that point
function _sqClosestPointOnSegment(p, p1, p2, sqDist) {
	var x = p1.x,
		y = p1.y,
		dx = p2.x - x,
		dy = p2.y - y,
		dot = dx * dx + dy * dy,
		t;

	if (dot > 0) {
		t = ((p.x - x) * dx + (p.y - y) * dy) / dot;

		if (t > 1) {
			x = p2.x;
			y = p2.y;
		} else if (t > 0) {
			x += dx * t;
			y += dy * t;
		}
	}

	dx = p.x - x;
	dy = p.y - y;

	return sqDist ? dx * dx + dy * dy : new Point(x, y);
}


// @function isFlat(latlngs: LatLng[]): Boolean
// Returns true if `latlngs` is a flat array, false is nested.
function isFlat(latlngs) {
	return !isArray(latlngs[0]) || (typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined');
}

function _flat(latlngs) {
	console.warn('Deprecated use of _flat, please use L.LineUtil.isFlat instead.');
	return isFlat(latlngs);
}


var LineUtil = (Object.freeze || Object)({
	simplify: simplify,
	pointToSegmentDistance: pointToSegmentDistance,
	closestPointOnSegment: closestPointOnSegment,
	clipSegment: clipSegment,
	_getEdgeIntersection: _getEdgeIntersection,
	_getBitCode: _getBitCode,
	_sqClosestPointOnSegment: _sqClosestPointOnSegment,
	isFlat: isFlat,
	_flat: _flat
});

/*
 * @namespace PolyUtil
 * Various utility functions for polygon geometries.
 */

/* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]
 * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).
 * Used by Leaflet to only show polygon points that are on the screen or near, increasing
 * performance. Note that polygon points needs different algorithm for clipping
 * than polyline, so there's a separate method for it.
 */
function clipPolygon(points, bounds, round) {
	var clippedPoints,
		edges = [1, 4, 2, 8],
		i, j, k,
		a, b,
		len, edge, p;

	for (i = 0, len = points.length; i < len; i++) {
		points[i]._code = _getBitCode(points[i], bounds);
	}

	// for each edge (left, bottom, right, top)
	for (k = 0; k < 4; k++) {
		edge = edges[k];
		clippedPoints = [];

		for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
			a = points[i];
			b = points[j];

			// if a is inside the clip window
			if (!(a._code & edge)) {
				// if b is outside the clip window (a->b goes out of screen)
				if (b._code & edge) {
					p = _getEdgeIntersection(b, a, edge, bounds, round);
					p._code = _getBitCode(p, bounds);
					clippedPoints.push(p);
				}
				clippedPoints.push(a);

			// else if b is inside the clip window (a->b enters the screen)
			} else if (!(b._code & edge)) {
				p = _getEdgeIntersection(b, a, edge, bounds, round);
				p._code = _getBitCode(p, bounds);
				clippedPoints.push(p);
			}
		}
		points = clippedPoints;
	}

	return points;
}


var PolyUtil = (Object.freeze || Object)({
	clipPolygon: clipPolygon
});

/*
 * @namespace Projection
 * @section
 * Leaflet comes with a set of already defined Projections out of the box:
 *
 * @projection L.Projection.LonLat
 *
 * Equirectangular, or Plate Carree projection — the most simple projection,
 * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as
 * latitude. Also suitable for flat worlds, e.g. game maps. Used by the
 * `EPSG:4326` and `Simple` CRS.
 */

var LonLat = {
	project: function (latlng) {
		return new Point(latlng.lng, latlng.lat);
	},

	unproject: function (point) {
		return new LatLng(point.y, point.x);
	},

	bounds: new Bounds([-180, -90], [180, 90])
};

/*
 * @namespace Projection
 * @projection L.Projection.Mercator
 *
 * Elliptical Mercator projection — more complex than Spherical Mercator. Takes into account that Earth is a geoid, not a perfect sphere. Used by the EPSG:3395 CRS.
 */

var Mercator = {
	R: 6378137,
	R_MINOR: 6356752.314245179,

	bounds: new Bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),

	project: function (latlng) {
		var d = Math.PI / 180,
			r = this.R,
			y = latlng.lat * d,
			tmp = this.R_MINOR / r,
			e = Math.sqrt(1 - tmp * tmp),
			con = e * Math.sin(y);

		var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
		y = -r * Math.log(Math.max(ts, 1E-10));

		return new Point(latlng.lng * d * r, y);
	},

	unproject: function (point) {
		var d = 180 / Math.PI,
			r = this.R,
			tmp = this.R_MINOR / r,
			e = Math.sqrt(1 - tmp * tmp),
			ts = Math.exp(-point.y / r),
			phi = Math.PI / 2 - 2 * Math.atan(ts);

		for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
			con = e * Math.sin(phi);
			con = Math.pow((1 - con) / (1 + con), e / 2);
			dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
			phi += dphi;
		}

		return new LatLng(phi * d, point.x * d / r);
	}
};

/*
 * @class Projection

 * An object with methods for projecting geographical coordinates of the world onto
 * a flat surface (and back). See [Map projection](http://en.wikipedia.org/wiki/Map_projection).

 * @property bounds: Bounds
 * The bounds (specified in CRS units) where the projection is valid

 * @method project(latlng: LatLng): Point
 * Projects geographical coordinates into a 2D point.
 * Only accepts actual `L.LatLng` instances, not arrays.

 * @method unproject(point: Point): LatLng
 * The inverse of `project`. Projects a 2D point into a geographical location.
 * Only accepts actual `L.Point` instances, not arrays.

 * Note that the projection instances do not inherit from Leafet's `Class` object,
 * and can't be instantiated. Also, new classes can't inherit from them,
 * and methods can't be added to them with the `include` function.

 */




var index = (Object.freeze || Object)({
	LonLat: LonLat,
	Mercator: Mercator,
	SphericalMercator: SphericalMercator
});

/*
 * @namespace CRS
 * @crs L.CRS.EPSG3395
 *
 * Rarely used by some commercial tile providers. Uses Elliptical Mercator projection.
 */
var EPSG3395 = extend({}, Earth, {
	code: 'EPSG:3395',
	projection: Mercator,

	transformation: (function () {
		var scale = 0.5 / (Math.PI * Mercator.R);
		return toTransformation(scale, 0.5, -scale, 0.5);
	}())
});

/*
 * @namespace CRS
 * @crs L.CRS.EPSG4326
 *
 * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.
 *
 * Leaflet 1.0.x complies with the [TMS coordinate scheme for EPSG:4326](https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification#global-geodetic),
 * which is a breaking change from 0.7.x behaviour.  If you are using a `TileLayer`
 * with this CRS, ensure that there are two 256x256 pixel tiles covering the
 * whole earth at zoom level zero, and that the tile coordinate origin is (-180,+90),
 * or (-180,-90) for `TileLayer`s with [the `tms` option](#tilelayer-tms) set.
 */

var EPSG4326 = extend({}, Earth, {
	code: 'EPSG:4326',
	projection: LonLat,
	transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)
});

/*
 * @namespace CRS
 * @crs L.CRS.Simple
 *
 * A simple CRS that maps longitude and latitude into `x` and `y` directly.
 * May be used for maps of flat surfaces (e.g. game maps). Note that the `y`
 * axis should still be inverted (going from bottom to top). `distance()` returns
 * simple euclidean distance.
 */

var Simple = extend({}, CRS, {
	projection: LonLat,
	transformation: toTransformation(1, 0, -1, 0),

	scale: function (zoom) {
		return Math.pow(2, zoom);
	},

	zoom: function (scale) {
		return Math.log(scale) / Math.LN2;
	},

	distance: function (latlng1, latlng2) {
		var dx = latlng2.lng - latlng1.lng,
			dy = latlng2.lat - latlng1.lat;

		return Math.sqrt(dx * dx + dy * dy);
	},

	infinite: true
});

CRS.Earth = Earth;
CRS.EPSG3395 = EPSG3395;
CRS.EPSG3857 = EPSG3857;
CRS.EPSG900913 = EPSG900913;
CRS.EPSG4326 = EPSG4326;
CRS.Simple = Simple;

/*
 * @class Layer
 * @inherits Evented
 * @aka L.Layer
 * @aka ILayer
 *
 * A set of methods from the Layer base class that all Leaflet layers use.
 * Inherits all methods, options and events from `L.Evented`.
 *
 * @example
 *
 * ```js
 * var layer = L.Marker(latlng).addTo(map);
 * layer.addTo(map);
 * layer.remove();
 * ```
 *
 * @event add: Event
 * Fired after the layer is added to a map
 *
 * @event remove: Event
 * Fired after the layer is removed from a map
 */


var Layer = Evented.extend({

	// Classes extending `L.Layer` will inherit the following options:
	options: {
		// @option pane: String = 'overlayPane'
		// By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
		pane: 'overlayPane',

		// @option attribution: String = null
		// String to be shown in the attribution control, e.g. "© OpenStreetMap contributors". It describes the layer data and is often a legal obligation towards copyright holders and tile providers.
		attribution: null,

		bubblingMouseEvents: true
	},

	/* @section
	 * Classes extending `L.Layer` will inherit the following methods:
	 *
	 * @method addTo(map: Map|LayerGroup): this
	 * Adds the layer to the given map or layer group.
	 */
	addTo: function (map) {
		map.addLayer(this);
		return this;
	},

	// @method remove: this
	// Removes the layer from the map it is currently active on.
	remove: function () {
		return this.removeFrom(this._map || this._mapToAdd);
	},

	// @method removeFrom(map: Map): this
	// Removes the layer from the given map
	removeFrom: function (obj) {
		if (obj) {
			obj.removeLayer(this);
		}
		return this;
	},

	// @method getPane(name? : String): HTMLElement
	// Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
	getPane: function (name) {
		return this._map.getPane(name ? (this.options[name] || name) : this.options.pane);
	},

	addInteractiveTarget: function (targetEl) {
		this._map._targets[stamp(targetEl)] = this;
		return this;
	},

	removeInteractiveTarget: function (targetEl) {
		delete this._map._targets[stamp(targetEl)];
		return this;
	},

	// @method getAttribution: String
	// Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
	getAttribution: function () {
		return this.options.attribution;
	},

	_layerAdd: function (e) {
		var map = e.target;

		// check in case layer gets added and then removed before the map is ready
		if (!map.hasLayer(this)) { return; }

		this._map = map;
		this._zoomAnimated = map._zoomAnimated;

		if (this.getEvents) {
			var events = this.getEvents();
			map.on(events, this);
			this.once('remove', function () {
				map.off(events, this);
			}, this);
		}

		this.onAdd(map);

		if (this.getAttribution && map.attributionControl) {
			map.attributionControl.addAttribution(this.getAttribution());
		}

		this.fire('add');
		map.fire('layeradd', {layer: this});
	}
});

/* @section Extension methods
 * @uninheritable
 *
 * Every layer should extend from `L.Layer` and (re-)implement the following methods.
 *
 * @method onAdd(map: Map): this
 * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on [`map.addLayer(layer)`](#map-addlayer).
 *
 * @method onRemove(map: Map): this
 * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in [`onAdd`](#layer-onadd). Called on [`map.removeLayer(layer)`](#map-removelayer).
 *
 * @method getEvents(): Object
 * This optional method should return an object like `{ viewreset: this._reset }` for [`addEventListener`](#evented-addeventlistener). The event handlers in this object will be automatically added and removed from the map with your layer.
 *
 * @method getAttribution(): String
 * This optional method should return a string containing HTML to be shown on the `Attribution control` whenever the layer is visible.
 *
 * @method beforeAdd(map: Map): this
 * Optional method. Called on [`map.addLayer(layer)`](#map-addlayer), before the layer is added to the map, before events are initialized, without waiting until the map is in a usable state. Use for early initialization only.
 */


/* @namespace Map
 * @section Layer events
 *
 * @event layeradd: LayerEvent
 * Fired when a new layer is added to the map.
 *
 * @event layerremove: LayerEvent
 * Fired when some layer is removed from the map
 *
 * @section Methods for Layers and Controls
 */
Map.include({
	// @method addLayer(layer: Layer): this
	// Adds the given layer to the map
	addLayer: function (layer) {
		if (!layer._layerAdd) {
			throw new Error('The provided object is not a Layer.');
		}

		var id = stamp(layer);
		if (this._layers[id]) { return this; }
		this._layers[id] = layer;

		layer._mapToAdd = this;

		if (layer.beforeAdd) {
			layer.beforeAdd(this);
		}

		this.whenReady(layer._layerAdd, layer);

		return this;
	},

	// @method removeLayer(layer: Layer): this
	// Removes the given layer from the map.
	removeLayer: function (layer) {
		var id = stamp(layer);

		if (!this._layers[id]) { return this; }

		if (this._loaded) {
			layer.onRemove(this);
		}

		if (layer.getAttribution && this.attributionControl) {
			this.attributionControl.removeAttribution(layer.getAttribution());
		}

		delete this._layers[id];

		if (this._loaded) {
			this.fire('layerremove', {layer: layer});
			layer.fire('remove');
		}

		layer._map = layer._mapToAdd = null;

		return this;
	},

	// @method hasLayer(layer: Layer): Boolean
	// Returns `true` if the given layer is currently added to the map
	hasLayer: function (layer) {
		return !!layer && (stamp(layer) in this._layers);
	},

	/* @method eachLayer(fn: Function, context?: Object): this
	 * Iterates over the layers of the map, optionally specifying context of the iterator function.
	 * ```
	 * map.eachLayer(function(layer){
	 *     layer.bindPopup('Hello');
	 * });
	 * ```
	 */
	eachLayer: function (method, context) {
		for (var i in this._layers) {
			method.call(context, this._layers[i]);
		}
		return this;
	},

	_addLayers: function (layers) {
		layers = layers ? (isArray(layers) ? layers : [layers]) : [];

		for (var i = 0, len = layers.length; i < len; i++) {
			this.addLayer(layers[i]);
		}
	},

	_addZoomLimit: function (layer) {
		if (isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
			this._zoomBoundLayers[stamp(layer)] = layer;
			this._updateZoomLevels();
		}
	},

	_removeZoomLimit: function (layer) {
		var id = stamp(layer);

		if (this._zoomBoundLayers[id]) {
			delete this._zoomBoundLayers[id];
			this._updateZoomLevels();
		}
	},

	_updateZoomLevels: function () {
		var minZoom = Infinity,
			maxZoom = -Infinity,
			oldZoomSpan = this._getZoomSpan();

		for (var i in this._zoomBoundLayers) {
			var options = this._zoomBoundLayers[i].options;

			minZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);
			maxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);
		}

		this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;
		this._layersMinZoom = minZoom === Infinity ? undefined : minZoom;

		// @section Map state change events
		// @event zoomlevelschange: Event
		// Fired when the number of zoomlevels on the map is changed due
		// to adding or removing a layer.
		if (oldZoomSpan !== this._getZoomSpan()) {
			this.fire('zoomlevelschange');
		}

		if (this.options.maxZoom === undefined && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {
			this.setZoom(this._layersMaxZoom);
		}
		if (this.options.minZoom === undefined && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {
			this.setZoom(this._layersMinZoom);
		}
	}
});

/*
 * @class LayerGroup
 * @aka L.LayerGroup
 * @inherits Layer
 *
 * Used to group several layers and handle them as one. If you add it to the map,
 * any layers added or removed from the group will be added/removed on the map as
 * well. Extends `Layer`.
 *
 * @example
 *
 * ```js
 * L.layerGroup([marker1, marker2])
 * 	.addLayer(polyline)
 * 	.addTo(map);
 * ```
 */

var LayerGroup = Layer.extend({

	initialize: function (layers, options) {
		setOptions(this, options);

		this._layers = {};

		var i, len;

		if (layers) {
			for (i = 0, len = layers.length; i < len; i++) {
				this.addLayer(layers[i]);
			}
		}
	},

	// @method addLayer(layer: Layer): this
	// Adds the given layer to the group.
	addLayer: function (layer) {
		var id = this.getLayerId(layer);

		this._layers[id] = layer;

		if (this._map) {
			this._map.addLayer(layer);
		}

		return this;
	},

	// @method removeLayer(layer: Layer): this
	// Removes the given layer from the group.
	// @alternative
	// @method removeLayer(id: Number): this
	// Removes the layer with the given internal ID from the group.
	removeLayer: function (layer) {
		var id = layer in this._layers ? layer : this.getLayerId(layer);

		if (this._map && this._layers[id]) {
			this._map.removeLayer(this._layers[id]);
		}

		delete this._layers[id];

		return this;
	},

	// @method hasLayer(layer: Layer): Boolean
	// Returns `true` if the given layer is currently added to the group.
	// @alternative
	// @method hasLayer(id: Number): Boolean
	// Returns `true` if the given internal ID is currently added to the group.
	hasLayer: function (layer) {
		return !!layer && (layer in this._layers || this.getLayerId(layer) in this._layers);
	},

	// @method clearLayers(): this
	// Removes all the layers from the group.
	clearLayers: function () {
		return this.eachLayer(this.removeLayer, this);
	},

	// @method invoke(methodName: String, …): this
	// Calls `methodName` on every layer contained in this group, passing any
	// additional parameters. Has no effect if the layers contained do not
	// implement `methodName`.
	invoke: function (methodName) {
		var args = Array.prototype.slice.call(arguments, 1),
			i, layer;

		for (i in this._layers) {
			layer = this._layers[i];

			if (layer[methodName]) {
				layer[methodName].apply(layer, args);
			}
		}

		return this;
	},

	onAdd: function (map) {
		this.eachLayer(map.addLayer, map);
	},

	onRemove: function (map) {
		this.eachLayer(map.removeLayer, map);
	},

	// @method eachLayer(fn: Function, context?: Object): this
	// Iterates over the layers of the group, optionally specifying context of the iterator function.
	// ```js
	// group.eachLayer(function (layer) {
	// 	layer.bindPopup('Hello');
	// });
	// ```
	eachLayer: function (method, context) {
		for (var i in this._layers) {
			method.call(context, this._layers[i]);
		}
		return this;
	},

	// @method getLayer(id: Number): Layer
	// Returns the layer with the given internal ID.
	getLayer: function (id) {
		return this._layers[id];
	},

	// @method getLayers(): Layer[]
	// Returns an array of all the layers added to the group.
	getLayers: function () {
		var layers = [];
		this.eachLayer(layers.push, layers);
		return layers;
	},

	// @method setZIndex(zIndex: Number): this
	// Calls `setZIndex` on every layer contained in this group, passing the z-index.
	setZIndex: function (zIndex) {
		return this.invoke('setZIndex', zIndex);
	},

	// @method getLayerId(layer: Layer): Number
	// Returns the internal ID for a layer
	getLayerId: function (layer) {
		return stamp(layer);
	}
});


// @factory L.layerGroup(layers?: Layer[], options?: Object)
// Create a layer group, optionally given an initial set of layers and an `options` object.
var layerGroup = function (layers, options) {
	return new LayerGroup(layers, options);
};

/*
 * @class FeatureGroup
 * @aka L.FeatureGroup
 * @inherits LayerGroup
 *
 * Extended `LayerGroup` that makes it easier to do the same thing to all its member layers:
 *  * [`bindPopup`](#layer-bindpopup) binds a popup to all of the layers at once (likewise with [`bindTooltip`](#layer-bindtooltip))
 *  * Events are propagated to the `FeatureGroup`, so if the group has an event
 * handler, it will handle events from any of the layers. This includes mouse events
 * and custom events.
 *  * Has `layeradd` and `layerremove` events
 *
 * @example
 *
 * ```js
 * L.featureGroup([marker1, marker2, polyline])
 * 	.bindPopup('Hello world!')
 * 	.on('click', function() { alert('Clicked on a member of the group!'); })
 * 	.addTo(map);
 * ```
 */

var FeatureGroup = LayerGroup.extend({

	addLayer: function (layer) {
		if (this.hasLayer(layer)) {
			return this;
		}

		layer.addEventParent(this);

		LayerGroup.prototype.addLayer.call(this, layer);

		// @event layeradd: LayerEvent
		// Fired when a layer is added to this `FeatureGroup`
		return this.fire('layeradd', {layer: layer});
	},

	removeLayer: function (layer) {
		if (!this.hasLayer(layer)) {
			return this;
		}
		if (layer in this._layers) {
			layer = this._layers[layer];
		}

		layer.removeEventParent(this);

		LayerGroup.prototype.removeLayer.call(this, layer);

		// @event layerremove: LayerEvent
		// Fired when a layer is removed from this `FeatureGroup`
		return this.fire('layerremove', {layer: layer});
	},

	// @method setStyle(style: Path options): this
	// Sets the given path options to each layer of the group that has a `setStyle` method.
	setStyle: function (style) {
		return this.invoke('setStyle', style);
	},

	// @method bringToFront(): this
	// Brings the layer group to the top of all other layers
	bringToFront: function () {
		return this.invoke('bringToFront');
	},

	// @method bringToBack(): this
	// Brings the layer group to the back of all other layers
	bringToBack: function () {
		return this.invoke('bringToBack');
	},

	// @method getBounds(): LatLngBounds
	// Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
	getBounds: function () {
		var bounds = new LatLngBounds();

		for (var id in this._layers) {
			var layer = this._layers[id];
			bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
		}
		return bounds;
	}
});

// @factory L.featureGroup(layers: Layer[])
// Create a feature group, optionally given an initial set of layers.
var featureGroup = function (layers) {
	return new FeatureGroup(layers);
};

/*
 * @class Icon
 * @aka L.Icon
 *
 * Represents an icon to provide when creating a marker.
 *
 * @example
 *
 * ```js
 * var myIcon = L.icon({
 *     iconUrl: 'my-icon.png',
 *     iconRetinaUrl: 'my-icon@2x.png',
 *     iconSize: [38, 95],
 *     iconAnchor: [22, 94],
 *     popupAnchor: [-3, -76],
 *     shadowUrl: 'my-icon-shadow.png',
 *     shadowRetinaUrl: 'my-icon-shadow@2x.png',
 *     shadowSize: [68, 95],
 *     shadowAnchor: [22, 94]
 * });
 *
 * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
 * ```
 *
 * `L.Icon.Default` extends `L.Icon` and is the blue icon Leaflet uses for markers by default.
 *
 */

var Icon = Class.extend({

	/* @section
	 * @aka Icon options
	 *
	 * @option iconUrl: String = null
	 * **(required)** The URL to the icon image (absolute or relative to your script path).
	 *
	 * @option iconRetinaUrl: String = null
	 * The URL to a retina sized version of the icon image (absolute or relative to your
	 * script path). Used for Retina screen devices.
	 *
	 * @option iconSize: Point = null
	 * Size of the icon image in pixels.
	 *
	 * @option iconAnchor: Point = null
	 * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
	 * will be aligned so that this point is at the marker's geographical location. Centered
	 * by default if size is specified, also can be set in CSS with negative margins.
	 *
	 * @option popupAnchor: Point = [0, 0]
	 * The coordinates of the point from which popups will "open", relative to the icon anchor.
	 *
	 * @option tooltipAnchor: Point = [0, 0]
	 * The coordinates of the point from which tooltips will "open", relative to the icon anchor.
	 *
	 * @option shadowUrl: String = null
	 * The URL to the icon shadow image. If not specified, no shadow image will be created.
	 *
	 * @option shadowRetinaUrl: String = null
	 *
	 * @option shadowSize: Point = null
	 * Size of the shadow image in pixels.
	 *
	 * @option shadowAnchor: Point = null
	 * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
	 * as iconAnchor if not specified).
	 *
	 * @option className: String = ''
	 * A custom class name to assign to both icon and shadow images. Empty by default.
	 */

	options: {
		popupAnchor: [0, 0],
		tooltipAnchor: [0, 0]
	},

	initialize: function (options) {
		setOptions(this, options);
	},

	// @method createIcon(oldIcon?: HTMLElement): HTMLElement
	// Called internally when the icon has to be shown, returns a `<img>` HTML element
	// styled according to the options.
	createIcon: function (oldIcon) {
		return this._createIcon('icon', oldIcon);
	},

	// @method createShadow(oldIcon?: HTMLElement): HTMLElement
	// As `createIcon`, but for the shadow beneath it.
	createShadow: function (oldIcon) {
		return this._createIcon('shadow', oldIcon);
	},

	_createIcon: function (name, oldIcon) {
		var src = this._getIconUrl(name);

		if (!src) {
			if (name === 'icon') {
				throw new Error('iconUrl not set in Icon options (see the docs).');
			}
			return null;
		}

		var img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);
		this._setIconStyles(img, name);

		return img;
	},

	_setIconStyles: function (img, name) {
		var options = this.options;
		var sizeOption = options[name + 'Size'];

		if (typeof sizeOption === 'number') {
			sizeOption = [sizeOption, sizeOption];
		}

		var size = toPoint(sizeOption),
			anchor = toPoint(name === 'shadow' && options.shadowAnchor || options.iconAnchor ||
					size && size.divideBy(2, true));

		img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');

		if (anchor) {
			img.style.marginLeft = (-anchor.x) + 'px';
			img.style.marginTop  = (-anchor.y) + 'px';
		}

		if (size) {
			img.style.width  = size.x + 'px';
			img.style.height = size.y + 'px';
		}
	},

	_createImg: function (src, el) {
		el = el || document.createElement('img');
		el.src = src;
		return el;
	},

	_getIconUrl: function (name) {
		return retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];
	}
});


// @factory L.icon(options: Icon options)
// Creates an icon instance with the given options.
function icon(options) {
	return new Icon(options);
}

/*
 * @miniclass Icon.Default (Icon)
 * @aka L.Icon.Default
 * @section
 *
 * A trivial subclass of `Icon`, represents the icon to use in `Marker`s when
 * no icon is specified. Points to the blue marker image distributed with Leaflet
 * releases.
 *
 * In order to customize the default icon, just change the properties of `L.Icon.Default.prototype.options`
 * (which is a set of `Icon options`).
 *
 * If you want to _completely_ replace the default icon, override the
 * `L.Marker.prototype.options.icon` with your own icon instead.
 */

var IconDefault = Icon.extend({

	options: {
		iconUrl:       'marker-icon.png',
		iconRetinaUrl: 'marker-icon-2x.png',
		shadowUrl:     'marker-shadow.png',
		iconSize:    [25, 41],
		iconAnchor:  [12, 41],
		popupAnchor: [1, -34],
		tooltipAnchor: [16, -28],
		shadowSize:  [41, 41]
	},

	_getIconUrl: function (name) {
		if (!IconDefault.imagePath) {	// Deprecated, backwards-compatibility only
			IconDefault.imagePath = this._detectIconPath();
		}

		// @option imagePath: String
		// `Icon.Default` will try to auto-detect the location of the
		// blue icon images. If you are placing these images in a non-standard
		// way, set this option to point to the right path.
		return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);
	},

	_detectIconPath: function () {
		var el = create$1('div',  'leaflet-default-icon-path', document.body);
		var path = getStyle(el, 'background-image') ||
				   getStyle(el, 'backgroundImage');	// IE8

		document.body.removeChild(el);

		if (path === null || path.indexOf('url') !== 0) {
			path = '';
		} else {
			path = path.replace(/^url\(["']?/, '').replace(/marker-icon\.png["']?\)$/, '');
		}

		return path;
	}
});

/*
 * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.
 */


/* @namespace Marker
 * @section Interaction handlers
 *
 * Interaction handlers are properties of a marker instance that allow you to control interaction behavior in runtime, enabling or disabling certain features such as dragging (see `Handler` methods). Example:
 *
 * ```js
 * marker.dragging.disable();
 * ```
 *
 * @property dragging: Handler
 * Marker dragging handler (by both mouse and touch). Only valid when the marker is on the map (Otherwise set [`marker.options.draggable`](#marker-draggable)).
 */

var MarkerDrag = Handler.extend({
	initialize: function (marker) {
		this._marker = marker;
	},

	addHooks: function () {
		var icon = this._marker._icon;

		if (!this._draggable) {
			this._draggable = new Draggable(icon, icon, true);
		}

		this._draggable.on({
			dragstart: this._onDragStart,
			predrag: this._onPreDrag,
			drag: this._onDrag,
			dragend: this._onDragEnd
		}, this).enable();

		addClass(icon, 'leaflet-marker-draggable');
	},

	removeHooks: function () {
		this._draggable.off({
			dragstart: this._onDragStart,
			predrag: this._onPreDrag,
			drag: this._onDrag,
			dragend: this._onDragEnd
		}, this).disable();

		if (this._marker._icon) {
			removeClass(this._marker._icon, 'leaflet-marker-draggable');
		}
	},

	moved: function () {
		return this._draggable && this._draggable._moved;
	},

	_adjustPan: function (e) {
		var marker = this._marker,
			map = marker._map,
			speed = this._marker.options.autoPanSpeed,
			padding = this._marker.options.autoPanPadding,
			iconPos = getPosition(marker._icon),
			bounds = map.getPixelBounds(),
			origin = map.getPixelOrigin();

		var panBounds = toBounds(
			bounds.min._subtract(origin).add(padding),
			bounds.max._subtract(origin).subtract(padding)
		);

		if (!panBounds.contains(iconPos)) {
			// Compute incremental movement
			var movement = toPoint(
				(Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) -
				(Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x),

				(Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) -
				(Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)
			).multiplyBy(speed);

			map.panBy(movement, {animate: false});

			this._draggable._newPos._add(movement);
			this._draggable._startPos._add(movement);

			setPosition(marker._icon, this._draggable._newPos);
			this._onDrag(e);

			this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
		}
	},

	_onDragStart: function () {
		// @section Dragging events
		// @event dragstart: Event
		// Fired when the user starts dragging the marker.

		// @event movestart: Event
		// Fired when the marker starts moving (because of dragging).

		this._oldLatLng = this._marker.getLatLng();
		this._marker
			.closePopup()
			.fire('movestart')
			.fire('dragstart');
	},

	_onPreDrag: function (e) {
		if (this._marker.options.autoPan) {
			cancelAnimFrame(this._panRequest);
			this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
		}
	},

	_onDrag: function (e) {
		var marker = this._marker,
			shadow = marker._shadow,
			iconPos = getPosition(marker._icon),
			latlng = marker._map.layerPointToLatLng(iconPos);

		// update shadow position
		if (shadow) {
			setPosition(shadow, iconPos);
		}

		marker._latlng = latlng;
		e.latlng = latlng;
		e.oldLatLng = this._oldLatLng;

		// @event drag: Event
		// Fired repeatedly while the user drags the marker.
		marker
			.fire('move', e)
			.fire('drag', e);
	},

	_onDragEnd: function (e) {
		// @event dragend: DragEndEvent
		// Fired when the user stops dragging the marker.

		 cancelAnimFrame(this._panRequest);

		// @event moveend: Event
		// Fired when the marker stops moving (because of dragging).
		delete this._oldLatLng;
		this._marker
			.fire('moveend')
			.fire('dragend', e);
	}
});

/*
 * @class Marker
 * @inherits Interactive layer
 * @aka L.Marker
 * L.Marker is used to display clickable/draggable icons on the map. Extends `Layer`.
 *
 * @example
 *
 * ```js
 * L.marker([50.5, 30.5]).addTo(map);
 * ```
 */

var Marker = Layer.extend({

	// @section
	// @aka Marker options
	options: {
		// @option icon: Icon = *
		// Icon instance to use for rendering the marker.
		// See [Icon documentation](#L.Icon) for details on how to customize the marker icon.
		// If not specified, a common instance of `L.Icon.Default` is used.
		icon: new IconDefault(),

		// Option inherited from "Interactive layer" abstract class
		interactive: true,

		// @option keyboard: Boolean = true
		// Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
		keyboard: true,

		// @option title: String = ''
		// Text for the browser tooltip that appear on marker hover (no tooltip by default).
		title: '',

		// @option alt: String = ''
		// Text for the `alt` attribute of the icon image (useful for accessibility).
		alt: '',

		// @option zIndexOffset: Number = 0
		// By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
		zIndexOffset: 0,

		// @option opacity: Number = 1.0
		// The opacity of the marker.
		opacity: 1,

		// @option riseOnHover: Boolean = false
		// If `true`, the marker will get on top of others when you hover the mouse over it.
		riseOnHover: false,

		// @option riseOffset: Number = 250
		// The z-index offset used for the `riseOnHover` feature.
		riseOffset: 250,

		// @option pane: String = 'markerPane'
		// `Map pane` where the markers icon will be added.
		pane: 'markerPane',

		// @option bubblingMouseEvents: Boolean = false
		// When `true`, a mouse event on this marker will trigger the same event on the map
		// (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
		bubblingMouseEvents: false,

		// @section Draggable marker options
		// @option draggable: Boolean = false
		// Whether the marker is draggable with mouse/touch or not.
		draggable: false,

		// @option autoPan: Boolean = false
		// Whether to pan the map when dragging this marker near its edge or not.
		autoPan: false,

		// @option autoPanPadding: Point = Point(50, 50)
		// Distance (in pixels to the left/right and to the top/bottom) of the
		// map edge to start panning the map.
		autoPanPadding: [50, 50],

		// @option autoPanSpeed: Number = 10
		// Number of pixels the map should pan by.
		autoPanSpeed: 10
	},

	/* @section
	 *
	 * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
	 */

	initialize: function (latlng, options) {
		setOptions(this, options);
		this._latlng = toLatLng(latlng);
	},

	onAdd: function (map) {
		this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;

		if (this._zoomAnimated) {
			map.on('zoomanim', this._animateZoom, this);
		}

		this._initIcon();
		this.update();
	},

	onRemove: function (map) {
		if (this.dragging && this.dragging.enabled()) {
			this.options.draggable = true;
			this.dragging.removeHooks();
		}
		delete this.dragging;

		if (this._zoomAnimated) {
			map.off('zoomanim', this._animateZoom, this);
		}

		this._removeIcon();
		this._removeShadow();
	},

	getEvents: function () {
		return {
			zoom: this.update,
			viewreset: this.update
		};
	},

	// @method getLatLng: LatLng
	// Returns the current geographical position of the marker.
	getLatLng: function () {
		return this._latlng;
	},

	// @method setLatLng(latlng: LatLng): this
	// Changes the marker position to the given point.
	setLatLng: function (latlng) {
		var oldLatLng = this._latlng;
		this._latlng = toLatLng(latlng);
		this.update();

		// @event move: Event
		// Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.
		return this.fire('move', {oldLatLng: oldLatLng, latlng: this._latlng});
	},

	// @method setZIndexOffset(offset: Number): this
	// Changes the [zIndex offset](#marker-zindexoffset) of the marker.
	setZIndexOffset: function (offset) {
		this.options.zIndexOffset = offset;
		return this.update();
	},

	// @method setIcon(icon: Icon): this
	// Changes the marker icon.
	setIcon: function (icon) {

		this.options.icon = icon;

		if (this._map) {
			this._initIcon();
			this.update();
		}

		if (this._popup) {
			this.bindPopup(this._popup, this._popup.options);
		}

		return this;
	},

	getElement: function () {
		return this._icon;
	},

	update: function () {

		if (this._icon && this._map) {
			var pos = this._map.latLngToLayerPoint(this._latlng).round();
			this._setPos(pos);
		}

		return this;
	},

	_initIcon: function () {
		var options = this.options,
			classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

		var icon = options.icon.createIcon(this._icon),
			addIcon = false;

		// if we're not reusing the icon, remove the old one and init new one
		if (icon !== this._icon) {
			if (this._icon) {
				this._removeIcon();
			}
			addIcon = true;

			if (options.title) {
				icon.title = options.title;
			}

			if (icon.tagName === 'IMG') {
				icon.alt = options.alt || '';
			}
		}

		addClass(icon, classToAdd);

		if (options.keyboard) {
			icon.tabIndex = '0';
		}

		this._icon = icon;

		if (options.riseOnHover) {
			this.on({
				mouseover: this._bringToFront,
				mouseout: this._resetZIndex
			});
		}

		var newShadow = options.icon.createShadow(this._shadow),
			addShadow = false;

		if (newShadow !== this._shadow) {
			this._removeShadow();
			addShadow = true;
		}

		if (newShadow) {
			addClass(newShadow, classToAdd);
			newShadow.alt = '';
		}
		this._shadow = newShadow;


		if (options.opacity < 1) {
			this._updateOpacity();
		}


		if (addIcon) {
			this.getPane().appendChild(this._icon);
		}
		this._initInteraction();
		if (newShadow && addShadow) {
			this.getPane('shadowPane').appendChild(this._shadow);
		}
	},

	_removeIcon: function () {
		if (this.options.riseOnHover) {
			this.off({
				mouseover: this._bringToFront,
				mouseout: this._resetZIndex
			});
		}

		remove(this._icon);
		this.removeInteractiveTarget(this._icon);

		this._icon = null;
	},

	_removeShadow: function () {
		if (this._shadow) {
			remove(this._shadow);
		}
		this._shadow = null;
	},

	_setPos: function (pos) {
		setPosition(this._icon, pos);

		if (this._shadow) {
			setPosition(this._shadow, pos);
		}

		this._zIndex = pos.y + this.options.zIndexOffset;

		this._resetZIndex();
	},

	_updateZIndex: function (offset) {
		this._icon.style.zIndex = this._zIndex + offset;
	},

	_animateZoom: function (opt) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();

		this._setPos(pos);
	},

	_initInteraction: function () {

		if (!this.options.interactive) { return; }

		addClass(this._icon, 'leaflet-interactive');

		this.addInteractiveTarget(this._icon);

		if (MarkerDrag) {
			var draggable = this.options.draggable;
			if (this.dragging) {
				draggable = this.dragging.enabled();
				this.dragging.disable();
			}

			this.dragging = new MarkerDrag(this);

			if (draggable) {
				this.dragging.enable();
			}
		}
	},

	// @method setOpacity(opacity: Number): this
	// Changes the opacity of the marker.
	setOpacity: function (opacity) {
		this.options.opacity = opacity;
		if (this._map) {
			this._updateOpacity();
		}

		return this;
	},

	_updateOpacity: function () {
		var opacity = this.options.opacity;

		setOpacity(this._icon, opacity);

		if (this._shadow) {
			setOpacity(this._shadow, opacity);
		}
	},

	_bringToFront: function () {
		this._updateZIndex(this.options.riseOffset);
	},

	_resetZIndex: function () {
		this._updateZIndex(0);
	},

	_getPopupAnchor: function () {
		return this.options.icon.options.popupAnchor;
	},

	_getTooltipAnchor: function () {
		return this.options.icon.options.tooltipAnchor;
	}
});


// factory L.marker(latlng: LatLng, options? : Marker options)

// @factory L.marker(latlng: LatLng, options? : Marker options)
// Instantiates a Marker object given a geographical point and optionally an options object.
function marker(latlng, options) {
	return new Marker(latlng, options);
}

/*
 * @class Path
 * @aka L.Path
 * @inherits Interactive layer
 *
 * An abstract class that contains options and constants shared between vector
 * overlays (Polygon, Polyline, Circle). Do not use it directly. Extends `Layer`.
 */

var Path = Layer.extend({

	// @section
	// @aka Path options
	options: {
		// @option stroke: Boolean = true
		// Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
		stroke: true,

		// @option color: String = '#3388ff'
		// Stroke color
		color: '#3388ff',

		// @option weight: Number = 3
		// Stroke width in pixels
		weight: 3,

		// @option opacity: Number = 1.0
		// Stroke opacity
		opacity: 1,

		// @option lineCap: String= 'round'
		// A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
		lineCap: 'round',

		// @option lineJoin: String = 'round'
		// A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
		lineJoin: 'round',

		// @option dashArray: String = null
		// A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
		dashArray: null,

		// @option dashOffset: String = null
		// A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
		dashOffset: null,

		// @option fill: Boolean = depends
		// Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
		fill: false,

		// @option fillColor: String = *
		// Fill color. Defaults to the value of the [`color`](#path-color) option
		fillColor: null,

		// @option fillOpacity: Number = 0.2
		// Fill opacity.
		fillOpacity: 0.2,

		// @option fillRule: String = 'evenodd'
		// A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
		fillRule: 'evenodd',

		// className: '',

		// Option inherited from "Interactive layer" abstract class
		interactive: true,

		// @option bubblingMouseEvents: Boolean = true
		// When `true`, a mouse event on this path will trigger the same event on the map
		// (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
		bubblingMouseEvents: true
	},

	beforeAdd: function (map) {
		// Renderer is set here because we need to call renderer.getEvents
		// before this.getEvents.
		this._renderer = map.getRenderer(this);
	},

	onAdd: function () {
		this._renderer._initPath(this);
		this._reset();
		this._renderer._addPath(this);
	},

	onRemove: function () {
		this._renderer._removePath(this);
	},

	// @method redraw(): this
	// Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
	redraw: function () {
		if (this._map) {
			this._renderer._updatePath(this);
		}
		return this;
	},

	// @method setStyle(style: Path options): this
	// Changes the appearance of a Path based on the options in the `Path options` object.
	setStyle: function (style) {
		setOptions(this, style);
		if (this._renderer) {
			this._renderer._updateStyle(this);
		}
		return this;
	},

	// @method bringToFront(): this
	// Brings the layer to the top of all path layers.
	bringToFront: function () {
		if (this._renderer) {
			this._renderer._bringToFront(this);
		}
		return this;
	},

	// @method bringToBack(): this
	// Brings the layer to the bottom of all path layers.
	bringToBack: function () {
		if (this._renderer) {
			this._renderer._bringToBack(this);
		}
		return this;
	},

	getElement: function () {
		return this._path;
	},

	_reset: function () {
		// defined in child classes
		this._project();
		this._update();
	},

	_clickTolerance: function () {
		// used when doing hit detection for Canvas layers
		return (this.options.stroke ? this.options.weight / 2 : 0) + this._renderer.options.tolerance;
	}
});

/*
 * @class CircleMarker
 * @aka L.CircleMarker
 * @inherits Path
 *
 * A circle of a fixed size with radius specified in pixels. Extends `Path`.
 */

var CircleMarker = Path.extend({

	// @section
	// @aka CircleMarker options
	options: {
		fill: true,

		// @option radius: Number = 10
		// Radius of the circle marker, in pixels
		radius: 10
	},

	initialize: function (latlng, options) {
		setOptions(this, options);
		this._latlng = toLatLng(latlng);
		this._radius = this.options.radius;
	},

	// @method setLatLng(latLng: LatLng): this
	// Sets the position of a circle marker to a new location.
	setLatLng: function (latlng) {
		this._latlng = toLatLng(latlng);
		this.redraw();
		return this.fire('move', {latlng: this._latlng});
	},

	// @method getLatLng(): LatLng
	// Returns the current geographical position of the circle marker
	getLatLng: function () {
		return this._latlng;
	},

	// @method setRadius(radius: Number): this
	// Sets the radius of a circle marker. Units are in pixels.
	setRadius: function (radius) {
		this.options.radius = this._radius = radius;
		return this.redraw();
	},

	// @method getRadius(): Number
	// Returns the current radius of the circle
	getRadius: function () {
		return this._radius;
	},

	setStyle : function (options) {
		var radius = options && options.radius || this._radius;
		Path.prototype.setStyle.call(this, options);
		this.setRadius(radius);
		return this;
	},

	_project: function () {
		this._point = this._map.latLngToLayerPoint(this._latlng);
		this._updateBounds();
	},

	_updateBounds: function () {
		var r = this._radius,
			r2 = this._radiusY || r,
			w = this._clickTolerance(),
			p = [r + w, r2 + w];
		this._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));
	},

	_update: function () {
		if (this._map) {
			this._updatePath();
		}
	},

	_updatePath: function () {
		this._renderer._updateCircle(this);
	},

	_empty: function () {
		return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
	},

	// Needed by the `Canvas` renderer for interactivity
	_containsPoint: function (p) {
		return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
	}
});


// @factory L.circleMarker(latlng: LatLng, options?: CircleMarker options)
// Instantiates a circle marker object given a geographical point, and an optional options object.
function circleMarker(latlng, options) {
	return new CircleMarker(latlng, options);
}

/*
 * @class Circle
 * @aka L.Circle
 * @inherits CircleMarker
 *
 * A class for drawing circle overlays on a map. Extends `CircleMarker`.
 *
 * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion).
 *
 * @example
 *
 * ```js
 * L.circle([50.5, 30.5], {radius: 200}).addTo(map);
 * ```
 */

var Circle = CircleMarker.extend({

	initialize: function (latlng, options, legacyOptions) {
		if (typeof options === 'number') {
			// Backwards compatibility with 0.7.x factory (latlng, radius, options?)
			options = extend({}, legacyOptions, {radius: options});
		}
		setOptions(this, options);
		this._latlng = toLatLng(latlng);

		if (isNaN(this.options.radius)) { throw new Error('Circle radius cannot be NaN'); }

		// @section
		// @aka Circle options
		// @option radius: Number; Radius of the circle, in meters.
		this._mRadius = this.options.radius;
	},

	// @method setRadius(radius: Number): this
	// Sets the radius of a circle. Units are in meters.
	setRadius: function (radius) {
		this._mRadius = radius;
		return this.redraw();
	},

	// @method getRadius(): Number
	// Returns the current radius of a circle. Units are in meters.
	getRadius: function () {
		return this._mRadius;
	},

	// @method getBounds(): LatLngBounds
	// Returns the `LatLngBounds` of the path.
	getBounds: function () {
		var half = [this._radius, this._radiusY || this._radius];

		return new LatLngBounds(
			this._map.layerPointToLatLng(this._point.subtract(half)),
			this._map.layerPointToLatLng(this._point.add(half)));
	},

	setStyle: Path.prototype.setStyle,

	_project: function () {

		var lng = this._latlng.lng,
			lat = this._latlng.lat,
			map = this._map,
			crs = map.options.crs;

		if (crs.distance === Earth.distance) {
			var d = Math.PI / 180,
				latR = (this._mRadius / Earth.R) / d,
				top = map.project([lat + latR, lng]),
				bottom = map.project([lat - latR, lng]),
				p = top.add(bottom).divideBy(2),
				lat2 = map.unproject(p).lat,
				lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) /
						(Math.cos(lat * d) * Math.cos(lat2 * d))) / d;

			if (isNaN(lngR) || lngR === 0) {
				lngR = latR / Math.cos(Math.PI / 180 * lat); // Fallback for edge case, #2425
			}

			this._point = p.subtract(map.getPixelOrigin());
			this._radius = isNaN(lngR) ? 0 : p.x - map.project([lat2, lng - lngR]).x;
			this._radiusY = p.y - top.y;

		} else {
			var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));

			this._point = map.latLngToLayerPoint(this._latlng);
			this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;
		}

		this._updateBounds();
	}
});

// @factory L.circle(latlng: LatLng, options?: Circle options)
// Instantiates a circle object given a geographical point, and an options object
// which contains the circle radius.
// @alternative
// @factory L.circle(latlng: LatLng, radius: Number, options?: Circle options)
// Obsolete way of instantiating a circle, for compatibility with 0.7.x code.
// Do not use in new applications or plugins.
function circle(latlng, options, legacyOptions) {
	return new Circle(latlng, options, legacyOptions);
}

/*
 * @class Polyline
 * @aka L.Polyline
 * @inherits Path
 *
 * A class for drawing polyline overlays on a map. Extends `Path`.
 *
 * @example
 *
 * ```js
 * // create a red polyline from an array of LatLng points
 * var latlngs = [
 * 	[45.51, -122.68],
 * 	[37.77, -122.43],
 * 	[34.04, -118.2]
 * ];
 *
 * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);
 *
 * // zoom the map to the polyline
 * map.fitBounds(polyline.getBounds());
 * ```
 *
 * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:
 *
 * ```js
 * // create a red polyline from an array of arrays of LatLng points
 * var latlngs = [
 * 	[[45.51, -122.68],
 * 	 [37.77, -122.43],
 * 	 [34.04, -118.2]],
 * 	[[40.78, -73.91],
 * 	 [41.83, -87.62],
 * 	 [32.76, -96.72]]
 * ];
 * ```
 */


var Polyline = Path.extend({

	// @section
	// @aka Polyline options
	options: {
		// @option smoothFactor: Number = 1.0
		// How much to simplify the polyline on each zoom level. More means
		// better performance and smoother look, and less means more accurate representation.
		smoothFactor: 1.0,

		// @option noClip: Boolean = false
		// Disable polyline clipping.
		noClip: false
	},

	initialize: function (latlngs, options) {
		setOptions(this, options);
		this._setLatLngs(latlngs);
	},

	// @method getLatLngs(): LatLng[]
	// Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
	getLatLngs: function () {
		return this._latlngs;
	},

	// @method setLatLngs(latlngs: LatLng[]): this
	// Replaces all the points in the polyline with the given array of geographical points.
	setLatLngs: function (latlngs) {
		this._setLatLngs(latlngs);
		return this.redraw();
	},

	// @method isEmpty(): Boolean
	// Returns `true` if the Polyline has no LatLngs.
	isEmpty: function () {
		return !this._latlngs.length;
	},

	// @method closestLayerPoint(p: Point): Point
	// Returns the point closest to `p` on the Polyline.
	closestLayerPoint: function (p) {
		var minDistance = Infinity,
			minPoint = null,
			closest = _sqClosestPointOnSegment,
			p1, p2;

		for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
			var points = this._parts[j];

			for (var i = 1, len = points.length; i < len; i++) {
				p1 = points[i - 1];
				p2 = points[i];

				var sqDist = closest(p, p1, p2, true);

				if (sqDist < minDistance) {
					minDistance = sqDist;
					minPoint = closest(p, p1, p2);
				}
			}
		}
		if (minPoint) {
			minPoint.distance = Math.sqrt(minDistance);
		}
		return minPoint;
	},

	// @method getCenter(): LatLng
	// Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the polyline.
	getCenter: function () {
		// throws error when not yet added to map as this center calculation requires projected coordinates
		if (!this._map) {
			throw new Error('Must add layer to map before using getCenter()');
		}

		var i, halfDist, segDist, dist, p1, p2, ratio,
			points = this._rings[0],
			len = points.length;

		if (!len) { return null; }

		// polyline centroid algorithm; only uses the first ring if there are multiple

		for (i = 0, halfDist = 0; i < len - 1; i++) {
			halfDist += points[i].distanceTo(points[i + 1]) / 2;
		}

		// The line is so small in the current view that all points are on the same pixel.
		if (halfDist === 0) {
			return this._map.layerPointToLatLng(points[0]);
		}

		for (i = 0, dist = 0; i < len - 1; i++) {
			p1 = points[i];
			p2 = points[i + 1];
			segDist = p1.distanceTo(p2);
			dist += segDist;

			if (dist > halfDist) {
				ratio = (dist - halfDist) / segDist;
				return this._map.layerPointToLatLng([
					p2.x - ratio * (p2.x - p1.x),
					p2.y - ratio * (p2.y - p1.y)
				]);
			}
		}
	},

	// @method getBounds(): LatLngBounds
	// Returns the `LatLngBounds` of the path.
	getBounds: function () {
		return this._bounds;
	},

	// @method addLatLng(latlng: LatLng, latlngs? LatLng[]): this
	// Adds a given point to the polyline. By default, adds to the first ring of
	// the polyline in case of a multi-polyline, but can be overridden by passing
	// a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
	addLatLng: function (latlng, latlngs) {
		latlngs = latlngs || this._defaultShape();
		latlng = toLatLng(latlng);
		latlngs.push(latlng);
		this._bounds.extend(latlng);
		return this.redraw();
	},

	_setLatLngs: function (latlngs) {
		this._bounds = new LatLngBounds();
		this._latlngs = this._convertLatLngs(latlngs);
	},

	_defaultShape: function () {
		return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];
	},

	// recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
	_convertLatLngs: function (latlngs) {
		var result = [],
			flat = isFlat(latlngs);

		for (var i = 0, len = latlngs.length; i < len; i++) {
			if (flat) {
				result[i] = toLatLng(latlngs[i]);
				this._bounds.extend(result[i]);
			} else {
				result[i] = this._convertLatLngs(latlngs[i]);
			}
		}

		return result;
	},

	_project: function () {
		var pxBounds = new Bounds();
		this._rings = [];
		this._projectLatlngs(this._latlngs, this._rings, pxBounds);

		var w = this._clickTolerance(),
			p = new Point(w, w);

		if (this._bounds.isValid() && pxBounds.isValid()) {
			pxBounds.min._subtract(p);
			pxBounds.max._add(p);
			this._pxBounds = pxBounds;
		}
	},

	// recursively turns latlngs into a set of rings with projected coordinates
	_projectLatlngs: function (latlngs, result, projectedBounds) {
		var flat = latlngs[0] instanceof LatLng,
			len = latlngs.length,
			i, ring;

		if (flat) {
			ring = [];
			for (i = 0; i < len; i++) {
				ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
				projectedBounds.extend(ring[i]);
			}
			result.push(ring);
		} else {
			for (i = 0; i < len; i++) {
				this._projectLatlngs(latlngs[i], result, projectedBounds);
			}
		}
	},

	// clip polyline by renderer bounds so that we have less to render for performance
	_clipPoints: function () {
		var bounds = this._renderer._bounds;

		this._parts = [];
		if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
			return;
		}

		if (this.options.noClip) {
			this._parts = this._rings;
			return;
		}

		var parts = this._parts,
			i, j, k, len, len2, segment, points;

		for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
			points = this._rings[i];

			for (j = 0, len2 = points.length; j < len2 - 1; j++) {
				segment = clipSegment(points[j], points[j + 1], bounds, j, true);

				if (!segment) { continue; }

				parts[k] = parts[k] || [];
				parts[k].push(segment[0]);

				// if segment goes out of screen, or it's the last one, it's the end of the line part
				if ((segment[1] !== points[j + 1]) || (j === len2 - 2)) {
					parts[k].push(segment[1]);
					k++;
				}
			}
		}
	},

	// simplify each clipped part of the polyline for performance
	_simplifyPoints: function () {
		var parts = this._parts,
			tolerance = this.options.smoothFactor;

		for (var i = 0, len = parts.length; i < len; i++) {
			parts[i] = simplify(parts[i], tolerance);
		}
	},

	_update: function () {
		if (!this._map) { return; }

		this._clipPoints();
		this._simplifyPoints();
		this._updatePath();
	},

	_updatePath: function () {
		this._renderer._updatePoly(this);
	},

	// Needed by the `Canvas` renderer for interactivity
	_containsPoint: function (p, closed) {
		var i, j, k, len, len2, part,
			w = this._clickTolerance();

		if (!this._pxBounds || !this._pxBounds.contains(p)) { return false; }

		// hit detection for polylines
		for (i = 0, len = this._parts.length; i < len; i++) {
			part = this._parts[i];

			for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
				if (!closed && (j === 0)) { continue; }

				if (pointToSegmentDistance(p, part[k], part[j]) <= w) {
					return true;
				}
			}
		}
		return false;
	}
});

// @factory L.polyline(latlngs: LatLng[], options?: Polyline options)
// Instantiates a polyline object given an array of geographical points and
// optionally an options object. You can create a `Polyline` object with
// multiple separate lines (`MultiPolyline`) by passing an array of arrays
// of geographic points.
function polyline(latlngs, options) {
	return new Polyline(latlngs, options);
}

// Retrocompat. Allow plugins to support Leaflet versions before and after 1.1.
Polyline._flat = _flat;

/*
 * @class Polygon
 * @aka L.Polygon
 * @inherits Polyline
 *
 * A class for drawing polygon overlays on a map. Extends `Polyline`.
 *
 * Note that points you pass when creating a polygon shouldn't have an additional last point equal to the first one — it's better to filter out such points.
 *
 *
 * @example
 *
 * ```js
 * // create a red polygon from an array of LatLng points
 * var latlngs = [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]];
 *
 * var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map);
 *
 * // zoom the map to the polygon
 * map.fitBounds(polygon.getBounds());
 * ```
 *
 * You can also pass an array of arrays of latlngs, with the first array representing the outer shape and the other arrays representing holes in the outer shape:
 *
 * ```js
 * var latlngs = [
 *   [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
 *   [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
 * ];
 * ```
 *
 * Additionally, you can pass a multi-dimensional array to represent a MultiPolygon shape.
 *
 * ```js
 * var latlngs = [
 *   [ // first polygon
 *     [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
 *     [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
 *   ],
 *   [ // second polygon
 *     [[41, -111.03],[45, -111.04],[45, -104.05],[41, -104.05]]
 *   ]
 * ];
 * ```
 */

var Polygon = Polyline.extend({

	options: {
		fill: true
	},

	isEmpty: function () {
		return !this._latlngs.length || !this._latlngs[0].length;
	},

	getCenter: function () {
		// throws error when not yet added to map as this center calculation requires projected coordinates
		if (!this._map) {
			throw new Error('Must add layer to map before using getCenter()');
		}

		var i, j, p1, p2, f, area, x, y, center,
			points = this._rings[0],
			len = points.length;

		if (!len) { return null; }

		// polygon centroid algorithm; only uses the first ring if there are multiple

		area = x = y = 0;

		for (i = 0, j = len - 1; i < len; j = i++) {
			p1 = points[i];
			p2 = points[j];

			f = p1.y * p2.x - p2.y * p1.x;
			x += (p1.x + p2.x) * f;
			y += (p1.y + p2.y) * f;
			area += f * 3;
		}

		if (area === 0) {
			// Polygon is so small that all points are on same pixel.
			center = points[0];
		} else {
			center = [x / area, y / area];
		}
		return this._map.layerPointToLatLng(center);
	},

	_convertLatLngs: function (latlngs) {
		var result = Polyline.prototype._convertLatLngs.call(this, latlngs),
			len = result.length;

		// remove last point if it equals first one
		if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {
			result.pop();
		}
		return result;
	},

	_setLatLngs: function (latlngs) {
		Polyline.prototype._setLatLngs.call(this, latlngs);
		if (isFlat(this._latlngs)) {
			this._latlngs = [this._latlngs];
		}
	},

	_defaultShape: function () {
		return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
	},

	_clipPoints: function () {
		// polygons need a different clipping algorithm so we redefine that

		var bounds = this._renderer._bounds,
			w = this.options.weight,
			p = new Point(w, w);

		// increase clip padding by stroke width to avoid stroke on clip edges
		bounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));

		this._parts = [];
		if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
			return;
		}

		if (this.options.noClip) {
			this._parts = this._rings;
			return;
		}

		for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
			clipped = clipPolygon(this._rings[i], bounds, true);
			if (clipped.length) {
				this._parts.push(clipped);
			}
		}
	},

	_updatePath: function () {
		this._renderer._updatePoly(this, true);
	},

	// Needed by the `Canvas` renderer for interactivity
	_containsPoint: function (p) {
		var inside = false,
			part, p1, p2, i, j, k, len, len2;

		if (!this._pxBounds || !this._pxBounds.contains(p)) { return false; }

		// ray casting algorithm for detecting if point is in polygon
		for (i = 0, len = this._parts.length; i < len; i++) {
			part = this._parts[i];

			for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
				p1 = part[j];
				p2 = part[k];

				if (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
					inside = !inside;
				}
			}
		}

		// also check if it's on polygon stroke
		return inside || Polyline.prototype._containsPoint.call(this, p, true);
	}

});


// @factory L.polygon(latlngs: LatLng[], options?: Polyline options)
function polygon(latlngs, options) {
	return new Polygon(latlngs, options);
}

/*
 * @class GeoJSON
 * @aka L.GeoJSON
 * @inherits FeatureGroup
 *
 * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse
 * GeoJSON data and display it on the map. Extends `FeatureGroup`.
 *
 * @example
 *
 * ```js
 * L.geoJSON(data, {
 * 	style: function (feature) {
 * 		return {color: feature.properties.color};
 * 	}
 * }).bindPopup(function (layer) {
 * 	return layer.feature.properties.description;
 * }).addTo(map);
 * ```
 */

var GeoJSON = FeatureGroup.extend({

	/* @section
	 * @aka GeoJSON options
	 *
	 * @option pointToLayer: Function = *
	 * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
	 * called when data is added, passing the GeoJSON point feature and its `LatLng`.
	 * The default is to spawn a default `Marker`:
	 * ```js
	 * function(geoJsonPoint, latlng) {
	 * 	return L.marker(latlng);
	 * }
	 * ```
	 *
	 * @option style: Function = *
	 * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
	 * called internally when data is added.
	 * The default value is to not override any defaults:
	 * ```js
	 * function (geoJsonFeature) {
	 * 	return {}
	 * }
	 * ```
	 *
	 * @option onEachFeature: Function = *
	 * A `Function` that will be called once for each created `Feature`, after it has
	 * been created and styled. Useful for attaching events and popups to features.
	 * The default is to do nothing with the newly created layers:
	 * ```js
	 * function (feature, layer) {}
	 * ```
	 *
	 * @option filter: Function = *
	 * A `Function` that will be used to decide whether to include a feature or not.
	 * The default is to include all features:
	 * ```js
	 * function (geoJsonFeature) {
	 * 	return true;
	 * }
	 * ```
	 * Note: dynamically changing the `filter` option will have effect only on newly
	 * added data. It will _not_ re-evaluate already included features.
	 *
	 * @option coordsToLatLng: Function = *
	 * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
	 * The default is the `coordsToLatLng` static method.
	 */

	initialize: function (geojson, options) {
		setOptions(this, options);

		this._layers = {};

		if (geojson) {
			this.addData(geojson);
		}
	},

	// @method addData( <GeoJSON> data ): this
	// Adds a GeoJSON object to the layer.
	addData: function (geojson) {
		var features = isArray(geojson) ? geojson : geojson.features,
			i, len, feature;

		if (features) {
			for (i = 0, len = features.length; i < len; i++) {
				// only add this if geometry or geometries are set and not null
				feature = features[i];
				if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
					this.addData(feature);
				}
			}
			return this;
		}

		var options = this.options;

		if (options.filter && !options.filter(geojson)) { return this; }

		var layer = geometryToLayer(geojson, options);
		if (!layer) {
			return this;
		}
		layer.feature = asFeature(geojson);

		layer.defaultOptions = layer.options;
		this.resetStyle(layer);

		if (options.onEachFeature) {
			options.onEachFeature(geojson, layer);
		}

		return this.addLayer(layer);
	},

	// @method resetStyle( <Path> layer ): this
	// Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
	resetStyle: function (layer) {
		// reset any custom styles
		layer.options = extend({}, layer.defaultOptions);
		this._setLayerStyle(layer, this.options.style);
		return this;
	},

	// @method setStyle( <Function> style ): this
	// Changes styles of GeoJSON vector layers with the given style function.
	setStyle: function (style) {
		return this.eachLayer(function (layer) {
			this._setLayerStyle(layer, style);
		}, this);
	},

	_setLayerStyle: function (layer, style) {
		if (typeof style === 'function') {
			style = style(layer.feature);
		}
		if (layer.setStyle) {
			layer.setStyle(style);
		}
	}
});

// @section
// There are several static functions which can be called without instantiating L.GeoJSON:

// @function geometryToLayer(featureData: Object, options?: GeoJSON options): Layer
// Creates a `Layer` from a given GeoJSON feature. Can use a custom
// [`pointToLayer`](#geojson-pointtolayer) and/or [`coordsToLatLng`](#geojson-coordstolatlng)
// functions if provided as options.
function geometryToLayer(geojson, options) {

	var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
		coords = geometry ? geometry.coordinates : null,
		layers = [],
		pointToLayer = options && options.pointToLayer,
		_coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng,
		latlng, latlngs, i, len;

	if (!coords && !geometry) {
		return null;
	}

	switch (geometry.type) {
	case 'Point':
		latlng = _coordsToLatLng(coords);
		return pointToLayer ? pointToLayer(geojson, latlng) : new Marker(latlng);

	case 'MultiPoint':
		for (i = 0, len = coords.length; i < len; i++) {
			latlng = _coordsToLatLng(coords[i]);
			layers.push(pointToLayer ? pointToLayer(geojson, latlng) : new Marker(latlng));
		}
		return new FeatureGroup(layers);

	case 'LineString':
	case 'MultiLineString':
		latlngs = coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, _coordsToLatLng);
		return new Polyline(latlngs, options);

	case 'Polygon':
	case 'MultiPolygon':
		latlngs = coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, _coordsToLatLng);
		return new Polygon(latlngs, options);

	case 'GeometryCollection':
		for (i = 0, len = geometry.geometries.length; i < len; i++) {
			var layer = geometryToLayer({
				geometry: geometry.geometries[i],
				type: 'Feature',
				properties: geojson.properties
			}, options);

			if (layer) {
				layers.push(layer);
			}
		}
		return new FeatureGroup(layers);

	default:
		throw new Error('Invalid GeoJSON object.');
	}
}

// @function coordsToLatLng(coords: Array): LatLng
// Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)
// or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.
function coordsToLatLng(coords) {
	return new LatLng(coords[1], coords[0], coords[2]);
}

// @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array
// Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.
// `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).
// Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.
function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {
	var latlngs = [];

	for (var i = 0, len = coords.length, latlng; i < len; i++) {
		latlng = levelsDeep ?
			coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) :
			(_coordsToLatLng || coordsToLatLng)(coords[i]);

		latlngs.push(latlng);
	}

	return latlngs;
}

// @function latLngToCoords(latlng: LatLng, precision?: Number): Array
// Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)
function latLngToCoords(latlng, precision) {
	precision = typeof precision === 'number' ? precision : 6;
	return latlng.alt !== undefined ?
		[formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] :
		[formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];
}

// @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean): Array
// Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)
// `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.
function latLngsToCoords(latlngs, levelsDeep, closed, precision) {
	var coords = [];

	for (var i = 0, len = latlngs.length; i < len; i++) {
		coords.push(levelsDeep ?
			latLngsToCoords(latlngs[i], levelsDeep - 1, closed, precision) :
			latLngToCoords(latlngs[i], precision));
	}

	if (!levelsDeep && closed) {
		coords.push(coords[0]);
	}

	return coords;
}

function getFeature(layer, newGeometry) {
	return layer.feature ?
		extend({}, layer.feature, {geometry: newGeometry}) :
		asFeature(newGeometry);
}

// @function asFeature(geojson: Object): Object
// Normalize GeoJSON geometries/features into GeoJSON features.
function asFeature(geojson) {
	if (geojson.type === 'Feature' || geojson.type === 'FeatureCollection') {
		return geojson;
	}

	return {
		type: 'Feature',
		properties: {},
		geometry: geojson
	};
}

var PointToGeoJSON = {
	toGeoJSON: function (precision) {
		return getFeature(this, {
			type: 'Point',
			coordinates: latLngToCoords(this.getLatLng(), precision)
		});
	}
};

// @namespace Marker
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the marker (as a GeoJSON `Point` Feature).
Marker.include(PointToGeoJSON);

// @namespace CircleMarker
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the circle marker (as a GeoJSON `Point` Feature).
Circle.include(PointToGeoJSON);
CircleMarker.include(PointToGeoJSON);


// @namespace Polyline
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polyline (as a GeoJSON `LineString` or `MultiLineString` Feature).
Polyline.include({
	toGeoJSON: function (precision) {
		var multi = !isFlat(this._latlngs);

		var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);

		return getFeature(this, {
			type: (multi ? 'Multi' : '') + 'LineString',
			coordinates: coords
		});
	}
});

// @namespace Polygon
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polygon (as a GeoJSON `Polygon` or `MultiPolygon` Feature).
Polygon.include({
	toGeoJSON: function (precision) {
		var holes = !isFlat(this._latlngs),
			multi = holes && !isFlat(this._latlngs[0]);

		var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);

		if (!holes) {
			coords = [coords];
		}

		return getFeature(this, {
			type: (multi ? 'Multi' : '') + 'Polygon',
			coordinates: coords
		});
	}
});


// @namespace LayerGroup
LayerGroup.include({
	toMultiPoint: function (precision) {
		var coords = [];

		this.eachLayer(function (layer) {
			coords.push(layer.toGeoJSON(precision).geometry.coordinates);
		});

		return getFeature(this, {
			type: 'MultiPoint',
			coordinates: coords
		});
	},

	// @method toGeoJSON(): Object
	// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).
	toGeoJSON: function (precision) {

		var type = this.feature && this.feature.geometry && this.feature.geometry.type;

		if (type === 'MultiPoint') {
			return this.toMultiPoint(precision);
		}

		var isGeometryCollection = type === 'GeometryCollection',
			jsons = [];

		this.eachLayer(function (layer) {
			if (layer.toGeoJSON) {
				var json = layer.toGeoJSON(precision);
				if (isGeometryCollection) {
					jsons.push(json.geometry);
				} else {
					var feature = asFeature(json);
					// Squash nested feature collections
					if (feature.type === 'FeatureCollection') {
						jsons.push.apply(jsons, feature.features);
					} else {
						jsons.push(feature);
					}
				}
			}
		});

		if (isGeometryCollection) {
			return getFeature(this, {
				geometries: jsons,
				type: 'GeometryCollection'
			});
		}

		return {
			type: 'FeatureCollection',
			features: jsons
		};
	}
});

// @namespace GeoJSON
// @factory L.geoJSON(geojson?: Object, options?: GeoJSON options)
// Creates a GeoJSON layer. Optionally accepts an object in
// [GeoJSON format](https://tools.ietf.org/html/rfc7946) to display on the map
// (you can alternatively add it later with `addData` method) and an `options` object.
function geoJSON(geojson, options) {
	return new GeoJSON(geojson, options);
}

// Backward compatibility.
var geoJson = geoJSON;

/*
 * @class ImageOverlay
 * @aka L.ImageOverlay
 * @inherits Interactive layer
 *
 * Used to load and display a single image over specific bounds of the map. Extends `Layer`.
 *
 * @example
 *
 * ```js
 * var imageUrl = 'http://www.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',
 * 	imageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];
 * L.imageOverlay(imageUrl, imageBounds).addTo(map);
 * ```
 */

var ImageOverlay = Layer.extend({

	// @section
	// @aka ImageOverlay options
	options: {
		// @option opacity: Number = 1.0
		// The opacity of the image overlay.
		opacity: 1,

		// @option alt: String = ''
		// Text for the `alt` attribute of the image (useful for accessibility).
		alt: '',

		// @option interactive: Boolean = false
		// If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
		interactive: false,

		// @option crossOrigin: Boolean|String = false
		// Whether the crossOrigin attribute will be added to the image.
		// If a String is provided, the image will have its crossOrigin attribute set to the String provided. This is needed if you want to access image pixel data.
		// Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
		crossOrigin: false,

		// @option errorOverlayUrl: String = ''
		// URL to the overlay image to show in place of the overlay that failed to load.
		errorOverlayUrl: '',

		// @option zIndex: Number = 1
		// The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the overlay layer.
		zIndex: 1,

		// @option className: String = ''
		// A custom class name to assign to the image. Empty by default.
		className: ''
	},

	initialize: function (url, bounds, options) { // (String, LatLngBounds, Object)
		this._url = url;
		this._bounds = toLatLngBounds(bounds);

		setOptions(this, options);
	},

	onAdd: function () {
		if (!this._image) {
			this._initImage();

			if (this.options.opacity < 1) {
				this._updateOpacity();
			}
		}

		if (this.options.interactive) {
			addClass(this._image, 'leaflet-interactive');
			this.addInteractiveTarget(this._image);
		}

		this.getPane().appendChild(this._image);
		this._reset();
	},

	onRemove: function () {
		remove(this._image);
		if (this.options.interactive) {
			this.removeInteractiveTarget(this._image);
		}
	},

	// @method setOpacity(opacity: Number): this
	// Sets the opacity of the overlay.
	setOpacity: function (opacity) {
		this.options.opacity = opacity;

		if (this._image) {
			this._updateOpacity();
		}
		return this;
	},

	setStyle: function (styleOpts) {
		if (styleOpts.opacity) {
			this.setOpacity(styleOpts.opacity);
		}
		return this;
	},

	// @method bringToFront(): this
	// Brings the layer to the top of all overlays.
	bringToFront: function () {
		if (this._map) {
			toFront(this._image);
		}
		return this;
	},

	// @method bringToBack(): this
	// Brings the layer to the bottom of all overlays.
	bringToBack: function () {
		if (this._map) {
			toBack(this._image);
		}
		return this;
	},

	// @method setUrl(url: String): this
	// Changes the URL of the image.
	setUrl: function (url) {
		this._url = url;

		if (this._image) {
			this._image.src = url;
		}
		return this;
	},

	// @method setBounds(bounds: LatLngBounds): this
	// Update the bounds that this ImageOverlay covers
	setBounds: function (bounds) {
		this._bounds = toLatLngBounds(bounds);

		if (this._map) {
			this._reset();
		}
		return this;
	},

	getEvents: function () {
		var events = {
			zoom: this._reset,
			viewreset: this._reset
		};

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}

		return events;
	},

	// @method setZIndex(value: Number): this
	// Changes the [zIndex](#imageoverlay-zindex) of the image overlay.
	setZIndex: function (value) {
		this.options.zIndex = value;
		this._updateZIndex();
		return this;
	},

	// @method getBounds(): LatLngBounds
	// Get the bounds that this ImageOverlay covers
	getBounds: function () {
		return this._bounds;
	},

	// @method getElement(): HTMLElement
	// Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)
	// used by this overlay.
	getElement: function () {
		return this._image;
	},

	_initImage: function () {
		var wasElementSupplied = this._url.tagName === 'IMG';
		var img = this._image = wasElementSupplied ? this._url : create$1('img');

		addClass(img, 'leaflet-image-layer');
		if (this._zoomAnimated) { addClass(img, 'leaflet-zoom-animated'); }
		if (this.options.className) { addClass(img, this.options.className); }

		img.onselectstart = falseFn;
		img.onmousemove = falseFn;

		// @event load: Event
		// Fired when the ImageOverlay layer has loaded its image
		img.onload = bind(this.fire, this, 'load');
		img.onerror = bind(this._overlayOnError, this, 'error');

		if (this.options.crossOrigin || this.options.crossOrigin === '') {
			img.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;
		}

		if (this.options.zIndex) {
			this._updateZIndex();
		}

		if (wasElementSupplied) {
			this._url = img.src;
			return;
		}

		img.src = this._url;
		img.alt = this.options.alt;
	},

	_animateZoom: function (e) {
		var scale = this._map.getZoomScale(e.zoom),
			offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;

		setTransform(this._image, offset, scale);
	},

	_reset: function () {
		var image = this._image,
			bounds = new Bounds(
				this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
				this._map.latLngToLayerPoint(this._bounds.getSouthEast())),
			size = bounds.getSize();

		setPosition(image, bounds.min);

		image.style.width  = size.x + 'px';
		image.style.height = size.y + 'px';
	},

	_updateOpacity: function () {
		setOpacity(this._image, this.options.opacity);
	},

	_updateZIndex: function () {
		if (this._image && this.options.zIndex !== undefined && this.options.zIndex !== null) {
			this._image.style.zIndex = this.options.zIndex;
		}
	},

	_overlayOnError: function () {
		// @event error: Event
		// Fired when the ImageOverlay layer fails to load its image
		this.fire('error');

		var errorUrl = this.options.errorOverlayUrl;
		if (errorUrl && this._url !== errorUrl) {
			this._url = errorUrl;
			this._image.src = errorUrl;
		}
	}
});

// @factory L.imageOverlay(imageUrl: String, bounds: LatLngBounds, options?: ImageOverlay options)
// Instantiates an image overlay object given the URL of the image and the
// geographical bounds it is tied to.
var imageOverlay = function (url, bounds, options) {
	return new ImageOverlay(url, bounds, options);
};

/*
 * @class VideoOverlay
 * @aka L.VideoOverlay
 * @inherits ImageOverlay
 *
 * Used to load and display a video player over specific bounds of the map. Extends `ImageOverlay`.
 *
 * A video overlay uses the [`<video>`](https://developer.mozilla.org/docs/Web/HTML/Element/video)
 * HTML5 element.
 *
 * @example
 *
 * ```js
 * var videoUrl = 'https://www.mapbox.com/bites/00188/patricia_nasa.webm',
 * 	videoBounds = [[ 32, -130], [ 13, -100]];
 * L.videoOverlay(videoUrl, videoBounds ).addTo(map);
 * ```
 */

var VideoOverlay = ImageOverlay.extend({

	// @section
	// @aka VideoOverlay options
	options: {
		// @option autoplay: Boolean = true
		// Whether the video starts playing automatically when loaded.
		autoplay: true,

		// @option loop: Boolean = true
		// Whether the video will loop back to the beginning when played.
		loop: true
	},

	_initImage: function () {
		var wasElementSupplied = this._url.tagName === 'VIDEO';
		var vid = this._image = wasElementSupplied ? this._url : create$1('video');

		addClass(vid, 'leaflet-image-layer');
		if (this._zoomAnimated) { addClass(vid, 'leaflet-zoom-animated'); }

		vid.onselectstart = falseFn;
		vid.onmousemove = falseFn;

		// @event load: Event
		// Fired when the video has finished loading the first frame
		vid.onloadeddata = bind(this.fire, this, 'load');

		if (wasElementSupplied) {
			var sourceElements = vid.getElementsByTagName('source');
			var sources = [];
			for (var j = 0; j < sourceElements.length; j++) {
				sources.push(sourceElements[j].src);
			}

			this._url = (sourceElements.length > 0) ? sources : [vid.src];
			return;
		}

		if (!isArray(this._url)) { this._url = [this._url]; }

		vid.autoplay = !!this.options.autoplay;
		vid.loop = !!this.options.loop;
		for (var i = 0; i < this._url.length; i++) {
			var source = create$1('source');
			source.src = this._url[i];
			vid.appendChild(source);
		}
	}

	// @method getElement(): HTMLVideoElement
	// Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)
	// used by this overlay.
});


// @factory L.videoOverlay(video: String|Array|HTMLVideoElement, bounds: LatLngBounds, options?: VideoOverlay options)
// Instantiates an image overlay object given the URL of the video (or array of URLs, or even a video element) and the
// geographical bounds it is tied to.

function videoOverlay(video, bounds, options) {
	return new VideoOverlay(video, bounds, options);
}

/*
 * @class DivOverlay
 * @inherits Layer
 * @aka L.DivOverlay
 * Base model for L.Popup and L.Tooltip. Inherit from it for custom popup like plugins.
 */

// @namespace DivOverlay
var DivOverlay = Layer.extend({

	// @section
	// @aka DivOverlay options
	options: {
		// @option offset: Point = Point(0, 7)
		// The offset of the popup position. Useful to control the anchor
		// of the popup when opening it on some overlays.
		offset: [0, 7],

		// @option className: String = ''
		// A custom CSS class name to assign to the popup.
		className: '',

		// @option pane: String = 'popupPane'
		// `Map pane` where the popup will be added.
		pane: 'popupPane'
	},

	initialize: function (options, source) {
		setOptions(this, options);

		this._source = source;
	},

	onAdd: function (map) {
		this._zoomAnimated = map._zoomAnimated;

		if (!this._container) {
			this._initLayout();
		}

		if (map._fadeAnimated) {
			setOpacity(this._container, 0);
		}

		clearTimeout(this._removeTimeout);
		this.getPane().appendChild(this._container);
		this.update();

		if (map._fadeAnimated) {
			setOpacity(this._container, 1);
		}

		this.bringToFront();
	},

	onRemove: function (map) {
		if (map._fadeAnimated) {
			setOpacity(this._container, 0);
			this._removeTimeout = setTimeout(bind(remove, undefined, this._container), 200);
		} else {
			remove(this._container);
		}
	},

	// @namespace Popup
	// @method getLatLng: LatLng
	// Returns the geographical point of popup.
	getLatLng: function () {
		return this._latlng;
	},

	// @method setLatLng(latlng: LatLng): this
	// Sets the geographical point where the popup will open.
	setLatLng: function (latlng) {
		this._latlng = toLatLng(latlng);
		if (this._map) {
			this._updatePosition();
			this._adjustPan();
		}
		return this;
	},

	// @method getContent: String|HTMLElement
	// Returns the content of the popup.
	getContent: function () {
		return this._content;
	},

	// @method setContent(htmlContent: String|HTMLElement|Function): this
	// Sets the HTML content of the popup. If a function is passed the source layer will be passed to the function. The function should return a `String` or `HTMLElement` to be used in the popup.
	setContent: function (content) {
		this._content = content;
		this.update();
		return this;
	},

	// @method getElement: String|HTMLElement
	// Alias for [getContent()](#popup-getcontent)
	getElement: function () {
		return this._container;
	},

	// @method update: null
	// Updates the popup content, layout and position. Useful for updating the popup after something inside changed, e.g. image loaded.
	update: function () {
		if (!this._map) { return; }

		this._container.style.visibility = 'hidden';

		this._updateContent();
		this._updateLayout();
		this._updatePosition();

		this._container.style.visibility = '';

		this._adjustPan();
	},

	getEvents: function () {
		var events = {
			zoom: this._updatePosition,
			viewreset: this._updatePosition
		};

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}
		return events;
	},

	// @method isOpen: Boolean
	// Returns `true` when the popup is visible on the map.
	isOpen: function () {
		return !!this._map && this._map.hasLayer(this);
	},

	// @method bringToFront: this
	// Brings this popup in front of other popups (in the same map pane).
	bringToFront: function () {
		if (this._map) {
			toFront(this._container);
		}
		return this;
	},

	// @method bringToBack: this
	// Brings this popup to the back of other popups (in the same map pane).
	bringToBack: function () {
		if (this._map) {
			toBack(this._container);
		}
		return this;
	},

	_updateContent: function () {
		if (!this._content) { return; }

		var node = this._contentNode;
		var content = (typeof this._content === 'function') ? this._content(this._source || this) : this._content;

		if (typeof content === 'string') {
			node.innerHTML = content;
		} else {
			while (node.hasChildNodes()) {
				node.removeChild(node.firstChild);
			}
			node.appendChild(content);
		}
		this.fire('contentupdate');
	},

	_updatePosition: function () {
		if (!this._map) { return; }

		var pos = this._map.latLngToLayerPoint(this._latlng),
			offset = toPoint(this.options.offset),
			anchor = this._getAnchor();

		if (this._zoomAnimated) {
			setPosition(this._container, pos.add(anchor));
		} else {
			offset = offset.add(pos).add(anchor);
		}

		var bottom = this._containerBottom = -offset.y,
			left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;

		// bottom position the popup in case the height of the popup changes (images loading etc)
		this._container.style.bottom = bottom + 'px';
		this._container.style.left = left + 'px';
	},

	_getAnchor: function () {
		return [0, 0];
	}

});

/*
 * @class Popup
 * @inherits DivOverlay
 * @aka L.Popup
 * Used to open popups in certain places of the map. Use [Map.openPopup](#map-openpopup) to
 * open popups while making sure that only one popup is open at one time
 * (recommended for usability), or use [Map.addLayer](#map-addlayer) to open as many as you want.
 *
 * @example
 *
 * If you want to just bind a popup to marker click and then open it, it's really easy:
 *
 * ```js
 * marker.bindPopup(popupContent).openPopup();
 * ```
 * Path overlays like polylines also have a `bindPopup` method.
 * Here's a more complicated way to open a popup on a map:
 *
 * ```js
 * var popup = L.popup()
 * 	.setLatLng(latlng)
 * 	.setContent('<p>Hello world!<br />This is a nice popup.</p>')
 * 	.openOn(map);
 * ```
 */


// @namespace Popup
var Popup = DivOverlay.extend({

	// @section
	// @aka Popup options
	options: {
		// @option maxWidth: Number = 300
		// Max width of the popup, in pixels.
		maxWidth: 300,

		// @option minWidth: Number = 50
		// Min width of the popup, in pixels.
		minWidth: 50,

		// @option maxHeight: Number = null
		// If set, creates a scrollable container of the given height
		// inside a popup if its content exceeds it.
		maxHeight: null,

		// @option autoPan: Boolean = true
		// Set it to `false` if you don't want the map to do panning animation
		// to fit the opened popup.
		autoPan: true,

		// @option autoPanPaddingTopLeft: Point = null
		// The margin between the popup and the top left corner of the map
		// view after autopanning was performed.
		autoPanPaddingTopLeft: null,

		// @option autoPanPaddingBottomRight: Point = null
		// The margin between the popup and the bottom right corner of the map
		// view after autopanning was performed.
		autoPanPaddingBottomRight: null,

		// @option autoPanPadding: Point = Point(5, 5)
		// Equivalent of setting both top left and bottom right autopan padding to the same value.
		autoPanPadding: [5, 5],

		// @option keepInView: Boolean = false
		// Set it to `true` if you want to prevent users from panning the popup
		// off of the screen while it is open.
		keepInView: false,

		// @option closeButton: Boolean = true
		// Controls the presence of a close button in the popup.
		closeButton: true,

		// @option autoClose: Boolean = true
		// Set it to `false` if you want to override the default behavior of
		// the popup closing when another popup is opened.
		autoClose: true,

		// @option closeOnEscapeKey: Boolean = true
		// Set it to `false` if you want to override the default behavior of
		// the ESC key for closing of the popup.
		closeOnEscapeKey: true,

		// @option closeOnClick: Boolean = *
		// Set it if you want to override the default behavior of the popup closing when user clicks
		// on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.

		// @option className: String = ''
		// A custom CSS class name to assign to the popup.
		className: ''
	},

	// @namespace Popup
	// @method openOn(map: Map): this
	// Adds the popup to the map and closes the previous one. The same as `map.openPopup(popup)`.
	openOn: function (map) {
		map.openPopup(this);
		return this;
	},

	onAdd: function (map) {
		DivOverlay.prototype.onAdd.call(this, map);

		// @namespace Map
		// @section Popup events
		// @event popupopen: PopupEvent
		// Fired when a popup is opened in the map
		map.fire('popupopen', {popup: this});

		if (this._source) {
			// @namespace Layer
			// @section Popup events
			// @event popupopen: PopupEvent
			// Fired when a popup bound to this layer is opened
			this._source.fire('popupopen', {popup: this}, true);
			// For non-path layers, we toggle the popup when clicking
			// again the layer, so prevent the map to reopen it.
			if (!(this._source instanceof Path)) {
				this._source.on('preclick', stopPropagation);
			}
		}
	},

	onRemove: function (map) {
		DivOverlay.prototype.onRemove.call(this, map);

		// @namespace Map
		// @section Popup events
		// @event popupclose: PopupEvent
		// Fired when a popup in the map is closed
		map.fire('popupclose', {popup: this});

		if (this._source) {
			// @namespace Layer
			// @section Popup events
			// @event popupclose: PopupEvent
			// Fired when a popup bound to this layer is closed
			this._source.fire('popupclose', {popup: this}, true);
			if (!(this._source instanceof Path)) {
				this._source.off('preclick', stopPropagation);
			}
		}
	},

	getEvents: function () {
		var events = DivOverlay.prototype.getEvents.call(this);

		if (this.options.closeOnClick !== undefined ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
			events.preclick = this._close;
		}

		if (this.options.keepInView) {
			events.moveend = this._adjustPan;
		}

		return events;
	},

	_close: function () {
		if (this._map) {
			this._map.closePopup(this);
		}
	},

	_initLayout: function () {
		var prefix = 'leaflet-popup',
			container = this._container = create$1('div',
			prefix + ' ' + (this.options.className || '') +
			' leaflet-zoom-animated');

		var wrapper = this._wrapper = create$1('div', prefix + '-content-wrapper', container);
		this._contentNode = create$1('div', prefix + '-content', wrapper);

		disableClickPropagation(wrapper);
		disableScrollPropagation(this._contentNode);
		on(wrapper, 'contextmenu', stopPropagation);

		this._tipContainer = create$1('div', prefix + '-tip-container', container);
		this._tip = create$1('div', prefix + '-tip', this._tipContainer);

		if (this.options.closeButton) {
			var closeButton = this._closeButton = create$1('a', prefix + '-close-button', container);
			closeButton.href = '#close';
			closeButton.innerHTML = '&#215;';

			on(closeButton, 'click', this._onCloseButtonClick, this);
		}
	},

	_updateLayout: function () {
		var container = this._contentNode,
			style = container.style;

		style.width = '';
		style.whiteSpace = 'nowrap';

		var width = container.offsetWidth;
		width = Math.min(width, this.options.maxWidth);
		width = Math.max(width, this.options.minWidth);

		style.width = (width + 1) + 'px';
		style.whiteSpace = '';

		style.height = '';

		var height = container.offsetHeight,
			maxHeight = this.options.maxHeight,
			scrolledClass = 'leaflet-popup-scrolled';

		if (maxHeight && height > maxHeight) {
			style.height = maxHeight + 'px';
			addClass(container, scrolledClass);
		} else {
			removeClass(container, scrolledClass);
		}

		this._containerWidth = this._container.offsetWidth;
	},

	_animateZoom: function (e) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center),
			anchor = this._getAnchor();
		setPosition(this._container, pos.add(anchor));
	},

	_adjustPan: function () {
		if (!this.options.autoPan) { return; }
		if (this._map._panAnim) { this._map._panAnim.stop(); }

		var map = this._map,
			marginBottom = parseInt(getStyle(this._container, 'marginBottom'), 10) || 0,
			containerHeight = this._container.offsetHeight + marginBottom,
			containerWidth = this._containerWidth,
			layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);

		layerPos._add(getPosition(this._container));

		var containerPos = map.layerPointToContainerPoint(layerPos),
			padding = toPoint(this.options.autoPanPadding),
			paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding),
			paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding),
			size = map.getSize(),
			dx = 0,
			dy = 0;

		if (containerPos.x + containerWidth + paddingBR.x > size.x) { // right
			dx = containerPos.x + containerWidth - size.x + paddingBR.x;
		}
		if (containerPos.x - dx - paddingTL.x < 0) { // left
			dx = containerPos.x - paddingTL.x;
		}
		if (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom
			dy = containerPos.y + containerHeight - size.y + paddingBR.y;
		}
		if (containerPos.y - dy - paddingTL.y < 0) { // top
			dy = containerPos.y - paddingTL.y;
		}

		// @namespace Map
		// @section Popup events
		// @event autopanstart: Event
		// Fired when the map starts autopanning when opening a popup.
		if (dx || dy) {
			map
				.fire('autopanstart')
				.panBy([dx, dy]);
		}
	},

	_onCloseButtonClick: function (e) {
		this._close();
		stop(e);
	},

	_getAnchor: function () {
		// Where should we anchor the popup on the source layer?
		return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
	}

});

// @namespace Popup
// @factory L.popup(options?: Popup options, source?: Layer)
// Instantiates a `Popup` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the popup with a reference to the Layer to which it refers.
var popup = function (options, source) {
	return new Popup(options, source);
};


/* @namespace Map
 * @section Interaction Options
 * @option closePopupOnClick: Boolean = true
 * Set it to `false` if you don't want popups to close when user clicks the map.
 */
Map.mergeOptions({
	closePopupOnClick: true
});


// @namespace Map
// @section Methods for Layers and Controls
Map.include({
	// @method openPopup(popup: Popup): this
	// Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
	// @alternative
	// @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
	// Creates a popup with the specified content and options and opens it in the given point on a map.
	openPopup: function (popup, latlng, options) {
		if (!(popup instanceof Popup)) {
			popup = new Popup(options).setContent(popup);
		}

		if (latlng) {
			popup.setLatLng(latlng);
		}

		if (this.hasLayer(popup)) {
			return this;
		}

		if (this._popup && this._popup.options.autoClose) {
			this.closePopup();
		}

		this._popup = popup;
		return this.addLayer(popup);
	},

	// @method closePopup(popup?: Popup): this
	// Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
	closePopup: function (popup) {
		if (!popup || popup === this._popup) {
			popup = this._popup;
			this._popup = null;
		}
		if (popup) {
			this.removeLayer(popup);
		}
		return this;
	}
});

/*
 * @namespace Layer
 * @section Popup methods example
 *
 * All layers share a set of methods convenient for binding popups to it.
 *
 * ```js
 * var layer = L.Polygon(latlngs).bindPopup('Hi There!').addTo(map);
 * layer.openPopup();
 * layer.closePopup();
 * ```
 *
 * Popups will also be automatically opened when the layer is clicked on and closed when the layer is removed from the map or another popup is opened.
 */

// @section Popup methods
Layer.include({

	// @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
	// Binds a popup to the layer with the passed `content` and sets up the
	// necessary event listeners. If a `Function` is passed it will receive
	// the layer as the first argument and should return a `String` or `HTMLElement`.
	bindPopup: function (content, options) {

		if (content instanceof Popup) {
			setOptions(content, options);
			this._popup = content;
			content._source = this;
		} else {
			if (!this._popup || options) {
				this._popup = new Popup(options, this);
			}
			this._popup.setContent(content);
		}

		if (!this._popupHandlersAdded) {
			this.on({
				click: this._openPopup,
				keypress: this._onKeyPress,
				remove: this.closePopup,
				move: this._movePopup
			});
			this._popupHandlersAdded = true;
		}

		return this;
	},

	// @method unbindPopup(): this
	// Removes the popup previously bound with `bindPopup`.
	unbindPopup: function () {
		if (this._popup) {
			this.off({
				click: this._openPopup,
				keypress: this._onKeyPress,
				remove: this.closePopup,
				move: this._movePopup
			});
			this._popupHandlersAdded = false;
			this._popup = null;
		}
		return this;
	},

	// @method openPopup(latlng?: LatLng): this
	// Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.
	openPopup: function (layer, latlng) {
		if (!(layer instanceof Layer)) {
			latlng = layer;
			layer = this;
		}

		if (layer instanceof FeatureGroup) {
			for (var id in this._layers) {
				layer = this._layers[id];
				break;
			}
		}

		if (!latlng) {
			latlng = layer.getCenter ? layer.getCenter() : layer.getLatLng();
		}

		if (this._popup && this._map) {
			// set popup source to this layer
			this._popup._source = layer;

			// update the popup (content, layout, ect...)
			this._popup.update();

			// open the popup on the map
			this._map.openPopup(this._popup, latlng);
		}

		return this;
	},

	// @method closePopup(): this
	// Closes the popup bound to this layer if it is open.
	closePopup: function () {
		if (this._popup) {
			this._popup._close();
		}
		return this;
	},

	// @method togglePopup(): this
	// Opens or closes the popup bound to this layer depending on its current state.
	togglePopup: function (target) {
		if (this._popup) {
			if (this._popup._map) {
				this.closePopup();
			} else {
				this.openPopup(target);
			}
		}
		return this;
	},

	// @method isPopupOpen(): boolean
	// Returns `true` if the popup bound to this layer is currently open.
	isPopupOpen: function () {
		return (this._popup ? this._popup.isOpen() : false);
	},

	// @method setPopupContent(content: String|HTMLElement|Popup): this
	// Sets the content of the popup bound to this layer.
	setPopupContent: function (content) {
		if (this._popup) {
			this._popup.setContent(content);
		}
		return this;
	},

	// @method getPopup(): Popup
	// Returns the popup bound to this layer.
	getPopup: function () {
		return this._popup;
	},

	_openPopup: function (e) {
		var layer = e.layer || e.target;

		if (!this._popup) {
			return;
		}

		if (!this._map) {
			return;
		}

		// prevent map click
		stop(e);

		// if this inherits from Path its a vector and we can just
		// open the popup at the new location
		if (layer instanceof Path) {
			this.openPopup(e.layer || e.target, e.latlng);
			return;
		}

		// otherwise treat it like a marker and figure out
		// if we should toggle it open/closed
		if (this._map.hasLayer(this._popup) && this._popup._source === layer) {
			this.closePopup();
		} else {
			this.openPopup(layer, e.latlng);
		}
	},

	_movePopup: function (e) {
		this._popup.setLatLng(e.latlng);
	},

	_onKeyPress: function (e) {
		if (e.originalEvent.keyCode === 13) {
			this._openPopup(e);
		}
	}
});

/*
 * @class Tooltip
 * @inherits DivOverlay
 * @aka L.Tooltip
 * Used to display small texts on top of map layers.
 *
 * @example
 *
 * ```js
 * marker.bindTooltip("my tooltip text").openTooltip();
 * ```
 * Note about tooltip offset. Leaflet takes two options in consideration
 * for computing tooltip offsetting:
 * - the `offset` Tooltip option: it defaults to [0, 0], and it's specific to one tooltip.
 *   Add a positive x offset to move the tooltip to the right, and a positive y offset to
 *   move it to the bottom. Negatives will move to the left and top.
 * - the `tooltipAnchor` Icon option: this will only be considered for Marker. You
 *   should adapt this value if you use a custom icon.
 */


// @namespace Tooltip
var Tooltip = DivOverlay.extend({

	// @section
	// @aka Tooltip options
	options: {
		// @option pane: String = 'tooltipPane'
		// `Map pane` where the tooltip will be added.
		pane: 'tooltipPane',

		// @option offset: Point = Point(0, 0)
		// Optional offset of the tooltip position.
		offset: [0, 0],

		// @option direction: String = 'auto'
		// Direction where to open the tooltip. Possible values are: `right`, `left`,
		// `top`, `bottom`, `center`, `auto`.
		// `auto` will dynamically switch between `right` and `left` according to the tooltip
		// position on the map.
		direction: 'auto',

		// @option permanent: Boolean = false
		// Whether to open the tooltip permanently or only on mouseover.
		permanent: false,

		// @option sticky: Boolean = false
		// If true, the tooltip will follow the mouse instead of being fixed at the feature center.
		sticky: false,

		// @option interactive: Boolean = false
		// If true, the tooltip will listen to the feature events.
		interactive: false,

		// @option opacity: Number = 0.9
		// Tooltip container opacity.
		opacity: 0.9
	},

	onAdd: function (map) {
		DivOverlay.prototype.onAdd.call(this, map);
		this.setOpacity(this.options.opacity);

		// @namespace Map
		// @section Tooltip events
		// @event tooltipopen: TooltipEvent
		// Fired when a tooltip is opened in the map.
		map.fire('tooltipopen', {tooltip: this});

		if (this._source) {
			// @namespace Layer
			// @section Tooltip events
			// @event tooltipopen: TooltipEvent
			// Fired when a tooltip bound to this layer is opened.
			this._source.fire('tooltipopen', {tooltip: this}, true);
		}
	},

	onRemove: function (map) {
		DivOverlay.prototype.onRemove.call(this, map);

		// @namespace Map
		// @section Tooltip events
		// @event tooltipclose: TooltipEvent
		// Fired when a tooltip in the map is closed.
		map.fire('tooltipclose', {tooltip: this});

		if (this._source) {
			// @namespace Layer
			// @section Tooltip events
			// @event tooltipclose: TooltipEvent
			// Fired when a tooltip bound to this layer is closed.
			this._source.fire('tooltipclose', {tooltip: this}, true);
		}
	},

	getEvents: function () {
		var events = DivOverlay.prototype.getEvents.call(this);

		if (touch && !this.options.permanent) {
			events.preclick = this._close;
		}

		return events;
	},

	_close: function () {
		if (this._map) {
			this._map.closeTooltip(this);
		}
	},

	_initLayout: function () {
		var prefix = 'leaflet-tooltip',
			className = prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

		this._contentNode = this._container = create$1('div', className);
	},

	_updateLayout: function () {},

	_adjustPan: function () {},

	_setPosition: function (pos) {
		var map = this._map,
			container = this._container,
			centerPoint = map.latLngToContainerPoint(map.getCenter()),
			tooltipPoint = map.layerPointToContainerPoint(pos),
			direction = this.options.direction,
			tooltipWidth = container.offsetWidth,
			tooltipHeight = container.offsetHeight,
			offset = toPoint(this.options.offset),
			anchor = this._getAnchor();

		if (direction === 'top') {
			pos = pos.add(toPoint(-tooltipWidth / 2 + offset.x, -tooltipHeight + offset.y + anchor.y, true));
		} else if (direction === 'bottom') {
			pos = pos.subtract(toPoint(tooltipWidth / 2 - offset.x, -offset.y, true));
		} else if (direction === 'center') {
			pos = pos.subtract(toPoint(tooltipWidth / 2 + offset.x, tooltipHeight / 2 - anchor.y + offset.y, true));
		} else if (direction === 'right' || direction === 'auto' && tooltipPoint.x < centerPoint.x) {
			direction = 'right';
			pos = pos.add(toPoint(offset.x + anchor.x, anchor.y - tooltipHeight / 2 + offset.y, true));
		} else {
			direction = 'left';
			pos = pos.subtract(toPoint(tooltipWidth + anchor.x - offset.x, tooltipHeight / 2 - anchor.y - offset.y, true));
		}

		removeClass(container, 'leaflet-tooltip-right');
		removeClass(container, 'leaflet-tooltip-left');
		removeClass(container, 'leaflet-tooltip-top');
		removeClass(container, 'leaflet-tooltip-bottom');
		addClass(container, 'leaflet-tooltip-' + direction);
		setPosition(container, pos);
	},

	_updatePosition: function () {
		var pos = this._map.latLngToLayerPoint(this._latlng);
		this._setPosition(pos);
	},

	setOpacity: function (opacity) {
		this.options.opacity = opacity;

		if (this._container) {
			setOpacity(this._container, opacity);
		}
	},

	_animateZoom: function (e) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);
		this._setPosition(pos);
	},

	_getAnchor: function () {
		// Where should we anchor the tooltip on the source layer?
		return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
	}

});

// @namespace Tooltip
// @factory L.tooltip(options?: Tooltip options, source?: Layer)
// Instantiates a Tooltip object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the tooltip with a reference to the Layer to which it refers.
var tooltip = function (options, source) {
	return new Tooltip(options, source);
};

// @namespace Map
// @section Methods for Layers and Controls
Map.include({

	// @method openTooltip(tooltip: Tooltip): this
	// Opens the specified tooltip.
	// @alternative
	// @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
	// Creates a tooltip with the specified content and options and open it.
	openTooltip: function (tooltip, latlng, options) {
		if (!(tooltip instanceof Tooltip)) {
			tooltip = new Tooltip(options).setContent(tooltip);
		}

		if (latlng) {
			tooltip.setLatLng(latlng);
		}

		if (this.hasLayer(tooltip)) {
			return this;
		}

		return this.addLayer(tooltip);
	},

	// @method closeTooltip(tooltip?: Tooltip): this
	// Closes the tooltip given as parameter.
	closeTooltip: function (tooltip) {
		if (tooltip) {
			this.removeLayer(tooltip);
		}
		return this;
	}

});

/*
 * @namespace Layer
 * @section Tooltip methods example
 *
 * All layers share a set of methods convenient for binding tooltips to it.
 *
 * ```js
 * var layer = L.Polygon(latlngs).bindTooltip('Hi There!').addTo(map);
 * layer.openTooltip();
 * layer.closeTooltip();
 * ```
 */

// @section Tooltip methods
Layer.include({

	// @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
	// Binds a tooltip to the layer with the passed `content` and sets up the
	// necessary event listeners. If a `Function` is passed it will receive
	// the layer as the first argument and should return a `String` or `HTMLElement`.
	bindTooltip: function (content, options) {

		if (content instanceof Tooltip) {
			setOptions(content, options);
			this._tooltip = content;
			content._source = this;
		} else {
			if (!this._tooltip || options) {
				this._tooltip = new Tooltip(options, this);
			}
			this._tooltip.setContent(content);

		}

		this._initTooltipInteractions();

		if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {
			this.openTooltip();
		}

		return this;
	},

	// @method unbindTooltip(): this
	// Removes the tooltip previously bound with `bindTooltip`.
	unbindTooltip: function () {
		if (this._tooltip) {
			this._initTooltipInteractions(true);
			this.closeTooltip();
			this._tooltip = null;
		}
		return this;
	},

	_initTooltipInteractions: function (remove$$1) {
		if (!remove$$1 && this._tooltipHandlersAdded) { return; }
		var onOff = remove$$1 ? 'off' : 'on',
			events = {
			remove: this.closeTooltip,
			move: this._moveTooltip
			};
		if (!this._tooltip.options.permanent) {
			events.mouseover = this._openTooltip;
			events.mouseout = this.closeTooltip;
			if (this._tooltip.options.sticky) {
				events.mousemove = this._moveTooltip;
			}
			if (touch) {
				events.click = this._openTooltip;
			}
		} else {
			events.add = this._openTooltip;
		}
		this[onOff](events);
		this._tooltipHandlersAdded = !remove$$1;
	},

	// @method openTooltip(latlng?: LatLng): this
	// Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.
	openTooltip: function (layer, latlng) {
		if (!(layer instanceof Layer)) {
			latlng = layer;
			layer = this;
		}

		if (layer instanceof FeatureGroup) {
			for (var id in this._layers) {
				layer = this._layers[id];
				break;
			}
		}

		if (!latlng) {
			latlng = layer.getCenter ? layer.getCenter() : layer.getLatLng();
		}

		if (this._tooltip && this._map) {

			// set tooltip source to this layer
			this._tooltip._source = layer;

			// update the tooltip (content, layout, ect...)
			this._tooltip.update();

			// open the tooltip on the map
			this._map.openTooltip(this._tooltip, latlng);

			// Tooltip container may not be defined if not permanent and never
			// opened.
			if (this._tooltip.options.interactive && this._tooltip._container) {
				addClass(this._tooltip._container, 'leaflet-clickable');
				this.addInteractiveTarget(this._tooltip._container);
			}
		}

		return this;
	},

	// @method closeTooltip(): this
	// Closes the tooltip bound to this layer if it is open.
	closeTooltip: function () {
		if (this._tooltip) {
			this._tooltip._close();
			if (this._tooltip.options.interactive && this._tooltip._container) {
				removeClass(this._tooltip._container, 'leaflet-clickable');
				this.removeInteractiveTarget(this._tooltip._container);
			}
		}
		return this;
	},

	// @method toggleTooltip(): this
	// Opens or closes the tooltip bound to this layer depending on its current state.
	toggleTooltip: function (target) {
		if (this._tooltip) {
			if (this._tooltip._map) {
				this.closeTooltip();
			} else {
				this.openTooltip(target);
			}
		}
		return this;
	},

	// @method isTooltipOpen(): boolean
	// Returns `true` if the tooltip bound to this layer is currently open.
	isTooltipOpen: function () {
		return this._tooltip.isOpen();
	},

	// @method setTooltipContent(content: String|HTMLElement|Tooltip): this
	// Sets the content of the tooltip bound to this layer.
	setTooltipContent: function (content) {
		if (this._tooltip) {
			this._tooltip.setContent(content);
		}
		return this;
	},

	// @method getTooltip(): Tooltip
	// Returns the tooltip bound to this layer.
	getTooltip: function () {
		return this._tooltip;
	},

	_openTooltip: function (e) {
		var layer = e.layer || e.target;

		if (!this._tooltip || !this._map) {
			return;
		}
		this.openTooltip(layer, this._tooltip.options.sticky ? e.latlng : undefined);
	},

	_moveTooltip: function (e) {
		var latlng = e.latlng, containerPoint, layerPoint;
		if (this._tooltip.options.sticky && e.originalEvent) {
			containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);
			layerPoint = this._map.containerPointToLayerPoint(containerPoint);
			latlng = this._map.layerPointToLatLng(layerPoint);
		}
		this._tooltip.setLatLng(latlng);
	}
});

/*
 * @class DivIcon
 * @aka L.DivIcon
 * @inherits Icon
 *
 * Represents a lightweight icon for markers that uses a simple `<div>`
 * element instead of an image. Inherits from `Icon` but ignores the `iconUrl` and shadow options.
 *
 * @example
 * ```js
 * var myIcon = L.divIcon({className: 'my-div-icon'});
 * // you can set .my-div-icon styles in CSS
 *
 * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
 * ```
 *
 * By default, it has a 'leaflet-div-icon' CSS class and is styled as a little white square with a shadow.
 */

var DivIcon = Icon.extend({
	options: {
		// @section
		// @aka DivIcon options
		iconSize: [12, 12], // also can be set through CSS

		// iconAnchor: (Point),
		// popupAnchor: (Point),

		// @option html: String = ''
		// Custom HTML code to put inside the div element, empty by default.
		html: false,

		// @option bgPos: Point = [0, 0]
		// Optional relative position of the background, in pixels
		bgPos: null,

		className: 'leaflet-div-icon'
	},

	createIcon: function (oldIcon) {
		var div = (oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'),
			options = this.options;

		div.innerHTML = options.html !== false ? options.html : '';

		if (options.bgPos) {
			var bgPos = toPoint(options.bgPos);
			div.style.backgroundPosition = (-bgPos.x) + 'px ' + (-bgPos.y) + 'px';
		}
		this._setIconStyles(div, 'icon');

		return div;
	},

	createShadow: function () {
		return null;
	}
});

// @factory L.divIcon(options: DivIcon options)
// Creates a `DivIcon` instance with the given options.
function divIcon(options) {
	return new DivIcon(options);
}

Icon.Default = IconDefault;

/*
 * @class GridLayer
 * @inherits Layer
 * @aka L.GridLayer
 *
 * Generic class for handling a tiled grid of HTML elements. This is the base class for all tile layers and replaces `TileLayer.Canvas`.
 * GridLayer can be extended to create a tiled grid of HTML elements like `<canvas>`, `<img>` or `<div>`. GridLayer will handle creating and animating these DOM elements for you.
 *
 *
 * @section Synchronous usage
 * @example
 *
 * To create a custom layer, extend GridLayer and implement the `createTile()` method, which will be passed a `Point` object with the `x`, `y`, and `z` (zoom level) coordinates to draw your tile.
 *
 * ```js
 * var CanvasLayer = L.GridLayer.extend({
 *     createTile: function(coords){
 *         // create a <canvas> element for drawing
 *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
 *
 *         // setup tile width and height according to the options
 *         var size = this.getTileSize();
 *         tile.width = size.x;
 *         tile.height = size.y;
 *
 *         // get a canvas context and draw something on it using coords.x, coords.y and coords.z
 *         var ctx = tile.getContext('2d');
 *
 *         // return the tile so it can be rendered on screen
 *         return tile;
 *     }
 * });
 * ```
 *
 * @section Asynchronous usage
 * @example
 *
 * Tile creation can also be asynchronous, this is useful when using a third-party drawing library. Once the tile is finished drawing it can be passed to the `done()` callback.
 *
 * ```js
 * var CanvasLayer = L.GridLayer.extend({
 *     createTile: function(coords, done){
 *         var error;
 *
 *         // create a <canvas> element for drawing
 *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
 *
 *         // setup tile width and height according to the options
 *         var size = this.getTileSize();
 *         tile.width = size.x;
 *         tile.height = size.y;
 *
 *         // draw something asynchronously and pass the tile to the done() callback
 *         setTimeout(function() {
 *             done(error, tile);
 *         }, 1000);
 *
 *         return tile;
 *     }
 * });
 * ```
 *
 * @section
 */


var GridLayer = Layer.extend({

	// @section
	// @aka GridLayer options
	options: {
		// @option tileSize: Number|Point = 256
		// Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
		tileSize: 256,

		// @option opacity: Number = 1.0
		// Opacity of the tiles. Can be used in the `createTile()` function.
		opacity: 1,

		// @option updateWhenIdle: Boolean = (depends)
		// Load new tiles only when panning ends.
		// `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
		// `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the
		// [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
		updateWhenIdle: mobile,

		// @option updateWhenZooming: Boolean = true
		// By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
		updateWhenZooming: true,

		// @option updateInterval: Number = 200
		// Tiles will not update more than once every `updateInterval` milliseconds when panning.
		updateInterval: 200,

		// @option zIndex: Number = 1
		// The explicit zIndex of the tile layer.
		zIndex: 1,

		// @option bounds: LatLngBounds = undefined
		// If set, tiles will only be loaded inside the set `LatLngBounds`.
		bounds: null,

		// @option minZoom: Number = 0
		// The minimum zoom level down to which this layer will be displayed (inclusive).
		minZoom: 0,

		// @option maxZoom: Number = undefined
		// The maximum zoom level up to which this layer will be displayed (inclusive).
		maxZoom: undefined,

		// @option maxNativeZoom: Number = undefined
		// Maximum zoom number the tile source has available. If it is specified,
		// the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
		// from `maxNativeZoom` level and auto-scaled.
		maxNativeZoom: undefined,

		// @option minNativeZoom: Number = undefined
		// Minimum zoom number the tile source has available. If it is specified,
		// the tiles on all zoom levels lower than `minNativeZoom` will be loaded
		// from `minNativeZoom` level and auto-scaled.
		minNativeZoom: undefined,

		// @option noWrap: Boolean = false
		// Whether the layer is wrapped around the antimeridian. If `true`, the
		// GridLayer will only be displayed once at low zoom levels. Has no
		// effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
		// in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
		// tiles outside the CRS limits.
		noWrap: false,

		// @option pane: String = 'tilePane'
		// `Map pane` where the grid layer will be added.
		pane: 'tilePane',

		// @option className: String = ''
		// A custom class name to assign to the tile layer. Empty by default.
		className: '',

		// @option keepBuffer: Number = 2
		// When panning the map, keep this many rows and columns of tiles before unloading them.
		keepBuffer: 2
	},

	initialize: function (options) {
		setOptions(this, options);
	},

	onAdd: function () {
		this._initContainer();

		this._levels = {};
		this._tiles = {};

		this._resetView();
		this._update();
	},

	beforeAdd: function (map) {
		map._addZoomLimit(this);
	},

	onRemove: function (map) {
		this._removeAllTiles();
		remove(this._container);
		map._removeZoomLimit(this);
		this._container = null;
		this._tileZoom = undefined;
	},

	// @method bringToFront: this
	// Brings the tile layer to the top of all tile layers.
	bringToFront: function () {
		if (this._map) {
			toFront(this._container);
			this._setAutoZIndex(Math.max);
		}
		return this;
	},

	// @method bringToBack: this
	// Brings the tile layer to the bottom of all tile layers.
	bringToBack: function () {
		if (this._map) {
			toBack(this._container);
			this._setAutoZIndex(Math.min);
		}
		return this;
	},

	// @method getContainer: HTMLElement
	// Returns the HTML element that contains the tiles for this layer.
	getContainer: function () {
		return this._container;
	},

	// @method setOpacity(opacity: Number): this
	// Changes the [opacity](#gridlayer-opacity) of the grid layer.
	setOpacity: function (opacity) {
		this.options.opacity = opacity;
		this._updateOpacity();
		return this;
	},

	// @method setZIndex(zIndex: Number): this
	// Changes the [zIndex](#gridlayer-zindex) of the grid layer.
	setZIndex: function (zIndex) {
		this.options.zIndex = zIndex;
		this._updateZIndex();

		return this;
	},

	// @method isLoading: Boolean
	// Returns `true` if any tile in the grid layer has not finished loading.
	isLoading: function () {
		return this._loading;
	},

	// @method redraw: this
	// Causes the layer to clear all the tiles and request them again.
	redraw: function () {
		if (this._map) {
			this._removeAllTiles();
			this._update();
		}
		return this;
	},

	getEvents: function () {
		var events = {
			viewprereset: this._invalidateAll,
			viewreset: this._resetView,
			zoom: this._resetView,
			moveend: this._onMoveEnd
		};

		if (!this.options.updateWhenIdle) {
			// update tiles on move, but not more often than once per given interval
			if (!this._onMove) {
				this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);
			}

			events.move = this._onMove;
		}

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}

		return events;
	},

	// @section Extension methods
	// Layers extending `GridLayer` shall reimplement the following method.
	// @method createTile(coords: Object, done?: Function): HTMLElement
	// Called only internally, must be overridden by classes extending `GridLayer`.
	// Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
	// is specified, it must be called when the tile has finished loading and drawing.
	createTile: function () {
		return document.createElement('div');
	},

	// @section
	// @method getTileSize: Point
	// Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
	getTileSize: function () {
		var s = this.options.tileSize;
		return s instanceof Point ? s : new Point(s, s);
	},

	_updateZIndex: function () {
		if (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {
			this._container.style.zIndex = this.options.zIndex;
		}
	},

	_setAutoZIndex: function (compare) {
		// go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)

		var layers = this.getPane().children,
			edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min

		for (var i = 0, len = layers.length, zIndex; i < len; i++) {

			zIndex = layers[i].style.zIndex;

			if (layers[i] !== this._container && zIndex) {
				edgeZIndex = compare(edgeZIndex, +zIndex);
			}
		}

		if (isFinite(edgeZIndex)) {
			this.options.zIndex = edgeZIndex + compare(-1, 1);
			this._updateZIndex();
		}
	},

	_updateOpacity: function () {
		if (!this._map) { return; }

		// IE doesn't inherit filter opacity properly, so we're forced to set it on tiles
		if (ielt9) { return; }

		setOpacity(this._container, this.options.opacity);

		var now = +new Date(),
			nextFrame = false,
			willPrune = false;

		for (var key in this._tiles) {
			var tile = this._tiles[key];
			if (!tile.current || !tile.loaded) { continue; }

			var fade = Math.min(1, (now - tile.loaded) / 200);

			setOpacity(tile.el, fade);
			if (fade < 1) {
				nextFrame = true;
			} else {
				if (tile.active) {
					willPrune = true;
				} else {
					this._onOpaqueTile(tile);
				}
				tile.active = true;
			}
		}

		if (willPrune && !this._noPrune) { this._pruneTiles(); }

		if (nextFrame) {
			cancelAnimFrame(this._fadeFrame);
			this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
		}
	},

	_onOpaqueTile: falseFn,

	_initContainer: function () {
		if (this._container) { return; }

		this._container = create$1('div', 'leaflet-layer ' + (this.options.className || ''));
		this._updateZIndex();

		if (this.options.opacity < 1) {
			this._updateOpacity();
		}

		this.getPane().appendChild(this._container);
	},

	_updateLevels: function () {

		var zoom = this._tileZoom,
			maxZoom = this.options.maxZoom;

		if (zoom === undefined) { return undefined; }

		for (var z in this._levels) {
			if (this._levels[z].el.children.length || z === zoom) {
				this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);
				this._onUpdateLevel(z);
			} else {
				remove(this._levels[z].el);
				this._removeTilesAtZoom(z);
				this._onRemoveLevel(z);
				delete this._levels[z];
			}
		}

		var level = this._levels[zoom],
			map = this._map;

		if (!level) {
			level = this._levels[zoom] = {};

			level.el = create$1('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);
			level.el.style.zIndex = maxZoom;

			level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();
			level.zoom = zoom;

			this._setZoomTransform(level, map.getCenter(), map.getZoom());

			// force the browser to consider the newly added element for transition
			falseFn(level.el.offsetWidth);

			this._onCreateLevel(level);
		}

		this._level = level;

		return level;
	},

	_onUpdateLevel: falseFn,

	_onRemoveLevel: falseFn,

	_onCreateLevel: falseFn,

	_pruneTiles: function () {
		if (!this._map) {
			return;
		}

		var key, tile;

		var zoom = this._map.getZoom();
		if (zoom > this.options.maxZoom ||
			zoom < this.options.minZoom) {
			this._removeAllTiles();
			return;
		}

		for (key in this._tiles) {
			tile = this._tiles[key];
			tile.retain = tile.current;
		}

		for (key in this._tiles) {
			tile = this._tiles[key];
			if (tile.current && !tile.active) {
				var coords = tile.coords;
				if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
					this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
				}
			}
		}

		for (key in this._tiles) {
			if (!this._tiles[key].retain) {
				this._removeTile(key);
			}
		}
	},

	_removeTilesAtZoom: function (zoom) {
		for (var key in this._tiles) {
			if (this._tiles[key].coords.z !== zoom) {
				continue;
			}
			this._removeTile(key);
		}
	},

	_removeAllTiles: function () {
		for (var key in this._tiles) {
			this._removeTile(key);
		}
	},

	_invalidateAll: function () {
		for (var z in this._levels) {
			remove(this._levels[z].el);
			this._onRemoveLevel(z);
			delete this._levels[z];
		}
		this._removeAllTiles();

		this._tileZoom = undefined;
	},

	_retainParent: function (x, y, z, minZoom) {
		var x2 = Math.floor(x / 2),
			y2 = Math.floor(y / 2),
			z2 = z - 1,
			coords2 = new Point(+x2, +y2);
		coords2.z = +z2;

		var key = this._tileCoordsToKey(coords2),
			tile = this._tiles[key];

		if (tile && tile.active) {
			tile.retain = true;
			return true;

		} else if (tile && tile.loaded) {
			tile.retain = true;
		}

		if (z2 > minZoom) {
			return this._retainParent(x2, y2, z2, minZoom);
		}

		return false;
	},

	_retainChildren: function (x, y, z, maxZoom) {

		for (var i = 2 * x; i < 2 * x + 2; i++) {
			for (var j = 2 * y; j < 2 * y + 2; j++) {

				var coords = new Point(i, j);
				coords.z = z + 1;

				var key = this._tileCoordsToKey(coords),
					tile = this._tiles[key];

				if (tile && tile.active) {
					tile.retain = true;
					continue;

				} else if (tile && tile.loaded) {
					tile.retain = true;
				}

				if (z + 1 < maxZoom) {
					this._retainChildren(i, j, z + 1, maxZoom);
				}
			}
		}
	},

	_resetView: function (e) {
		var animating = e && (e.pinch || e.flyTo);
		this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
	},

	_animateZoom: function (e) {
		this._setView(e.center, e.zoom, true, e.noUpdate);
	},

	_clampZoom: function (zoom) {
		var options = this.options;

		if (undefined !== options.minNativeZoom && zoom < options.minNativeZoom) {
			return options.minNativeZoom;
		}

		if (undefined !== options.maxNativeZoom && options.maxNativeZoom < zoom) {
			return options.maxNativeZoom;
		}

		return zoom;
	},

	_setView: function (center, zoom, noPrune, noUpdate) {
		var tileZoom = this._clampZoom(Math.round(zoom));
		if ((this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom) ||
			(this.options.minZoom !== undefined && tileZoom < this.options.minZoom)) {
			tileZoom = undefined;
		}

		var tileZoomChanged = this.options.updateWhenZooming && (tileZoom !== this._tileZoom);

		if (!noUpdate || tileZoomChanged) {

			this._tileZoom = tileZoom;

			if (this._abortLoading) {
				this._abortLoading();
			}

			this._updateLevels();
			this._resetGrid();

			if (tileZoom !== undefined) {
				this._update(center);
			}

			if (!noPrune) {
				this._pruneTiles();
			}

			// Flag to prevent _updateOpacity from pruning tiles during
			// a zoom anim or a pinch gesture
			this._noPrune = !!noPrune;
		}

		this._setZoomTransforms(center, zoom);
	},

	_setZoomTransforms: function (center, zoom) {
		for (var i in this._levels) {
			this._setZoomTransform(this._levels[i], center, zoom);
		}
	},

	_setZoomTransform: function (level, center, zoom) {
		var scale = this._map.getZoomScale(zoom, level.zoom),
			translate = level.origin.multiplyBy(scale)
				.subtract(this._map._getNewPixelOrigin(center, zoom)).round();

		if (any3d) {
			setTransform(level.el, translate, scale);
		} else {
			setPosition(level.el, translate);
		}
	},

	_resetGrid: function () {
		var map = this._map,
			crs = map.options.crs,
			tileSize = this._tileSize = this.getTileSize(),
			tileZoom = this._tileZoom;

		var bounds = this._map.getPixelWorldBounds(this._tileZoom);
		if (bounds) {
			this._globalTileRange = this._pxBoundsToTileRange(bounds);
		}

		this._wrapX = crs.wrapLng && !this.options.noWrap && [
			Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x),
			Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)
		];
		this._wrapY = crs.wrapLat && !this.options.noWrap && [
			Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x),
			Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)
		];
	},

	_onMoveEnd: function () {
		if (!this._map || this._map._animatingZoom) { return; }

		this._update();
	},

	_getTiledPixelBounds: function (center) {
		var map = this._map,
			mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(),
			scale = map.getZoomScale(mapZoom, this._tileZoom),
			pixelCenter = map.project(center, this._tileZoom).floor(),
			halfSize = map.getSize().divideBy(scale * 2);

		return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
	},

	// Private method to load tiles in the grid's active zoom level according to map bounds
	_update: function (center) {
		var map = this._map;
		if (!map) { return; }
		var zoom = this._clampZoom(map.getZoom());

		if (center === undefined) { center = map.getCenter(); }
		if (this._tileZoom === undefined) { return; }	// if out of minzoom/maxzoom

		var pixelBounds = this._getTiledPixelBounds(center),
			tileRange = this._pxBoundsToTileRange(pixelBounds),
			tileCenter = tileRange.getCenter(),
			queue = [],
			margin = this.options.keepBuffer,
			noPruneRange = new Bounds(tileRange.getBottomLeft().subtract([margin, -margin]),
									  tileRange.getTopRight().add([margin, -margin]));

		// Sanity check: panic if the tile range contains Infinity somewhere.
		if (!(isFinite(tileRange.min.x) &&
			  isFinite(tileRange.min.y) &&
			  isFinite(tileRange.max.x) &&
			  isFinite(tileRange.max.y))) { throw new Error('Attempted to load an infinite number of tiles'); }

		for (var key in this._tiles) {
			var c = this._tiles[key].coords;
			if (c.z !== this._tileZoom || !noPruneRange.contains(new Point(c.x, c.y))) {
				this._tiles[key].current = false;
			}
		}

		// _update just loads more tiles. If the tile zoom level differs too much
		// from the map's, let _setView reset levels and prune old tiles.
		if (Math.abs(zoom - this._tileZoom) > 1) { this._setView(center, zoom); return; }

		// create a queue of coordinates to load tiles from
		for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
			for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
				var coords = new Point(i, j);
				coords.z = this._tileZoom;

				if (!this._isValidTile(coords)) { continue; }

				var tile = this._tiles[this._tileCoordsToKey(coords)];
				if (tile) {
					tile.current = true;
				} else {
					queue.push(coords);
				}
			}
		}

		// sort tile queue to load tiles in order of their distance to center
		queue.sort(function (a, b) {
			return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
		});

		if (queue.length !== 0) {
			// if it's the first batch of tiles to load
			if (!this._loading) {
				this._loading = true;
				// @event loading: Event
				// Fired when the grid layer starts loading tiles.
				this.fire('loading');
			}

			// create DOM fragment to append tiles in one batch
			var fragment = document.createDocumentFragment();

			for (i = 0; i < queue.length; i++) {
				this._addTile(queue[i], fragment);
			}

			this._level.el.appendChild(fragment);
		}
	},

	_isValidTile: function (coords) {
		var crs = this._map.options.crs;

		if (!crs.infinite) {
			// don't load tile if it's out of bounds and not wrapped
			var bounds = this._globalTileRange;
			if ((!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x)) ||
				(!crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y))) { return false; }
		}

		if (!this.options.bounds) { return true; }

		// don't load tile if it doesn't intersect the bounds in options
		var tileBounds = this._tileCoordsToBounds(coords);
		return toLatLngBounds(this.options.bounds).overlaps(tileBounds);
	},

	_keyToBounds: function (key) {
		return this._tileCoordsToBounds(this._keyToTileCoords(key));
	},

	_tileCoordsToNwSe: function (coords) {
		var map = this._map,
			tileSize = this.getTileSize(),
			nwPoint = coords.scaleBy(tileSize),
			sePoint = nwPoint.add(tileSize),
			nw = map.unproject(nwPoint, coords.z),
			se = map.unproject(sePoint, coords.z);
		return [nw, se];
	},

	// converts tile coordinates to its geographical bounds
	_tileCoordsToBounds: function (coords) {
		var bp = this._tileCoordsToNwSe(coords),
			bounds = new LatLngBounds(bp[0], bp[1]);

		if (!this.options.noWrap) {
			bounds = this._map.wrapLatLngBounds(bounds);
		}
		return bounds;
	},
	// converts tile coordinates to key for the tile cache
	_tileCoordsToKey: function (coords) {
		return coords.x + ':' + coords.y + ':' + coords.z;
	},

	// converts tile cache key to coordinates
	_keyToTileCoords: function (key) {
		var k = key.split(':'),
			coords = new Point(+k[0], +k[1]);
		coords.z = +k[2];
		return coords;
	},

	_removeTile: function (key) {
		var tile = this._tiles[key];
		if (!tile) { return; }

		remove(tile.el);

		delete this._tiles[key];

		// @event tileunload: TileEvent
		// Fired when a tile is removed (e.g. when a tile goes off the screen).
		this.fire('tileunload', {
			tile: tile.el,
			coords: this._keyToTileCoords(key)
		});
	},

	_initTile: function (tile) {
		addClass(tile, 'leaflet-tile');

		var tileSize = this.getTileSize();
		tile.style.width = tileSize.x + 'px';
		tile.style.height = tileSize.y + 'px';

		tile.onselectstart = falseFn;
		tile.onmousemove = falseFn;

		// update opacity on tiles in IE7-8 because of filter inheritance problems
		if (ielt9 && this.options.opacity < 1) {
			setOpacity(tile, this.options.opacity);
		}

		// without this hack, tiles disappear after zoom on Chrome for Android
		// https://github.com/Leaflet/Leaflet/issues/2078
		if (android && !android23) {
			tile.style.WebkitBackfaceVisibility = 'hidden';
		}
	},

	_addTile: function (coords, container) {
		var tilePos = this._getTilePos(coords),
			key = this._tileCoordsToKey(coords);

		var tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));

		this._initTile(tile);

		// if createTile is defined with a second argument ("done" callback),
		// we know that tile is async and will be ready later; otherwise
		if (this.createTile.length < 2) {
			// mark tile as ready, but delay one frame for opacity animation to happen
			requestAnimFrame(bind(this._tileReady, this, coords, null, tile));
		}

		setPosition(tile, tilePos);

		// save tile in cache
		this._tiles[key] = {
			el: tile,
			coords: coords,
			current: true
		};

		container.appendChild(tile);
		// @event tileloadstart: TileEvent
		// Fired when a tile is requested and starts loading.
		this.fire('tileloadstart', {
			tile: tile,
			coords: coords
		});
	},

	_tileReady: function (coords, err, tile) {
		if (err) {
			// @event tileerror: TileErrorEvent
			// Fired when there is an error loading a tile.
			this.fire('tileerror', {
				error: err,
				tile: tile,
				coords: coords
			});
		}

		var key = this._tileCoordsToKey(coords);

		tile = this._tiles[key];
		if (!tile) { return; }

		tile.loaded = +new Date();
		if (this._map._fadeAnimated) {
			setOpacity(tile.el, 0);
			cancelAnimFrame(this._fadeFrame);
			this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
		} else {
			tile.active = true;
			this._pruneTiles();
		}

		if (!err) {
			addClass(tile.el, 'leaflet-tile-loaded');

			// @event tileload: TileEvent
			// Fired when a tile loads.
			this.fire('tileload', {
				tile: tile.el,
				coords: coords
			});
		}

		if (this._noTilesToLoad()) {
			this._loading = false;
			// @event load: Event
			// Fired when the grid layer loaded all visible tiles.
			this.fire('load');

			if (ielt9 || !this._map._fadeAnimated) {
				requestAnimFrame(this._pruneTiles, this);
			} else {
				// Wait a bit more than 0.2 secs (the duration of the tile fade-in)
				// to trigger a pruning.
				setTimeout(bind(this._pruneTiles, this), 250);
			}
		}
	},

	_getTilePos: function (coords) {
		return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
	},

	_wrapCoords: function (coords) {
		var newCoords = new Point(
			this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x,
			this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y);
		newCoords.z = coords.z;
		return newCoords;
	},

	_pxBoundsToTileRange: function (bounds) {
		var tileSize = this.getTileSize();
		return new Bounds(
			bounds.min.unscaleBy(tileSize).floor(),
			bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));
	},

	_noTilesToLoad: function () {
		for (var key in this._tiles) {
			if (!this._tiles[key].loaded) { return false; }
		}
		return true;
	}
});

// @factory L.gridLayer(options?: GridLayer options)
// Creates a new instance of GridLayer with the supplied options.
function gridLayer(options) {
	return new GridLayer(options);
}

/*
 * @class TileLayer
 * @inherits GridLayer
 * @aka L.TileLayer
 * Used to load and display tile layers on the map. Note that most tile servers require attribution, which you can set under `Layer`. Extends `GridLayer`.
 *
 * @example
 *
 * ```js
 * L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar', attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, <a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>'}).addTo(map);
 * ```
 *
 * @section URL template
 * @example
 *
 * A string of the following form:
 *
 * ```
 * 'http://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'
 * ```
 *
 * `{s}` means one of the available subdomains (used sequentially to help with browser parallel requests per domain limitation; subdomain values are specified in options; `a`, `b` or `c` by default, can be omitted), `{z}` — zoom level, `{x}` and `{y}` — tile coordinates. `{r}` can be used to add "&commat;2x" to the URL to load retina tiles.
 *
 * You can use custom keys in the template, which will be [evaluated](#util-template) from TileLayer options, like this:
 *
 * ```
 * L.tileLayer('http://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});
 * ```
 */


var TileLayer = GridLayer.extend({

	// @section
	// @aka TileLayer options
	options: {
		// @option minZoom: Number = 0
		// The minimum zoom level down to which this layer will be displayed (inclusive).
		minZoom: 0,

		// @option maxZoom: Number = 18
		// The maximum zoom level up to which this layer will be displayed (inclusive).
		maxZoom: 18,

		// @option subdomains: String|String[] = 'abc'
		// Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
		subdomains: 'abc',

		// @option errorTileUrl: String = ''
		// URL to the tile image to show in place of the tile that failed to load.
		errorTileUrl: '',

		// @option zoomOffset: Number = 0
		// The zoom number used in tile URLs will be offset with this value.
		zoomOffset: 0,

		// @option tms: Boolean = false
		// If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
		tms: false,

		// @option zoomReverse: Boolean = false
		// If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
		zoomReverse: false,

		// @option detectRetina: Boolean = false
		// If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
		detectRetina: false,

		// @option crossOrigin: Boolean|String = false
		// Whether the crossOrigin attribute will be added to the tiles.
		// If a String is provided, all tiles will have their crossOrigin attribute set to the String provided. This is needed if you want to access tile pixel data.
		// Refer to [CORS Settings](https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_settings_attributes) for valid String values.
		crossOrigin: false
	},

	initialize: function (url, options) {

		this._url = url;

		options = setOptions(this, options);

		// detecting retina displays, adjusting tileSize and zoom levels
		if (options.detectRetina && retina && options.maxZoom > 0) {

			options.tileSize = Math.floor(options.tileSize / 2);

			if (!options.zoomReverse) {
				options.zoomOffset++;
				options.maxZoom--;
			} else {
				options.zoomOffset--;
				options.minZoom++;
			}

			options.minZoom = Math.max(0, options.minZoom);
		}

		if (typeof options.subdomains === 'string') {
			options.subdomains = options.subdomains.split('');
		}

		// for https://github.com/Leaflet/Leaflet/issues/137
		if (!android) {
			this.on('tileunload', this._onTileRemove);
		}
	},

	// @method setUrl(url: String, noRedraw?: Boolean): this
	// Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
	// If the URL does not change, the layer will not be redrawn unless
	// the noRedraw parameter is set to false.
	setUrl: function (url, noRedraw) {
		if (this._url === url && noRedraw === undefined) {
			noRedraw = true;
		}

		this._url = url;

		if (!noRedraw) {
			this.redraw();
		}
		return this;
	},

	// @method createTile(coords: Object, done?: Function): HTMLElement
	// Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
	// to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`
	// callback is called when the tile has been loaded.
	createTile: function (coords, done) {
		var tile = document.createElement('img');

		on(tile, 'load', bind(this._tileOnLoad, this, done, tile));
		on(tile, 'error', bind(this._tileOnError, this, done, tile));

		if (this.options.crossOrigin || this.options.crossOrigin === '') {
			tile.crossOrigin = this.options.crossOrigin === true ? '' : this.options.crossOrigin;
		}

		/*
		 Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons
		 http://www.w3.org/TR/WCAG20-TECHS/H67
		*/
		tile.alt = '';

		/*
		 Set role="presentation" to force screen readers to ignore this
		 https://www.w3.org/TR/wai-aria/roles#textalternativecomputation
		*/
		tile.setAttribute('role', 'presentation');

		tile.src = this.getTileUrl(coords);

		return tile;
	},

	// @section Extension methods
	// @uninheritable
	// Layers extending `TileLayer` might reimplement the following method.
	// @method getTileUrl(coords: Object): String
	// Called only internally, returns the URL for a tile given its coordinates.
	// Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
	getTileUrl: function (coords) {
		var data = {
			r: retina ? '@2x' : '',
			s: this._getSubdomain(coords),
			x: coords.x,
			y: coords.y,
			z: this._getZoomForUrl()
		};
		if (this._map && !this._map.options.crs.infinite) {
			var invertedY = this._globalTileRange.max.y - coords.y;
			if (this.options.tms) {
				data['y'] = invertedY;
			}
			data['-y'] = invertedY;
		}

		return template(this._url, extend(data, this.options));
	},

	_tileOnLoad: function (done, tile) {
		// For https://github.com/Leaflet/Leaflet/issues/3332
		if (ielt9) {
			setTimeout(bind(done, this, null, tile), 0);
		} else {
			done(null, tile);
		}
	},

	_tileOnError: function (done, tile, e) {
		var errorUrl = this.options.errorTileUrl;
		if (errorUrl && tile.getAttribute('src') !== errorUrl) {
			tile.src = errorUrl;
		}
		done(e, tile);
	},

	_onTileRemove: function (e) {
		e.tile.onload = null;
	},

	_getZoomForUrl: function () {
		var zoom = this._tileZoom,
		maxZoom = this.options.maxZoom,
		zoomReverse = this.options.zoomReverse,
		zoomOffset = this.options.zoomOffset;

		if (zoomReverse) {
			zoom = maxZoom - zoom;
		}

		return zoom + zoomOffset;
	},

	_getSubdomain: function (tilePoint) {
		var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
		return this.options.subdomains[index];
	},

	// stops loading all tiles in the background layer
	_abortLoading: function () {
		var i, tile;
		for (i in this._tiles) {
			if (this._tiles[i].coords.z !== this._tileZoom) {
				tile = this._tiles[i].el;

				tile.onload = falseFn;
				tile.onerror = falseFn;

				if (!tile.complete) {
					tile.src = emptyImageUrl;
					remove(tile);
					delete this._tiles[i];
				}
			}
		}
	},

	_removeTile: function (key) {
		var tile = this._tiles[key];
		if (!tile) { return; }

		// Cancels any pending http requests associated with the tile
		// unless we're on Android's stock browser,
		// see https://github.com/Leaflet/Leaflet/issues/137
		if (!androidStock) {
			tile.el.setAttribute('src', emptyImageUrl);
		}

		return GridLayer.prototype._removeTile.call(this, key);
	},

	_tileReady: function (coords, err, tile) {
		if (!this._map || (tile && tile.getAttribute('src') === emptyImageUrl)) {
			return;
		}

		return GridLayer.prototype._tileReady.call(this, coords, err, tile);
	}
});


// @factory L.tilelayer(urlTemplate: String, options?: TileLayer options)
// Instantiates a tile layer object given a `URL template` and optionally an options object.

function tileLayer(url, options) {
	return new TileLayer(url, options);
}

/*
 * @class TileLayer.WMS
 * @inherits TileLayer
 * @aka L.TileLayer.WMS
 * Used to display [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services as tile layers on the map. Extends `TileLayer`.
 *
 * @example
 *
 * ```js
 * var nexrad = L.tileLayer.wms("http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi", {
 * 	layers: 'nexrad-n0r-900913',
 * 	format: 'image/png',
 * 	transparent: true,
 * 	attribution: "Weather data © 2012 IEM Nexrad"
 * });
 * ```
 */

var TileLayerWMS = TileLayer.extend({

	// @section
	// @aka TileLayer.WMS options
	// If any custom options not documented here are used, they will be sent to the
	// WMS server as extra parameters in each request URL. This can be useful for
	// [non-standard vendor WMS parameters](http://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
	defaultWmsParams: {
		service: 'WMS',
		request: 'GetMap',

		// @option layers: String = ''
		// **(required)** Comma-separated list of WMS layers to show.
		layers: '',

		// @option styles: String = ''
		// Comma-separated list of WMS styles.
		styles: '',

		// @option format: String = 'image/jpeg'
		// WMS image format (use `'image/png'` for layers with transparency).
		format: 'image/jpeg',

		// @option transparent: Boolean = false
		// If `true`, the WMS service will return images with transparency.
		transparent: false,

		// @option version: String = '1.1.1'
		// Version of the WMS service to use
		version: '1.1.1'
	},

	options: {
		// @option crs: CRS = null
		// Coordinate Reference System to use for the WMS requests, defaults to
		// map CRS. Don't change this if you're not sure what it means.
		crs: null,

		// @option uppercase: Boolean = false
		// If `true`, WMS request parameter keys will be uppercase.
		uppercase: false
	},

	initialize: function (url, options) {

		this._url = url;

		var wmsParams = extend({}, this.defaultWmsParams);

		// all keys that are not TileLayer options go to WMS params
		for (var i in options) {
			if (!(i in this.options)) {
				wmsParams[i] = options[i];
			}
		}

		options = setOptions(this, options);

		var realRetina = options.detectRetina && retina ? 2 : 1;
		var tileSize = this.getTileSize();
		wmsParams.width = tileSize.x * realRetina;
		wmsParams.height = tileSize.y * realRetina;

		this.wmsParams = wmsParams;
	},

	onAdd: function (map) {

		this._crs = this.options.crs || map.options.crs;
		this._wmsVersion = parseFloat(this.wmsParams.version);

		var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
		this.wmsParams[projectionKey] = this._crs.code;

		TileLayer.prototype.onAdd.call(this, map);
	},

	getTileUrl: function (coords) {

		var tileBounds = this._tileCoordsToNwSe(coords),
			crs = this._crs,
			bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])),
			min = bounds.min,
			max = bounds.max,
			bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ?
			[min.y, min.x, max.y, max.x] :
			[min.x, min.y, max.x, max.y]).join(','),
			url = TileLayer.prototype.getTileUrl.call(this, coords);
		return url +
			getParamString(this.wmsParams, url, this.options.uppercase) +
			(this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;
	},

	// @method setParams(params: Object, noRedraw?: Boolean): this
	// Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
	setParams: function (params, noRedraw) {

		extend(this.wmsParams, params);

		if (!noRedraw) {
			this.redraw();
		}

		return this;
	}
});


// @factory L.tileLayer.wms(baseUrl: String, options: TileLayer.WMS options)
// Instantiates a WMS tile layer object given a base URL of the WMS service and a WMS parameters/options object.
function tileLayerWMS(url, options) {
	return new TileLayerWMS(url, options);
}

TileLayer.WMS = TileLayerWMS;
tileLayer.wms = tileLayerWMS;

/*
 * @class Renderer
 * @inherits Layer
 * @aka L.Renderer
 *
 * Base class for vector renderer implementations (`SVG`, `Canvas`). Handles the
 * DOM container of the renderer, its bounds, and its zoom animation.
 *
 * A `Renderer` works as an implicit layer group for all `Path`s - the renderer
 * itself can be added or removed to the map. All paths use a renderer, which can
 * be implicit (the map will decide the type of renderer and use it automatically)
 * or explicit (using the [`renderer`](#path-renderer) option of the path).
 *
 * Do not use this class directly, use `SVG` and `Canvas` instead.
 *
 * @event update: Event
 * Fired when the renderer updates its bounds, center and zoom, for example when
 * its map has moved
 */

var Renderer = Layer.extend({

	// @section
	// @aka Renderer options
	options: {
		// @option padding: Number = 0.1
		// How much to extend the clip area around the map view (relative to its size)
		// e.g. 0.1 would be 10% of map view in each direction
		padding: 0.1,

		// @option tolerance: Number = 0
		// How much to extend click tolerance round a path/object on the map
		tolerance : 0
	},

	initialize: function (options) {
		setOptions(this, options);
		stamp(this);
		this._layers = this._layers || {};
	},

	onAdd: function () {
		if (!this._container) {
			this._initContainer(); // defined by renderer implementations

			if (this._zoomAnimated) {
				addClass(this._container, 'leaflet-zoom-animated');
			}
		}

		this.getPane().appendChild(this._container);
		this._update();
		this.on('update', this._updatePaths, this);
	},

	onRemove: function () {
		this.off('update', this._updatePaths, this);
		this._destroyContainer();
	},

	getEvents: function () {
		var events = {
			viewreset: this._reset,
			zoom: this._onZoom,
			moveend: this._update,
			zoomend: this._onZoomEnd
		};
		if (this._zoomAnimated) {
			events.zoomanim = this._onAnimZoom;
		}
		return events;
	},

	_onAnimZoom: function (ev) {
		this._updateTransform(ev.center, ev.zoom);
	},

	_onZoom: function () {
		this._updateTransform(this._map.getCenter(), this._map.getZoom());
	},

	_updateTransform: function (center, zoom) {
		var scale = this._map.getZoomScale(zoom, this._zoom),
			position = getPosition(this._container),
			viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding),
			currentCenterPoint = this._map.project(this._center, zoom),
			destCenterPoint = this._map.project(center, zoom),
			centerOffset = destCenterPoint.subtract(currentCenterPoint),

			topLeftOffset = viewHalf.multiplyBy(-scale).add(position).add(viewHalf).subtract(centerOffset);

		if (any3d) {
			setTransform(this._container, topLeftOffset, scale);
		} else {
			setPosition(this._container, topLeftOffset);
		}
	},

	_reset: function () {
		this._update();
		this._updateTransform(this._center, this._zoom);

		for (var id in this._layers) {
			this._layers[id]._reset();
		}
	},

	_onZoomEnd: function () {
		for (var id in this._layers) {
			this._layers[id]._project();
		}
	},

	_updatePaths: function () {
		for (var id in this._layers) {
			this._layers[id]._update();
		}
	},

	_update: function () {
		// Update pixel bounds of renderer container (for positioning/sizing/clipping later)
		// Subclasses are responsible of firing the 'update' event.
		var p = this.options.padding,
			size = this._map.getSize(),
			min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();

		this._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());

		this._center = this._map.getCenter();
		this._zoom = this._map.getZoom();
	}
});

/*
 * @class Canvas
 * @inherits Renderer
 * @aka L.Canvas
 *
 * Allows vector layers to be displayed with [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
 * Inherits `Renderer`.
 *
 * Due to [technical limitations](http://caniuse.com/#search=canvas), Canvas is not
 * available in all web browsers, notably IE8, and overlapping geometries might
 * not display properly in some edge cases.
 *
 * @example
 *
 * Use Canvas by default for all paths in the map:
 *
 * ```js
 * var map = L.map('map', {
 * 	renderer: L.canvas()
 * });
 * ```
 *
 * Use a Canvas renderer with extra padding for specific vector geometries:
 *
 * ```js
 * var map = L.map('map');
 * var myRenderer = L.canvas({ padding: 0.5 });
 * var line = L.polyline( coordinates, { renderer: myRenderer } );
 * var circle = L.circle( center, { renderer: myRenderer } );
 * ```
 */

var Canvas = Renderer.extend({
	getEvents: function () {
		var events = Renderer.prototype.getEvents.call(this);
		events.viewprereset = this._onViewPreReset;
		return events;
	},

	_onViewPreReset: function () {
		// Set a flag so that a viewprereset+moveend+viewreset only updates&redraws once
		this._postponeUpdatePaths = true;
	},

	onAdd: function () {
		Renderer.prototype.onAdd.call(this);

		// Redraw vectors since canvas is cleared upon removal,
		// in case of removing the renderer itself from the map.
		this._draw();
	},

	_initContainer: function () {
		var container = this._container = document.createElement('canvas');

		on(container, 'mousemove', throttle(this._onMouseMove, 32, this), this);
		on(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this);
		on(container, 'mouseout', this._handleMouseOut, this);

		this._ctx = container.getContext('2d');
	},

	_destroyContainer: function () {
		cancelAnimFrame(this._redrawRequest);
		delete this._ctx;
		remove(this._container);
		off(this._container);
		delete this._container;
	},

	_updatePaths: function () {
		if (this._postponeUpdatePaths) { return; }

		var layer;
		this._redrawBounds = null;
		for (var id in this._layers) {
			layer = this._layers[id];
			layer._update();
		}
		this._redraw();
	},

	_update: function () {
		if (this._map._animatingZoom && this._bounds) { return; }

		Renderer.prototype._update.call(this);

		var b = this._bounds,
			container = this._container,
			size = b.getSize(),
			m = retina ? 2 : 1;

		setPosition(container, b.min);

		// set canvas size (also clearing it); use double size on retina
		container.width = m * size.x;
		container.height = m * size.y;
		container.style.width = size.x + 'px';
		container.style.height = size.y + 'px';

		if (retina) {
			this._ctx.scale(2, 2);
		}

		// translate so we use the same path coordinates after canvas element moves
		this._ctx.translate(-b.min.x, -b.min.y);

		// Tell paths to redraw themselves
		this.fire('update');
	},

	_reset: function () {
		Renderer.prototype._reset.call(this);

		if (this._postponeUpdatePaths) {
			this._postponeUpdatePaths = false;
			this._updatePaths();
		}
	},

	_initPath: function (layer) {
		this._updateDashArray(layer);
		this._layers[stamp(layer)] = layer;

		var order = layer._order = {
			layer: layer,
			prev: this._drawLast,
			next: null
		};
		if (this._drawLast) { this._drawLast.next = order; }
		this._drawLast = order;
		this._drawFirst = this._drawFirst || this._drawLast;
	},

	_addPath: function (layer) {
		this._requestRedraw(layer);
	},

	_removePath: function (layer) {
		var order = layer._order;
		var next = order.next;
		var prev = order.prev;

		if (next) {
			next.prev = prev;
		} else {
			this._drawLast = prev;
		}
		if (prev) {
			prev.next = next;
		} else {
			this._drawFirst = next;
		}

		delete layer._order;

		delete this._layers[stamp(layer)];

		this._requestRedraw(layer);
	},

	_updatePath: function (layer) {
		// Redraw the union of the layer's old pixel
		// bounds and the new pixel bounds.
		this._extendRedrawBounds(layer);
		layer._project();
		layer._update();
		// The redraw will extend the redraw bounds
		// with the new pixel bounds.
		this._requestRedraw(layer);
	},

	_updateStyle: function (layer) {
		this._updateDashArray(layer);
		this._requestRedraw(layer);
	},

	_updateDashArray: function (layer) {
		if (typeof layer.options.dashArray === 'string') {
			var parts = layer.options.dashArray.split(/[, ]+/),
				dashArray = [],
				dashValue,
				i;
			for (i = 0; i < parts.length; i++) {
				dashValue = Number(parts[i]);
				// Ignore dash array containing invalid lengths
				if (isNaN(dashValue)) { return; }
				dashArray.push(dashValue);
			}
			layer.options._dashArray = dashArray;
		} else {
			layer.options._dashArray = layer.options.dashArray;
		}
	},

	_requestRedraw: function (layer) {
		if (!this._map) { return; }

		this._extendRedrawBounds(layer);
		this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);
	},

	_extendRedrawBounds: function (layer) {
		if (layer._pxBounds) {
			var padding = (layer.options.weight || 0) + 1;
			this._redrawBounds = this._redrawBounds || new Bounds();
			this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));
			this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));
		}
	},

	_redraw: function () {
		this._redrawRequest = null;

		if (this._redrawBounds) {
			this._redrawBounds.min._floor();
			this._redrawBounds.max._ceil();
		}

		this._clear(); // clear layers in redraw bounds
		this._draw(); // draw layers

		this._redrawBounds = null;
	},

	_clear: function () {
		var bounds = this._redrawBounds;
		if (bounds) {
			var size = bounds.getSize();
			this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);
		} else {
			this._ctx.clearRect(0, 0, this._container.width, this._container.height);
		}
	},

	_draw: function () {
		var layer, bounds = this._redrawBounds;
		this._ctx.save();
		if (bounds) {
			var size = bounds.getSize();
			this._ctx.beginPath();
			this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);
			this._ctx.clip();
		}

		this._drawing = true;

		for (var order = this._drawFirst; order; order = order.next) {
			layer = order.layer;
			if (!bounds || (layer._pxBounds && layer._pxBounds.intersects(bounds))) {
				layer._updatePath();
			}
		}

		this._drawing = false;

		this._ctx.restore();  // Restore state before clipping.
	},

	_updatePoly: function (layer, closed) {
		if (!this._drawing) { return; }

		var i, j, len2, p,
			parts = layer._parts,
			len = parts.length,
			ctx = this._ctx;

		if (!len) { return; }

		ctx.beginPath();

		for (i = 0; i < len; i++) {
			for (j = 0, len2 = parts[i].length; j < len2; j++) {
				p = parts[i][j];
				ctx[j ? 'lineTo' : 'moveTo'](p.x, p.y);
			}
			if (closed) {
				ctx.closePath();
			}
		}

		this._fillStroke(ctx, layer);

		// TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature
	},

	_updateCircle: function (layer) {

		if (!this._drawing || layer._empty()) { return; }

		var p = layer._point,
			ctx = this._ctx,
			r = Math.max(Math.round(layer._radius), 1),
			s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;

		if (s !== 1) {
			ctx.save();
			ctx.scale(1, s);
		}

		ctx.beginPath();
		ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);

		if (s !== 1) {
			ctx.restore();
		}

		this._fillStroke(ctx, layer);
	},

	_fillStroke: function (ctx, layer) {
		var options = layer.options;

		if (options.fill) {
			ctx.globalAlpha = options.fillOpacity;
			ctx.fillStyle = options.fillColor || options.color;
			ctx.fill(options.fillRule || 'evenodd');
		}

		if (options.stroke && options.weight !== 0) {
			if (ctx.setLineDash) {
				ctx.setLineDash(layer.options && layer.options._dashArray || []);
			}
			ctx.globalAlpha = options.opacity;
			ctx.lineWidth = options.weight;
			ctx.strokeStyle = options.color;
			ctx.lineCap = options.lineCap;
			ctx.lineJoin = options.lineJoin;
			ctx.stroke();
		}
	},

	// Canvas obviously doesn't have mouse events for individual drawn objects,
	// so we emulate that by calculating what's under the mouse on mousemove/click manually

	_onClick: function (e) {
		var point = this._map.mouseEventToLayerPoint(e), layer, clickedLayer;

		for (var order = this._drawFirst; order; order = order.next) {
			layer = order.layer;
			if (layer.options.interactive && layer._containsPoint(point) && !this._map._draggableMoved(layer)) {
				clickedLayer = layer;
			}
		}
		if (clickedLayer)  {
			fakeStop(e);
			this._fireEvent([clickedLayer], e);
		}
	},

	_onMouseMove: function (e) {
		if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) { return; }

		var point = this._map.mouseEventToLayerPoint(e);
		this._handleMouseHover(e, point);
	},


	_handleMouseOut: function (e) {
		var layer = this._hoveredLayer;
		if (layer) {
			// if we're leaving the layer, fire mouseout
			removeClass(this._container, 'leaflet-interactive');
			this._fireEvent([layer], e, 'mouseout');
			this._hoveredLayer = null;
		}
	},

	_handleMouseHover: function (e, point) {
		var layer, candidateHoveredLayer;

		for (var order = this._drawFirst; order; order = order.next) {
			layer = order.layer;
			if (layer.options.interactive && layer._containsPoint(point)) {
				candidateHoveredLayer = layer;
			}
		}

		if (candidateHoveredLayer !== this._hoveredLayer) {
			this._handleMouseOut(e);

			if (candidateHoveredLayer) {
				addClass(this._container, 'leaflet-interactive'); // change cursor
				this._fireEvent([candidateHoveredLayer], e, 'mouseover');
				this._hoveredLayer = candidateHoveredLayer;
			}
		}

		if (this._hoveredLayer) {
			this._fireEvent([this._hoveredLayer], e);
		}
	},

	_fireEvent: function (layers, e, type) {
		this._map._fireDOMEvent(e, type || e.type, layers);
	},

	_bringToFront: function (layer) {
		var order = layer._order;

		if (!order) { return; }

		var next = order.next;
		var prev = order.prev;

		if (next) {
			next.prev = prev;
		} else {
			// Already last
			return;
		}
		if (prev) {
			prev.next = next;
		} else if (next) {
			// Update first entry unless this is the
			// single entry
			this._drawFirst = next;
		}

		order.prev = this._drawLast;
		this._drawLast.next = order;

		order.next = null;
		this._drawLast = order;

		this._requestRedraw(layer);
	},

	_bringToBack: function (layer) {
		var order = layer._order;

		if (!order) { return; }

		var next = order.next;
		var prev = order.prev;

		if (prev) {
			prev.next = next;
		} else {
			// Already first
			return;
		}
		if (next) {
			next.prev = prev;
		} else if (prev) {
			// Update last entry unless this is the
			// single entry
			this._drawLast = prev;
		}

		order.prev = null;

		order.next = this._drawFirst;
		this._drawFirst.prev = order;
		this._drawFirst = order;

		this._requestRedraw(layer);
	}
});

// @factory L.canvas(options?: Renderer options)
// Creates a Canvas renderer with the given options.
function canvas$1(options) {
	return canvas ? new Canvas(options) : null;
}

/*
 * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!
 */


var vmlCreate = (function () {
	try {
		document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');
		return function (name) {
			return document.createElement('<lvml:' + name + ' class="lvml">');
		};
	} catch (e) {
		return function (name) {
			return document.createElement('<' + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
		};
	}
})();


/*
 * @class SVG
 *
 *
 * VML was deprecated in 2012, which means VML functionality exists only for backwards compatibility
 * with old versions of Internet Explorer.
 */

// mixin to redefine some SVG methods to handle VML syntax which is similar but with some differences
var vmlMixin = {

	_initContainer: function () {
		this._container = create$1('div', 'leaflet-vml-container');
	},

	_update: function () {
		if (this._map._animatingZoom) { return; }
		Renderer.prototype._update.call(this);
		this.fire('update');
	},

	_initPath: function (layer) {
		var container = layer._container = vmlCreate('shape');

		addClass(container, 'leaflet-vml-shape ' + (this.options.className || ''));

		container.coordsize = '1 1';

		layer._path = vmlCreate('path');
		container.appendChild(layer._path);

		this._updateStyle(layer);
		this._layers[stamp(layer)] = layer;
	},

	_addPath: function (layer) {
		var container = layer._container;
		this._container.appendChild(container);

		if (layer.options.interactive) {
			layer.addInteractiveTarget(container);
		}
	},

	_removePath: function (layer) {
		var container = layer._container;
		remove(container);
		layer.removeInteractiveTarget(container);
		delete this._layers[stamp(layer)];
	},

	_updateStyle: function (layer) {
		var stroke = layer._stroke,
			fill = layer._fill,
			options = layer.options,
			container = layer._container;

		container.stroked = !!options.stroke;
		container.filled = !!options.fill;

		if (options.stroke) {
			if (!stroke) {
				stroke = layer._stroke = vmlCreate('stroke');
			}
			container.appendChild(stroke);
			stroke.weight = options.weight + 'px';
			stroke.color = options.color;
			stroke.opacity = options.opacity;

			if (options.dashArray) {
				stroke.dashStyle = isArray(options.dashArray) ?
					options.dashArray.join(' ') :
					options.dashArray.replace(/( *, *)/g, ' ');
			} else {
				stroke.dashStyle = '';
			}
			stroke.endcap = options.lineCap.replace('butt', 'flat');
			stroke.joinstyle = options.lineJoin;

		} else if (stroke) {
			container.removeChild(stroke);
			layer._stroke = null;
		}

		if (options.fill) {
			if (!fill) {
				fill = layer._fill = vmlCreate('fill');
			}
			container.appendChild(fill);
			fill.color = options.fillColor || options.color;
			fill.opacity = options.fillOpacity;

		} else if (fill) {
			container.removeChild(fill);
			layer._fill = null;
		}
	},

	_updateCircle: function (layer) {
		var p = layer._point.round(),
			r = Math.round(layer._radius),
			r2 = Math.round(layer._radiusY || r);

		this._setPath(layer, layer._empty() ? 'M0 0' :
			'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r2 + ' 0,' + (65535 * 360));
	},

	_setPath: function (layer, path) {
		layer._path.v = path;
	},

	_bringToFront: function (layer) {
		toFront(layer._container);
	},

	_bringToBack: function (layer) {
		toBack(layer._container);
	}
};

var create$2 = vml ? vmlCreate : svgCreate;

/*
 * @class SVG
 * @inherits Renderer
 * @aka L.SVG
 *
 * Allows vector layers to be displayed with [SVG](https://developer.mozilla.org/docs/Web/SVG).
 * Inherits `Renderer`.
 *
 * Due to [technical limitations](http://caniuse.com/#search=svg), SVG is not
 * available in all web browsers, notably Android 2.x and 3.x.
 *
 * Although SVG is not available on IE7 and IE8, these browsers support
 * [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language)
 * (a now deprecated technology), and the SVG renderer will fall back to VML in
 * this case.
 *
 * @example
 *
 * Use SVG by default for all paths in the map:
 *
 * ```js
 * var map = L.map('map', {
 * 	renderer: L.svg()
 * });
 * ```
 *
 * Use a SVG renderer with extra padding for specific vector geometries:
 *
 * ```js
 * var map = L.map('map');
 * var myRenderer = L.svg({ padding: 0.5 });
 * var line = L.polyline( coordinates, { renderer: myRenderer } );
 * var circle = L.circle( center, { renderer: myRenderer } );
 * ```
 */

var SVG = Renderer.extend({

	getEvents: function () {
		var events = Renderer.prototype.getEvents.call(this);
		events.zoomstart = this._onZoomStart;
		return events;
	},

	_initContainer: function () {
		this._container = create$2('svg');

		// makes it possible to click through svg root; we'll reset it back in individual paths
		this._container.setAttribute('pointer-events', 'none');

		this._rootGroup = create$2('g');
		this._container.appendChild(this._rootGroup);
	},

	_destroyContainer: function () {
		remove(this._container);
		off(this._container);
		delete this._container;
		delete this._rootGroup;
		delete this._svgSize;
	},

	_onZoomStart: function () {
		// Drag-then-pinch interactions might mess up the center and zoom.
		// In this case, the easiest way to prevent this is re-do the renderer
		//   bounds and padding when the zooming starts.
		this._update();
	},

	_update: function () {
		if (this._map._animatingZoom && this._bounds) { return; }

		Renderer.prototype._update.call(this);

		var b = this._bounds,
			size = b.getSize(),
			container = this._container;

		// set size of svg-container if changed
		if (!this._svgSize || !this._svgSize.equals(size)) {
			this._svgSize = size;
			container.setAttribute('width', size.x);
			container.setAttribute('height', size.y);
		}

		// movement: update container viewBox so that we don't have to change coordinates of individual layers
		setPosition(container, b.min);
		container.setAttribute('viewBox', [b.min.x, b.min.y, size.x, size.y].join(' '));

		this.fire('update');
	},

	// methods below are called by vector layers implementations

	_initPath: function (layer) {
		var path = layer._path = create$2('path');

		// @namespace Path
		// @option className: String = null
		// Custom class name set on an element. Only for SVG renderer.
		if (layer.options.className) {
			addClass(path, layer.options.className);
		}

		if (layer.options.interactive) {
			addClass(path, 'leaflet-interactive');
		}

		this._updateStyle(layer);
		this._layers[stamp(layer)] = layer;
	},

	_addPath: function (layer) {
		if (!this._rootGroup) { this._initContainer(); }
		this._rootGroup.appendChild(layer._path);
		layer.addInteractiveTarget(layer._path);
	},

	_removePath: function (layer) {
		remove(layer._path);
		layer.removeInteractiveTarget(layer._path);
		delete this._layers[stamp(layer)];
	},

	_updatePath: function (layer) {
		layer._project();
		layer._update();
	},

	_updateStyle: function (layer) {
		var path = layer._path,
			options = layer.options;

		if (!path) { return; }

		if (options.stroke) {
			path.setAttribute('stroke', options.color);
			path.setAttribute('stroke-opacity', options.opacity);
			path.setAttribute('stroke-width', options.weight);
			path.setAttribute('stroke-linecap', options.lineCap);
			path.setAttribute('stroke-linejoin', options.lineJoin);

			if (options.dashArray) {
				path.setAttribute('stroke-dasharray', options.dashArray);
			} else {
				path.removeAttribute('stroke-dasharray');
			}

			if (options.dashOffset) {
				path.setAttribute('stroke-dashoffset', options.dashOffset);
			} else {
				path.removeAttribute('stroke-dashoffset');
			}
		} else {
			path.setAttribute('stroke', 'none');
		}

		if (options.fill) {
			path.setAttribute('fill', options.fillColor || options.color);
			path.setAttribute('fill-opacity', options.fillOpacity);
			path.setAttribute('fill-rule', options.fillRule || 'evenodd');
		} else {
			path.setAttribute('fill', 'none');
		}
	},

	_updatePoly: function (layer, closed) {
		this._setPath(layer, pointsToPath(layer._parts, closed));
	},

	_updateCircle: function (layer) {
		var p = layer._point,
			r = Math.max(Math.round(layer._radius), 1),
			r2 = Math.max(Math.round(layer._radiusY), 1) || r,
			arc = 'a' + r + ',' + r2 + ' 0 1,0 ';

		// drawing a circle with two half-arcs
		var d = layer._empty() ? 'M0 0' :
			'M' + (p.x - r) + ',' + p.y +
			arc + (r * 2) + ',0 ' +
			arc + (-r * 2) + ',0 ';

		this._setPath(layer, d);
	},

	_setPath: function (layer, path) {
		layer._path.setAttribute('d', path);
	},

	// SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
	_bringToFront: function (layer) {
		toFront(layer._path);
	},

	_bringToBack: function (layer) {
		toBack(layer._path);
	}
});

if (vml) {
	SVG.include(vmlMixin);
}

// @namespace SVG
// @factory L.svg(options?: Renderer options)
// Creates a SVG renderer with the given options.
function svg$1(options) {
	return svg || vml ? new SVG(options) : null;
}

Map.include({
	// @namespace Map; @method getRenderer(layer: Path): Renderer
	// Returns the instance of `Renderer` that should be used to render the given
	// `Path`. It will ensure that the `renderer` options of the map and paths
	// are respected, and that the renderers do exist on the map.
	getRenderer: function (layer) {
		// @namespace Path; @option renderer: Renderer
		// Use this specific instance of `Renderer` for this path. Takes
		// precedence over the map's [default renderer](#map-renderer).
		var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;

		if (!renderer) {
			renderer = this._renderer = this._createRenderer();
		}

		if (!this.hasLayer(renderer)) {
			this.addLayer(renderer);
		}
		return renderer;
	},

	_getPaneRenderer: function (name) {
		if (name === 'overlayPane' || name === undefined) {
			return false;
		}

		var renderer = this._paneRenderers[name];
		if (renderer === undefined) {
			renderer = this._createRenderer({pane: name});
			this._paneRenderers[name] = renderer;
		}
		return renderer;
	},

	_createRenderer: function (options) {
		// @namespace Map; @option preferCanvas: Boolean = false
		// Whether `Path`s should be rendered on a `Canvas` renderer.
		// By default, all `Path`s are rendered in a `SVG` renderer.
		return (this.options.preferCanvas && canvas$1(options)) || svg$1(options);
	}
});

/*
 * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.
 */

/*
 * @class Rectangle
 * @aka L.Rectangle
 * @inherits Polygon
 *
 * A class for drawing rectangle overlays on a map. Extends `Polygon`.
 *
 * @example
 *
 * ```js
 * // define rectangle geographical bounds
 * var bounds = [[54.559322, -5.767822], [56.1210604, -3.021240]];
 *
 * // create an orange rectangle
 * L.rectangle(bounds, {color: "#ff7800", weight: 1}).addTo(map);
 *
 * // zoom the map to the rectangle bounds
 * map.fitBounds(bounds);
 * ```
 *
 */


var Rectangle = Polygon.extend({
	initialize: function (latLngBounds, options) {
		Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
	},

	// @method setBounds(latLngBounds: LatLngBounds): this
	// Redraws the rectangle with the passed bounds.
	setBounds: function (latLngBounds) {
		return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
	},

	_boundsToLatLngs: function (latLngBounds) {
		latLngBounds = toLatLngBounds(latLngBounds);
		return [
			latLngBounds.getSouthWest(),
			latLngBounds.getNorthWest(),
			latLngBounds.getNorthEast(),
			latLngBounds.getSouthEast()
		];
	}
});


// @factory L.rectangle(latLngBounds: LatLngBounds, options?: Polyline options)
function rectangle(latLngBounds, options) {
	return new Rectangle(latLngBounds, options);
}

SVG.create = create$2;
SVG.pointsToPath = pointsToPath;

GeoJSON.geometryToLayer = geometryToLayer;
GeoJSON.coordsToLatLng = coordsToLatLng;
GeoJSON.coordsToLatLngs = coordsToLatLngs;
GeoJSON.latLngToCoords = latLngToCoords;
GeoJSON.latLngsToCoords = latLngsToCoords;
GeoJSON.getFeature = getFeature;
GeoJSON.asFeature = asFeature;

/*
 * L.Handler.BoxZoom is used to add shift-drag zoom interaction to the map
 * (zoom to a selected bounding box), enabled by default.
 */

// @namespace Map
// @section Interaction Options
Map.mergeOptions({
	// @option boxZoom: Boolean = true
	// Whether the map can be zoomed to a rectangular area specified by
	// dragging the mouse while pressing the shift key.
	boxZoom: true
});

var BoxZoom = Handler.extend({
	initialize: function (map) {
		this._map = map;
		this._container = map._container;
		this._pane = map._panes.overlayPane;
		this._resetStateTimeout = 0;
		map.on('unload', this._destroy, this);
	},

	addHooks: function () {
		on(this._container, 'mousedown', this._onMouseDown, this);
	},

	removeHooks: function () {
		off(this._container, 'mousedown', this._onMouseDown, this);
	},

	moved: function () {
		return this._moved;
	},

	_destroy: function () {
		remove(this._pane);
		delete this._pane;
	},

	_resetState: function () {
		this._resetStateTimeout = 0;
		this._moved = false;
	},

	_clearDeferredResetState: function () {
		if (this._resetStateTimeout !== 0) {
			clearTimeout(this._resetStateTimeout);
			this._resetStateTimeout = 0;
		}
	},

	_onMouseDown: function (e) {
		if (!e.shiftKey || ((e.which !== 1) && (e.button !== 1))) { return false; }

		// Clear the deferred resetState if it hasn't executed yet, otherwise it
		// will interrupt the interaction and orphan a box element in the container.
		this._clearDeferredResetState();
		this._resetState();

		disableTextSelection();
		disableImageDrag();

		this._startPoint = this._map.mouseEventToContainerPoint(e);

		on(document, {
			contextmenu: stop,
			mousemove: this._onMouseMove,
			mouseup: this._onMouseUp,
			keydown: this._onKeyDown
		}, this);
	},

	_onMouseMove: function (e) {
		if (!this._moved) {
			this._moved = true;

			this._box = create$1('div', 'leaflet-zoom-box', this._container);
			addClass(this._container, 'leaflet-crosshair');

			this._map.fire('boxzoomstart');
		}

		this._point = this._map.mouseEventToContainerPoint(e);

		var bounds = new Bounds(this._point, this._startPoint),
			size = bounds.getSize();

		setPosition(this._box, bounds.min);

		this._box.style.width  = size.x + 'px';
		this._box.style.height = size.y + 'px';
	},

	_finish: function () {
		if (this._moved) {
			remove(this._box);
			removeClass(this._container, 'leaflet-crosshair');
		}

		enableTextSelection();
		enableImageDrag();

		off(document, {
			contextmenu: stop,
			mousemove: this._onMouseMove,
			mouseup: this._onMouseUp,
			keydown: this._onKeyDown
		}, this);
	},

	_onMouseUp: function (e) {
		if ((e.which !== 1) && (e.button !== 1)) { return; }

		this._finish();

		if (!this._moved) { return; }
		// Postpone to next JS tick so internal click event handling
		// still see it as "moved".
		this._clearDeferredResetState();
		this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);

		var bounds = new LatLngBounds(
				this._map.containerPointToLatLng(this._startPoint),
				this._map.containerPointToLatLng(this._point));

		this._map
			.fitBounds(bounds)
			.fire('boxzoomend', {boxZoomBounds: bounds});
	},

	_onKeyDown: function (e) {
		if (e.keyCode === 27) {
			this._finish();
		}
	}
});

// @section Handlers
// @property boxZoom: Handler
// Box (shift-drag with mouse) zoom handler.
Map.addInitHook('addHandler', 'boxZoom', BoxZoom);

/*
 * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.
 */

// @namespace Map
// @section Interaction Options

Map.mergeOptions({
	// @option doubleClickZoom: Boolean|String = true
	// Whether the map can be zoomed in by double clicking on it and
	// zoomed out by double clicking while holding shift. If passed
	// `'center'`, double-click zoom will zoom to the center of the
	//  view regardless of where the mouse was.
	doubleClickZoom: true
});

var DoubleClickZoom = Handler.extend({
	addHooks: function () {
		this._map.on('dblclick', this._onDoubleClick, this);
	},

	removeHooks: function () {
		this._map.off('dblclick', this._onDoubleClick, this);
	},

	_onDoubleClick: function (e) {
		var map = this._map,
			oldZoom = map.getZoom(),
			delta = map.options.zoomDelta,
			zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;

		if (map.options.doubleClickZoom === 'center') {
			map.setZoom(zoom);
		} else {
			map.setZoomAround(e.containerPoint, zoom);
		}
	}
});

// @section Handlers
//
// Map properties include interaction handlers that allow you to control
// interaction behavior in runtime, enabling or disabling certain features such
// as dragging or touch zoom (see `Handler` methods). For example:
//
// ```js
// map.doubleClickZoom.disable();
// ```
//
// @property doubleClickZoom: Handler
// Double click zoom handler.
Map.addInitHook('addHandler', 'doubleClickZoom', DoubleClickZoom);

/*
 * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.
 */

// @namespace Map
// @section Interaction Options
Map.mergeOptions({
	// @option dragging: Boolean = true
	// Whether the map be draggable with mouse/touch or not.
	dragging: true,

	// @section Panning Inertia Options
	// @option inertia: Boolean = *
	// If enabled, panning of the map will have an inertia effect where
	// the map builds momentum while dragging and continues moving in
	// the same direction for some time. Feels especially nice on touch
	// devices. Enabled by default unless running on old Android devices.
	inertia: !android23,

	// @option inertiaDeceleration: Number = 3000
	// The rate with which the inertial movement slows down, in pixels/second².
	inertiaDeceleration: 3400, // px/s^2

	// @option inertiaMaxSpeed: Number = Infinity
	// Max speed of the inertial movement, in pixels/second.
	inertiaMaxSpeed: Infinity, // px/s

	// @option easeLinearity: Number = 0.2
	easeLinearity: 0.2,

	// TODO refactor, move to CRS
	// @option worldCopyJump: Boolean = false
	// With this option enabled, the map tracks when you pan to another "copy"
	// of the world and seamlessly jumps to the original one so that all overlays
	// like markers and vector layers are still visible.
	worldCopyJump: false,

	// @option maxBoundsViscosity: Number = 0.0
	// If `maxBounds` is set, this option will control how solid the bounds
	// are when dragging the map around. The default value of `0.0` allows the
	// user to drag outside the bounds at normal speed, higher values will
	// slow down map dragging outside bounds, and `1.0` makes the bounds fully
	// solid, preventing the user from dragging outside the bounds.
	maxBoundsViscosity: 0.0
});

var Drag = Handler.extend({
	addHooks: function () {
		if (!this._draggable) {
			var map = this._map;

			this._draggable = new Draggable(map._mapPane, map._container);

			this._draggable.on({
				dragstart: this._onDragStart,
				drag: this._onDrag,
				dragend: this._onDragEnd
			}, this);

			this._draggable.on('predrag', this._onPreDragLimit, this);
			if (map.options.worldCopyJump) {
				this._draggable.on('predrag', this._onPreDragWrap, this);
				map.on('zoomend', this._onZoomEnd, this);

				map.whenReady(this._onZoomEnd, this);
			}
		}
		addClass(this._map._container, 'leaflet-grab leaflet-touch-drag');
		this._draggable.enable();
		this._positions = [];
		this._times = [];
	},

	removeHooks: function () {
		removeClass(this._map._container, 'leaflet-grab');
		removeClass(this._map._container, 'leaflet-touch-drag');
		this._draggable.disable();
	},

	moved: function () {
		return this._draggable && this._draggable._moved;
	},

	moving: function () {
		return this._draggable && this._draggable._moving;
	},

	_onDragStart: function () {
		var map = this._map;

		map._stop();
		if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
			var bounds = toLatLngBounds(this._map.options.maxBounds);

			this._offsetLimit = toBounds(
				this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1),
				this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1)
					.add(this._map.getSize()));

			this._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));
		} else {
			this._offsetLimit = null;
		}

		map
			.fire('movestart')
			.fire('dragstart');

		if (map.options.inertia) {
			this._positions = [];
			this._times = [];
		}
	},

	_onDrag: function (e) {
		if (this._map.options.inertia) {
			var time = this._lastTime = +new Date(),
				pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;

			this._positions.push(pos);
			this._times.push(time);

			this._prunePositions(time);
		}

		this._map
			.fire('move', e)
			.fire('drag', e);
	},

	_prunePositions: function (time) {
		while (this._positions.length > 1 && time - this._times[0] > 50) {
			this._positions.shift();
			this._times.shift();
		}
	},

	_onZoomEnd: function () {
		var pxCenter = this._map.getSize().divideBy(2),
			pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);

		this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
		this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
	},

	_viscousLimit: function (value, threshold) {
		return value - (value - threshold) * this._viscosity;
	},

	_onPreDragLimit: function () {
		if (!this._viscosity || !this._offsetLimit) { return; }

		var offset = this._draggable._newPos.subtract(this._draggable._startPos);

		var limit = this._offsetLimit;
		if (offset.x < limit.min.x) { offset.x = this._viscousLimit(offset.x, limit.min.x); }
		if (offset.y < limit.min.y) { offset.y = this._viscousLimit(offset.y, limit.min.y); }
		if (offset.x > limit.max.x) { offset.x = this._viscousLimit(offset.x, limit.max.x); }
		if (offset.y > limit.max.y) { offset.y = this._viscousLimit(offset.y, limit.max.y); }

		this._draggable._newPos = this._draggable._startPos.add(offset);
	},

	_onPreDragWrap: function () {
		// TODO refactor to be able to adjust map pane position after zoom
		var worldWidth = this._worldWidth,
			halfWidth = Math.round(worldWidth / 2),
			dx = this._initialWorldOffset,
			x = this._draggable._newPos.x,
			newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,
			newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,
			newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;

		this._draggable._absPos = this._draggable._newPos.clone();
		this._draggable._newPos.x = newX;
	},

	_onDragEnd: function (e) {
		var map = this._map,
			options = map.options,

			noInertia = !options.inertia || this._times.length < 2;

		map.fire('dragend', e);

		if (noInertia) {
			map.fire('moveend');

		} else {
			this._prunePositions(+new Date());

			var direction = this._lastPos.subtract(this._positions[0]),
				duration = (this._lastTime - this._times[0]) / 1000,
				ease = options.easeLinearity,

				speedVector = direction.multiplyBy(ease / duration),
				speed = speedVector.distanceTo([0, 0]),

				limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),
				limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),

				decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),
				offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();

			if (!offset.x && !offset.y) {
				map.fire('moveend');

			} else {
				offset = map._limitOffset(offset, map.options.maxBounds);

				requestAnimFrame(function () {
					map.panBy(offset, {
						duration: decelerationDuration,
						easeLinearity: ease,
						noMoveStart: true,
						animate: true
					});
				});
			}
		}
	}
});

// @section Handlers
// @property dragging: Handler
// Map dragging handler (by both mouse and touch).
Map.addInitHook('addHandler', 'dragging', Drag);

/*
 * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.
 */

// @namespace Map
// @section Keyboard Navigation Options
Map.mergeOptions({
	// @option keyboard: Boolean = true
	// Makes the map focusable and allows users to navigate the map with keyboard
	// arrows and `+`/`-` keys.
	keyboard: true,

	// @option keyboardPanDelta: Number = 80
	// Amount of pixels to pan when pressing an arrow key.
	keyboardPanDelta: 80
});

var Keyboard = Handler.extend({

	keyCodes: {
		left:    [37],
		right:   [39],
		down:    [40],
		up:      [38],
		zoomIn:  [187, 107, 61, 171],
		zoomOut: [189, 109, 54, 173]
	},

	initialize: function (map) {
		this._map = map;

		this._setPanDelta(map.options.keyboardPanDelta);
		this._setZoomDelta(map.options.zoomDelta);
	},

	addHooks: function () {
		var container = this._map._container;

		// make the container focusable by tabbing
		if (container.tabIndex <= 0) {
			container.tabIndex = '0';
		}

		on(container, {
			focus: this._onFocus,
			blur: this._onBlur,
			mousedown: this._onMouseDown
		}, this);

		this._map.on({
			focus: this._addHooks,
			blur: this._removeHooks
		}, this);
	},

	removeHooks: function () {
		this._removeHooks();

		off(this._map._container, {
			focus: this._onFocus,
			blur: this._onBlur,
			mousedown: this._onMouseDown
		}, this);

		this._map.off({
			focus: this._addHooks,
			blur: this._removeHooks
		}, this);
	},

	_onMouseDown: function () {
		if (this._focused) { return; }

		var body = document.body,
			docEl = document.documentElement,
			top = body.scrollTop || docEl.scrollTop,
			left = body.scrollLeft || docEl.scrollLeft;

		this._map._container.focus();

		window.scrollTo(left, top);
	},

	_onFocus: function () {
		this._focused = true;
		this._map.fire('focus');
	},

	_onBlur: function () {
		this._focused = false;
		this._map.fire('blur');
	},

	_setPanDelta: function (panDelta) {
		var keys = this._panKeys = {},
			codes = this.keyCodes,
			i, len;

		for (i = 0, len = codes.left.length; i < len; i++) {
			keys[codes.left[i]] = [-1 * panDelta, 0];
		}
		for (i = 0, len = codes.right.length; i < len; i++) {
			keys[codes.right[i]] = [panDelta, 0];
		}
		for (i = 0, len = codes.down.length; i < len; i++) {
			keys[codes.down[i]] = [0, panDelta];
		}
		for (i = 0, len = codes.up.length; i < len; i++) {
			keys[codes.up[i]] = [0, -1 * panDelta];
		}
	},

	_setZoomDelta: function (zoomDelta) {
		var keys = this._zoomKeys = {},
			codes = this.keyCodes,
			i, len;

		for (i = 0, len = codes.zoomIn.length; i < len; i++) {
			keys[codes.zoomIn[i]] = zoomDelta;
		}
		for (i = 0, len = codes.zoomOut.length; i < len; i++) {
			keys[codes.zoomOut[i]] = -zoomDelta;
		}
	},

	_addHooks: function () {
		on(document, 'keydown', this._onKeyDown, this);
	},

	_removeHooks: function () {
		off(document, 'keydown', this._onKeyDown, this);
	},

	_onKeyDown: function (e) {
		if (e.altKey || e.ctrlKey || e.metaKey) { return; }

		var key = e.keyCode,
			map = this._map,
			offset;

		if (key in this._panKeys) {
			if (!map._panAnim || !map._panAnim._inProgress) {
				offset = this._panKeys[key];
				if (e.shiftKey) {
					offset = toPoint(offset).multiplyBy(3);
				}

				map.panBy(offset);

				if (map.options.maxBounds) {
					map.panInsideBounds(map.options.maxBounds);
				}
			}
		} else if (key in this._zoomKeys) {
			map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);

		} else if (key === 27 && map._popup && map._popup.options.closeOnEscapeKey) {
			map.closePopup();

		} else {
			return;
		}

		stop(e);
	}
});

// @section Handlers
// @section Handlers
// @property keyboard: Handler
// Keyboard navigation handler.
Map.addInitHook('addHandler', 'keyboard', Keyboard);

/*
 * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.
 */

// @namespace Map
// @section Interaction Options
Map.mergeOptions({
	// @section Mousewheel options
	// @option scrollWheelZoom: Boolean|String = true
	// Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
	// it will zoom to the center of the view regardless of where the mouse was.
	scrollWheelZoom: true,

	// @option wheelDebounceTime: Number = 40
	// Limits the rate at which a wheel can fire (in milliseconds). By default
	// user can't zoom via wheel more often than once per 40 ms.
	wheelDebounceTime: 40,

	// @option wheelPxPerZoomLevel: Number = 60
	// How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
	// mean a change of one full zoom level. Smaller values will make wheel-zooming
	// faster (and vice versa).
	wheelPxPerZoomLevel: 60
});

var ScrollWheelZoom = Handler.extend({
	addHooks: function () {
		on(this._map._container, 'mousewheel', this._onWheelScroll, this);

		this._delta = 0;
	},

	removeHooks: function () {
		off(this._map._container, 'mousewheel', this._onWheelScroll, this);
	},

	_onWheelScroll: function (e) {
		var delta = getWheelDelta(e);

		var debounce = this._map.options.wheelDebounceTime;

		this._delta += delta;
		this._lastMousePos = this._map.mouseEventToContainerPoint(e);

		if (!this._startTime) {
			this._startTime = +new Date();
		}

		var left = Math.max(debounce - (+new Date() - this._startTime), 0);

		clearTimeout(this._timer);
		this._timer = setTimeout(bind(this._performZoom, this), left);

		stop(e);
	},

	_performZoom: function () {
		var map = this._map,
			zoom = map.getZoom(),
			snap = this._map.options.zoomSnap || 0;

		map._stop(); // stop panning and fly animations if any

		// map the delta with a sigmoid function to -4..4 range leaning on -1..1
		var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4),
			d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2,
			d4 = snap ? Math.ceil(d3 / snap) * snap : d3,
			delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;

		this._delta = 0;
		this._startTime = null;

		if (!delta) { return; }

		if (map.options.scrollWheelZoom === 'center') {
			map.setZoom(zoom + delta);
		} else {
			map.setZoomAround(this._lastMousePos, zoom + delta);
		}
	}
});

// @section Handlers
// @property scrollWheelZoom: Handler
// Scroll wheel zoom handler.
Map.addInitHook('addHandler', 'scrollWheelZoom', ScrollWheelZoom);

/*
 * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.
 */

// @namespace Map
// @section Interaction Options
Map.mergeOptions({
	// @section Touch interaction options
	// @option tap: Boolean = true
	// Enables mobile hacks for supporting instant taps (fixing 200ms click
	// delay on iOS/Android) and touch holds (fired as `contextmenu` events).
	tap: true,

	// @option tapTolerance: Number = 15
	// The max number of pixels a user can shift his finger during touch
	// for it to be considered a valid tap.
	tapTolerance: 15
});

var Tap = Handler.extend({
	addHooks: function () {
		on(this._map._container, 'touchstart', this._onDown, this);
	},

	removeHooks: function () {
		off(this._map._container, 'touchstart', this._onDown, this);
	},

	_onDown: function (e) {
		if (!e.touches) { return; }

		preventDefault(e);

		this._fireClick = true;

		// don't simulate click or track longpress if more than 1 touch
		if (e.touches.length > 1) {
			this._fireClick = false;
			clearTimeout(this._holdTimeout);
			return;
		}

		var first = e.touches[0],
			el = first.target;

		this._startPos = this._newPos = new Point(first.clientX, first.clientY);

		// if touching a link, highlight it
		if (el.tagName && el.tagName.toLowerCase() === 'a') {
			addClass(el, 'leaflet-active');
		}

		// simulate long hold but setting a timeout
		this._holdTimeout = setTimeout(bind(function () {
			if (this._isTapValid()) {
				this._fireClick = false;
				this._onUp();
				this._simulateEvent('contextmenu', first);
			}
		}, this), 1000);

		this._simulateEvent('mousedown', first);

		on(document, {
			touchmove: this._onMove,
			touchend: this._onUp
		}, this);
	},

	_onUp: function (e) {
		clearTimeout(this._holdTimeout);

		off(document, {
			touchmove: this._onMove,
			touchend: this._onUp
		}, this);

		if (this._fireClick && e && e.changedTouches) {

			var first = e.changedTouches[0],
				el = first.target;

			if (el && el.tagName && el.tagName.toLowerCase() === 'a') {
				removeClass(el, 'leaflet-active');
			}

			this._simulateEvent('mouseup', first);

			// simulate click if the touch didn't move too much
			if (this._isTapValid()) {
				this._simulateEvent('click', first);
			}
		}
	},

	_isTapValid: function () {
		return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
	},

	_onMove: function (e) {
		var first = e.touches[0];
		this._newPos = new Point(first.clientX, first.clientY);
		this._simulateEvent('mousemove', first);
	},

	_simulateEvent: function (type, e) {
		var simulatedEvent = document.createEvent('MouseEvents');

		simulatedEvent._simulated = true;
		e.target._simulatedClick = true;

		simulatedEvent.initMouseEvent(
				type, true, true, window, 1,
				e.screenX, e.screenY,
				e.clientX, e.clientY,
				false, false, false, false, 0, null);

		e.target.dispatchEvent(simulatedEvent);
	}
});

// @section Handlers
// @property tap: Handler
// Mobile touch hacks (quick tap and touch hold) handler.
if (touch && !pointer) {
	Map.addInitHook('addHandler', 'tap', Tap);
}

/*
 * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.
 */

// @namespace Map
// @section Interaction Options
Map.mergeOptions({
	// @section Touch interaction options
	// @option touchZoom: Boolean|String = *
	// Whether the map can be zoomed by touch-dragging with two fingers. If
	// passed `'center'`, it will zoom to the center of the view regardless of
	// where the touch events (fingers) were. Enabled for touch-capable web
	// browsers except for old Androids.
	touchZoom: touch && !android23,

	// @option bounceAtZoomLimits: Boolean = true
	// Set it to false if you don't want the map to zoom beyond min/max zoom
	// and then bounce back when pinch-zooming.
	bounceAtZoomLimits: true
});

var TouchZoom = Handler.extend({
	addHooks: function () {
		addClass(this._map._container, 'leaflet-touch-zoom');
		on(this._map._container, 'touchstart', this._onTouchStart, this);
	},

	removeHooks: function () {
		removeClass(this._map._container, 'leaflet-touch-zoom');
		off(this._map._container, 'touchstart', this._onTouchStart, this);
	},

	_onTouchStart: function (e) {
		var map = this._map;
		if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) { return; }

		var p1 = map.mouseEventToContainerPoint(e.touches[0]),
			p2 = map.mouseEventToContainerPoint(e.touches[1]);

		this._centerPoint = map.getSize()._divideBy(2);
		this._startLatLng = map.containerPointToLatLng(this._centerPoint);
		if (map.options.touchZoom !== 'center') {
			this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));
		}

		this._startDist = p1.distanceTo(p2);
		this._startZoom = map.getZoom();

		this._moved = false;
		this._zooming = true;

		map._stop();

		on(document, 'touchmove', this._onTouchMove, this);
		on(document, 'touchend', this._onTouchEnd, this);

		preventDefault(e);
	},

	_onTouchMove: function (e) {
		if (!e.touches || e.touches.length !== 2 || !this._zooming) { return; }

		var map = this._map,
			p1 = map.mouseEventToContainerPoint(e.touches[0]),
			p2 = map.mouseEventToContainerPoint(e.touches[1]),
			scale = p1.distanceTo(p2) / this._startDist;

		this._zoom = map.getScaleZoom(scale, this._startZoom);

		if (!map.options.bounceAtZoomLimits && (
			(this._zoom < map.getMinZoom() && scale < 1) ||
			(this._zoom > map.getMaxZoom() && scale > 1))) {
			this._zoom = map._limitZoom(this._zoom);
		}

		if (map.options.touchZoom === 'center') {
			this._center = this._startLatLng;
			if (scale === 1) { return; }
		} else {
			// Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng
			var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
			if (scale === 1 && delta.x === 0 && delta.y === 0) { return; }
			this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
		}

		if (!this._moved) {
			map._moveStart(true, false);
			this._moved = true;
		}

		cancelAnimFrame(this._animRequest);

		var moveFn = bind(map._move, map, this._center, this._zoom, {pinch: true, round: false});
		this._animRequest = requestAnimFrame(moveFn, this, true);

		preventDefault(e);
	},

	_onTouchEnd: function () {
		if (!this._moved || !this._zooming) {
			this._zooming = false;
			return;
		}

		this._zooming = false;
		cancelAnimFrame(this._animRequest);

		off(document, 'touchmove', this._onTouchMove);
		off(document, 'touchend', this._onTouchEnd);

		// Pinch updates GridLayers' levels only when zoomSnap is off, so zoomSnap becomes noUpdate.
		if (this._map.options.zoomAnimation) {
			this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
		} else {
			this._map._resetView(this._center, this._map._limitZoom(this._zoom));
		}
	}
});

// @section Handlers
// @property touchZoom: Handler
// Touch zoom handler.
Map.addInitHook('addHandler', 'touchZoom', TouchZoom);

Map.BoxZoom = BoxZoom;
Map.DoubleClickZoom = DoubleClickZoom;
Map.Drag = Drag;
Map.Keyboard = Keyboard;
Map.ScrollWheelZoom = ScrollWheelZoom;
Map.Tap = Tap;
Map.TouchZoom = TouchZoom;

Object.freeze = freeze;

exports.version = version;
exports.Control = Control;
exports.control = control;
exports.Browser = Browser;
exports.Evented = Evented;
exports.Mixin = Mixin;
exports.Util = Util;
exports.Class = Class;
exports.Handler = Handler;
exports.extend = extend;
exports.bind = bind;
exports.stamp = stamp;
exports.setOptions = setOptions;
exports.DomEvent = DomEvent;
exports.DomUtil = DomUtil;
exports.PosAnimation = PosAnimation;
exports.Draggable = Draggable;
exports.LineUtil = LineUtil;
exports.PolyUtil = PolyUtil;
exports.Point = Point;
exports.point = toPoint;
exports.Bounds = Bounds;
exports.bounds = toBounds;
exports.Transformation = Transformation;
exports.transformation = toTransformation;
exports.Projection = index;
exports.LatLng = LatLng;
exports.latLng = toLatLng;
exports.LatLngBounds = LatLngBounds;
exports.latLngBounds = toLatLngBounds;
exports.CRS = CRS;
exports.GeoJSON = GeoJSON;
exports.geoJSON = geoJSON;
exports.geoJson = geoJson;
exports.Layer = Layer;
exports.LayerGroup = LayerGroup;
exports.layerGroup = layerGroup;
exports.FeatureGroup = FeatureGroup;
exports.featureGroup = featureGroup;
exports.ImageOverlay = ImageOverlay;
exports.imageOverlay = imageOverlay;
exports.VideoOverlay = VideoOverlay;
exports.videoOverlay = videoOverlay;
exports.DivOverlay = DivOverlay;
exports.Popup = Popup;
exports.popup = popup;
exports.Tooltip = Tooltip;
exports.tooltip = tooltip;
exports.Icon = Icon;
exports.icon = icon;
exports.DivIcon = DivIcon;
exports.divIcon = divIcon;
exports.Marker = Marker;
exports.marker = marker;
exports.TileLayer = TileLayer;
exports.tileLayer = tileLayer;
exports.GridLayer = GridLayer;
exports.gridLayer = gridLayer;
exports.SVG = SVG;
exports.svg = svg$1;
exports.Renderer = Renderer;
exports.Canvas = Canvas;
exports.canvas = canvas$1;
exports.Path = Path;
exports.CircleMarker = CircleMarker;
exports.circleMarker = circleMarker;
exports.Circle = Circle;
exports.circle = circle;
exports.Polyline = Polyline;
exports.polyline = polyline;
exports.Polygon = Polygon;
exports.polygon = polygon;
exports.Rectangle = Rectangle;
exports.rectangle = rectangle;
exports.Map = Map;
exports.map = createMap;

var oldL = window.L;
exports.noConflict = function() {
	window.L = oldL;
	return this;
}

// Always export us to window global (see #2364)
window.L = exports;

})));
//# sourceMappingURL=leaflet-src.js.map
};

exports();
module.resolveWith(exports);
};
// module factory: end

FD40.module("leaflet", moduleFactory);

}());
			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var jQuery = $; 
var exports = function() { 

// ----------------------------------------------------------------------------
// markItUp! Universal MarkUp Engine, JQuery plugin
// v 1.1.x
// Dual licensed under the MIT and GPL licenses.
// ----------------------------------------------------------------------------
// Copyright (C) 2007-2012 Jay Salvat
// http://markitup.jaysalvat.com/
// ----------------------------------------------------------------------------
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
// ----------------------------------------------------------------------------

(function($) {
	$.fn.markItUp = function(settings, extraSettings) {
		var method, params, options, ctrlKey, shiftKey, altKey; ctrlKey = shiftKey = altKey = false;

		if (typeof settings == 'string') {
			method = settings;
			params = extraSettings;
		}

		options = {	id:						'',
					nameSpace:				'',
					root:					'',
					previewHandler:			false,
					previewInWindow:		'', // 'width=800, height=600, resizable=yes, scrollbars=yes'
					previewInElement:		'',
					previewAutoRefresh:		true,
					previewPosition:		'after',
					previewTemplatePath:	'~/templates/preview.html',
					previewParser:			false,
					previewParserPath:		'',
					previewParserVar:		'data',
					resizeHandle:			true,
					beforeInsert:			'',
					afterInsert:			'',
					onEnter:				{},
					onShiftEnter:			{},
					onCtrlEnter:			{},
					onTab:					{},
					markupSet:			[	{ /* set */ } ]
				};

		$.extend(options, settings, $.markItUp.sets[(extraSettings || settings || {}).set], extraSettings);

		// compute markItUp! path
		if (!options.root) {
			$('script').each(function(a, tag) {
				miuScript = $(tag).get(0).src.match(/(.*)jquery\.markitup(\.pack)?\.js$/);
				if (miuScript !== null) {
					options.root = miuScript[1];
				}
			});
		}

		return this.each(function() {
			var $$, textarea, levels, scrollPosition, caretPosition, caretOffset,
				clicked, hash, header, footer, previewWindow, template, iFrame, abort;
			$$ = $(this);
			textarea = this;
			levels = [];
			abort = false;
			scrollPosition = caretPosition = 0;
			caretOffset = -1;

			options.previewParserPath = localize(options.previewParserPath);
			options.previewTemplatePath = localize(options.previewTemplatePath);

			if (method) {
				switch(method) {
					case 'remove':
						remove();
					break;
					case 'insert':
						markup(params);
					break;
					default:
						$.error('Method ' +  method + ' does not exist on jQuery.markItUp');
				}
				return;
			}

			// apply the computed path to ~/
			function localize(data, inText) {
				if (inText) {
					return 	data.replace(/("|')~\//g, "$1"+options.root);
				}
				return 	data.replace(/^~\//, options.root);
			}

			// init and build editor
			function init() {
				id = ''; nameSpace = '';
				if (options.id) {
					id = 'id="'+options.id+'"';
				} else if ($$.attr("id")) {
					id = 'id="markItUp'+($$.attr("id").substr(0, 1).toUpperCase())+($$.attr("id").substr(1))+'"';

				}
				if (options.nameSpace) {
					nameSpace = 'class="'+options.nameSpace+'"';
				}
				$$.wrap('<div '+nameSpace+'></div>');
				$$.wrap('<div '+id+' class="markItUp"></div>');
				$$.wrap('<div class="markItUpContainer"></div>');
				$$.addClass("markItUpEditor");

				// add the header before the textarea
				header = $('<div class="markItUpHeader"></div>').insertBefore($$);
				$(dropMenus(options.markupSet)).appendTo(header);

				// add the footer after the textarea
				footer = $('<div class="markItUpFooter"></div>').insertAfter($$);

				// Wrapper for expandingTextarea
				$$.wrap('<div class="markItUpExpanding"></div>');

				// add the resize handle after textarea
				if (options.resizeHandle === true && $.browser.safari !== true) {
					resizeHandle = $('<div class="markItUpResizeHandle"></div>')
						.insertAfter($$)
						.bind("mousedown.markItUp", function(e) {
							var h = $$.height(), y = e.clientY, mouseMove, mouseUp;
							mouseMove = function(e) {
								$$.css("height", Math.max(20, e.clientY+h-y)+"px");
								return false;
							};
							mouseUp = function(e) {
								$("html").unbind("mousemove.markItUp", mouseMove).unbind("mouseup.markItUp", mouseUp);
								return false;
							};
							$("html").bind("mousemove.markItUp", mouseMove).bind("mouseup.markItUp", mouseUp);
					});
					footer.append(resizeHandle);
				}

				// listen key events
				$$.bind('keydown.markItUp', keyPressed).bind('keyup', keyPressed);

				// bind an event to catch external calls
				$$.bind("insertion.markItUp", function(e, settings) {
					if (settings.target !== false) {
						get();
					}
					if (textarea === $.markItUp.focused) {
						markup(settings);
					}
				});

				// remember the last focus
				$$.bind('focus.markItUp', function() {
					$.markItUp.focused = this;
				});

				if (options.previewInElement) {
					refreshPreview();
				}
			}

			// recursively build header with dropMenus from markupset
			function dropMenus(markupSet) {
				var ul = $('<ul></ul>'), i = 0;
				$('li:hover > ul', ul).css('display', 'block');
				$.each(markupSet, function() {
					var button = this, t = '', title, li, j;
					title = (button.key) ? (button.name||'')+' [Ctrl+'+button.key+']' : (button.name||'');
					key   = (button.key) ? 'accesskey="'+button.key+'"' : '';
					if (button.separator) {
						li = $('<li class="markItUpSeparator">'+(button.separator||'')+'</li>').appendTo(ul);
					} else {
						i++;
						for (j = levels.length -1; j >= 0; j--) {
							t += levels[j]+"-";
						}
						li = $('<li class="markItUpButton markItUpButton'+t+(i)+' '+(button.className||'')+'"><a href="" '+key+' title="'+title+'">'+(button.name||'')+'</a></li>')
						.bind("contextmenu.markItUp", function() { // prevent contextmenu on mac and allow ctrl+click
							return false;
						}).bind('click.markItUp', function() {
							return false;
						}).bind("focusin.markItUp", function(){
                            $$.focus();
						}).bind('mouseup', function() {
							if (button.call) {
								eval(button.call)();
							}
							setTimeout(function() { markup(button) },1);
							return false;
						}).bind('mouseenter.markItUp', function() {
								$('> ul', this).show();
								$(document).one('click', function() { // close dropmenu if click outside
										$('ul ul', header).hide();
									}
								);
						}).bind('mouseleave.markItUp', function() {
								$('> ul', this).hide();
						}).appendTo(ul);
						if (button.dropMenu) {
							levels.push(i);
							$(li).addClass('markItUpDropMenu').append(dropMenus(button.dropMenu));
						}
					}
				});
				levels.pop();
				return ul;
			}

			// markItUp! markups
			function magicMarkups(string) {
				if (string) {
					string = string.toString();
					string = string.replace(/\(\!\(([\s\S]*?)\)\!\)/g,
						function(x, a) {
							var b = a.split('|!|');
							if (altKey === true) {
								return (b[1] !== undefined) ? b[1] : b[0];
							} else {
								return (b[1] === undefined) ? "" : b[0];
							}
						}
					);
					// [![prompt]!], [![prompt:!:value]!]
					string = string.replace(/\[\!\[([\s\S]*?)\]\!\]/g,
						function(x, a) {
							var b = a.split(':!:');
							if (abort === true) {
								return false;
							}
							value = prompt(b[0], (b[1]) ? b[1] : '');
							if (value === null) {
								abort = true;
							}
							return value;
						}
					);
					return string;
				}
				return "";
			}

			// prepare action
			function prepare(action) {
				if ($.isFunction(action)) {
					action = action(hash);
				}
				return magicMarkups(action);
			}

			// build block to insert
			function build(string) {
				var openWith 			= prepare(clicked.openWith);
				var placeHolder 		= prepare(clicked.placeHolder);
				var replaceWith 		= prepare(clicked.replaceWith);
				var closeWith 			= prepare(clicked.closeWith);
				var openBlockWith 		= prepare(clicked.openBlockWith);
				var closeBlockWith 		= prepare(clicked.closeBlockWith);
				var multiline 			= clicked.multiline;

				if (replaceWith !== "") {
					block = openWith + replaceWith + closeWith;
				} else if (selection === '' && placeHolder !== '') {
					block = openWith + placeHolder + closeWith;
				} else {
					string = string || selection;

					var lines = [string], blocks = [];

					if (multiline === true) {
						lines = string.split(/\r?\n/);
					}

					for (var l = 0; l < lines.length; l++) {
						line = lines[l];
						var trailingSpaces;
						if (trailingSpaces = line.match(/ *$/)) {
							blocks.push(openWith + line.replace(/ *$/g, '') + closeWith + trailingSpaces);
						} else {
							blocks.push(openWith + line + closeWith);
						}
					}

					block = blocks.join("\n");
				}

				block = openBlockWith + block + closeBlockWith;

				return {	block:block,
							openWith:openWith,
							replaceWith:replaceWith,
							placeHolder:placeHolder,
							closeWith:closeWith
					};
			}

			// define markup to insert
			function markup(button) {
				var len, j, n, i;
				hash = clicked = button;
				get();
				$.extend(hash, {	line:"",
						 			root:options.root,
									textarea:textarea,
									selection:(selection||''),
									caretPosition:caretPosition,
									ctrlKey:ctrlKey,
									shiftKey:shiftKey,
									altKey:altKey
								}
							);
				// callbacks before insertion
				prepare(options.beforeInsert);
				prepare(clicked.beforeInsert);
				if ((ctrlKey === true && shiftKey === true) || button.multiline === true) {
					prepare(clicked.beforeMultiInsert);
				}
				$.extend(hash, { line:1 });

				if ((ctrlKey === true && shiftKey === true)) {
					lines = selection.split(/\r?\n/);
					for (j = 0, n = lines.length, i = 0; i < n; i++) {
						if ($.trim(lines[i]) !== '') {
							$.extend(hash, { line:++j, selection:lines[i] } );
							lines[i] = build(lines[i]).block;
						} else {
							lines[i] = "";
						}
					}

					string = { block:lines.join('\n')};
					start = caretPosition;
					len = string.block.length + (($.browser.opera) ? n-1 : 0);
				} else if (ctrlKey === true) {
					string = build(selection);
					start = caretPosition + string.openWith.length;
					len = string.block.length - string.openWith.length - string.closeWith.length;
					len = len - (string.block.match(/ $/) ? 1 : 0);
					len -= fixIeBug(string.block);
				} else if (shiftKey === true) {
					string = build(selection);
					start = caretPosition;
					len = string.block.length;
					len -= fixIeBug(string.block);
				} else {
					string = build(selection);
					start = caretPosition + string.block.length ;
					len = 0;
					start -= fixIeBug(string.block);
				}
				if ((selection === '' && string.replaceWith === '')) {
					caretOffset += fixOperaBug(string.block);

					start = caretPosition + string.openWith.length;
					len = string.block.length - string.openWith.length - string.closeWith.length;

					caretOffset = $$.val().substring(caretPosition,  $$.val().length).length;
					caretOffset -= fixOperaBug($$.val().substring(0, caretPosition));
				}
				$.extend(hash, { caretPosition:caretPosition, scrollPosition:scrollPosition } );

				if (string.block !== selection && abort === false) {
					insert(string.block);
					set(start, len);
				} else {
					caretOffset = -1;
				}
				get();

				$.extend(hash, { line:'', selection:selection });

				// callbacks after insertion
				if ((ctrlKey === true && shiftKey === true) || button.multiline === true) {
					prepare(clicked.afterMultiInsert);
				}
				prepare(clicked.afterInsert);
				prepare(options.afterInsert);

				// refresh preview if opened
				if (previewWindow && options.previewAutoRefresh) {
					refreshPreview();
				}

				// reinit keyevent
				shiftKey = altKey = ctrlKey = abort = false;
			}

			// Substract linefeed in Opera
			function fixOperaBug(string) {
				if ($.browser.opera) {
					return string.length - string.replace(/\n*/g, '').length;
				}
				return 0;
			}
			// Substract linefeed in IE
			function fixIeBug(string) {
				if ($.browser.msie) {
					return string.length - string.replace(/\r*/g, '').length;
				}
				return 0;
			}

			// add markup
			function insert(block) {
				if (document.selection) {
					var newSelection = document.selection.createRange();
					newSelection.text = block;
				} else {
					textarea.value =  textarea.value.substring(0, caretPosition)  + block + textarea.value.substring(caretPosition + selection.length, textarea.value.length);
				}
			}

			// set a selection
			function set(start, len) {
				if (textarea.createTextRange){
					// quick fix to make it work on Opera 9.5
					if ($.browser.opera && $.browser.version >= 9.5 && len == 0) {
						return false;
					}
					range = textarea.createTextRange();
					range.collapse(true);
					range.moveStart('character', start);
					range.moveEnd('character', len);
					range.select();
				} else if (textarea.setSelectionRange ){
					textarea.setSelectionRange(start, start + len);
				}
				textarea.scrollTop = scrollPosition;
				textarea.focus();
			}

			// get the selection
			function get() {
				textarea.focus();

				scrollPosition = textarea.scrollTop;
				if (document.selection) {
					selection = document.selection.createRange().text;
					if ($.browser.msie) { // ie
						var range = document.selection.createRange(), rangeCopy = range.duplicate();
						rangeCopy.moveToElementText(textarea);
						caretPosition = -1;
						while(rangeCopy.inRange(range)) {
							rangeCopy.moveStart('character');
							caretPosition ++;
						}
					} else { // opera
						caretPosition = textarea.selectionStart;
					}
				} else { // gecko & webkit
					caretPosition = textarea.selectionStart;

					selection = textarea.value.substring(caretPosition, textarea.selectionEnd);
				}
				return selection;
			}

			// open preview window
			function preview() {
				if (typeof options.previewHandler === 'function') {
					previewWindow = true;
				} else if (options.previewInElement) {
					previewWindow = $(options.previewInElement);
				} else if (!previewWindow || previewWindow.closed) {
					if (options.previewInWindow) {
						previewWindow = window.open('', 'preview', options.previewInWindow);
						$(window).unload(function() {
							previewWindow.close();
						});
					} else {
						iFrame = $('<iframe class="markItUpPreviewFrame"></iframe>');
						if (options.previewPosition == 'after') {
							iFrame.insertAfter(footer);
						} else {
							iFrame.insertBefore(header);
						}
						previewWindow = iFrame[iFrame.length - 1].contentWindow || frame[iFrame.length - 1];
					}
				} else if (altKey === true) {
					if (iFrame) {
						iFrame.remove();
					} else {
						previewWindow.close();
					}
					previewWindow = iFrame = false;
				}
				if (!options.previewAutoRefresh) {
					refreshPreview();
				}
				if (options.previewInWindow) {
					previewWindow.focus();
				}
			}

			// refresh Preview window
			function refreshPreview() {
 				renderPreview();
			}

			function renderPreview() {
				var phtml;
				if (options.previewHandler && typeof options.previewHandler === 'function') {
					options.previewHandler( $$.val() );
				} else if (options.previewParser && typeof options.previewParser === 'function') {
					var data = options.previewParser( $$.val() );
					writeInPreview(localize(data, 1) );
				} else if (options.previewParserPath !== '') {
					$.ajax({
						type: 'POST',
						dataType: 'text',
						global: false,
						url: options.previewParserPath,
						data: options.previewParserVar+'='+encodeURIComponent($$.val()),
						success: function(data) {
							writeInPreview( localize(data, 1) );
						}
					});
				} else {
					if (!template) {
						$.ajax({
							url: options.previewTemplatePath,
							dataType: 'text',
							global: false,
							success: function(data) {
								writeInPreview( localize(data, 1).replace(/<!-- content -->/g, $$.val()) );
							}
						});
					}
				}
				return false;
			}

			function writeInPreview(data) {
				if (options.previewInElement) {
					$(options.previewInElement).html(data);
				} else if (previewWindow && previewWindow.document) {
					try {
						sp = previewWindow.document.documentElement.scrollTop
					} catch(e) {
						sp = 0;
					}
					previewWindow.document.open();
					previewWindow.document.write(data);
					previewWindow.document.close();
					previewWindow.document.documentElement.scrollTop = sp;
				}
			}

			// set keys pressed
			function keyPressed(e) {
				shiftKey = e.shiftKey;
				altKey = e.altKey;
				ctrlKey = (!(e.altKey && e.ctrlKey)) ? (e.ctrlKey || e.metaKey) : false;

				if (e.type === 'keydown') {
					if (ctrlKey === true) {
						li = $('a[accesskey="'+((e.keyCode == 13) ? '\\n' : String.fromCharCode(e.keyCode))+'"]', header).parent('li');
						if (li.length !== 0) {
							ctrlKey = false;
							setTimeout(function() {
								li.triggerHandler('mouseup');
							},1);
							return false;
						}
					}
					if (e.keyCode === 13 || e.keyCode === 10) { // Enter key
						if (ctrlKey === true) {  // Enter + Ctrl
							ctrlKey = false;
							markup(options.onCtrlEnter);
							return options.onCtrlEnter.keepDefault;
						} else if (shiftKey === true) { // Enter + Shift
							shiftKey = false;
							markup(options.onShiftEnter);
							return options.onShiftEnter.keepDefault;
						} else { // only Enter
							markup(options.onEnter);
							return options.onEnter.keepDefault;
						}
					}
					if (e.keyCode === 9) { // Tab key
						if (shiftKey == true || ctrlKey == true || altKey == true) {
							return false;
						}
						if (caretOffset !== -1) {
							get();
							caretOffset = $$.val().length - caretOffset;
							set(caretOffset, 0);
							caretOffset = -1;
							return false;
						} else {
							markup(options.onTab);
							return options.onTab.keepDefault;
						}
					}
				}
			}

			function remove() {
				$$.unbind(".markItUp").removeClass('markItUpEditor');
				$$.parents('div.markItUp').parent('div').replaceWith($$);
				$$.data('markItUp', null);
			}

			init();
		});
	};

	$.fn.markItUpRemove = function() {
		return this.each(function() {
				$(this).markItUp('remove');
			}
		);
	};

	var sets;

	if (typeof $.markItUp === "object") {
		sets = $.markItUp.sets;
	}

	$.markItUp = function(settings) {
		var options = { target:false };
		$.extend(options, settings);
		if (options.target) {
			return $(options.target).each(function() {
				$(this).focus();
				$(this).trigger('insertion', [options]);
			});
		} else {
			$('textarea').trigger('insertion', [options]);
		}
	};

	$.markItUp.sets = {};

	if (sets) {
		$.extend($.markItUp.sets, sets);
	}

})(jQuery);

}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("markitup", moduleFactory);

}());			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this;
var exports = function() {

/**
 * jquery.mentions.
 * Textarea with ability to highlight text blocks
 * Includes built-in autogrow and autocomplete
 * and a inspector utility for debugging purposes.
 *
 * Customizable trigger keys allows you to create
 * mentions, hashtags and nything else that fit your needs.
 *
 * Copyright (c) 2013 Jensen Tonne
 * http://www.jstonne.com
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 * Trigger configuration:
 *
 * type
 *   Name for the trigger type.
 *
 * wrap
 *   Whether or not hitting a trigger key before existing
 *   characters will wrap these characters into the block
 *   marker until a stop character is found. Space will
 *   always be a stop character whether or not it is
 *   specified in allowSpace or stop option. (default: false)
 *
 * stop
 *   A string of characters that will end the block. (default: "")
 *
 * allowSpace
 *   If true, hitting on a space in a block marker
 *   will not end the block marker until a consecutive
 *   space is pressed. (default: false)
 *
 * query
 *   Accepts a url string, an array of objects or
 *   a function that returns a deferred object that
 *   resolves with an array of objects. Also accept a
 *   query configuration object (advanced users only!).
 *
 * finalize
 *    If true, after selecting an item from the
 *    autocomplete menu, the block marker is finalized
 *    and any further changes to within the block marker
 *    will simply destroy the entire marker. (default: false)
 *
 * triggers: {
 *     "@": {
 *         type: "entity",
 *         wrap: false,
 *         stop: "",
 *         allowSpace: true,
 *         query: http://json/rest/api?q=
 *     },
 *     "#": {
 *         type: "hashtag",
 *         wrap: true,
 *         stop: " #",
 *         allowSpace: false
 *     }
 * }
 *
 */var _backspace = "",
	_space     = " ",
	_nbsp      = "\u00a0",
	_newline   = "\n",
	_typeAttr  = "data-type",
	_valueAttr = "data-value",
	KEYCODE = {
		BACKSPACE: 8,
		COMMA: 188,
		DELETE: 46,
		DOWN: 40,
		ENTER: 13,
		ESCAPE: 27,
		LEFT: 37,
		RIGHT: 39,
		SPACE: 32,
		TAB: 9,
		UP: 38
	};

// TODO: Put this elsewhere
$.fn.caret = function(start, end) {

	if (this.length == 0) {
		return;
	}

	if (typeof start == 'number') {

		end = (typeof end == 'number') ? end : start;

		return this.each(function() {

			if (this.setSelectionRange) {
				var obj = this;

				// window.setTimout is a walkaround to address the chrome bug.
				window.setTimeout(function() {
					obj.setSelectionRange(start, end);
				}, 0);

			} else if (this.createTextRange) {
				var range = this.createTextRange();
				range.collapse(true);
				range.moveEnd('character', end);
				range.moveStart('character', start);
				try { range.select(); } catch (ex) { }
			}
		});

	} else {
		if (this[0].setSelectionRange)
		{
			start = this[0].selectionStart;
			end = this[0].selectionEnd;
		} else if (document.selection && document.selection.createRange)
		{
			var range = document.selection.createRange();
			start = 0 - range.duplicate().moveStart('character', -100000);
			end = start + range.text.length;
		}
		return { start: start, end: end };
	}
};
var Marker = function(options) {
	$.extend(this, options);
}

$.extend(Marker.prototype, {

	val: function(str) {

		var marker = this;

		if (str===undefined) {
			return marker.text.nodeValue;
		}

		// Update text value
		marker.text.nodeValue = str;

		// Update end & length
		marker.end = marker.start + (marker.length = str.length);

		return marker;
	},

	nextSibling: function(node) {

		var next = node.nextSibling;

		while (next && next.nodeType===1 && next.hasAttribute("data-ignore")) {
			next = next.nextSibling;
		}

		return next;
	},

	insert: function(str, start, end) {

		// Marker
		var marker     = this,
			block      = marker.block,
			text       = marker.text,
			parent     = marker.parent,
			br         = marker.br,
			val        = marker.val(),
			length     = marker.length,

			// Character flags
			newline    = str==_newline,
			space      = str==_space,
			backspace  = str==_backspace,

			// Trigger
			trigger = marker.trigger || {},
			finalize = trigger.finalize,
			finalized = marker.finalized,

			// Spaces
			// We need to insert space in a spawned marker when:
			//  - space is not allowed in block marker
			//  - space is allowed in block marker
			//    but there's already a trailing space.
			trailingSpace = val.charCodeAt(start - 1) == 32,
			allowSpace = trigger.allowSpace || marker.allowSpace,
			spawnSpace = space && (!allowSpace || (allowSpace && trailingSpace));

		// If no start position was given,
		// assume want to insert at the end of the text.
		if (start===undefined) start = length;

		// If no end position was given,
		// assume we want to insert in a single position.
		if (end===undefined) end = start;

		// If this block marker already has a trailing space
		// but the block marker hasn't been finalized yet.
		if (block && trailingSpace && !allowSpace && !finalized) {

			// Reverse the insertion on textarea
			if (space) {

				var $textarea = $(marker.textarea),
					wholeText = $textarea.val(),
					pos = $textarea.caret().end - 1,
					offset = marker.start + start;

				$textarea
					.val(wholeText.substring(0, offset) + wholeText.slice(offset + 1))
					.caret(pos);
			}

			// Convert to text marker
			marker.toTextMarker();

			// TODO: Refactor this
			if (space) {
				// Trigger marker for post processing
				$(parent).trigger("markerInsert", [marker, nodes, str, start, end]);
				return marker;
			// For other characters, restart text insertion process.
			} else {
				return marker.insert(str, start, end);
			}
		}

		// If we are at the end of a block marker OR this is a newline block marker,
		// space & newline should be added to beginning of the next marker.
		if (block && end==length && !backspace && (spawnSpace || newline || br || finalized)) {
			var spawn = marker.spawn().insert(str, 0);
			$(parent).trigger("markerExit", [marker, nodes, spawn, str, start, end]);
			return spawn;
		}

		// Quick monkey patch for typing before a block marker
		// in the beginning of the textarea.
		if (block && marker.index===0 && end===0 && str.length===1) {
			var textnode = document.createTextNode(str);
			parent.insertBefore(textnode, block);

			var newMarker = new Marker({
				index: 0,
				start: 0,
				end: str.length,
				text: textnode,
				parent: parent,
				textarea: marker.textarea,
				allowSpace: true,
			});

			// Trigger marker for post processing
			$(parent).trigger("markerInsert", [newMarker, nodes, str, start, end]);

			return newMarker;
		}

		// Nodes
		var next   = block ? block.nextSibling : text.nextSibling,

			// Text
			prefix = val.substring(0, start),
			suffix = val.slice(end),

			// Chunks
			// Replace double space with one space and one nbsp to ensure
			// overlay is rendered proper spacing + identical word-wrap.
			chunks = str.replace(/  /g, " " + _nbsp).split(_newline),
			nodes  = [],
			node   = block || text,
			i      = chunks.length;

		// Add the prefix/suffix to the first/last chunk.
		// If this is a single chunk, the suffix is
		// actually added to the same chunk. :)
		chunks[0] = prefix + chunks[0];
		chunks[i-1] += suffix;

		// If this is a single chunk, this loop won't execute
		// but we still benefit from having the correct index. :)
		while (--i) {

			var node = document.createTextNode(chunks[i]),
				br = document.createElement("BR");

			nodes.push(parent.insertBefore(node, next));
			nodes.push(parent.insertBefore(br, node));

			next = br;
		}

		// Update the text value in the current marker
		marker.val(chunks[i]);

		// Trigger marker for post processing
		$(parent).trigger("markerInsert", [marker, nodes, str, start, end]);

		return marker;
	},

	remove: function() {

		var marker = this,
			parent = marker.parent,
			block = marker.block,
			text = marker.text;

		if (block) $(block).trigger("triggerDestroy", [marker]);

		parent.removeChild(block || text);

		marker.removed = true;

		$(parent).trigger("markerRemove", [marker]);

		return marker;
	},

	toTextMarker: function() {

		var marker = this,
			block  = marker.block,
			parent = marker.parent;

		if (!block) return marker;

		// Create a copy of the old marker
		var old = marker.clone();

		if (block) $(block).trigger("triggerDestroy", [marker]);

		// Move the text node out and
		// place it before the next marker.
		// Note: This doesn't need marker.nextSibling();
		parent.insertBefore(marker.text, block.nextSibling);

		// Remove the block node
		parent.removeChild(block);
		delete marker.block;
		delete marker.trigger;

		$(marker.parent).trigger("markerConvert", [marker, old, "text"]);

		return marker;
	},

	toBlockMarker: function(normalize) {

		var marker = this;

		// If this is a block marker, skip.
		if (marker.block) return;

		var old = marker.clone(),
			parent = marker.parent,
			block = marker.block = document.createElement("SPAN"),
			text  = marker.text;

		// Insert block before the next marker
		// Note: This doesn't need marker.nextSibling();
		parent.insertBefore(block, text.nextSibling);

		// Move text inside block marker
		block.appendChild(text);

		// Create empty marker data
		$(block).data("marker", {});

		$(marker.parent).trigger("markerConvert", [marker, old, "block"]);

		return marker;
	},

	spawn: function(start, end) {

		var marker = this,
			text   = marker.text,
			parent = marker.parent,
			block  = marker.block,
			// Note: This doesn't need marker.nextSibling();
			next   = block ? block.nextSibling : text.nextSibling;

		// If not start and end position was given, assume that
		// we're spawning an empty marker next to the current marker.
		// [hello] --> [hello[]
		if (start===undefined) {
			start = end = marker.length;
		}

		// If we're spawning in text in the middle,
		// split out the end marker and insert it before the next marker.
		// [he*ll*o] --> [he*ll*][o]
		if (end < marker.length) {
			next = parent.insertBefore(text.splitText(end), next);
		}

		// Split out the text
		// [he*ll*][o] --> [he][ll][o]
		text = parent.insertBefore(text.splitText(start), next);

		// Create marker object from new text object
		var spawn = new Marker({
			index     : marker.index + 1,
			start     : (start = marker.start + start),
			end       : (end = marker.start + end),
			length    : end - start,
			text      : text,
			parent    : parent,
			textarea  : marker.textarea,
			before    : marker,
			after     : marker.after,
			br        : false,
			allowSpace: true,
			finalized : false
		});

		// Update current marker
		marker.end    = start,
		marker.length = marker.end - marker.start;
		marker.after  = spawn;

		return spawn;
	},

	clone: function() {

		return new Marker(
			$.pick(this, "index,start,end,length,text,parent,textarea,before,after,br,allowSpace,trigger,value,finalized".split(","))
		);
	},

	finalize: function(value) {

		var marker = this,
			block = marker.block;

		// Text marker cannot be finalized
		if (!block) return;

		var data = $(block).data("marker");
			data.value = value;
			data.finalized = true;

		$.extend(marker, data);
	},

	updateValue: function(value) {

		var marker = this,
			block = marker.block;

		// Text marker cannot be finalized
		if (!block) return;

		var data = $(block).data("marker");
			data.value = value;

		$.extend(marker, data);
	}
});

$.Controller("Mentions", {
	pluginName: "mentions",
	hostname: "mentions",
	defaultOptions: {

		cssCloneProps: [
			'lineHeight', 'textDecoration', 'letterSpacing',
			'fontSize', 'fontFamily', 'fontStyle',
			'fontWeight', 'textTransform', 'textAlign',
			'direction', 'wordSpacing', 'fontSizeAdjust'
		],

		triggers: {},

		"{textarea}": "[data-mentions-textarea]",
		"{overlay}" : "[data-mentions-overlay]",
		"{block}"   : "[data-mentions-overlay] > span"
	}
}, function(self) { return {

	init: function() {

		// Speed up access to overlay
		self._overlay  = self.overlay()[0];
		self._textarea = self.textarea()[0];

		// Put this in a non-blocking thread
		setTimeout(function(){
			self.cloneLayout();
		}, 15);

		self.addPlugin("autocomplete");

		self.initialCaret = self.textarea().data("initial") || 0;
	},

	setLayout: function() {

		self.normalize();
	},

	cloneLayout: function() {

		var $overlay = self.overlay(),
			overlay = $overlay.detach()[0],
			textarea = self.textarea(),
			props = self.options.cssCloneProps,
			i = 0;

		while (prop = props[i++]) {
			overlay.style[prop] = textarea.css(prop);
		}

		overlay.style.opacity = 1;

		$overlay.insertBefore(textarea);

		self.setLayout();
	},

	reset: function() {

		// Overlay
		var overlay = self.overlay(),
			overlayDefault = overlay.data("default");

		if (overlayDefault !== undefined) {
			// TODO: Use $.toHTML() in the future
			// after all is on 3.1.11.
			overlay.html($('<div>').html(overlayDefault).html());
		} else {
			overlay.empty();
		}

		// Textarea
		var textarea = self.textarea(),
			textareaDefault = textarea.data("default");

		if (textareaDefault !== undefined) {
			textarea.val($('<div>').html(textareaDefault).text());
		} else {
			textarea.val("");
		}

		self.caretBefore = self.caretAfter = {start: 0, end: 0};
		self.previousMarker = null;

		self.normalize();

		self.initialFocus = true;

		self.trigger("triggerClear");

		self.previousCursorPosition = 0;
	},

	moveCursor: function(pos) {
		self.textarea().trigger('focus');
		self.textarea().caret(pos);
	},

	//--- Triggers ----//

	getTrigger: function(key) {

		var triggers = self.options.triggers;
		if (triggers.hasOwnProperty(key)) {
			var trigger = triggers[key];
			trigger.key = key;
			return trigger;
		}
	},

	getTriggerFromType: function(type) {

		var triggers = self.options.triggers,
			found;

		$.each(triggers, function(key, trigger) {
			if (trigger.type===type) {
				found = trigger;
				return false;
			}
		});

		return found;
	},

	getStopIndex: function(str, stop) {

		var i = stop.length,
			idx = str.length;

		// Find the first earliest stop character, that's where the string ends
		while (i--) {
			var chr = stop.substr(i, 1),
				pos = str.indexOf(chr);
			idx = (pos < 0) ? idx : Math.min(idx, pos);
		}

		return idx;
	},

	//--- Marker traversal ----//

	getMarkers: function(callback) {

		var textarea = self._textarea,
			overlay = self._overlay,
			nodes = $.makeArray(overlay.childNodes),
			node,
			i = 0,
			start = 0,
			before = null,
			skip = false,
			results = [],
			iterator = function(marker) {

				var ret;

				// Execute callback while passing in marker object
				if (callback) ret = callback.apply(marker, [marker]);

				// If callback returned:
				// false     - stop the loop
				// null      - don't add anything to the result list
				// undefined - add the same marker object to the result list
				// value     - add the value to the result list
				if (ret!==null && ret!==false) results.push(ret!==undefined ? ret : marker);

				return ret; // if ret is false, the parent loop will stop
			};

		// Filter out nodes to ignore
		$.remove(nodes, function(node){
			return node.nodeType===1 && node.hasAttribute('data-ignore');
		});

		while (node = nodes[i++]) {

			// Nodes
			var nodeType = node.nodeType,
				nodeName = node.nodeName,
				text, block = null,

				// Marker positions
				end, length,

				// Marker behaviour
				br = false, allowSpace = false;

			// If this is a text node, assign this node as marker text
			if (nodeType==3) {
				text = node;
				allowSpace = true;
			// else assign this node as marker block,
			// then test if node is <br/>, create a detached text node contaning a line break,
			} else if ((block = node) && nodeName=="BR") {
				text = document.createTextNode(_newline);
				br = true;
			// if this is an invalid node, e.g. node not element, node not span, span has no text child node,
			// remove code from overlay and skip this loop.
			} else if (nodeType!==1 || nodeName!=="SPAN" || !(text = node.childNodes[0]) || text.nodeType!==3) {
				overlay.removeChild(node);
				continue;
			}

			// Create marker props
			var props = {
				index     : i - 1,
				start     : start,
				end       : (end = start + (length = text.length)),
				length    : length,
				text      : text,
				block     : block,
				parent    : overlay,
				textarea  : textarea,
				before    : before,
				br        : br,
				allowSpace: allowSpace,
				finalized : false
			};

			// Create marker data
			if (block) {
				var $node = $(node), data = $node.data("marker");
				if (!data) (data = {}) && $node.data("marker", data);

				// Restore trigger from data attribute
				if (node.hasAttribute(_typeAttr)) {

					var type = $node.attr(_typeAttr),
						trigger = self.getTriggerFromType(type);

					if (trigger) data.trigger = trigger;
					$node.removeAttr(_typeAttr);
				}

				// Restore value from data attribute
				if (node.hasAttribute(_valueAttr)) {

					data.value = $node.attr(_valueAttr);
					data.finalized = true;
					$node.removeAttr(_valueAttr);
				}

				$.extend(props, data);
			}

			// Create marker
			var marker = new Marker(props);

			// If this is the second iteration, decorate the marker the after property
			// of the marker before this with the current marker.
			if (i > 1 && before !== null) {
				before.after = marker;
				// Execute iterator for the marker before this
				// If iterator returned false, stop the loop.
				if (skip = (iterator(before)===false)) break;
			}

			// Else reset start position and
			// continue with next child node.
			start = end;
			before = marker;
		}

		// Execute iterator one more time for the last marker
		if (!skip) iterator(before);

		return results;
	},

	getMarkerAt: function(pos) {

		if (pos===undefined) return;

		var marker;

		self.getMarkers(function(){

			// If position is inside current node,
			// stop and return marker.
			if (pos >= this.start && pos <= this.end) {
				marker = this;
				return false;
			}
		});

		return marker;
	},

	getMarkersBetween: function(start, end) {

		if (start===undefined) return;

		return self.getMarkers(function(){

			return (this.start > end) ? false : (this.end < start) ? null : this;
		});
	},

	toArray: function(stringify, asc) {

		var results = self.getMarkers(function(){

			var marker = this;

			if (!marker.block || marker.br) return null;

			// If there's no trigger, try to find it.
			if (!marker.trigger) {

				// Identify the trigger being used
				var wholeText = marker.text.nodeValue,
					key = wholeText.slice(0, 1),
					trigger = self.getTrigger(key);

				if (!trigger) return null;

				marker.trigger = trigger;
				marker.value = wholeText.slice(1);
			}

			// Default start value
			var markerStart = marker.start;

			// We try to detect if there is any newline before the first word
			var text = self._textarea.value;
			var matches = text.match(/^\n+/g);

			// If there is, we need to re-adjust the marker.start
			if (matches != null) {
				var lines = matches[0].split(/\r*\n/);
				var newLineCount = lines.length - 1;

				if (newLineCount > 0) {
					var markerStart = marker.start - newLineCount;
				}
			}

			var data = {
				start  : markerStart,
				length : marker.length,
				type   : marker.trigger.type,
				value  : marker.value
			};

			return (stringify) ? JSON.stringify(data) : data;
		});

		return (asc) ? results : results.reverse();
	},

	//--- Marker/overlay/text manipulation ---//

	insert: function(str, start, end) {

		var marker, offset;

		// If we are inserting character(s)
		if (start===end || end===undefined) {

			// Get marker & offset
			marker = self.getMarkerAt(start);
			offset = marker.start;

			// Insert character
			marker.insert(str, start - offset, end - offset);

		} else {

			// If we are replacing character(s)

			// Identify affected markers
			var markers = self.getMarkersBetween(start, end),
				length = markers.length;

			// If there are no marker, stop.
			if (length < 1) return;

			// If we're modifying a single marker
			// e.g. he*llo* --> he*y*
			if (length==1) {

				// Get marker & offset
				marker = markers[0];
				offset = marker.start;

				// Insert character
				marker.insert(str, start - offset, end - offset);
			} else {

				// If we're modifying multiple markers
				// e.g. he*llo [john] [do*e] --> he*xxx*e

				// Deal with markers in reverse
				var i = length - 1,
					marker = markers[i];

				// Convert block marker into text marker
				// [doe] --> doe
				// hello [john] [doe] --> hello [john] doe
				if (marker.block && end > marker.start) marker.toTextMarker();

				// Remove characters from text marker
				// doe --> e
				// hello [john] doe --> hello [john] e

				// Do not perform this operation if it does
				// not changes the value of the marker.
				if ((end - marker.start) > 0) {
					marker.insert("", 0, end - marker.start);
				}

				// Remove all markers in between
				// [john] --> (removed)
				// hello [john] --> hello
				while ((marker = markers[--i]) && i > 0) {
					marker.remove();
				}

				// If we're in the beginning of the textarea,
				// convert block into text marker.
				if (marker.block && marker.index===0 && start===0) marker.toTextMarker();

				// Insert characters in the first marker
				// hello -> hexxxe
				marker.insert(str, start - marker.start, marker.length);

				// Special case for handling br tag in the beginning of the textarea
				if (start===0 && marker.br) {
					marker.remove();
				}
			}
		}

		// Normalize all text markers
		self.normalize();

		return marker;
	},

	textareaInsert: function(str, start, end) {

		var textarea = self._textarea,
			val = textarea.value;

		return textarea.value = val.substring(0, start) + str + val.slice(end);
	},

	normalize: function() {

		var overlay = self._overlay,
			textarea = self._textarea;

		// This clean up empty text nodes in the beginning and
		// the end of the overlay and join disjointed text nodes
		// that are supposed to be a single text node.
		overlay.normalize();

		// This is a double-edged workaround.
		// - When there is no child element (empty textarea),
		//   an empty text node ensure overlay has a minimum
		//   single line-height.
		// - If there is a newline at the end of the overlay,
		//   an empty text node ensure overlay accomodates
		//   the height of the newline.
		var first = overlay.firstChild,
			last = overlay.lastChild,
			textNode = document.createTextNode("");

		if (!last || last.nodeName==="BR") {
			overlay.appendChild(textNode);
		}

		if (last && last==first && last.nodeType===1 && last.hasAttribute("data-ignore")) {
			overlay.insertBefore(textNode, last);
		}

		// Chrome, Opera & IE doesn't accomodate height of
		// newline after an empty text node, so reset the
		// overlay height to auto, and retrieve the textarea
		// scrollHeight again.
		overlay.style.height = "auto";
		overlay.style.height = textarea.scrollHeight + "px";

		// IE & Opera textarea's scrollTop may jump position
		// from time to time so we need to reset it back.
		textarea.scrollTop = 0;

		// Remember the current textarea length.
		// We do it here instead of keydown event
		// because Opera returns the length of the
		// textarea after it has been changed.
		self.lengthBefore = textarea.value.length;

		// console.log("after", overlay.childNodes);
	},

	//--- Key events & caret handling ---//

	/*
	List of input patterns to test:

	0. Meta-characters via alt + shift + (any key).

	1. Holding arrow key + pressing another character.

	2. Select a range of characters (covering single/multiple marker)
	   - and press any key
	   - and press enter
	   - and press backspace

	3. Repeat step 2 with range starting at a block marker where caret is at:
	   - the beginning
	   - the middle
	   - the end
	   of the block marker and also when block marker is at:
	   - the beginning
	   - the middle
	   - the end
	   of the textarea.

	4. Typing accented character.
	   Hold a key until candidate window shows up, then:
	   - Press a number
	   - Release key, then press a number
	   - Navigate using arrow keys
	   - Press enter to select a character
	   - Click on a candidate to select a character
	   - Press backspace until candidate window dissappears

	5. Typing romanized-to-unicode (Chinese/Japanese/Arabian/etc) characters.
	   Type multiple characters in the candidate window, then proceed with
	   the next course of action at test no. 4.

	6. Pressing enter continously to create multiple newlines:
	   - at the beginning of the textarea
	   - at the middle of marker/text
	   - at the end of textarea
	   then:
	   - enter a key at the newline
	   - press backspace to remove those newlines
	   - select a range of newlines, then proceed with
		 the next course of action at test no. 2.
	*/

	lengthBefore: 0,
	caretBefore: {start: 0, end: 0},
	caretAfter: {start: 0, end: 0},
	skipKeydown: false,
	previousMarker: null,

	initialFocus: true,

	isPasting: false,
	smileyLength: 0,
	tagToProcess: [],
	previousCursorPosition: 0,

	"{textarea} focus": function() {

		if (self.initialFocus) {
			self.textarea().caret(self.initialCaret || 0);
		}
	},

	"{textarea} focusout": function() {
		self.previousCursorPosition = self.textarea().prop('selectionEnd');
	},

	"{textarea} keydown": function(textarea, event) {

		self.initialFocus = false;

		// If keydown event has been fired multiple times
		// this might mean the user has entered candidate
		// window and we should not do anything.
		if (self.skipKeydown) return;

		var caret = self.caretBefore = textarea.caret();

		if (event.keyCode===8 && $.IE < 10) {
			self.overlay().css('opacity', 0);
		}

		self.skipKeydown = true;
	},

	// Keypress event will not trigger when meta keys are pressed,
	// it will trigger on well-formed characters.
	"{textarea} keypress": function(textarea, event) {

		// This will help on situations where user
		// holds an arrow key + presses another character.
		self.caretBefore = textarea.caret();

		// FF fires keypress on backspace, while Chrome & IE doesn't.
		// We normalize this behaviour by not doing anything on backspace.
		if (event.keyCode===8) return;
	},

	"convertHashTag": function(textarea) {

		// Get current hashtag overlay
		var newHtml = self.overlay().html();

		// Remove all span tags from the overlay
		// newHtml = newHtml.replace(/<\/?span[^>]*>/g, '');
		newHtml = newHtml.replace(/<span[^>]*>(#.*?)<\/span[^>]*>/g, '$1');

		// Replace <br> with \n
		newHtml = newHtml.replace(/<br\s*[\/]?>/gi, '\n');

		// Match if there is any hashtag or not
		// In the future we should use lookbehind method as it is more accurate.
		// Too bad Firefox don't have support for lookbehind yet..
		// http://kangax.github.io/compat-table/es2016plus/#test-RegExp_Lookbehind_Assertions
		// var tags = newHtml.match(/(?<=\s|^)#[^\s]+[\w]/g);

		// Alternative for lookbehind match.
		var tags = newHtml.match(/(\s|^)(#[^\s]+[\w])/g);

		if (tags && tags.length > 0) {

			// Ensure that the tags is unique.
			var results = [];

			$.each(tags, function(i, e) {

				// Can remove this once lookbehind regex is supported.
				e = e.trim();

				if ($.inArray(e, results) == -1) results.push(e);
			});

			$(results).each(function(i, tag) {

				// check if this is a valid hashtag or not.
				var testSubject = tag.replace('#', '');
				var invalidChars = testSubject.match(/[&=\?]/g);

				if (invalidChars) {
					return;
				}

				spanEle = '<span>$1</span>';

				// Wrap the selected tag with <span>
				var expression = new RegExp('(' + tag + ')($|^|\\b)', 'gm');

				newHtml = newHtml.replace(expression, spanEle);
			});

			// Replace the overlay
			self.overlay().html(newHtml);
		}
	},

	"convertEmoticon": function(textarea) {

		// Get current overlay
		var newHtml = self.overlay().html();

		// Remove all span tags from the overlay
		// newHtml = newHtml.replace(/<\/?span[^>]*>/g, '');
		newHtml = newHtml.replace(/<span[^>]*>(:.*?)<\/span[^>]*>/g, '$1');

		// Divide the regex in 2 part
		// newHtml = newHtml.replace(/<span>/g, '');
		// newHtml = newHtml.replace(/<\/span>/g, '');

		// Trim any excess whitespaces
		newHtml = newHtml.trim();

		// Replace <br> with \n
		newHtml = newHtml.replace(/<br\s*[\/]?>/gi, '\n');

		// match if there is any emoticons or not
		var emoticons = newHtml.match(/:\([^\s]+[\w]\)/g);

		if (emoticons && emoticons.length > 0) {

			// Ensure that the emoticons is unique.
			var results = [];

			$.each(emoticons, function(i, e) {
				if ($.inArray(e, results) == -1) results.push(e);
			});

			$(results).each(function(i, tag) {

				// check if this is a valid hashtag or not.
				// var testSubject = tag.replace('#', '');
				// var invalidChars = testSubject.match(/[&=\?]/g);

				// if (invalidChars) {
				// 	return;
				// }

				tag = tag.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
				spanEle = '<span>$1</span> ';

				// Wrap the selected tag with <span>
				var expression = new RegExp('(' + tag + ')($|^| |\\b)', 'gm');

				newHtml = newHtml.replace(expression, spanEle);
			});

			// Replace the overlay
			self.overlay().html(newHtml);
		}
	},

	"{textarea} input": function(textarea) {

		// Reflect the overlay with current input
		self.reflect();

		if (self.isPasting) {
			self.convertHashTag();
			self.convertEmoticon();

			self.isPasting = false;
		}

		// Extra precaution in case overlay goes wrong,
		// user can start all over again by reseting mentions.
		if (textarea.val().length < 1) {
			self.reset();
		}
	},

	"{textarea} paste": function(textarea, event) {

		// Set pasting flag
		self.isPasting = true;
	},

	"{textarea} keyup": function(textarea, event) {

		self.skipKeydown = false;

		// Listen to backspace during keydown because
		// it is not fired on input/keypress on IE9.
		if (event.keyCode === 8 && $.IE < 10) {

			var caretBefore = self.caretBefore,
				caretAfter  = self.caretAfter = self.textarea().caret();

			self.insert("", caretAfter.end, caretBefore.end);

			self.caretBefore = caretAfter;

			self.overlay().css('opacity', 1);
		}

		// reset pasting flag
		if (self.isPasting) {
			self.isPasting = false;
		}
	},

	"{textarea} click": function(textarea, event) {
		self.caretBefore = textarea.caret();
	},

	reflect: function() {
		var textarea = self._textarea,

			wholeText = textarea.value,

			// Caret position retrieved on previous input event
			// is the position before the character is inserted
			caretBefore = self.caretBefore,

			// Caret position retrieved on current input event
			// is the position after the character is inserted.
			caretAfter = self.caretAfter = $(textarea).caret(),

			// Determine if user is on Opera + candidate window.
			operaCandidateWindow = ($.browser.opera && caretAfter.end > caretAfter.start),

			marker = self.getMarkerAt(caretBefore.start),

			diff = self.lengthBefore - wholeText.length,

			replace = false;


		// Ensure Opera follows the caretBefore behaviour of other
		// browsers when typing inside the candidate window.
		if (operaCandidateWindow) {
			if (caretBefore.start!==caretBefore.end) {
				caretBefore.end += diff;
			}
		}

		if (self.smileyLength > 0) {
			var t = self.previousCursorPosition + self.smileyLength;
			caretAfter.start = t;
			caretAfter.end = t;

			// reset for the next input
			self.smileyLength = 0;
		}

		// In case there was an issue retrieving marker.
		// TODO: Figure out the pattern, usually when typed too early.
		if (!marker) return;

		var previousMarker = self.previousMarker,
			block = marker.block;

		// If the previous marker hasn't been finalized, convert back to text block.
		if (previousMarker) {

			var previousBlock = previousMarker.block,
				finalize = (previousMarker.trigger || {}).finalize;

			if (previousBlock && finalize && !previousMarker.finalized && previousBlock!==block) {
				try {
					previousMarker.toTextMarker();
				} catch(e) {
					self.previousMarker = null;
				}
			}
		}

		// If there is a change in the text content but the length of the
		// text content is the same length as before, it is impossible to
		// tell what has changed, so we replace the entire text in the marker
		// where the caret is at. This happens when:
		// - User holds a character + presses a number to select a
		//   character from the candidate window.
		// - User navigates between characters using arrow keys
		//   within the candidate window.
		//
		// The caretAfter could be earlier than the caretBefore when:
		// - User enters backspace to remove a character.
		// - User finalizes a selection from the candidate window where characters
		//   are shorter than being typed, e.g. "ni hao" --> "你好".

		if (!marker.br && (diff===0 || caretAfter.end < caretBefore.start)) {

			var textStart  = marker.start,
				textEnd    = marker.end - diff,
				rangeStart = caretAfter.end,
				rangeEnd   = caretBefore.start,
				replace    = textStart!==textEnd;

		 // If user is inserting text as usual.
		} else {

			// In Chrome, the caretAfter has a range if the user is typing within the
			// candidate window. The characters may change due to fuzzy logic suggestions.
			// You can test this by using Chinese pinyin input and typing "a" then
			// "asdasdasd" one at a time slowly until you see the difference.

			// So, we give prefential treatment to start positions which are earlier
			// whether it is coming from caretBefore or caretAfter.
			var rangeStart = textStart = Math.min(caretBefore.start, caretAfter.start),
				rangeEnd = caretBefore.end,
				textEnd = caretAfter.end;


		}

		// Extract text from the given start and end position
		var text = wholeText.substring(textStart, textEnd);

		// If the strategy is to replace a single marker
		if (replace) {

			// If text being replaced is not identical on
			// a finalized marker, then convert to text marker.
			if (marker.val() !== text && marker.finalized) {
				marker.toTextMarker();
			}

			marker.val(text);

			// Emulate markerInsert event
			self.overlay().trigger("markerInsert", [marker, [], text, textStart, textEnd]);

			self.normalize();

		// If the strategy is to insert chracters onto single/multiple markers
		} else {
			self.insert(text, rangeStart, rangeEnd);
		}

		// Ensure Opera follows the caretAfter behaviour of other
		// browsers when typing inside the candidate window.
		if (operaCandidateWindow) {
			caretAfter.start = caretAfter.end;
		}

		// Set caretBefore as current caret
		// This is used to track text range when exiting candidate window.
		self.caretBefore = self.caretAfter;
	},

	//--- Marker Events ----//

	"{overlay} markerInsert": function(overlay, event, marker, nodes, str, start, end) {

		var text = marker.text,
			wholeText = text.nodeValue,
			trigger;

		self.previousMarker = null;

		// Ensure the character before is a space, e.g.
		// we don't want to listen to @ in an email address.
		// or a # that is not intended to be a hashtag.
		// var charBefore = wholeText.charCodeAt(start - 1),
		// 	brBefore = marker.before && marker.before.br;
		var charBefore = wholeText.charCodeAt(start - 1),
			brBefore = marker.before && marker.before.br;

		// If a trigger key was entered
		if (trigger = self.getTrigger(str) && (charBefore === 32 || isNaN(charBefore))) {

			if (marker.index === 0 || (charBefore === 32 || brBefore)) {

				// Extract the remaining string after the trigger key
				// coding #js --> #js
				var remainingText = wholeText.slice(start),
					content = remainingText.slice(1);

				// If this trigger allows wrapping and
				// there are remaining characters to wrap.
				// *#js and*    --> *#js* and
				// *#js#foobar* --> *#js*#foobar
				if (trigger.wrap && remainingText.length > 1 && content.charCodeAt() != 32) {

					// Get stop position, add start offset and trigger key offset.
					end = self.getStopIndex(content, trigger.stop) + start + 1;

				// If trigger does not allow wrapping
				// *@foobar* --> *@*foobar
				} else {
					end = start + 1;
				}

				// Spawn a new marker from this string
				// and convert this marker into a block marker
				// *#*          --> [#]
				// *#js* and    --> [#js] and
				// *#js*#foobar --> [#js]#foobar
				// *@*foobar    --> [@]foobar
				var spawn = marker.spawn(start, end).toBlockMarker(),
					content = spawn.val().slice(1);

				// Update data
				var data = $(spawn.block).data("marker");
					data.value = content;
					data.trigger = trigger;

				self.previousMarker = spawn;

				// Trigger triggerCreate event
				self.trigger("triggerCreate", [spawn, trigger, content]);
			}
		}

		// If we're inside an existing block marker,
		// determine if we need to mutate the block.
		if (marker.block && !marker.br) {

			// If this marker is finalized, any changes to the
			// text content will convert it to a text marker.
			// [Jensen *#*Tonne] --> Jensen #Tonne
			// [Jensen Tonn`e`]  --> Jensen Tonn
			if (marker.finalized) {

				var length = marker.length;

				if (end < length - 1) marker.toTextMarker();

			} else {

				// Identify the trigger being used
				var key = wholeText.slice(0, 1),
					trigger = self.getTrigger(key);

				// If we could not identify the trigger, skip.
				if (!trigger) return;

				// Check for occurence of stop character
				var content = wholeText.slice(1),
					start = self.getStopIndex(content, trigger.stop) + 1,
					end = wholeText.length,
					spawn = false;

				// If the end position is shorter than content length
				if (start < end) {

					// Spawn out a new marker containing
					// the remaining text after the block marker.
					// [#foo* *bar] --> [#foo] bar
					spawn = marker.spawn(start, end);
				}

				// Trigger triggerChange event
				content = marker.val().slice(1);

				// Update data
				var data = $(marker.block).data("marker");
					data.value = content;
					data.trigger = trigger;

				self.previousMarker = marker;

				self.trigger("triggerChange", [marker, spawn, trigger, content]);
			}
		}
	},

	"{overlay} markerExit": function(overlay, event, marker, nodes, spawn, str, start, end) {

		var trigger = marker.trigger;

		if (!trigger) return;

		var allowSpace = trigger.allowSpace || marker.allowSpace,
			content = marker.val();

		if (!allowSpace && marker.val()===trigger.key) {
			marker.toTextMarker();
		}

		self.trigger("triggerExit", [marker, spawn, trigger, content]);
	}

	// Events available for use
	// "{overlay} markerRemove": function(overlay, event, marker) {},
	// "{overlay} markerConvert": function(overlay, event, marker, type) {},
	// "{overlay} markerExit": function(overlay, event, marker, nodes, str, start, end) {},
	// "{self} triggerCreate": function(el, event, marker, trigger, content) {},
	// "{self} triggerDestroy": function(el, event, marker) {},
	// "{self} triggerChange": function(el, event, marker, spawn, trigger) {},

	// TODO: Better support for cut & paste
	// "{textarea} beforecut": function() { console.log("BEFORECUT", arguments); },
	// "{textarea} beforepaste": function() { console.log("BEFOREPASTE", arguments); },
	// "{textarea} cut": function(el, event) { console.log("CUT", arguments); },
	// "{textarea} paste": function() { console.log("PASTE", arguments); }
}});

$.template("mentions/menu", '<div class="mentions-autocomplete" data-mentions-autocomplete><b><b></b></b><div class="mentions-autocomplete-inner" data-mentions-autocomplete-viewport><div class="mentions-autocomplete-loading" data-mentions-autocomplete-loading data-mentions-autocomplete-close></div><div class="mentions-autocomplete-empty" data-mentions-autocomplete-empty></div><div class="mentions-autocomplete-search" data-mentions-autocomplete-search></div><ul class="mentions-menu" data-mentions-menu></ul></div></div>');
$.template("mentions/menuItem", '<li class="mentions-menuItem" data-mentions-menuItem>[%== html %]</li>');
$.template("mentions/loadingHint", '<div class="mentions-autocomplete-loading-indicator"><div class="o-loader o-loader--top o-loader--sm is-active"></div></div>');
$.template("mentions/searchHint", '<span class="mentions-autocomplete-search-hint">Type a keyword to begin.</span>');
$.template("mentions/emptyHint", '<span class="mentions-autocomplete-empty-text">No items found.</span>');
/*
<div class="mentions-autocomplete" data-mentions-autocomplete>
	<b><b></b></b>
	<div class="mentions-autocomplete-inner" data-mentions-autocomplete-viewport>
		<div class="mentions-autocomplete-loading" data-mentions-autocomplete-loading></div>
		<div class="mentions-autocomplete-empty" data-mentions-autocomplete-empty></div>
		<div class="mentions-autocomplete-search" data-mentions-autocomplete-search></div>
		<ul class="mentions-menu" data-mentions-menu></ul>
	</div>
</div>
*/

$.Controller("Mentions.Autocomplete", {
	defaultOptions: {

		view: {
			menu: "mentions/menu",
			menuItem: "mentions/menuItem",
			searchHint: "mentions/searchHint",
			loadingHint: "mentions/loadingHint",
			emptyHint: "mentions/emptyHint"
		},

		id: "",
		component: "",
		modifier: "",
		shadow: false,
		sticky: false,
		animation: false,

		// This is the default query options
		// applied to all triggers unless
		// trigger override them.
		query: {
			data: null,
			cache: true,
			minLength: 1,
			limit: 10,
			highlight: true,
			caseSensitive: false,
			exclusive: false,
			searchHint: false,
			loadingHint: false,
			emptyHint: false,
			renderAll: false
		},

		position: {
			my: 'left top',
			at: 'left bottom',
			collision: 'none'
		},

		size: {
			width: "auto",
			height: "auto"
		},

		"{menu}": "[data-mentions-menu]",
		"{menuItem}": "[data-mentions-menuItem]",
		"{viewport}": "[data-mentions-autocomplete-viewport]",
		"{loadingHint}": "[data-mentions-autocomplete-loading]",
		"{emptyHint}": "[data-mentions-autocomplete-empty]",
		"{searchHint}": "[data-mentions-autocomplete-search]",
		"{closeButton}": "[data-mentions-autocomplete-close]"
	}
}, function(self, opts, base) { return {

	init: function() {

		// This doesn't need to be immediately initialized.
		// Shaves off about 20ms.
		setTimeout(function(){

			// Destroy controller
			if (!self.element.data(self.Class.fullName)) {

				self.destroy();

				// And reimplement on the context menu we created ourselves
				var menu =
				self.view.menu()
					.attr("id", opts.id)
					.addClass(opts.component)
					.addClass(opts.modifier)
					.addClass(opts.shadow ? 'has-shadow' : '')
					.addClass(opts.animation ? 'has-animation' : '')
					.addClass(opts.sticky ? 'is-sticky' : '')
					.appendTo("body")
					.data(self.Class.fullName, true)
					.addController(self.Class, opts);

				return;
			}

			var mentions = self.mentions;

			self.uid = $.uid();

			mentions.autocomplete = self;
			mentions.pluginInstances["autocomplete"] = self;

			// Set the position to be relative to the mentions
			if (!opts.position.of) {
				opts.position.of = self.mentions.element;
			}

			// Prepare this in advance to speed things up
			self.defaultSearchHint = self.view.searchHint().toHTML();
			self.defaultEmptyHint = self.view.emptyHint().toHTML();
			self.defaultLoadingHint = self.view.loadingHint().toHTML();

			// Only reattach element when autocomplete is needed.
			self.element.detach();

		}, 50);
	},

	setLayout: function() {

		if (!self.hidden) {

			var options = self.options,
				size = options.size,
				width = self.mentions.element.outerWidth(),
				height = "auto";

			if ($.isFunction(size.width)) {
				width = size.width(width);
			}

			if ($.isFunction(size.height)) {
				height = size.height(height);
			}

			self.element
				.css({
					opacity: 1,
					width: width
				})
				.position(self.options.position);

			setTimeout(function(){
				self.viewport()
					.addClass("active");
			}, 1);
		}
	},

	"{window} resize": $.debounce(function() {
		self.element.css("opacity", 0);
		self.setLayout();
	}, 250),

	"{window} scroll": $.debounce(function() {
		self.element.css("opacity", 0);
		self.setLayout();
	}, 250),

	"{window} dialogTransitionStart": function() {
		self.hidden = true;
		self.element.css("opacity", 0);
	},

	"{window} dialogTransitionEnd": function() {
		self.hidden = false;
		self.setLayout();
	},

	currentMarker: null,

	"{mentions} triggerCreate": function(el, event, marker, trigger, content) {

		self.populate(marker, trigger, content);

		self.currentMarker = marker;
	},

	"{mentions} triggerChange": function(el, event, marker, spawn, trigger, content) {

		self.populate(marker, trigger, content);

		self.currentMarker = marker;
	},

	"{mentions} triggerExit": function(el, event, marker, spawn, trigger, content) {

		// Abort any running query
		var query = self.activeQuery;
		if (query) {
			query.aborted = true;
		}

		self.hide();
	},

	"{mentions.block} triggerDestroy": function(el, event, marker) {

		self.hide();
	},

	"{mentions} triggerClear": function() {

		self.hide();
	},

	hidden: true,

	show: function(duration) {

		clearTimeout(self.sleep);

		self.element
			.appendTo("body")
			.show();

		self.hidden = false;

		self.viewport().removeClass("active");

		self.setLayout();

		// Hide autocomplete on click.
		var doc = $(document),
			hideOnClick = "click.mentions." + self.uid;

		doc
			.off(hideOnClick)
			.on(hideOnClick, function(event){

				// Collect list of bubbled elements
				var targets = $(event.target).parents().andSelf();

				// Don't hide autocomplete if user is clicking on itself
				if (targets.filter(base).length > 0) return;

				// Unbind hiding
				doc.off(hideOnClick);

				self.hide();
			});

		if (duration) {

			self.sleep = setTimeout(function(){

				self.hide();

			}, duration);
		}
	},

	hide: function() {

		self.element.hide();

		var menuItem = self.menuItem(),
			activeMenuItem = menuItem.filter(".active");

		if (activeMenuItem.length > 0) {
			self.lastItem = {
				// keyword: $.trim(self.textboxlist.textField().val()),
				keyword: "", // TODO: Port this
				item   : activeMenuItem.data("item")
			};
		}

		self.viewport().removeClass("active");

		menuItem.removeClass("active");

		self.render.reset();

		self.hidden = true;

		// Clear any previous sleep timer first
		clearTimeout(self.sleep);

		// If no activity within 3000 seconds, detach myself.
		self.sleep = setTimeout(function(){
			self.element.detach();
		}, 3000);
	},

	query: function(options) {

		if (!options) return;

		// If options passed in is not an object
		var query = $.extend(
				{},
				self.options.query,
				($.isPlainObject(options) ? options : {data: options})
			),
			data = query.data;

		if (!data) return;

		// Query URL
		if ($.isUrl(data)) {
			var url = data;
			query.lookup = function() {
				return $.ajax(url + query.keyword);
			}
		}

		// Query function
		if ($.isFunction(data)) {
			var func = data;
			query.lookup = function() {
				return func.call(self, query.keyword);
			}
		}

		// Query dataset
		if ($.isArray(data)) {

			var dataset = data;
			query.lookup = function() {

				var task = $.Deferred(),
					keyword = query.keyword.toLowerCase();

				// Fork this process
				// so it won't choke on large dataset.
				setTimeout(function(){
					var result = $.grep(dataset, function(item){
						return item.title.toLowerCase().indexOf(keyword) > -1;
					});
					task.resolve(result);
				}, 0);

				return task;
			}
		}

		return query;
	},

	tasks: {},

	delayTask: null,

	activeQuery: null,

	renderAllItems: function(query, marker, trigger, keyword) {
		// Get mentions
		var mentions = self.mentions,
			autocomplete = self,
			element = self.element,
			menu = self.menu(),
			qkeyword = query.keyword;

			// Clear out menu items
			menu.empty();

			$.each(query.data, function(i, item){

				// Trigger menuCreateItem
				mentions.trigger("menuCreateItem", [item, query, autocomplete, mentions]);

				// If the item is not an object,
				// or item should be discarded, stop.
				if (!$.isPlainObject(item) || item.discard) return;

				var html = item.menuHtml || item.title;

				self.view.menuItem({html: html})
					.data("item", item)
					.appendTo(menu);
			});

			menu.data("keyword", qkeyword);

			// Get menu Items
			var menuItems = self.menuItem();

			// Trigger menuCreate event
			mentions.trigger("menuCreate", [menu, menuItems, query, autocomplete, mentions]);

			// If menu is empty, toggle empty classname
			if (menuItems.filter(":not(.hidden)").length < 1) {

				element.addClass("empty");

				// If we shouldn't show an empty hint
				if (!query.emptyHint) {

					// Hide menu straightaway
					return self.hide();
				}
			}

			// If we only allow adding item from suggestions
			if (query.exclusive) {

				// Automatically select the first item
				self.menuItem(":not(.hidden):first").addClass("active");
			}

			// Trigger renderMenu event
			mentions.trigger("renderMenu", [menu, query, autocomplete, mentions]);

			self.show();

			// Set current query as active query
			self.activeQuery = query;

			// Store data in query
			query.keyword = keyword;
			query.trigger = trigger;
			query.marker  = marker;

			// Trigger queryPrepare event
			// for event handlers to modify the query object.
			self.trigger("queryPrepare", [query]);

			// If no keyword given or keyword doesn't meet minimum query length, stop.
			var keyword = query.keyword;

			// Create a query id for this task based on the keyword
			// and retrieve existing query task for this keyword.
			var id    = query.id = trigger.key + "|" + (query.caseSensitive) ? keyword : keyword.toLowerCase(),
				tasks = self.tasks,
				task  = query.task = tasks[id],

				// This function runs the query task
				// We wrap it in a function because we may
				// want to debounce running of this task.
				runTask = function(){

					// Trigger keywordBeforeQuery event
					// If the event was prevented, don't query the keyword.
					var event = self.trigger("queryBeforeStart", [query]);
					if (event.isDefaultPrevented()) return;

					task = tasks[id] = query.task = query.lookup();

					// Trigger query event
					self.trigger("queryStart", [query]);
				};

			clearTimeout(self.delayTask);
			self.delayTask = setTimeout(runTask, 250);
	},

	populate: function(marker, trigger, keyword) {

		// var addclass = trigger.type == 'emoticon';
		// self.element.toggleClass('es-story-mentions-autocomplete-emoji', addclass);

		// Abort any running query
		var query = self.activeQuery;
		if (query) {
			query.aborted = true;
		}

		// Create query object
		var query = self.query(trigger.query);

		if (!query) return;

		// We try to simulate the render menu item for emoticons
		// so that it will load all emoticons when triggering the listing
		if (query.renderAll && keyword === "") {
			self.renderAllItems(query, marker, trigger, keyword);
			return;
		}

		// Set current query as active query
		self.activeQuery = query;

		// Store data in query
		query.keyword = keyword;
		query.trigger = trigger;
		query.marker  = marker;

		// Trigger queryPrepare event
		// for event handlers to modify the query object.
		self.trigger("queryPrepare", [query]);

		// If no keyword given or keyword doesn't meet minimum query length, stop.
		var keyword = query.keyword;

		if (keyword==="" || (keyword.length < query.minLength)) {

			var searchHint = query.searchHint;

			if (searchHint) {

				self.searchHint()
					.html(
						// If searchHint is a html string
						$.isString(searchHint) ?
							// use query-specific searchHint
							searchHint :
							// else use default searchHint
							self.defaultSearchHint
					);

				self.element.addClass("search");

				self.show();
			} else {
				self.hide();
			}
			return;
		}

		// Create a query id for this task based on the keyword
		// and retrieve existing query task for this keyword.
		var id    = query.id = trigger.key + "|" + (query.caseSensitive) ? keyword : keyword.toLowerCase(),
			tasks = self.tasks,
			task  = query.task = tasks[id],

			// Determine if this is a new or existing query task
			// If query caching is disabled, it will always be a new task.
			newTask = !$.isDeferred(task) || !query.cache,

			// This function runs the query task
			// We wrap it in a function because we may
			// want to debounce running of this task.
			runTask = function(){

				// Trigger keywordBeforeQuery event
				// If the event was prevented, don't query the keyword.
				var event = self.trigger("queryBeforeStart", [query]);
				if (event.isDefaultPrevented()) return;

				// Query the keyword if:
				// - The query hasn't been made.
				// - The query has been rejected.
				if (newTask || (!newTask && task.state()=="rejected")) {
					task = tasks[id] = query.task = query.lookup();
				}

				// When query lookup is done, render items;
				task.done(
					self.render(function(items){
						return [items, query];
					})
				);

				// Trigger query event
				self.trigger("queryStart", [query]);
			};

		// If this is a new query task
		// Don't run until we are sure that user has finished typing
		if (newTask) {

			clearTimeout(self.delayTask);
			self.delayTask = setTimeout(runTask, 250);

		// Else run it immediately
		} else {
			runTask();
		}
	},

	"{self} queryPrepare": function(el, event, query) {

		// Remove both loading & empty class
		el.removeClass("loading empty search");

		if (query.loadingHint) {
			self.hide();
		}
	},

	"{self} queryBeforeStart": function(el, event, query) {

		var loadingHint = query.loadingHint;

		// Show loading hint
		if (loadingHint) {

			self.loadingHint()
				.html(
					// If searchHint is a html string
					$.isString(loadingHint) ?
						// use query-specific loadingHint
						loadingHint :
						// else use default loadingHint
						self.defaultLoadingHint
				);

			el.addClass("loading");
			self.show();
		}
	},

	"{self} queryStart": function(el, event, query) {

		query.task
			.fail(function(){
				self.hide();
			})
			.always(function(){
				el.removeClass("loading");
			});
	},

	render: $.Enqueue(function(items, query){

		// If query has been aborted, hide menu and stop.
		if (query.aborted) {
			self.hide();
			return;
		}

		// If items passed in isn't an array,
		// fake an empty array.
		if (!$.isArray(items)) { items = [] };

		// Get mentions
		var mentions = self.mentions,
			autocomplete = self,
			element = self.element,
			menu = self.menu(),
			keyword = query.keyword;

		// If there are no items, hide menu.
		if (items.length < 1) {

			var emptyHint = query.emptyHint;

			// If we are supposed to show an empty hint
			if (emptyHint) {

				self.emptyHint()
					.html(
						// If searchHint is a html string
						$.isString(emptyHint) ?
							// use query-specific emptyHint
							emptyHint :
							// else use default emptyHint
							self.defaultEmptyHint
					);

				// Clear out menu
				menu.empty();

				// Add empty class
				element.addClass("empty");

				// Show menu for only 2 seconds
				self.show(2000);

			// Just hide straight away
			} else {

				self.hide();
			}

			// Trigger menuRender event
			mentions.trigger("menuRender", [menu, query, autocomplete, mentions]);

			return;
		}

		// Remove empty class
		element.removeClass("empty");

		// Generate menu items
		if (!query.cache || menu.data("keyword")!==keyword) {

			// Clear out menu items
			menu.empty();

			$.each(items, function(i, item){

				// Trigger menuCreateItem
				mentions.trigger("menuCreateItem", [item, query, autocomplete, mentions]);

				// If the item is not an object,
				// or item should be discarded, stop.
				if (!$.isPlainObject(item) || item.discard) return;

				var html = item.menuHtml || item.title;

				self.view.menuItem({html: html})
					.data("item", item)
					.appendTo(menu);
			});

			menu.data("keyword", keyword);
		}

		// Get menu Items
		var menuItems = self.menuItem();

		// Trigger menuCreate event
		mentions.trigger("menuCreate", [menu, menuItems, query, autocomplete, mentions]);

		// If menu is empty, toggle empty classname
		if (menuItems.filter(":not(.hidden)").length < 1) {

			element.addClass("empty");

			// If we shouldn't show an empty hint
			if (!query.emptyHint) {

				// Hide menu straightaway
				return self.hide();
			}
		}

		// If we only allow adding item from suggestions
		if (query.exclusive) {

			// Automatically select the first item
			self.menuItem(":not(.hidden):first").addClass("active");
		}

		// Trigger renderMenu event
		mentions.trigger("renderMenu", [menu, query, autocomplete, mentions]);

		self.show();
	}),

	"{mentions.textarea} keydown": function(textarea, event) {

		// Prevent autocomplete from falling asleep.
		clearTimeout(self.sleep);

		// Get active menu item
		var activeMenuItem = self.menuItem(".active:not(.hidden)");

		if (activeMenuItem.length < 1) {
			activeMenuItem = false;
		}

		switch (event.keyCode) {

			// If up key is pressed
			case KEYCODE.UP:

				// Deactivate all menu item
				self.menuItem().removeClass("active");

				// If no menu items are activated,
				if (!activeMenuItem) {

					// activate the last one.
					self.menuItem(":not(.hidden):last").addClass("active");

				// Else find the menu item before it,
				} else {

					// and activate it.
					activeMenuItem.prev(self.menuItem.selector + ':not(.hidden)')
						.addClass("active");
				}

				// Prevent up/down keys from changing textfield cursor position.
				if (!self.hidden) {
					event.preventDefault();
				}
				break;

			// If down key is pressed
			case KEYCODE.DOWN:

				// Deactivate all menu item
				self.menuItem().removeClass("active");

				// If no menu items are activated,
				if (!activeMenuItem) {

					// activate the first one.
					self.menuItem(":not(.hidden):first").addClass("active");

				// Else find the menu item after it,
				} else {

					// and activate it.
					activeMenuItem.next(self.menuItem.selector + ':not(.hidden)')
						.addClass("active");
				}

				// Prevent up/down keys from changing textfield cursor position.
				if (!self.hidden) {
					event.preventDefault();
				}
				break;

			// If escape is pressed,
			case KEYCODE.ESCAPE:

				// hide menu.
				self.hide();
				break;

			// If enter is pressed, use item
			case KEYCODE.ENTER:

				if (!self.hidden && activeMenuItem) {
					var item = activeMenuItem.data("item");

					self.use(item);
					event.preventDefault();
				}
				break;
		}

		// Get newly activated item
		var activeMenuItem = self.menuItem(".active:not(.hidden)");

		if (!self.hidden) {
			// Scroll menu viewport if it is out of visible area.
			self.viewport().scrollIntoView(activeMenuItem);
		}
	},

	"{menuItem} mouseup": function(menuItem) {

		// Hide context menu
		self.hide();

		// Add item
		var item = menuItem.data("item");

		self.use(item);

		// Refocus textarea
		setTimeout(function(){

			// Due to event delegation, this needs to be slightly delayed.
			self.mentions.textarea().focus();
		}, 150);
	},

	use: function(item) {

		// Get active query
		var query = self.activeQuery;

		// If there are no active query, stop.
		if (!query) return;

		var marker = query.marker,
			title = item.title;

		// Replace marker text
		marker.text.nodeValue = title;

		// delete item["menuHtml"];

		var value = item;

		if (query.use) {
			value = query.use(item);
		}

		// Finalize marker
		marker.finalize(value);

		// Replace textarea text
		self.mentions.textareaInsert(title, marker.start, marker.end);

		// Set caret position
		self.mentions.textarea().caret(marker.start + title.length);

		// Normalize is required so self.lengthBefore is correct.
		// Marker may run off when a user creates a block marker from
		// autocomplete, changes the cursor before/at the beginning of the
		// block marker, and presses backspace.
		self.mentions.normalize();

		// Quick hack to prevent repopulation
		self.hidden = true;

		self.hide();
	},

	"{menuItem} mouseover": function(menuItem) {

		self.menuItem().removeClass("active");

		menuItem.addClass("active");
	},

	"{menuItem} mouseout": function(menuItem) {

		self.menuItem().removeClass("active");
	},

	"{closeButton} click": function() {

		self.hide();
	},

	"{mentions} destroyed": function() {

		self.element.remove();
	}
}});


};

exports();
module.resolveWith(exports);

// module body: end

};
// module factory: end

FD40.module("mentions", moduleFactory);

}());
			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this;
var jQuery = $;
var exports = function() {

/*!
 * jQuery Mobile Events
 * by Ben Major
 *
 * Copyright 2011-2017, Ben Major
 * Licensed under the MIT License:
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 */

"use strict";

(function ($) {
	$.attrFn = $.attrFn || {};

	var touchCapable  = ('ontouchstart' in window),

		settings = {
			tap_pixel_range: 5,
			swipe_h_threshold: 50,
			swipe_v_threshold: 50,
			taphold_threshold: 750,
			doubletap_int: 500,
			shake_threshold: 15,

			touch_capable: touchCapable,
			orientation_support: ('orientation' in window && 'onorientationchange' in window),

			startevent:  (touchCapable) ? 'touchstart' : 'mousedown',
			endevent:    (touchCapable) ? 'touchend' : 'mouseup',
			moveevent:   (touchCapable) ? 'touchmove' : 'mousemove',
			tapevent:    (touchCapable) ? 'tap' : 'click',
			scrollevent: (touchCapable) ? 'touchmove' : 'scroll',

			hold_timer: null,
			tap_timer: null
		};

	// Declare touch namespace:
	$.touch = { };

	// Convenience functions:
	$.isTouchCapable = function() { return settings.touch_capable; };
	$.getStartEvent  = function() { return settings.startevent;    };
	$.getEndEvent    = function() { return settings.endevent;      };
	$.getMoveEvent   = function() { return settings.moveevent;     };
	$.getTapEvent    = function() { return settings.tapevent;      };
	$.getScrollEvent = function() { return settings.scrollevent;   };

	// SETTERS:
	// Set the X threshold of swipe events:
	$.touch.setSwipeThresholdX = function( threshold ) {
		if( typeof threshold !== 'number' ) { throw new Error('Threshold parameter must be a type of number'); }
		settings.swipe_h_threshold = threshold;
	};

	// Set the Y threshold of swipe events:
	$.touch.setSwipeThresholdY = function( threshold ) {
		if( typeof threshold !== 'number' ) { throw new Error('Threshold parameter must be a type of number'); }
		settings.swipe_v_threshold = threshold;
	};

	// Set the double tap interval:
	$.touch.setDoubleTapInt    = function( interval ) {
		if( typeof interval !== 'number' ) { throw new Error('Interval parameter must be a type of number'); }
		settings.doubletap_int = interval;
	};

	// Set the taphold threshold:
	$.touch.setTapHoldThreshold = function( threshold ) {
		if( typeof threshold !== 'number' ) { throw new Error('Threshold parameter must be a type of number'); }
		settings.taphold_threshold = threshold;
	};

	// Set the pixel range for tapas:
	$.touch.setTapRange = function( range ) {
		if( typeof range !== 'number' ) { throw new Error('Ranger parameter must be a type of number'); }
		settings.tap_pixel_range = threshold;
	};

	// Add Event shortcuts:
	$.each(['tapstart', 'tapend', 'tapmove', 'tap', 'singletap', 'doubletap', 'taphold', 'swipe', 'swipeup', 'swiperight', 'swipedown', 'swipeleft', 'swipeend', 'scrollstart', 'scrollend', 'orientationchange', 'tap2', 'taphold2'], function (i, name) {
		$.fn[name] = function (fn) {
			return fn ? this.on(name, fn) : this.trigger(name);
		};

		$.attrFn[name] = true;
	});

	// tapstart Event:
	$.event.special.tapstart = {
		setup: function () {

			var thisObject = this,
				$this = $(thisObject);

			$this.on(settings.startevent, function tapStartFunc(e) {

				$this.data('callee', tapStartFunc);
				if (e.which && e.which !== 1) {
					return false;
				}

				var origEvent = e.originalEvent,
					touchData = {
						'position': {
							'x': ((settings.touch_capable) ? origEvent.touches[0].pageX : e.pageX),
							'y': (settings.touch_capable) ? origEvent.touches[0].pageY : e.pageY
						},
						'offset': {
							'x': (settings.touch_capable) ? Math.round(origEvent.changedTouches[0].pageX - ($this.offset() ? $this.offset().left : 0)) : Math.round(e.pageX - ($this.offset() ? $this.offset().left : 0)),
							'y': (settings.touch_capable) ? Math.round(origEvent.changedTouches[0].pageY - ($this.offset() ? $this.offset().top : 0)) : Math.round(e.pageY - ($this.offset() ? $this.offset().top : 0))
						},
						'time': Date.now(),
						'target': e.target
					};

				triggerCustomEvent(thisObject, 'tapstart', e, touchData);
				return true;
			});
		},

		remove: function () {
			$(this).off(settings.startevent, $(this).data.callee);
		}
	};

	// tapmove Event:
	$.event.special.tapmove = {
		setup: function() {
			var thisObject = this,
			$this = $(thisObject);

			$this.on(settings.moveevent, function tapMoveFunc(e) {
				$this.data('callee', tapMoveFunc);

				var origEvent = e.originalEvent,
					touchData = {
						'position': {
							'x': ((settings.touch_capable) ? origEvent.touches[0].pageX : e.pageX),
							'y': (settings.touch_capable) ? origEvent.touches[0].pageY : e.pageY
						},
						'offset': {
							'x': (settings.touch_capable) ? Math.round(origEvent.changedTouches[0].pageX - ($this.offset() ? $this.offset().left : 0)) : Math.round(e.pageX - ($this.offset() ? $this.offset().left : 0)),
							'y': (settings.touch_capable) ? Math.round(origEvent.changedTouches[0].pageY - ($this.offset() ? $this.offset().top : 0)) : Math.round(e.pageY - ($this.offset() ? $this.offset().top : 0))
						},
						'time': Date.now(),
						'target': e.target
					};

				triggerCustomEvent(thisObject, 'tapmove', e, touchData);
				return true;
			});
		},
		remove: function() {
			$(this).off(settings.moveevent, $(this).data.callee);
		}
	};

	// tapend Event:
	$.event.special.tapend = {
		setup: function () {
			var thisObject = this,
				$this = $(thisObject);

			$this.on(settings.endevent, function tapEndFunc(e) {
				// Touch event data:
				$this.data('callee', tapEndFunc);

				var origEvent = e.originalEvent;
				var touchData = {
					'position': {
						'x': (settings.touch_capable) ? origEvent.changedTouches[0].pageX : e.pageX,
						'y': (settings.touch_capable) ? origEvent.changedTouches[0].pageY : e.pageY
					},
					'offset': {
						'x': (settings.touch_capable) ? Math.round(origEvent.changedTouches[0].pageX - ($this.offset() ? $this.offset().left : 0)) : Math.round(e.pageX - ($this.offset() ? $this.offset().left : 0)),
						'y': (settings.touch_capable) ? Math.round(origEvent.changedTouches[0].pageY - ($this.offset() ? $this.offset().top : 0)) : Math.round(e.pageY - ($this.offset() ? $this.offset().top : 0))
					},
					'time': Date.now(),
					'target': e.target
				};
				triggerCustomEvent(thisObject, 'tapend', e, touchData);
				return true;
			});
		},
		remove: function () {
			$(this).off(settings.endevent, $(this).data.callee);
		}
	};

	// taphold Event:
	$.event.special.taphold = {
		setup: function () {
			var thisObject = this,
				$this = $(thisObject),
				origTarget,
				start_pos = {
					x: 0,
					y: 0
				},
				end_x = 0,
				end_y = 0;

			$this.on(settings.startevent, function tapHoldFunc1(e) {
				if (e.which && e.which !== 1) {
					return false;
				} else {
					$this.data('tapheld', false);
					origTarget = e.target;

					var origEvent = e.originalEvent;
					var start_time = Date.now(),
						startPosition = {
							'x': (settings.touch_capable) ? origEvent.touches[0].pageX : e.pageX,
							'y': (settings.touch_capable) ? origEvent.touches[0].pageY : e.pageY
						},
						startOffset = {
							'x': (settings.touch_capable) ? origEvent.touches[0].pageX - origEvent.touches[0].target.offsetLeft : e.offsetX,
							'y': (settings.touch_capable) ? origEvent.touches[0].pageY - origEvent.touches[0].target.offsetTop : e.offsetY
						};

					start_pos.x = (e.originalEvent.targetTouches) ? e.originalEvent.targetTouches[0].pageX : e.pageX;
					start_pos.y = (e.originalEvent.targetTouches) ? e.originalEvent.targetTouches[0].pageY : e.pageY;

					end_x = start_pos.x;
					end_y = start_pos.y;

					// Get the element's threshold:
					var ele_threshold = ($this.parent().data('threshold')) ? $this.parent().data('threshold') : $this.data('threshold'),
						threshold = (typeof ele_threshold !== 'undefined' && ele_threshold !== false && parseInt(ele_threshold)) ? parseInt(ele_threshold) : settings.taphold_threshold;

					settings.hold_timer = window.setTimeout(function () {

						var diff_x = (start_pos.x - end_x),
							diff_y = (start_pos.y - end_y);

						if (e.target == origTarget && ((start_pos.x == end_x && start_pos.y == end_y) || (diff_x >= -(settings.tap_pixel_range) && diff_x <= settings.tap_pixel_range && diff_y >= -(settings.tap_pixel_range) && diff_y <= settings.tap_pixel_range))) {
							$this.data('tapheld', true);

							var end_time = Date.now();

							var duration  = end_time - start_time,
								touches   = (e.originalEvent.targetTouches) ? e.originalEvent.targetTouches : [ e ],
								touchData = [ ];

							for( var i = 0; i < touches.length; i++)
							{
								var touch = {
									'position': {
										'x': (settings.touch_capable) ? origEvent.changedTouches[i].pageX : e.pageX,
										'y': (settings.touch_capable) ? origEvent.changedTouches[i].pageY : e.pageY
									},
									'offset': {
										'x': (settings.touch_capable) ? Math.round(origEvent.changedTouches[i].pageX - ($this.offset() ? $this.offset().left : 0)) : Math.round(e.pageX - ($this.offset() ? $this.offset().left : 0)),
										'y': (settings.touch_capable) ? Math.round(origEvent.changedTouches[i].pageY - ($this.offset() ? $this.offset().top : 0)) : Math.round(e.pageY - ($this.offset() ? $this.offset().top : 0))
									},
									'time': Date.now(),
									'target': e.target,
									'duration': duration
								};

								touchData.push( touch );
							}

							var evt_name = ( touches.length == 2 ) ? 'taphold2' : 'taphold';

							$this.data('callee1', tapHoldFunc1);

							triggerCustomEvent(thisObject, evt_name, e, touchData);
						}
					}, threshold);

					return true;
				}
			}).on(settings.endevent, function tapHoldFunc2() {
				$this.data('callee2', tapHoldFunc2);
				$this.data('tapheld', false);
				window.clearTimeout(settings.hold_timer);
			})
			.on(settings.moveevent, function tapHoldFunc3(e) {
				$this.data('callee3', tapHoldFunc3);

				end_x = (e.originalEvent.targetTouches) ? e.originalEvent.targetTouches[0].pageX : e.pageX;
				end_y = (e.originalEvent.targetTouches) ? e.originalEvent.targetTouches[0].pageY : e.pageY;
			});
		},

		remove: function () {
			$(this).off(settings.startevent, $(this).data.callee1).off(settings.endevent, $(this).data.callee2).off(settings.moveevent, $(this).data.callee3);
		}
	};

	// doubletap Event:
	$.event.special.doubletap = {
		setup: function () {
			var thisObject = this,
				$this = $(thisObject),
				origTarget,
				action,
				firstTap = null,
				origEvent,
				cooloff,
				cooling = false;

			$this.on(settings.startevent, function doubleTapFunc1(e) {
				if (e.which && e.which !== 1) {
					return false;
				}

				$this.data('doubletapped', false);
				origTarget = e.target;
				$this.data('callee1', doubleTapFunc1);

				origEvent = e.originalEvent;
				if (!firstTap) {
					firstTap = {
						'position': {
							'x': (settings.touch_capable) ? origEvent.touches[0].pageX : e.pageX,
							'y': (settings.touch_capable) ? origEvent.touches[0].pageY : e.pageY
						},
						'offset': {
							'x': (settings.touch_capable) ? Math.round(origEvent.changedTouches[0].pageX - ($this.offset() ? $this.offset().left : 0)) : Math.round(e.pageX - ($this.offset() ? $this.offset().left : 0)),
							'y': (settings.touch_capable) ? Math.round(origEvent.changedTouches[0].pageY - ($this.offset() ? $this.offset().top : 0)) : Math.round(e.pageY - ($this.offset() ? $this.offset().top : 0))
						},
						'time': Date.now(),
						'target': e.target,
						'element': e.originalEvent.srcElement,
						'index':   $(e.target).index()
					};
				}

				return true;
			}).on(settings.endevent, function doubleTapFunc2(e) {

				var now = Date.now();
				var lastTouch = $this.data('lastTouch') || now + 1;
				var delta = now - lastTouch;
				window.clearTimeout(action);
				$this.data('callee2', doubleTapFunc2);

				if (delta < settings.doubletap_int && ($(e.target).index() == firstTap.index) && delta > 100) {
					$this.data('doubletapped', true);
					window.clearTimeout(settings.tap_timer);

					// Now get the current event:
					var lastTap = {
						'position': {
							'x': (settings.touch_capable) ? e.originalEvent.changedTouches[0].pageX : e.pageX,
							'y': (settings.touch_capable) ? e.originalEvent.changedTouches[0].pageY : e.pageY
						},
						'offset': {
							'x': (settings.touch_capable) ? Math.round(origEvent.changedTouches[0].pageX - ($this.offset() ? $this.offset().left : 0)) : Math.round(e.pageX - ($this.offset() ? $this.offset().left : 0)),
							'y': (settings.touch_capable) ? Math.round(origEvent.changedTouches[0].pageY - ($this.offset() ? $this.offset().top : 0)) : Math.round(e.pageY - ($this.offset() ? $this.offset().top : 0))
						},
						'time': Date.now(),
						'target': e.target,
						'element': e.originalEvent.srcElement,
						'index': $(e.target).index()
					};

					var touchData = {
						'firstTap': firstTap,
						'secondTap': lastTap,
						'interval': lastTap.time - firstTap.time
					};

					if (!cooling) {
						triggerCustomEvent(thisObject, 'doubletap', e, touchData);
						firstTap = null;
					}

					cooling = true;

					cooloff = window.setTimeout(function () {
						cooling = false;
					}, settings.doubletap_int);

				} else {
					$this.data('lastTouch', now);
					action = window.setTimeout(function () {
						firstTap = null;
						window.clearTimeout(action);
					}, settings.doubletap_int, [e]);
				}
				$this.data('lastTouch', now);
			});
		},
		remove: function () {
			$(this).off(settings.startevent, $(this).data.callee1).off(settings.endevent, $(this).data.callee2);
		}
	};

	// singletap Event:
	// This is used in conjuction with doubletap when both events are needed on the same element
	$.event.special.singletap = {
		setup: function () {
			var thisObject = this,
				$this = $(thisObject),
				origTarget = null,
				startTime = null,
				start_pos = {
					x: 0,
					y: 0
				};

			$this.on(settings.startevent, function singleTapFunc1(e) {
				if (e.which && e.which !== 1) {
					return false;
				} else {
					startTime = Date.now();
					origTarget = e.target;
					$this.data('callee1', singleTapFunc1);

					// Get the start x and y position:
					start_pos.x = (e.originalEvent.targetTouches) ? e.originalEvent.targetTouches[0].pageX : e.pageX;
					start_pos.y = (e.originalEvent.targetTouches) ? e.originalEvent.targetTouches[0].pageY : e.pageY;

					return true;
				}
			}).on(settings.endevent, function singleTapFunc2(e) {
				$this.data('callee2', singleTapFunc2);
				if (e.target == origTarget) {

					// Get the end point:
					var end_pos_x = (e.originalEvent.changedTouches) ? e.originalEvent.changedTouches[0].pageX : e.pageX,
						end_pos_y = (e.originalEvent.changedTouches) ? e.originalEvent.changedTouches[0].pageY : e.pageY;

					// We need to check if it was a taphold:

					settings.tap_timer = window.setTimeout(function () {

						var diff_x = (start_pos.x - end_pos_x), diff_y = (start_pos.y - end_pos_y);

						if(!$this.data('doubletapped') && !$this.data('tapheld') && (((start_pos.x == end_pos_x) && (start_pos.y == end_pos_y)) || (diff_x >= -(settings.tap_pixel_range) && diff_x <= settings.tap_pixel_range && diff_y >= -(settings.tap_pixel_range) && diff_y <= settings.tap_pixel_range))) {

							var origEvent = e.originalEvent;
							var touchData = {
								'position': {
									'x': (settings.touch_capable) ? origEvent.changedTouches[0].pageX : e.pageX,
									'y': (settings.touch_capable) ? origEvent.changedTouches[0].pageY : e.pageY
								},
								'offset': {
									'x': (settings.touch_capable) ? Math.round(origEvent.changedTouches[0].pageX - ($this.offset() ? $this.offset().left : 0)) : Math.round(e.pageX - ($this.offset() ? $this.offset().left : 0)),
									'y': (settings.touch_capable) ? Math.round(origEvent.changedTouches[0].pageY - ($this.offset() ? $this.offset().top : 0)) : Math.round(e.pageY - ($this.offset() ? $this.offset().top : 0))
								},
								'time': Date.now(),
								'target': e.target
							};

							// Was it a taphold?
							if((touchData.time - startTime) < settings.taphold_threshold)
							{
								triggerCustomEvent(thisObject, 'singletap', e, touchData);
							}
						}
					}, settings.doubletap_int);
				}
			});
		},

		remove: function () {
			$(this).off(settings.startevent, $(this).data.callee1).off(settings.endevent, $(this).data.callee2);
		}
	};

	// tap Event:
	$.event.special.tap = {
		setup: function () {
			var thisObject = this,
				$this = $(thisObject),
				started = false,
				origTarget = null,
				start_time,
				start_pos = {
					x: 0,
					y: 0
				},
				touches;

			$this.on(settings.startevent, function tapFunc1(e) {
				$this.data('callee1', tapFunc1);

				if( e.which && e.which !== 1 )
				{
					return false;
				}
				else
				{
					started = true;
					start_pos.x = (e.originalEvent.targetTouches) ? e.originalEvent.targetTouches[0].pageX : e.pageX;
					start_pos.y = (e.originalEvent.targetTouches) ? e.originalEvent.targetTouches[0].pageY : e.pageY;
					start_time = Date.now();
					origTarget = e.target;

					touches = (e.originalEvent.targetTouches) ? e.originalEvent.targetTouches : [ e ];
					return true;
				}
			}).on(settings.endevent, function tapFunc2(e) {
				$this.data('callee2', tapFunc2);

				// Only trigger if they've started, and the target matches:
				var end_x = (e.originalEvent.targetTouches) ? e.originalEvent.changedTouches[0].pageX : e.pageX,
					end_y = (e.originalEvent.targetTouches) ? e.originalEvent.changedTouches[0].pageY : e.pageY,
					diff_x = (start_pos.x - end_x),
					diff_y = (start_pos.y - end_y),
					eventName;

				if (origTarget == e.target && started && ((Date.now() - start_time) < settings.taphold_threshold) && ((start_pos.x == end_x && start_pos.y == end_y) || (diff_x >= -(settings.tap_pixel_range) && diff_x <= settings.tap_pixel_range && diff_y >= -(settings.tap_pixel_range) && diff_y <= settings.tap_pixel_range))) {
					var origEvent = e.originalEvent;
					var touchData = [ ];

					for( var i = 0; i < touches.length; i++)
					{
						var touch = {
							'position': {
								'x': (settings.touch_capable) ? origEvent.changedTouches[i].pageX : e.pageX,
								'y': (settings.touch_capable) ? origEvent.changedTouches[i].pageY : e.pageY
							},
							'offset': {
								'x': (settings.touch_capable) ? Math.round(origEvent.changedTouches[i].pageX - ($this.offset() ? $this.offset().left : 0)) : Math.round(e.pageX - ($this.offset() ? $this.offset().left : 0)),
								'y': (settings.touch_capable) ? Math.round(origEvent.changedTouches[i].pageY - ($this.offset() ? $this.offset().top : 0)) : Math.round(e.pageY - ($this.offset() ? $this.offset().top : 0))
							},
							'time': Date.now(),
							'target': e.target
						};

						touchData.push( touch );
					}

					var evt_name = ( touches.length == 2 ) ? 'tap2' : 'tap';

					triggerCustomEvent(thisObject, evt_name, e, touchData);
				}
			});
		},

		remove: function () {
			$(this).off(settings.startevent, $(this).data.callee1).off(settings.endevent, $(this).data.callee2);
		}
	};

	// swipe Event (also handles swipeup, swiperight, swipedown and swipeleft):
	$.event.special.swipe = {
		setup: function () {
			var thisObject = this,
				$this = $(thisObject),
				started = false,
				hasSwiped = false,
				originalCoord = {
					x: 0,
					y: 0
				},
				finalCoord = {
					x: 0,
					y: 0
				},
				startEvnt;

			// Screen touched, store the original coordinate

			function touchStart(e) {
				$this = $(e.currentTarget);
				$this.data('callee1', touchStart);
				originalCoord.x = (e.originalEvent.targetTouches) ? e.originalEvent.targetTouches[0].pageX : e.pageX;
				originalCoord.y = (e.originalEvent.targetTouches) ? e.originalEvent.targetTouches[0].pageY : e.pageY;
				finalCoord.x = originalCoord.x;
				finalCoord.y = originalCoord.y;
				started = true;
				var origEvent = e.originalEvent;
				// Read event data into our startEvt:
				startEvnt = {
					'position': {
						'x': (settings.touch_capable) ? origEvent.touches[0].pageX : e.pageX,
						'y': (settings.touch_capable) ? origEvent.touches[0].pageY : e.pageY
					},
					'offset': {
						'x': (settings.touch_capable) ? Math.round(origEvent.changedTouches[0].pageX - ($this.offset() ? $this.offset().left : 0)) : Math.round(e.pageX - ($this.offset() ? $this.offset().left : 0)),
						'y': (settings.touch_capable) ? Math.round(origEvent.changedTouches[0].pageY - ($this.offset() ? $this.offset().top : 0)) : Math.round(e.pageY - ($this.offset() ? $this.offset().top : 0))
					},
					'time': Date.now(),
					'target': e.target
				};
			}

			// Store coordinates as finger is swiping

			function touchMove(e) {
				$this = $(e.currentTarget);
				$this.data('callee2', touchMove);
				finalCoord.x = (e.originalEvent.targetTouches) ? e.originalEvent.targetTouches[0].pageX : e.pageX;
				finalCoord.y = (e.originalEvent.targetTouches) ? e.originalEvent.targetTouches[0].pageY : e.pageY;

				var swipedir;

				// We need to check if the element to which the event was bound contains a data-xthreshold | data-vthreshold:
				var ele_x_threshold = ($this.parent().data('xthreshold')) ? $this.parent().data('xthreshold') : $this.data('xthreshold'),
					ele_y_threshold = ($this.parent().data('ythreshold')) ? $this.parent().data('ythreshold') : $this.data('ythreshold'),
					h_threshold = (typeof ele_x_threshold !== 'undefined' && ele_x_threshold !== false && parseInt(ele_x_threshold)) ? parseInt(ele_x_threshold) : settings.swipe_h_threshold,
					v_threshold = (typeof ele_y_threshold !== 'undefined' && ele_y_threshold !== false && parseInt(ele_y_threshold)) ? parseInt(ele_y_threshold) : settings.swipe_v_threshold;

				if (originalCoord.y > finalCoord.y && (originalCoord.y - finalCoord.y > v_threshold)) {
					swipedir = 'swipeup';
				}
				if (originalCoord.x < finalCoord.x && (finalCoord.x - originalCoord.x > h_threshold)) {
					swipedir = 'swiperight';
				}
				if (originalCoord.y < finalCoord.y && (finalCoord.y - originalCoord.y > v_threshold)) {
					swipedir = 'swipedown';
				}
				if (originalCoord.x > finalCoord.x && (originalCoord.x - finalCoord.x > h_threshold)) {
					swipedir = 'swipeleft';
				}
				if (swipedir != undefined && started) {
					originalCoord.x = 0;
					originalCoord.y = 0;
					finalCoord.x = 0;
					finalCoord.y = 0;
					started = false;

					// Read event data into our endEvnt:
					var origEvent = e.originalEvent;
					var endEvnt = {
						'position': {
							'x': (settings.touch_capable) ? origEvent.touches[0].pageX : e.pageX,
							'y': (settings.touch_capable) ? origEvent.touches[0].pageY : e.pageY
						},
						'offset': {
							'x': (settings.touch_capable) ? Math.round(origEvent.changedTouches[0].pageX - ($this.offset() ? $this.offset().left : 0)) : Math.round(e.pageX - ($this.offset() ? $this.offset().left : 0)),
							'y': (settings.touch_capable) ? Math.round(origEvent.changedTouches[0].pageY - ($this.offset() ? $this.offset().top : 0)) : Math.round(e.pageY - ($this.offset() ? $this.offset().top : 0))
						},
						'time': Date.now(),
						'target': e.target
					};

					// Calculate the swipe amount (normalized):
					var xAmount = Math.abs(startEvnt.position.x - endEvnt.position.x),
						yAmount = Math.abs(startEvnt.position.y - endEvnt.position.y);

					var touchData = {
						'startEvnt': startEvnt,
						'endEvnt': endEvnt,
						'direction': swipedir.replace('swipe', ''),
						'xAmount': xAmount,
						'yAmount': yAmount,
						'duration': endEvnt.time - startEvnt.time
					};
					hasSwiped = true;
					$this.trigger('swipe', touchData).trigger(swipedir, touchData);
				}
			}

			function touchEnd(e) {
				$this = $(e.currentTarget);
				var swipedir = "";
				$this.data('callee3', touchEnd);
				if (hasSwiped) {
					// We need to check if the element to which the event was bound contains a data-xthreshold | data-vthreshold:
					var ele_x_threshold = $this.data('xthreshold'),
						ele_y_threshold = $this.data('ythreshold'),
						h_threshold = (typeof ele_x_threshold !== 'undefined' && ele_x_threshold !== false && parseInt(ele_x_threshold)) ? parseInt(ele_x_threshold) : settings.swipe_h_threshold,
						v_threshold = (typeof ele_y_threshold !== 'undefined' && ele_y_threshold !== false && parseInt(ele_y_threshold)) ? parseInt(ele_y_threshold) : settings.swipe_v_threshold;

					var origEvent = e.originalEvent;
					var endEvnt = {
						'position': {
							'x': (settings.touch_capable) ? origEvent.changedTouches[0].pageX : e.pageX,
							'y': (settings.touch_capable) ? origEvent.changedTouches[0].pageY : e.pageY
						},
						'offset': {
							'x': (settings.touch_capable) ? Math.round(origEvent.changedTouches[0].pageX - ($this.offset() ? $this.offset().left : 0)) : Math.round(e.pageX - ($this.offset() ? $this.offset().left : 0)),
							'y': (settings.touch_capable) ? Math.round(origEvent.changedTouches[0].pageY - ($this.offset() ? $this.offset().top : 0)) : Math.round(e.pageY - ($this.offset() ? $this.offset().top : 0))
						},
						'time': Date.now(),
						'target': e.target
					};

					// Read event data into our endEvnt:
					if (startEvnt.position.y > endEvnt.position.y && (startEvnt.position.y - endEvnt.position.y > v_threshold)) {
						swipedir = 'swipeup';
					}
					if (startEvnt.position.x < endEvnt.position.x && (endEvnt.position.x - startEvnt.position.x > h_threshold)) {
						swipedir = 'swiperight';
					}
					if (startEvnt.position.y < endEvnt.position.y && (endEvnt.position.y - startEvnt.position.y > v_threshold)) {
						swipedir = 'swipedown';
					}
					if (startEvnt.position.x > endEvnt.position.x && (startEvnt.position.x - endEvnt.position.x > h_threshold)) {
						swipedir = 'swipeleft';
					}

					// Calculate the swipe amount (normalized):
					var xAmount = Math.abs(startEvnt.position.x - endEvnt.position.x),
						yAmount = Math.abs(startEvnt.position.y - endEvnt.position.y);

					var touchData = {
						'startEvnt': startEvnt,
						'endEvnt': endEvnt,
						'direction': swipedir.replace('swipe', ''),
						'xAmount': xAmount,
						'yAmount': yAmount,
						'duration': endEvnt.time - startEvnt.time
					};
					$this.trigger('swipeend', touchData);
				}

				started = false;
				hasSwiped = false;
			}

			$this.on(settings.startevent, touchStart);
			$this.on(settings.moveevent, touchMove);
			$this.on(settings.endevent, touchEnd);
		},

		remove: function () {
			$(this).off(settings.startevent, $(this).data.callee1).off(settings.moveevent, $(this).data.callee2).off(settings.endevent, $(this).data.callee3);
		}
	};

	// scrollstart Event (also handles scrollend):
	$.event.special.scrollstart = {
		setup: function () {
			var thisObject = this,
				$this = $(thisObject),
				scrolling,
				timer;

			function trigger(event, state) {
				scrolling = state;
				triggerCustomEvent(thisObject, scrolling ? 'scrollstart' : 'scrollend', event);
			}

			// iPhone triggers scroll after a small delay; use touchmove instead
			$this.on(settings.scrollevent, function scrollFunc(event) {
				$this.data('callee', scrollFunc);

				if (!scrolling) {
					trigger(event, true);
				}

				clearTimeout(timer);
				timer = setTimeout(function () {
					trigger(event, false);
				}, 50);
			});
		},

		remove: function () {
			$(this).off(settings.scrollevent, $(this).data.callee);
		}
	};

	// This is the orientation change (largely borrowed from jQuery Mobile):
	var win = $(window),
		special_event,
		get_orientation,
		last_orientation,
		initial_orientation_is_landscape,
		initial_orientation_is_default,
		portrait_map = {
			'0': true,
			'180': true
		};

	if (settings.orientation_support) {
		var ww = window.innerWidth || win.width(),
			wh = window.innerHeight || win.height(),
			landscape_threshold = 50;

		initial_orientation_is_landscape = ww > wh && (ww - wh) > landscape_threshold;
		initial_orientation_is_default = portrait_map[window.orientation];

		if ((initial_orientation_is_landscape && initial_orientation_is_default) || (!initial_orientation_is_landscape && !initial_orientation_is_default)) {
			portrait_map = {
				'-90': true,
				'90': true
			};
		}
	}

	$.event.special.orientationchange = special_event = {
		setup: function () {
			// If the event is supported natively, return false so that jQuery
			// will on to the event using DOM methods.
			if (settings.orientation_support) {
				return false;
			}

			// Get the current orientation to avoid initial double-triggering.
			last_orientation = get_orientation();

			win.on('throttledresize', handler);
			return true;
		},
		teardown: function () {
			if (settings.orientation_support) {
				return false;
			}

			win.off('throttledresize', handler);
			return true;
		},
		add: function (handleObj) {
			// Save a reference to the bound event handler.
			var old_handler = handleObj.handler;

			handleObj.handler = function (event) {
				event.orientation = get_orientation();
				return old_handler.apply(this, arguments);
			};
		}
	};

	// If the event is not supported natively, this handler will be bound to
	// the window resize event to simulate the orientationchange event.

	function handler() {
		// Get the current orientation.
		var orientation = get_orientation();

		if (orientation !== last_orientation) {
			// The orientation has changed, so trigger the orientationchange event.
			last_orientation = orientation;
			win.trigger("orientationchange");
		}
	}

	$.event.special.orientationchange.orientation = get_orientation = function () {
		var isPortrait = true,
			elem = document.documentElement;

		if (settings.orientation_support) {
			isPortrait = portrait_map[window.orientation];
		} else {
			isPortrait = elem && elem.clientWidth / elem.clientHeight < 1.1;
		}

		return isPortrait ? 'portrait' : 'landscape';
	};

	// throttle Handler:
	$.event.special.throttledresize = {
		setup: function () {
			$(this).on('resize', throttle_handler);
		},
		teardown: function () {
			$(this).off('resize', throttle_handler);
		}
	};

	var throttle = 250,
		throttle_handler = function () {
			curr = Date.now();
			diff = curr - lastCall;

			if (diff >= throttle) {
				lastCall = curr;
				$(this).trigger('throttledresize');

			} else {
				if (heldCall) {
					window.clearTimeout(heldCall);
				}

				// Promise a held call will still execute
				heldCall = window.setTimeout(handler, throttle - diff);
			}
		},
		lastCall = 0,
		heldCall,
		curr,
		diff;

	// Trigger a custom event:

	function triggerCustomEvent(obj, eventType, event, touchData) {
		var originalType = event.type;
		event.type = eventType;

		$.event.dispatch.call(obj, event, touchData);
		event.type = originalType;
	}

	// Correctly on anything we've overloaded:
	$.each({
		scrollend: 'scrollstart',
		swipeup: 'swipe',
		swiperight: 'swipe',
		swipedown: 'swipe',
		swipeleft: 'swipe',
		swipeend: 'swipe',
		tap2:     'tap',
		taphold2: 'taphold'
	}, function (e, srcE) {
		$.event.special[e] = {
			setup: function () {
				$(this).on(srcE, $.noop);
			}
		};
	});

}(jQuery))};

exports();
module.resolveWith(exports);

// module body: end

};
// module factory: end

FD40.module("mobile-events", moduleFactory);

}());
			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var exports = function() { 

//! moment.js
//! version : 2.6.0
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

(function (undefined) {

    /************************************
        Constants
    ************************************/

    var moment,
        VERSION = "2.6.0",
        // the global-scope this is NOT the global object in Node.js
        globalScope = typeof global !== 'undefined' ? global : this,
        oldGlobalMoment,
        round = Math.round,
        i,

        YEAR = 0,
        MONTH = 1,
        DATE = 2,
        HOUR = 3,
        MINUTE = 4,
        SECOND = 5,
        MILLISECOND = 6,

        // internal storage for language config files
        languages = {},

        // moment internal properties
        momentProperties = {
            _isAMomentObject: null,
            _i : null,
            _f : null,
            _l : null,
            _strict : null,
            _isUTC : null,
            _offset : null,  // optional. Combine with _isUTC
            _pf : null,
            _lang : null  // optional
        },

        // check for nodeJS
        hasModule = (typeof module !== 'undefined' && module.exports),

        // ASP.NET json date format regex
        aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,
        aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,

        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
        isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,

        // format tokens
        formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|X|zz?|ZZ?|.)/g,
        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LT|LL?L?L?|l{1,4})/g,

        // parsing token regexes
        parseTokenOneOrTwoDigits = /\d\d?/, // 0 - 99
        parseTokenOneToThreeDigits = /\d{1,3}/, // 0 - 999
        parseTokenOneToFourDigits = /\d{1,4}/, // 0 - 9999
        parseTokenOneToSixDigits = /[+\-]?\d{1,6}/, // -999,999 - 999,999
        parseTokenDigits = /\d+/, // nonzero number of digits
        parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, // any word (or two) characters or numbers including two/three word month in arabic.
        parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
        parseTokenT = /T/i, // T (ISO separator)
        parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
        parseTokenOrdinal = /\d{1,2}/,

        //strict parsing regexes
        parseTokenOneDigit = /\d/, // 0 - 9
        parseTokenTwoDigits = /\d\d/, // 00 - 99
        parseTokenThreeDigits = /\d{3}/, // 000 - 999
        parseTokenFourDigits = /\d{4}/, // 0000 - 9999
        parseTokenSixDigits = /[+-]?\d{6}/, // -999,999 - 999,999
        parseTokenSignedNumber = /[+-]?\d+/, // -inf - inf

        // iso 8601 regex
        // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
        isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,

        isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',

        isoDates = [
            ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
            ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
            ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
            ['GGGG-[W]WW', /\d{4}-W\d{2}/],
            ['YYYY-DDD', /\d{4}-\d{3}/]
        ],

        // iso time formats and regexes
        isoTimes = [
            ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/],
            ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
            ['HH:mm', /(T| )\d\d:\d\d/],
            ['HH', /(T| )\d\d/]
        ],

        // timezone chunker "+10:00" > ["10", "00"] or "-1530" > ["-15", "30"]
        parseTimezoneChunker = /([\+\-]|\d\d)/gi,

        // getter and setter names
        proxyGettersAndSetters = 'Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),
        unitMillisecondFactors = {
            'Milliseconds' : 1,
            'Seconds' : 1e3,
            'Minutes' : 6e4,
            'Hours' : 36e5,
            'Days' : 864e5,
            'Months' : 2592e6,
            'Years' : 31536e6
        },

        unitAliases = {
            ms : 'millisecond',
            s : 'second',
            m : 'minute',
            h : 'hour',
            d : 'day',
            D : 'date',
            w : 'week',
            W : 'isoWeek',
            M : 'month',
            Q : 'quarter',
            y : 'year',
            DDD : 'dayOfYear',
            e : 'weekday',
            E : 'isoWeekday',
            gg: 'weekYear',
            GG: 'isoWeekYear'
        },

        camelFunctions = {
            dayofyear : 'dayOfYear',
            isoweekday : 'isoWeekday',
            isoweek : 'isoWeek',
            weekyear : 'weekYear',
            isoweekyear : 'isoWeekYear'
        },

        // format function strings
        formatFunctions = {},

        // tokens to ordinalize and pad
        ordinalizeTokens = 'DDD w W M D d'.split(' '),
        paddedTokens = 'M D H h m s w W'.split(' '),

        formatTokenFunctions = {
            M    : function () {
                return this.month() + 1;
            },
            MMM  : function (format) {
                return this.lang().monthsShort(this, format);
            },
            MMMM : function (format) {
                return this.lang().months(this, format);
            },
            D    : function () {
                return this.date();
            },
            DDD  : function () {
                return this.dayOfYear();
            },
            d    : function () {
                return this.day();
            },
            dd   : function (format) {
                return this.lang().weekdaysMin(this, format);
            },
            ddd  : function (format) {
                return this.lang().weekdaysShort(this, format);
            },
            dddd : function (format) {
                return this.lang().weekdays(this, format);
            },
            w    : function () {
                return this.week();
            },
            W    : function () {
                return this.isoWeek();
            },
            YY   : function () {
                return leftZeroFill(this.year() % 100, 2);
            },
            YYYY : function () {
                return leftZeroFill(this.year(), 4);
            },
            YYYYY : function () {
                return leftZeroFill(this.year(), 5);
            },
            YYYYYY : function () {
                var y = this.year(), sign = y >= 0 ? '+' : '-';
                return sign + leftZeroFill(Math.abs(y), 6);
            },
            gg   : function () {
                return leftZeroFill(this.weekYear() % 100, 2);
            },
            gggg : function () {
                return leftZeroFill(this.weekYear(), 4);
            },
            ggggg : function () {
                return leftZeroFill(this.weekYear(), 5);
            },
            GG   : function () {
                return leftZeroFill(this.isoWeekYear() % 100, 2);
            },
            GGGG : function () {
                return leftZeroFill(this.isoWeekYear(), 4);
            },
            GGGGG : function () {
                return leftZeroFill(this.isoWeekYear(), 5);
            },
            e : function () {
                return this.weekday();
            },
            E : function () {
                return this.isoWeekday();
            },
            a    : function () {
                return this.lang().meridiem(this.hours(), this.minutes(), true);
            },
            A    : function () {
                return this.lang().meridiem(this.hours(), this.minutes(), false);
            },
            H    : function () {
                return this.hours();
            },
            h    : function () {
                return this.hours() % 12 || 12;
            },
            m    : function () {
                return this.minutes();
            },
            s    : function () {
                return this.seconds();
            },
            S    : function () {
                return toInt(this.milliseconds() / 100);
            },
            SS   : function () {
                return leftZeroFill(toInt(this.milliseconds() / 10), 2);
            },
            SSS  : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            SSSS : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            Z    : function () {
                var a = -this.zone(),
                    b = "+";
                if (a < 0) {
                    a = -a;
                    b = "-";
                }
                return b + leftZeroFill(toInt(a / 60), 2) + ":" + leftZeroFill(toInt(a) % 60, 2);
            },
            ZZ   : function () {
                var a = -this.zone(),
                    b = "+";
                if (a < 0) {
                    a = -a;
                    b = "-";
                }
                return b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2);
            },
            z : function () {
                return this.zoneAbbr();
            },
            zz : function () {
                return this.zoneName();
            },
            X    : function () {
                return this.unix();
            },
            Q : function () {
                return this.quarter();
            }
        },

        lists = ['months', 'monthsShort', 'weekdays', 'weekdaysShort', 'weekdaysMin'];

    function defaultParsingFlags() {
        // We need to deep clone this object, and es5 standard is not very
        // helpful.
        return {
            empty : false,
            unusedTokens : [],
            unusedInput : [],
            overflow : -2,
            charsLeftOver : 0,
            nullInput : false,
            invalidMonth : null,
            invalidFormat : false,
            userInvalidated : false,
            iso: false
        };
    }

    function deprecate(msg, fn) {
        var firstTime = true;
        function printMsg() {
            if (moment.suppressDeprecationWarnings === false &&
                    typeof console !== 'undefined' && console.warn) {
                console.warn("Deprecation warning: " + msg);
            }
        }
        return extend(function () {
            if (firstTime) {
                printMsg();
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    function padToken(func, count) {
        return function (a) {
            return leftZeroFill(func.call(this, a), count);
        };
    }
    function ordinalizeToken(func, period) {
        return function (a) {
            return this.lang().ordinal(func.call(this, a), period);
        };
    }

    while (ordinalizeTokens.length) {
        i = ordinalizeTokens.pop();
        formatTokenFunctions[i + 'o'] = ordinalizeToken(formatTokenFunctions[i], i);
    }
    while (paddedTokens.length) {
        i = paddedTokens.pop();
        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
    }
    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);


    /************************************
        Constructors
    ************************************/

    function Language() {

    }

    // Moment prototype object
    function Moment(config) {
        checkOverflow(config);
        extend(this, config);
    }

    // Duration Constructor
    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 36e5; // 1000 * 60 * 60
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._bubble();
    }

    /************************************
        Helpers
    ************************************/


    function extend(a, b) {
        for (var i in b) {
            if (b.hasOwnProperty(i)) {
                a[i] = b[i];
            }
        }

        if (b.hasOwnProperty("toString")) {
            a.toString = b.toString;
        }

        if (b.hasOwnProperty("valueOf")) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function cloneMoment(m) {
        var result = {}, i;
        for (i in m) {
            if (m.hasOwnProperty(i) && momentProperties.hasOwnProperty(i)) {
                result[i] = m[i];
            }
        }

        return result;
    }

    function absRound(number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    // left zero fill a number
    // see http://jsperf.com/left-zero-filling for performance comparison
    function leftZeroFill(number, targetLength, forceSign) {
        var output = '' + Math.abs(number),
            sign = number >= 0;

        while (output.length < targetLength) {
            output = '0' + output;
        }
        return (sign ? (forceSign ? '+' : '') : '-') + output;
    }

    // helper function for _.addTime and _.subtractTime
    function addOrSubtractDurationFromMoment(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = duration._days,
            months = duration._months;
        updateOffset = updateOffset == null ? true : updateOffset;

        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        if (days) {
            rawSetter(mom, 'Date', rawGetter(mom, 'Date') + days * isAdding);
        }
        if (months) {
            rawMonthSetter(mom, rawGetter(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
            moment.updateOffset(mom, days || months);
        }
    }

    // check if is an array
    function isArray(input) {
        return Object.prototype.toString.call(input) === '[object Array]';
    }

    function isDate(input) {
        return  Object.prototype.toString.call(input) === '[object Date]' ||
                input instanceof Date;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function normalizeUnits(units) {
        if (units) {
            var lowered = units.toLowerCase().replace(/(.)s$/, '$1');
            units = unitAliases[units] || camelFunctions[lowered] || lowered;
        }
        return units;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (inputObject.hasOwnProperty(prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    function makeList(field) {
        var count, setter;

        if (field.indexOf('week') === 0) {
            count = 7;
            setter = 'day';
        }
        else if (field.indexOf('month') === 0) {
            count = 12;
            setter = 'month';
        }
        else {
            return;
        }

        moment[field] = function (format, index) {
            var i, getter,
                method = moment.fn._lang[field],
                results = [];

            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            getter = function (i) {
                var m = moment().utc().set(setter, i);
                return method.call(moment.fn._lang, m, format || '');
            };

            if (index != null) {
                return getter(index);
            }
            else {
                for (i = 0; i < count; i++) {
                    results.push(getter(i));
                }
                return results;
            }
        };
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            if (coercedNumber >= 0) {
                value = Math.floor(coercedNumber);
            } else {
                value = Math.ceil(coercedNumber);
            }
        }

        return value;
    }

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    function weeksInYear(year, dow, doy) {
        return weekOfYear(moment([year, 11, 31 + dow - doy]), dow, doy).week;
    }

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    function checkOverflow(m) {
        var overflow;
        if (m._a && m._pf.overflow === -2) {
            overflow =
                m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH :
                m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE :
                m._a[HOUR] < 0 || m._a[HOUR] > 23 ? HOUR :
                m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE :
                m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND :
                m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }

            m._pf.overflow = overflow;
        }
    }

    function isValid(m) {
        if (m._isValid == null) {
            m._isValid = !isNaN(m._d.getTime()) &&
                m._pf.overflow < 0 &&
                !m._pf.empty &&
                !m._pf.invalidMonth &&
                !m._pf.nullInput &&
                !m._pf.invalidFormat &&
                !m._pf.userInvalidated;

            if (m._strict) {
                m._isValid = m._isValid &&
                    m._pf.charsLeftOver === 0 &&
                    m._pf.unusedTokens.length === 0;
            }
        }
        return m._isValid;
    }

    function normalizeLanguage(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function makeAs(input, model) {
        return model._isUTC ? moment(input).zone(model._offset || 0) :
            moment(input).local();
    }

    /************************************
        Languages
    ************************************/


    extend(Language.prototype, {

        set : function (config) {
            var prop, i;
            for (i in config) {
                prop = config[i];
                if (typeof prop === 'function') {
                    this[i] = prop;
                } else {
                    this['_' + i] = prop;
                }
            }
        },

        _months : "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        months : function (m) {
            return this._months[m.month()];
        },

        _monthsShort : "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        monthsShort : function (m) {
            return this._monthsShort[m.month()];
        },

        monthsParse : function (monthName) {
            var i, mom, regex;

            if (!this._monthsParse) {
                this._monthsParse = [];
            }

            for (i = 0; i < 12; i++) {
                // make the regex if we don't have it already
                if (!this._monthsParse[i]) {
                    mom = moment.utc([2000, i]);
                    regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                    this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._monthsParse[i].test(monthName)) {
                    return i;
                }
            }
        },

        _weekdays : "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdays : function (m) {
            return this._weekdays[m.day()];
        },

        _weekdaysShort : "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysShort : function (m) {
            return this._weekdaysShort[m.day()];
        },

        _weekdaysMin : "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        weekdaysMin : function (m) {
            return this._weekdaysMin[m.day()];
        },

        weekdaysParse : function (weekdayName) {
            var i, mom, regex;

            if (!this._weekdaysParse) {
                this._weekdaysParse = [];
            }

            for (i = 0; i < 7; i++) {
                // make the regex if we don't have it already
                if (!this._weekdaysParse[i]) {
                    mom = moment([2000, 1]).day(i);
                    regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                    this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._weekdaysParse[i].test(weekdayName)) {
                    return i;
                }
            }
        },

        _longDateFormat : {
            LT : "h:mm A",
            L : "MM/DD/YYYY",
            LL : "MMMM D YYYY",
            LLL : "MMMM D YYYY LT",
            LLLL : "dddd, MMMM D YYYY LT"
        },
        longDateFormat : function (key) {
            var output = this._longDateFormat[key];
            if (!output && this._longDateFormat[key.toUpperCase()]) {
                output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {
                    return val.slice(1);
                });
                this._longDateFormat[key] = output;
            }
            return output;
        },

        isPM : function (input) {
            // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
            // Using charAt should be more compatible.
            return ((input + '').toLowerCase().charAt(0) === 'p');
        },

        _meridiemParse : /[ap]\.?m?\.?/i,
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'pm' : 'PM';
            } else {
                return isLower ? 'am' : 'AM';
            }
        },

        _calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        calendar : function (key, mom) {
            var output = this._calendar[key];
            return typeof output === 'function' ? output.apply(mom) : output;
        },

        _relativeTime : {
            future : "in %s",
            past : "%s ago",
            s : "a few seconds",
            m : "a minute",
            mm : "%d minutes",
            h : "an hour",
            hh : "%d hours",
            d : "a day",
            dd : "%d days",
            M : "a month",
            MM : "%d months",
            y : "a year",
            yy : "%d years"
        },
        relativeTime : function (number, withoutSuffix, string, isFuture) {
            var output = this._relativeTime[string];
            return (typeof output === 'function') ?
                output(number, withoutSuffix, string, isFuture) :
                output.replace(/%d/i, number);
        },
        pastFuture : function (diff, output) {
            var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
            return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
        },

        ordinal : function (number) {
            return this._ordinal.replace("%d", number);
        },
        _ordinal : "%d",

        preparse : function (string) {
            return string;
        },

        postformat : function (string) {
            return string;
        },

        week : function (mom) {
            return weekOfYear(mom, this._week.dow, this._week.doy).week;
        },

        _week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        },

        _invalidDate: 'Invalid date',
        invalidDate: function () {
            return this._invalidDate;
        }
    });

    // Loads a language definition into the `languages` cache.  The function
    // takes a key and optionally values.  If not in the browser and no values
    // are provided, it will load the language file module.  As a convenience,
    // this function also returns the language values.
    function loadLang(key, values) {
        values.abbr = key;
        if (!languages[key]) {
            languages[key] = new Language();
        }
        languages[key].set(values);
        return languages[key];
    }

    // Remove a language from the `languages` cache. Mostly useful in tests.
    function unloadLang(key) {
        delete languages[key];
    }

    // Determines which language definition to use and returns it.
    //
    // With no parameters, it will return the global language.  If you
    // pass in a language key, such as 'en', it will return the
    // definition for 'en', so long as 'en' has already been loaded using
    // moment.lang.
    function getLangDefinition(key) {
        var i = 0, j, lang, next, split,
            get = function (k) {
                if (!languages[k] && hasModule) {
                    try {
                        require('./lang/' + k);
                    } catch (e) { }
                }
                return languages[k];
            };

        if (!key) {
            return moment.fn._lang;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            lang = get(key);
            if (lang) {
                return lang;
            }
            key = [key];
        }

        //pick the language from the array
        //try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
        //substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
        while (i < key.length) {
            split = normalizeLanguage(key[i]).split('-');
            j = split.length;
            next = normalizeLanguage(key[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                lang = get(split.slice(0, j).join('-'));
                if (lang) {
                    return lang;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return moment.fn._lang;
    }

    /************************************
        Formatting
    ************************************/


    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = "";
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {

        if (!m.isValid()) {
            return m.lang().invalidDate();
        }

        format = expandFormat(format, m.lang());

        if (!formatFunctions[format]) {
            formatFunctions[format] = makeFormatFunction(format);
        }

        return formatFunctions[format](m);
    }

    function expandFormat(format, lang) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return lang.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }


    /************************************
        Parsing
    ************************************/


    // get the regex to find the next token
    function getParseRegexForToken(token, config) {
        var a, strict = config._strict;
        switch (token) {
        case 'Q':
            return parseTokenOneDigit;
        case 'DDDD':
            return parseTokenThreeDigits;
        case 'YYYY':
        case 'GGGG':
        case 'gggg':
            return strict ? parseTokenFourDigits : parseTokenOneToFourDigits;
        case 'Y':
        case 'G':
        case 'g':
            return parseTokenSignedNumber;
        case 'YYYYYY':
        case 'YYYYY':
        case 'GGGGG':
        case 'ggggg':
            return strict ? parseTokenSixDigits : parseTokenOneToSixDigits;
        case 'S':
            if (strict) { return parseTokenOneDigit; }
            /* falls through */
        case 'SS':
            if (strict) { return parseTokenTwoDigits; }
            /* falls through */
        case 'SSS':
            if (strict) { return parseTokenThreeDigits; }
            /* falls through */
        case 'DDD':
            return parseTokenOneToThreeDigits;
        case 'MMM':
        case 'MMMM':
        case 'dd':
        case 'ddd':
        case 'dddd':
            return parseTokenWord;
        case 'a':
        case 'A':
            return getLangDefinition(config._l)._meridiemParse;
        case 'X':
            return parseTokenTimestampMs;
        case 'Z':
        case 'ZZ':
            return parseTokenTimezone;
        case 'T':
            return parseTokenT;
        case 'SSSS':
            return parseTokenDigits;
        case 'MM':
        case 'DD':
        case 'YY':
        case 'GG':
        case 'gg':
        case 'HH':
        case 'hh':
        case 'mm':
        case 'ss':
        case 'ww':
        case 'WW':
            return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits;
        case 'M':
        case 'D':
        case 'd':
        case 'H':
        case 'h':
        case 'm':
        case 's':
        case 'w':
        case 'W':
        case 'e':
        case 'E':
            return parseTokenOneOrTwoDigits;
        case 'Do':
            return parseTokenOrdinal;
        default :
            a = new RegExp(regexpEscape(unescapeFormat(token.replace('\\', '')), "i"));
            return a;
        }
    }

    function timezoneMinutesFromString(string) {
        string = string || "";
        var possibleTzMatches = (string.match(parseTokenTimezone) || []),
            tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [],
            parts = (tzChunk + '').match(parseTimezoneChunker) || ['-', 0, 0],
            minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? -minutes : minutes;
    }

    // function to convert string input to date
    function addTimeToArrayFromToken(token, input, config) {
        var a, datePartArray = config._a;

        switch (token) {
        // QUARTER
        case 'Q':
            if (input != null) {
                datePartArray[MONTH] = (toInt(input) - 1) * 3;
            }
            break;
        // MONTH
        case 'M' : // fall through to MM
        case 'MM' :
            if (input != null) {
                datePartArray[MONTH] = toInt(input) - 1;
            }
            break;
        case 'MMM' : // fall through to MMMM
        case 'MMMM' :
            a = getLangDefinition(config._l).monthsParse(input);
            // if we didn't find a month name, mark the date as invalid.
            if (a != null) {
                datePartArray[MONTH] = a;
            } else {
                config._pf.invalidMonth = input;
            }
            break;
        // DAY OF MONTH
        case 'D' : // fall through to DD
        case 'DD' :
            if (input != null) {
                datePartArray[DATE] = toInt(input);
            }
            break;
        case 'Do' :
            if (input != null) {
                datePartArray[DATE] = toInt(parseInt(input, 10));
            }
            break;
        // DAY OF YEAR
        case 'DDD' : // fall through to DDDD
        case 'DDDD' :
            if (input != null) {
                config._dayOfYear = toInt(input);
            }

            break;
        // YEAR
        case 'YY' :
            datePartArray[YEAR] = moment.parseTwoDigitYear(input);
            break;
        case 'YYYY' :
        case 'YYYYY' :
        case 'YYYYYY' :
            datePartArray[YEAR] = toInt(input);
            break;
        // AM / PM
        case 'a' : // fall through to A
        case 'A' :
            config._isPm = getLangDefinition(config._l).isPM(input);
            break;
        // 24 HOUR
        case 'H' : // fall through to hh
        case 'HH' : // fall through to hh
        case 'h' : // fall through to hh
        case 'hh' :
            datePartArray[HOUR] = toInt(input);
            break;
        // MINUTE
        case 'm' : // fall through to mm
        case 'mm' :
            datePartArray[MINUTE] = toInt(input);
            break;
        // SECOND
        case 's' : // fall through to ss
        case 'ss' :
            datePartArray[SECOND] = toInt(input);
            break;
        // MILLISECOND
        case 'S' :
        case 'SS' :
        case 'SSS' :
        case 'SSSS' :
            datePartArray[MILLISECOND] = toInt(('0.' + input) * 1000);
            break;
        // UNIX TIMESTAMP WITH MS
        case 'X':
            config._d = new Date(parseFloat(input) * 1000);
            break;
        // TIMEZONE
        case 'Z' : // fall through to ZZ
        case 'ZZ' :
            config._useUTC = true;
            config._tzm = timezoneMinutesFromString(input);
            break;
        case 'w':
        case 'ww':
        case 'W':
        case 'WW':
        case 'd':
        case 'dd':
        case 'ddd':
        case 'dddd':
        case 'e':
        case 'E':
            token = token.substr(0, 1);
            /* falls through */
        case 'gg':
        case 'gggg':
        case 'GG':
        case 'GGGG':
        case 'GGGGG':
            token = token.substr(0, 2);
            if (input) {
                config._w = config._w || {};
                config._w[token] = input;
            }
            break;
        }
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function dateFromConfig(config) {
        var i, date, input = [], currentDate,
            yearToUse, fixYear, w, temp, lang, weekday, week;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            fixYear = function (val) {
                var intVal = parseInt(val, 10);
                return val ?
                  (val.length < 3 ? (intVal > 68 ? 1900 + intVal : 2000 + intVal) : intVal) :
                  (config._a[YEAR] == null ? moment().weekYear() : config._a[YEAR]);
            };

            w = config._w;
            if (w.GG != null || w.W != null || w.E != null) {
                temp = dayOfYearFromWeeks(fixYear(w.GG), w.W || 1, w.E, 4, 1);
            }
            else {
                lang = getLangDefinition(config._l);
                weekday = w.d != null ?  parseWeekday(w.d, lang) :
                  (w.e != null ?  parseInt(w.e, 10) + lang._week.dow : 0);

                week = parseInt(w.w, 10) || 1;

                //if we're parsing 'd', then the low day numbers may be next week
                if (w.d != null && weekday < lang._week.dow) {
                    week++;
                }

                temp = dayOfYearFromWeeks(fixYear(w.gg), week, weekday, lang._week.doy, lang._week.dow);
            }

            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = config._a[YEAR] == null ? currentDate[YEAR] : config._a[YEAR];

            if (config._dayOfYear > daysInYear(yearToUse)) {
                config._pf._overflowDayOfYear = true;
            }

            date = makeUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // add the offsets to the time to be parsed so that we can have a clean array for checking isValid
        input[HOUR] += toInt((config._tzm || 0) / 60);
        input[MINUTE] += toInt((config._tzm || 0) % 60);

        config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);
    }

    function dateFromObject(config) {
        var normalizedInput;

        if (config._d) {
            return;
        }

        normalizedInput = normalizeObjectUnits(config._i);
        config._a = [
            normalizedInput.year,
            normalizedInput.month,
            normalizedInput.day,
            normalizedInput.hour,
            normalizedInput.minute,
            normalizedInput.second,
            normalizedInput.millisecond
        ];

        dateFromConfig(config);
    }

    function currentDateArray(config) {
        var now = new Date();
        if (config._useUTC) {
            return [
                now.getUTCFullYear(),
                now.getUTCMonth(),
                now.getUTCDate()
            ];
        } else {
            return [now.getFullYear(), now.getMonth(), now.getDate()];
        }
    }

    // date from string and format string
    function makeDateFromStringAndFormat(config) {

        config._a = [];
        config._pf.empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var lang = getLangDefinition(config._l),
            string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, lang).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    config._pf.unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    config._pf.empty = false;
                }
                else {
                    config._pf.unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                config._pf.unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        config._pf.charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            config._pf.unusedInput.push(string);
        }

        // handle am pm
        if (config._isPm && config._a[HOUR] < 12) {
            config._a[HOUR] += 12;
        }
        // if is 12 am, change hours to 0
        if (config._isPm === false && config._a[HOUR] === 12) {
            config._a[HOUR] = 0;
        }

        dateFromConfig(config);
        checkOverflow(config);
    }

    function unescapeFormat(s) {
        return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        });
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function regexpEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    // date from string and array of format strings
    function makeDateFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            config._pf.invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = extend({}, config);
            tempConfig._pf = defaultParsingFlags();
            tempConfig._f = config._f[i];
            makeDateFromStringAndFormat(tempConfig);

            if (!isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += tempConfig._pf.charsLeftOver;

            //or tokens
            currentScore += tempConfig._pf.unusedTokens.length * 10;

            tempConfig._pf.score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    // date from iso format
    function makeDateFromString(config) {
        var i, l,
            string = config._i,
            match = isoRegex.exec(string);

        if (match) {
            config._pf.iso = true;
            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(string)) {
                    // match[5] should be "T" or undefined
                    config._f = isoDates[i][0] + (match[6] || " ");
                    break;
                }
            }
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(string)) {
                    config._f += isoTimes[i][0];
                    break;
                }
            }
            if (string.match(parseTokenTimezone)) {
                config._f += "Z";
            }
            makeDateFromStringAndFormat(config);
        }
        else {
            moment.createFromInputFallback(config);
        }
    }

    function makeDateFromInput(config) {
        var input = config._i,
            matched = aspNetJsonRegex.exec(input);

        if (input === undefined) {
            config._d = new Date();
        } else if (matched) {
            config._d = new Date(+matched[1]);
        } else if (typeof input === 'string') {
            makeDateFromString(config);
        } else if (isArray(input)) {
            config._a = input.slice(0);
            dateFromConfig(config);
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if (typeof(input) === 'object') {
            dateFromObject(config);
        } else if (typeof(input) === 'number') {
            // from milliseconds
            config._d = new Date(input);
        } else {
            moment.createFromInputFallback(config);
        }
    }

    function makeDate(y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor doesn't accept years < 1970
        if (y < 1970) {
            date.setFullYear(y);
        }
        return date;
    }

    function makeUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    function parseWeekday(input, language) {
        if (typeof input === 'string') {
            if (!isNaN(input)) {
                input = parseInt(input, 10);
            }
            else {
                input = language.weekdaysParse(input);
                if (typeof input !== 'number') {
                    return null;
                }
            }
        }
        return input;
    }

    /************************************
        Relative Time
    ************************************/


    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, lang) {
        return lang.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime(milliseconds, withoutSuffix, lang) {
        var seconds = round(Math.abs(milliseconds) / 1000),
            minutes = round(seconds / 60),
            hours = round(minutes / 60),
            days = round(hours / 24),
            years = round(days / 365),
            args = seconds < 45 && ['s', seconds] ||
                minutes === 1 && ['m'] ||
                minutes < 45 && ['mm', minutes] ||
                hours === 1 && ['h'] ||
                hours < 22 && ['hh', hours] ||
                days === 1 && ['d'] ||
                days <= 25 && ['dd', days] ||
                days <= 45 && ['M'] ||
                days < 345 && ['MM', round(days / 30)] ||
                years === 1 && ['y'] || ['yy', years];
        args[2] = withoutSuffix;
        args[3] = milliseconds > 0;
        args[4] = lang;
        return substituteTimeAgo.apply({}, args);
    }


    /************************************
        Week of Year
    ************************************/


    // firstDayOfWeek       0 = sun, 6 = sat
    //                      the day of the week that starts the week
    //                      (usually sunday or monday)
    // firstDayOfWeekOfYear 0 = sun, 6 = sat
    //                      the first week is the week that contains the first
    //                      of this day of the week
    //                      (eg. ISO weeks use thursday (4))
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek,
            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
            adjustedMoment;


        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }

        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }

        adjustedMoment = moment(mom).add('d', daysToDayOfWeek);
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var d = makeUTCDate(year, 0, 1).getUTCDay(), daysToAdd, dayOfYear;

        weekday = weekday != null ? weekday : firstDayOfWeek;
        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (d < firstDayOfWeek ? 7 : 0);
        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;

        return {
            year: dayOfYear > 0 ? year : year - 1,
            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear
        };
    }

    /************************************
        Top Level Functions
    ************************************/

    function makeMoment(config) {
        var input = config._i,
            format = config._f;

        if (input === null || (format === undefined && input === '')) {
            return moment.invalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = getLangDefinition().preparse(input);
        }

        if (moment.isMoment(input)) {
            config = cloneMoment(input);

            config._d = new Date(+input._d);
        } else if (format) {
            if (isArray(format)) {
                makeDateFromStringAndArray(config);
            } else {
                makeDateFromStringAndFormat(config);
            }
        } else {
            makeDateFromInput(config);
        }

        return new Moment(config);
    }

    moment = function (input, format, lang, strict) {
        var c;

        if (typeof(lang) === "boolean") {
            strict = lang;
            lang = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c = {};
        c._isAMomentObject = true;
        c._i = input;
        c._f = format;
        c._l = lang;
        c._strict = strict;
        c._isUTC = false;
        c._pf = defaultParsingFlags();

        return makeMoment(c);
    };

    moment.suppressDeprecationWarnings = false;

    moment.createFromInputFallback = deprecate(
            "moment construction falls back to js Date. This is " +
            "discouraged and will be removed in upcoming major " +
            "release. Please refer to " +
            "https://github.com/moment/moment/issues/1407 for more info.",
            function (config) {
        config._d = new Date(config._i);
    });

    // creating with utc
    moment.utc = function (input, format, lang, strict) {
        var c;

        if (typeof(lang) === "boolean") {
            strict = lang;
            lang = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c = {};
        c._isAMomentObject = true;
        c._useUTC = true;
        c._isUTC = true;
        c._l = lang;
        c._i = input;
        c._f = format;
        c._strict = strict;
        c._pf = defaultParsingFlags();

        return makeMoment(c).utc();
    };

    // creating with unix timestamp (in seconds)
    moment.unix = function (input) {
        return moment(input * 1000);
    };

    // duration
    moment.duration = function (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            parseIso;

        if (moment.isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {
            sign = (match[1] === "-") ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = isoDurationRegex.exec(input))) {
            sign = (match[1] === "-") ? -1 : 1;
            parseIso = function (inp) {
                // We'd normally use ~~inp for this, but unfortunately it also
                // converts floats to ints.
                // inp may be undefined, so careful calling replace on it.
                var res = inp && parseFloat(inp.replace(',', '.'));
                // apply sign while we're at it
                return (isNaN(res) ? 0 : res) * sign;
            };
            duration = {
                y: parseIso(match[2]),
                M: parseIso(match[3]),
                d: parseIso(match[4]),
                h: parseIso(match[5]),
                m: parseIso(match[6]),
                s: parseIso(match[7]),
                w: parseIso(match[8])
            };
        }

        ret = new Duration(duration);

        if (moment.isDuration(input) && input.hasOwnProperty('_lang')) {
            ret._lang = input._lang;
        }

        return ret;
    };

    // version number
    moment.version = VERSION;

    // default format
    moment.defaultFormat = isoFormat;

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    moment.momentProperties = momentProperties;

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    moment.updateOffset = function () {};

    // This function will load languages and then set the global language.  If
    // no arguments are passed in, it will simply return the current global
    // language key.
    moment.lang = function (key, values) {
        var r;
        if (!key) {
            return moment.fn._lang._abbr;
        }
        if (values) {
            loadLang(normalizeLanguage(key), values);
        } else if (values === null) {
            unloadLang(key);
            key = 'en';
        } else if (!languages[key]) {
            getLangDefinition(key);
        }
        r = moment.duration.fn._lang = moment.fn._lang = getLangDefinition(key);
        return r._abbr;
    };

    // returns language data
    moment.langData = function (key) {
        if (key && key._lang && key._lang._abbr) {
            key = key._lang._abbr;
        }
        return getLangDefinition(key);
    };

    // compare moment object
    moment.isMoment = function (obj) {
        return obj instanceof Moment ||
            (obj != null &&  obj.hasOwnProperty('_isAMomentObject'));
    };

    // for typechecking Duration objects
    moment.isDuration = function (obj) {
        return obj instanceof Duration;
    };

    for (i = lists.length - 1; i >= 0; --i) {
        makeList(lists[i]);
    }

    moment.normalizeUnits = function (units) {
        return normalizeUnits(units);
    };

    moment.invalid = function (flags) {
        var m = moment.utc(NaN);
        if (flags != null) {
            extend(m._pf, flags);
        }
        else {
            m._pf.userInvalidated = true;
        }

        return m;
    };

    moment.parseZone = function () {
        return moment.apply(null, arguments).parseZone();
    };

    moment.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    /************************************
        Moment Prototype
    ************************************/


    extend(moment.fn = Moment.prototype, {

        clone : function () {
            return moment(this);
        },

        valueOf : function () {
            return +this._d + ((this._offset || 0) * 60000);
        },

        unix : function () {
            return Math.floor(+this / 1000);
        },

        toString : function () {
            return this.clone().lang('en').format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
        },

        toDate : function () {
            return this._offset ? new Date(+this) : this._d;
        },

        toISOString : function () {
            var m = moment(this).utc();
            if (0 < m.year() && m.year() <= 9999) {
                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            } else {
                return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        },

        toArray : function () {
            var m = this;
            return [
                m.year(),
                m.month(),
                m.date(),
                m.hours(),
                m.minutes(),
                m.seconds(),
                m.milliseconds()
            ];
        },

        isValid : function () {
            return isValid(this);
        },

        isDSTShifted : function () {

            if (this._a) {
                return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;
            }

            return false;
        },

        parsingFlags : function () {
            return extend({}, this._pf);
        },

        invalidAt: function () {
            return this._pf.overflow;
        },

        utc : function () {
            return this.zone(0);
        },

        local : function () {
            this.zone(0);
            this._isUTC = false;
            return this;
        },

        format : function (inputString) {
            var output = formatMoment(this, inputString || moment.defaultFormat);
            return this.lang().postformat(output);
        },

        add : function (input, val) {
            var dur;
            // switch args to support add('s', 1) and add(1, 's')
            if (typeof input === 'string') {
                dur = moment.duration(+val, input);
            } else {
                dur = moment.duration(input, val);
            }
            addOrSubtractDurationFromMoment(this, dur, 1);
            return this;
        },

        subtract : function (input, val) {
            var dur;
            // switch args to support subtract('s', 1) and subtract(1, 's')
            if (typeof input === 'string') {
                dur = moment.duration(+val, input);
            } else {
                dur = moment.duration(input, val);
            }
            addOrSubtractDurationFromMoment(this, dur, -1);
            return this;
        },

        diff : function (input, units, asFloat) {
            var that = makeAs(input, this),
                zoneDiff = (this.zone() - that.zone()) * 6e4,
                diff, output;

            units = normalizeUnits(units);

            if (units === 'year' || units === 'month') {
                // average number of days in the months in the given dates
                diff = (this.daysInMonth() + that.daysInMonth()) * 432e5; // 24 * 60 * 60 * 1000 / 2
                // difference in months
                output = ((this.year() - that.year()) * 12) + (this.month() - that.month());
                // adjust by taking difference in days, average number of days
                // and dst in the given months.
                output += ((this - moment(this).startOf('month')) -
                        (that - moment(that).startOf('month'))) / diff;
                // same as above but with zones, to negate all dst
                output -= ((this.zone() - moment(this).startOf('month').zone()) -
                        (that.zone() - moment(that).startOf('month').zone())) * 6e4 / diff;
                if (units === 'year') {
                    output = output / 12;
                }
            } else {
                diff = (this - that);
                output = units === 'second' ? diff / 1e3 : // 1000
                    units === 'minute' ? diff / 6e4 : // 1000 * 60
                    units === 'hour' ? diff / 36e5 : // 1000 * 60 * 60
                    units === 'day' ? (diff - zoneDiff) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                    units === 'week' ? (diff - zoneDiff) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                    diff;
            }
            return asFloat ? output : absRound(output);
        },

        from : function (time, withoutSuffix) {
            return moment.duration(this.diff(time)).lang(this.lang()._abbr).humanize(!withoutSuffix);
        },

        fromNow : function (withoutSuffix) {
            return this.from(moment(), withoutSuffix);
        },

        calendar : function () {
            // We want to compare the start of today, vs this.
            // Getting start-of-today depends on whether we're zone'd or not.
            var sod = makeAs(moment(), this).startOf('day'),
                diff = this.diff(sod, 'days', true),
                format = diff < -6 ? 'sameElse' :
                    diff < -1 ? 'lastWeek' :
                    diff < 0 ? 'lastDay' :
                    diff < 1 ? 'sameDay' :
                    diff < 2 ? 'nextDay' :
                    diff < 7 ? 'nextWeek' : 'sameElse';
            return this.format(this.lang().calendar(format, this));
        },

        isLeapYear : function () {
            return isLeapYear(this.year());
        },

        isDST : function () {
            return (this.zone() < this.clone().month(0).zone() ||
                this.zone() < this.clone().month(5).zone());
        },

        day : function (input) {
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            if (input != null) {
                input = parseWeekday(input, this.lang());
                return this.add({ d : input - day });
            } else {
                return day;
            }
        },

        month : makeAccessor('Month', true),

        startOf: function (units) {
            units = normalizeUnits(units);
            // the following switch intentionally omits break keywords
            // to utilize falling through the cases.
            switch (units) {
            case 'year':
                this.month(0);
                /* falls through */
            case 'quarter':
            case 'month':
                this.date(1);
                /* falls through */
            case 'week':
            case 'isoWeek':
            case 'day':
                this.hours(0);
                /* falls through */
            case 'hour':
                this.minutes(0);
                /* falls through */
            case 'minute':
                this.seconds(0);
                /* falls through */
            case 'second':
                this.milliseconds(0);
                /* falls through */
            }

            // weeks are a special case
            if (units === 'week') {
                this.weekday(0);
            } else if (units === 'isoWeek') {
                this.isoWeekday(1);
            }

            // quarters are also special
            if (units === 'quarter') {
                this.month(Math.floor(this.month() / 3) * 3);
            }

            return this;
        },

        endOf: function (units) {
            units = normalizeUnits(units);
            return this.startOf(units).add((units === 'isoWeek' ? 'week' : units), 1).subtract('ms', 1);
        },

        isAfter: function (input, units) {
            units = typeof units !== 'undefined' ? units : 'millisecond';
            return +this.clone().startOf(units) > +moment(input).startOf(units);
        },

        isBefore: function (input, units) {
            units = typeof units !== 'undefined' ? units : 'millisecond';
            return +this.clone().startOf(units) < +moment(input).startOf(units);
        },

        isSame: function (input, units) {
            units = units || 'ms';
            return +this.clone().startOf(units) === +makeAs(input, this).startOf(units);
        },

        min: function (other) {
            other = moment.apply(null, arguments);
            return other < this ? this : other;
        },

        max: function (other) {
            other = moment.apply(null, arguments);
            return other > this ? this : other;
        },

        // keepTime = true means only change the timezone, without affecting
        // the local hour. So 5:31:26 +0300 --[zone(2, true)]--> 5:31:26 +0200
        // It is possible that 5:31:26 doesn't exist int zone +0200, so we
        // adjust the time as needed, to be valid.
        //
        // Keeping the time actually adds/subtracts (one hour)
        // from the actual represented time. That is why we call updateOffset
        // a second time. In case it wants us to change the offset again
        // _changeInProgress == true case, then we have to adjust, because
        // there is no such time in the given timezone.
        zone : function (input, keepTime) {
            var offset = this._offset || 0;
            if (input != null) {
                if (typeof input === "string") {
                    input = timezoneMinutesFromString(input);
                }
                if (Math.abs(input) < 16) {
                    input = input * 60;
                }
                this._offset = input;
                this._isUTC = true;
                if (offset !== input) {
                    if (!keepTime || this._changeInProgress) {
                        addOrSubtractDurationFromMoment(this,
                                moment.duration(offset - input, 'm'), 1, false);
                    } else if (!this._changeInProgress) {
                        this._changeInProgress = true;
                        moment.updateOffset(this, true);
                        this._changeInProgress = null;
                    }
                }
            } else {
                return this._isUTC ? offset : this._d.getTimezoneOffset();
            }
            return this;
        },

        zoneAbbr : function () {
            return this._isUTC ? "UTC" : "";
        },

        zoneName : function () {
            return this._isUTC ? "Coordinated Universal Time" : "";
        },

        parseZone : function () {
            if (this._tzm) {
                this.zone(this._tzm);
            } else if (typeof this._i === 'string') {
                this.zone(this._i);
            }
            return this;
        },

        hasAlignedHourOffset : function (input) {
            if (!input) {
                input = 0;
            }
            else {
                input = moment(input).zone();
            }

            return (this.zone() - input) % 60 === 0;
        },

        daysInMonth : function () {
            return daysInMonth(this.year(), this.month());
        },

        dayOfYear : function (input) {
            var dayOfYear = round((moment(this).startOf('day') - moment(this).startOf('year')) / 864e5) + 1;
            return input == null ? dayOfYear : this.add("d", (input - dayOfYear));
        },

        quarter : function (input) {
            return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
        },

        weekYear : function (input) {
            var year = weekOfYear(this, this.lang()._week.dow, this.lang()._week.doy).year;
            return input == null ? year : this.add("y", (input - year));
        },

        isoWeekYear : function (input) {
            var year = weekOfYear(this, 1, 4).year;
            return input == null ? year : this.add("y", (input - year));
        },

        week : function (input) {
            var week = this.lang().week(this);
            return input == null ? week : this.add("d", (input - week) * 7);
        },

        isoWeek : function (input) {
            var week = weekOfYear(this, 1, 4).week;
            return input == null ? week : this.add("d", (input - week) * 7);
        },

        weekday : function (input) {
            var weekday = (this.day() + 7 - this.lang()._week.dow) % 7;
            return input == null ? weekday : this.add("d", input - weekday);
        },

        isoWeekday : function (input) {
            // behaves the same as moment#day except
            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
            // as a setter, sunday should belong to the previous week.
            return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
        },

        isoWeeksInYear : function () {
            return weeksInYear(this.year(), 1, 4);
        },

        weeksInYear : function () {
            var weekInfo = this._lang._week;
            return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units]();
        },

        set : function (units, value) {
            units = normalizeUnits(units);
            if (typeof this[units] === 'function') {
                this[units](value);
            }
            return this;
        },

        // If passed a language key, it will set the language for this
        // instance.  Otherwise, it will return the language configuration
        // variables for this instance.
        lang : function (key) {
            if (key === undefined) {
                return this._lang;
            } else {
                this._lang = getLangDefinition(key);
                return this;
            }
        }
    });

    function rawMonthSetter(mom, value) {
        var dayOfMonth;

        // TODO: Move this out of here!
        if (typeof value === 'string') {
            value = mom.lang().monthsParse(value);
            // TODO: Another silent failure?
            if (typeof value !== 'number') {
                return mom;
            }
        }

        dayOfMonth = Math.min(mom.date(),
                daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function rawGetter(mom, unit) {
        return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();
    }

    function rawSetter(mom, unit, value) {
        if (unit === 'Month') {
            return rawMonthSetter(mom, value);
        } else {
            return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
    }

    function makeAccessor(unit, keepTime) {
        return function (value) {
            if (value != null) {
                rawSetter(this, unit, value);
                moment.updateOffset(this, keepTime);
                return this;
            } else {
                return rawGetter(this, unit);
            }
        };
    }

    moment.fn.millisecond = moment.fn.milliseconds = makeAccessor('Milliseconds', false);
    moment.fn.second = moment.fn.seconds = makeAccessor('Seconds', false);
    moment.fn.minute = moment.fn.minutes = makeAccessor('Minutes', false);
    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    moment.fn.hour = moment.fn.hours = makeAccessor('Hours', true);
    // moment.fn.month is defined separately
    moment.fn.date = makeAccessor('Date', true);
    moment.fn.dates = deprecate("dates accessor is deprecated. Use date instead.", makeAccessor('Date', true));
    moment.fn.year = makeAccessor('FullYear', true);
    moment.fn.years = deprecate("years accessor is deprecated. Use year instead.", makeAccessor('FullYear', true));

    // add plural methods
    moment.fn.days = moment.fn.day;
    moment.fn.months = moment.fn.month;
    moment.fn.weeks = moment.fn.week;
    moment.fn.isoWeeks = moment.fn.isoWeek;
    moment.fn.quarters = moment.fn.quarter;

    // add aliased format methods
    moment.fn.toJSON = moment.fn.toISOString;

    /************************************
        Duration Prototype
    ************************************/


    extend(moment.duration.fn = Duration.prototype, {

        _bubble : function () {
            var milliseconds = this._milliseconds,
                days = this._days,
                months = this._months,
                data = this._data,
                seconds, minutes, hours, years;

            // The following code bubbles up values, see the tests for
            // examples of what that means.
            data.milliseconds = milliseconds % 1000;

            seconds = absRound(milliseconds / 1000);
            data.seconds = seconds % 60;

            minutes = absRound(seconds / 60);
            data.minutes = minutes % 60;

            hours = absRound(minutes / 60);
            data.hours = hours % 24;

            days += absRound(hours / 24);
            data.days = days % 30;

            months += absRound(days / 30);
            data.months = months % 12;

            years = absRound(months / 12);
            data.years = years;
        },

        weeks : function () {
            return absRound(this.days() / 7);
        },

        valueOf : function () {
            return this._milliseconds +
              this._days * 864e5 +
              (this._months % 12) * 2592e6 +
              toInt(this._months / 12) * 31536e6;
        },

        humanize : function (withSuffix) {
            var difference = +this,
                output = relativeTime(difference, !withSuffix, this.lang());

            if (withSuffix) {
                output = this.lang().pastFuture(difference, output);
            }

            return this.lang().postformat(output);
        },

        add : function (input, val) {
            // supports only 2.0-style add(1, 's') or add(moment)
            var dur = moment.duration(input, val);

            this._milliseconds += dur._milliseconds;
            this._days += dur._days;
            this._months += dur._months;

            this._bubble();

            return this;
        },

        subtract : function (input, val) {
            var dur = moment.duration(input, val);

            this._milliseconds -= dur._milliseconds;
            this._days -= dur._days;
            this._months -= dur._months;

            this._bubble();

            return this;
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units.toLowerCase() + 's']();
        },

        as : function (units) {
            units = normalizeUnits(units);
            return this['as' + units.charAt(0).toUpperCase() + units.slice(1) + 's']();
        },

        lang : moment.fn.lang,

        toIsoString : function () {
            // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
            var years = Math.abs(this.years()),
                months = Math.abs(this.months()),
                days = Math.abs(this.days()),
                hours = Math.abs(this.hours()),
                minutes = Math.abs(this.minutes()),
                seconds = Math.abs(this.seconds() + this.milliseconds() / 1000);

            if (!this.asSeconds()) {
                // this is the same as C#'s (Noda) and python (isodate)...
                // but not other JS (goog.date)
                return 'P0D';
            }

            return (this.asSeconds() < 0 ? '-' : '') +
                'P' +
                (years ? years + 'Y' : '') +
                (months ? months + 'M' : '') +
                (days ? days + 'D' : '') +
                ((hours || minutes || seconds) ? 'T' : '') +
                (hours ? hours + 'H' : '') +
                (minutes ? minutes + 'M' : '') +
                (seconds ? seconds + 'S' : '');
        }
    });

    function makeDurationGetter(name) {
        moment.duration.fn[name] = function () {
            return this._data[name];
        };
    }

    function makeDurationAsGetter(name, factor) {
        moment.duration.fn['as' + name] = function () {
            return +this / factor;
        };
    }

    for (i in unitMillisecondFactors) {
        if (unitMillisecondFactors.hasOwnProperty(i)) {
            makeDurationAsGetter(i, unitMillisecondFactors[i]);
            makeDurationGetter(i.toLowerCase());
        }
    }

    makeDurationAsGetter('Weeks', 6048e5);
    moment.duration.fn.asMonths = function () {
        return (+this - this.years() * 31536e6) / 2592e6 + this.years() * 12;
    };


    /************************************
        Default Lang
    ************************************/


    // Set default language, other languages will inherit from English.
    moment.lang('en', {
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    $.moment = moment;

}).call(this);

}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("moment", moduleFactory);

}());			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var exports = function() { 

/*
 * Password Strength (0.1.2)
 * by Sagie Maoz (n0nick.net)
 * n0nick@php.net
 *
 * This plugin will check the value of a password field and evaluate the
 * strength of the typed password. This is done by checking for
 * the diversity of character types: numbers, lowercase and uppercase
 * letters and special characters.
 *
 * Copyright (c) 2010 Sagie Maoz <n0nick@php.net>
 * Licensed under the GPL license, see http://www.gnu.org/licenses/gpl-3.0.html
 *
 *
 * NOTE: This script requires jQuery to work.  Download jQuery at www.jquery.com
 *
 */

var passwordStrength = new function()
{
	this.countRegexp = function(val, rex)
	{
		var match = val.match(rex);
		return match ? match.length : 0;
	};

	this.getStrength = function(val, minLength)
	{
		var len = val.length;

		// too short =(
		if (len < minLength)
		{
			return 0;
		}

		var nums = this.countRegexp(val, /\d/g),
			lowers = this.countRegexp(val, /[a-z]/g),
			uppers = this.countRegexp(val, /[A-Z]/g),
			specials = len - nums - lowers - uppers;

		// just one type of characters =(
		if (nums == len || lowers == len || uppers == len || specials == len)
		{
			return 1;
		}

		var strength = 0;
		if (nums)	{ strength+= 2; }
		if (lowers)	{ strength+= uppers? 4 : 3; }
		if (uppers)	{ strength+= lowers? 4 : 3; }
		if (specials) { strength+= 5; }
		if (len > 10) { strength+= 1; }

		return strength;
	};

	this.getStrengthLevel = function(val, minLength)
	{
		var strength = this.getStrength(val, minLength),
				val = 1;
		if (strength <= 0) {
			val = 1;
		} else if (strength > 0 && strength <= 4) {
			val = 2;
		} else if (strength > 4 && strength <= 8) {
			val = 3;
		} else if (strength > 8 && strength <= 12) {
			val = 4;
		} else if (strength > 12) {
			val = 5;
		}

		return val;
	};
};

$.fn.password_strength = function(options)
{
	var settings = $.extend({
		'container' : null,
		'minLength' : 6,
		'texts' : {
			1 : 'Too weak',
			2 : 'Weak password',
			3 : 'Normal strength',
			4 : 'Strong password',
			5 : 'Very strong password'
		},
		'onCheck': null
	}, options);

	return this.each(function()
	{
		var container = null;
		if (settings.container)
		{
			container = $(settings.container);
		}
		else
		{
			container = $('<span/>').attr('class', 'password_strength');
			$(this).after(container);
		}

		$(this).keyup(function()
		{
			var val = $(this).val(),
					level = passwordStrength.getStrengthLevel(val, settings.minLength);

			if (val.length > 0)
			{
				var _class = 'password_strength_' + level;

				if (!container.hasClass(_class) && level in settings.texts)
				{
					container.text(settings.texts[level]).attr('class', 'password_strength ' + _class);
				}
			}
			else
			{
				container.text('').attr('class', 'password_strength');
			}
			if (settings.onCheck) {
				settings.onCheck.call(this, level);
			}
		});
	});
};
}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("passwordstrength", moduleFactory);

}());			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var jQuery = $; 
var exports = function() { 

/*! http://mths.be/placeholder v2.0.7 by @mathias */
;(function(window, document, $) {

	var isInputSupported = 'placeholder' in document.createElement('input'),
	    isTextareaSupported = 'placeholder' in document.createElement('textarea'),
	    prototype = $.fn,
	    valHooks = $.valHooks,
	    hooks,
	    placeholder;

	if (isInputSupported && isTextareaSupported) {

		placeholder = prototype.placeholder = function() {
			return this;
		};

		placeholder.input = placeholder.textarea = true;

	} else {

		placeholder = prototype.placeholder = function() {
			var $this = this;
			$this
				.filter((isInputSupported ? 'textarea' : ':input') + '[placeholder]')
				.not('.placeholder')
				.bind({
					'focus.placeholder': clearPlaceholder,
					'blur.placeholder': setPlaceholder
				})
				.data('placeholder-enabled', true)
				.trigger('blur.placeholder');
			return $this;
		};

		placeholder.input = isInputSupported;
		placeholder.textarea = isTextareaSupported;

		hooks = {
			'get': function(element) {
				var $element = $(element);
				return $element.data('placeholder-enabled') && $element.hasClass('placeholder') ? '' : element.value;
			},
			'set': function(element, value) {
				var $element = $(element);
				if (!$element.data('placeholder-enabled')) {
					return element.value = value;
				}
				if (value == '') {
					element.value = value;
					// Issue #56: Setting the placeholder causes problems if the element continues to have focus.
					if (element != document.activeElement) {
						// We can't use `triggerHandler` here because of dummy text/password inputs :(
						setPlaceholder.call(element);
					}
				} else if ($element.hasClass('placeholder')) {
					clearPlaceholder.call(element, true, value) || (element.value = value);
				} else {
					element.value = value;
				}
				// `set` can not return `undefined`; see http://jsapi.info/jquery/1.7.1/val#L2363
				return $element;
			}
		};

		isInputSupported || (valHooks.input = hooks);
		isTextareaSupported || (valHooks.textarea = hooks);

		$(function() {
			// Look for forms
			$(document).delegate('form', 'submit.placeholder', function() {
				// Clear the placeholder values so they don't get submitted
				var $inputs = $('.placeholder', this).each(clearPlaceholder);
				setTimeout(function() {
					$inputs.each(setPlaceholder);
				}, 10);
			});
		});

		// Clear placeholder values upon page reload
		$(window).bind('beforeunload.placeholder', function() {
			$('.placeholder').each(function() {
				this.value = '';
			});
		});

	}

	function args(elem) {
		// Return an object of element attributes
		var newAttrs = {},
		    rinlinejQuery = /^jQuery\d+$/;
		$.each(elem.attributes, function(i, attr) {
			if (attr.specified && !rinlinejQuery.test(attr.name)) {
				newAttrs[attr.name] = attr.value;
			}
		});
		return newAttrs;
	}

	function clearPlaceholder(event, value) {
		var input = this,
		    $input = $(input);
		if (input.value == $input.attr('placeholder') && $input.hasClass('placeholder')) {
			if ($input.data('placeholder-password')) {
				$input = $input.hide().next().show().attr('id', $input.removeAttr('id').data('placeholder-id'));
				// If `clearPlaceholder` was called from `$.valHooks.input.set`
				if (event === true) {
					return $input[0].value = value;
				}
				$input.focus();
			} else {
				input.value = '';
				$input.removeClass('placeholder');
				input == document.activeElement && input.select();
			}
		}
	}

	function setPlaceholder() {
		var $replacement,
		    input = this,
		    $input = $(input),
		    $origInput = $input,
		    id = this.id;
		if (input.value == '') {
			if (input.type == 'password') {
				if (!$input.data('placeholder-textinput')) {
					try {
						$replacement = $input.clone().attr({ 'type': 'text' });
					} catch(e) {
						$replacement = $('<input>').attr($.extend(args(this), { 'type': 'text' }));
					}
					$replacement
						.removeAttr('name')
						.data({
							'placeholder-password': true,
							'placeholder-id': id
						})
						.bind('focus.placeholder', clearPlaceholder);
					$input
						.data({
							'placeholder-textinput': $replacement,
							'placeholder-id': id
						})
						.before($replacement);
				}
				$input = $input.removeAttr('id').hide().prev().attr('id', id).show();
				// Note: `$input[0] != input` now!
			}
			$input.addClass('placeholder');
			$input[0].value = $input.attr('placeholder');
		} else {
			$input.removeClass('placeholder');
		}
	}

}(window, document, jQuery));

}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("placeholder", moduleFactory);

}());			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this;
var jQuery = $;
var exports = function() {
/**
 * plupload.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

// JSLint defined globals
/*global window:false, escape:false */

/*!@@version@@*/

(function() {
	var count = 0, runtimes = [], i18n = {}, mimes = {},
		xmlEncodeChars = {'<' : 'lt', '>' : 'gt', '&' : 'amp', '"' : 'quot', '\'' : '#39'},
		xmlEncodeRegExp = /[<>&\"\']/g, undef, delay = window.setTimeout,
		// A place to store references to event handlers
		eventhash = {},
		uid;

	// IE W3C like event funcs
	function preventDefault() {
		this.returnValue = false;
	}

	function stopPropagation() {
		this.cancelBubble = true;
	}

	// Parses the default mime types string into a mimes lookup map
	(function(mime_data) {
		var items = mime_data.split(/,/), i, y, ext;

		for (i = 0; i < items.length; i += 2) {
			ext = items[i + 1].split(/ /);

			for (y = 0; y < ext.length; y++) {
				mimes[ext[y]] = items[i];
			}
		}
	})(
		"application/msword,doc dot," +
		"application/pdf,pdf," +
		"application/pgp-signature,pgp," +
		"application/postscript,ps ai eps," +
		"application/rtf,rtf," +
		"application/vnd.ms-excel,xls xlb," +
		"application/vnd.ms-powerpoint,ppt pps pot," +
		"application/zip,zip," +
		"application/x-shockwave-flash,swf swfl," +
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document,docx," +
		"application/vnd.openxmlformats-officedocument.wordprocessingml.template,dotx," +
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,xlsx," +
		"application/vnd.openxmlformats-officedocument.presentationml.presentation,pptx," +
		"application/vnd.openxmlformats-officedocument.presentationml.template,potx," +
		"application/vnd.openxmlformats-officedocument.presentationml.slideshow,ppsx," +
		"application/x-javascript,js," +
		"application/json,json," +
		"audio/mpeg,mpga mpega mp2 mp3," +
		"audio/x-wav,wav," +
		"audio/mp4,m4a," +
		"image/bmp,bmp," +
		"image/gif,gif," +
		"image/jpeg,jpeg jpg jpe," +
		"image/photoshop,psd," +
		"image/png,png," +
		"image/svg+xml,svg svgz," +
		"image/tiff,tiff tif," +
		"text/plain,asc txt text diff log," +
		"text/html,htm html xhtml," +
		"text/css,css," +
		"text/csv,csv," +
		"text/rtf,rtf," +
		"video/mpeg,mpeg mpg mpe m2v," +
		"video/quicktime,qt mov," +
		"video/mp4,mp4," +
		"video/x-m4v,m4v," +
		"video/x-flv,flv," +
		"video/x-ms-wmv,wmv," +
		"video/avi,avi," +
		"video/webm,webm," +
		"video/3gpp,3gp," +
		"video/3gpp2,3g2," +
		"video/vnd.rn-realvideo,rv," +
		"application/vnd.oasis.opendocument.formula-template,otf," +
		"application/octet-stream,exe"
	);

	/**
	 * Plupload class with some global constants and functions.
	 *
	 * @example
	 * // Encode entities
	 * console.log(plupload.xmlEncode("My string &lt;&gt;"));
	 *
	 * // Generate unique id
	 * console.log(plupload.guid());
	 *
	 * @static
	 * @class plupload
	 */
	var plupload = {
		/**
		 * Plupload version will be replaced on build.
		 */
		VERSION : '@@version@@',

		/**
		 * Inital state of the queue and also the state ones it's finished all it's uploads.
		 *
		 * @property STOPPED
		 * @final
		 */
		STOPPED : 1,

		/**
		 * Upload process is running
		 *
		 * @property STARTED
		 * @final
		 */
		STARTED : 2,

		/**
		 * File is queued for upload
		 *
		 * @property QUEUED
		 * @final
		 */
		QUEUED : 1,

		/**
		 * File is being uploaded
		 *
		 * @property UPLOADING
		 * @final
		 */
		UPLOADING : 2,

		/**
		 * File has failed to be uploaded
		 *
		 * @property FAILED
		 * @final
		 */
		FAILED : 4,

		/**
		 * File has been uploaded successfully
		 *
		 * @property DONE
		 * @final
		 */
		DONE : 5,

		// Error constants used by the Error event

		/**
		 * Generic error for example if an exception is thrown inside Silverlight.
		 *
		 * @property GENERIC_ERROR
		 * @final
		 */
		GENERIC_ERROR : -100,

		/**
		 * HTTP transport error. For example if the server produces a HTTP status other than 200.
		 *
		 * @property HTTP_ERROR
		 * @final
		 */
		HTTP_ERROR : -200,

		/**
		 * Generic I/O error. For exampe if it wasn't possible to open the file stream on local machine.
		 *
		 * @property IO_ERROR
		 * @final
		 */
		IO_ERROR : -300,

		/**
		 * Generic I/O error. For exampe if it wasn't possible to open the file stream on local machine.
		 *
		 * @property SECURITY_ERROR
		 * @final
		 */
		SECURITY_ERROR : -400,

		/**
		 * Initialization error. Will be triggered if no runtime was initialized.
		 *
		 * @property INIT_ERROR
		 * @final
		 */
		INIT_ERROR : -500,

		/**
		 * File size error. If the user selects a file that is too large it will be blocked and an error of this type will be triggered.
		 *
		 * @property FILE_SIZE_ERROR
		 * @final
		 */
		FILE_SIZE_ERROR : -600,

		/**
		 * File extension error. If the user selects a file that isn't valid according to the filters setting.
		 *
		 * @property FILE_EXTENSION_ERROR
		 * @final
		 */
		FILE_EXTENSION_ERROR : -601,

		/**
		 * Runtime will try to detect if image is proper one. Otherwise will throw this error.
		 *
		 * @property IMAGE_FORMAT_ERROR
		 * @final
		 */
		IMAGE_FORMAT_ERROR : -700,

		/**
		 * While working on the image runtime will try to detect if the operation may potentially run out of memeory and will throw this error.
		 *
		 * @property IMAGE_MEMORY_ERROR
		 * @final
		 */
		IMAGE_MEMORY_ERROR : -701,

		/**
		 * Each runtime has an upper limit on a dimension of the image it can handle. If bigger, will throw this error.
		 *
		 * @property IMAGE_DIMENSIONS_ERROR
		 * @final
		 */
		IMAGE_DIMENSIONS_ERROR : -702,


		/**
		 * Mime type lookup table.
		 *
		 * @property mimeTypes
		 * @type Object
		 * @final
		 */
		mimeTypes : mimes,

		/**
		 * In some cases sniffing is the only way around :(
		 */
		ua: (function() {
			var nav = navigator, userAgent = nav.userAgent, vendor = nav.vendor, webkit, opera, safari;

			webkit = /WebKit/.test(userAgent);
			safari = webkit && vendor.indexOf('Apple') !== -1;
			opera = window.opera && window.opera.buildNumber;

			return {
				windows: navigator.platform.indexOf('Win') !== -1,
				android: /Android/.test(userAgent),
				ie: !webkit && !opera && (/MSIE/gi).test(userAgent) && (/Explorer/gi).test(nav.appName),
				webkit: webkit,
				gecko: !webkit && /Gecko/.test(userAgent),
				safari: safari,
				opera: !!opera
			};
		}()),

		/**
		 * Gets the true type of the built-in object (better version of typeof).
		 * @credits Angus Croll (http://javascriptweblog.wordpress.com/)
		 *
		 * @param {Object} o Object to check.
		 * @return {String} Object [[Class]]
		 */
		typeOf: function(o) {
			return ({}).toString.call(o).match(/\s([a-z|A-Z]+)/)[1].toLowerCase();
		},

		/**
		 * Extends the specified object with another object.
		 *
		 * @method extend
		 * @param {Object} target Object to extend.
		 * @param {Object..} obj Multiple objects to extend with.
		 * @return {Object} Same as target, the extended object.
		 */
		extend : function(target) {
			plupload.each(arguments, function(arg, i) {
				if (i > 0) {
					plupload.each(arg, function(value, key) {
						target[key] = value;
					});
				}
			});

			return target;
		},

		/**
		 * Cleans the specified name from national characters (diacritics). The result will be a name with only a-z, 0-9 and _.
		 *
		 * @method cleanName
		 * @param {String} s String to clean up.
		 * @return {String} Cleaned string.
		 */
		cleanName : function(name) {
			var i, lookup;

			// Replace diacritics
			lookup = [
				/[\300-\306]/g, 'A', /[\340-\346]/g, 'a',
				/\307/g, 'C', /\347/g, 'c',
				/[\310-\313]/g, 'E', /[\350-\353]/g, 'e',
				/[\314-\317]/g, 'I', /[\354-\357]/g, 'i',
				/\321/g, 'N', /\361/g, 'n',
				/[\322-\330]/g, 'O', /[\362-\370]/g, 'o',
				/[\331-\334]/g, 'U', /[\371-\374]/g, 'u'
			];

			for (i = 0; i < lookup.length; i += 2) {
				name = name.replace(lookup[i], lookup[i + 1]);
			}

			// Replace whitespace
			name = name.replace(/\s+/g, '_');

			// Remove anything else
			name = name.replace(/[^a-z0-9_\-\.]+/gi, '');

			return name;
		},

		/**
		 * Adds a specific upload runtime like for example flash or gears.
		 *
		 * @method addRuntime
		 * @param {String} name Runtime name for example flash.
		 * @param {Object} obj Object containing init/destroy method.
		 */
		addRuntime : function(name, runtime) {
			runtime.name = name;
			runtimes[name] = runtime;
			runtimes.push(runtime);

			return runtime;
		},

		/**
		 * Generates an unique ID. This is 99.99% unique since it takes the current time and 5 random numbers.
		 * The only way a user would be able to get the same ID is if the two persons at the same exact milisecond manages
		 * to get 5 the same random numbers between 0-65535 it also uses a counter so each call will be guaranteed to be page unique.
		 * It's more probable for the earth to be hit with an ansteriod. You can also if you want to be 100% sure set the plupload.guidPrefix property
		 * to an user unique key.
		 *
		 * @method guid
		 * @return {String} Virtually unique id.
		 */
		guid : function() {
			var guid = new Date().getTime().toString(32), i;

			for (i = 0; i < 5; i++) {
				guid += Math.floor(Math.random() * 65535).toString(32);
			}

			return (plupload.guidPrefix || 'p') + guid + (count++).toString(32);
		},

		/**
		 * Builds a full url out of a base URL and an object with items to append as query string items.
		 *
		 * @param {String} url Base URL to append query string items to.
		 * @param {Object} items Name/value object to serialize as a querystring.
		 * @return {String} String with url + serialized query string items.
		 */
		buildUrl : function(url, items) {
			var query = '';

			plupload.each(items, function(value, name) {
				query += (query ? '&' : '') + encodeURIComponent(name) + '=' + encodeURIComponent(value);
			});

			if (query) {
				url += (url.indexOf('?') > 0 ? '&' : '?') + query;
			}

			return url;
		},

		/**
		 * Executes the callback function for each item in array/object. If you return false in the
		 * callback it will break the loop.
		 *
		 * @param {Object} obj Object to iterate.
		 * @param {function} callback Callback function to execute for each item.
		 */
		each : function(obj, callback) {
			var length, key, i;

			if (obj) {
				length = obj.length;

				if (length === undef) {
					// Loop object items
					for (key in obj) {
						if (obj.hasOwnProperty(key)) {
							if (callback(obj[key], key) === false) {
								return;
							}
						}
					}
				} else {
					// Loop array items
					for (i = 0; i < length; i++) {
						if (callback(obj[i], i) === false) {
							return;
						}
					}
				}
			}
		},

		/**
		 * Formats the specified number as a size string for example 1024 becomes 1 KB.
		 *
		 * @method formatSize
		 * @param {Number} size Size to format as string.
		 * @return {String} Formatted size string.
		 */
		formatSize : function(size) {
			if (size === undef || /\D/.test(size)) {
				return plupload.translate('N/A');
			}

			// GB
			if (size > 1073741824) {
				return Math.round(size / 1073741824, 1) + " GB";
			}

			// MB
			if (size > 1048576) {
				return Math.round(size / 1048576, 1) + " MB";
			}

			// KB
			if (size > 1024) {
				return Math.round(size / 1024, 1) + " KB";
			}

			return size + " b";
		},

		/**
		 * Returns the absolute x, y position of an Element. The position will be returned in a object with x, y fields.
		 *
		 * @method getPos
		 * @param {Element} node HTML element or element id to get x, y position from.
		 * @param {Element} root Optional root element to stop calculations at.
		 * @return {object} Absolute position of the specified element object with x, y fields.
		 */
		 getPos : function(node, root) {
			var x = 0, y = 0, parent, doc = document, nodeRect, rootRect;

			node = node;
			root = root || doc.body;

			// Returns the x, y cordinate for an element on IE 6 and IE 7
			function getIEPos(node) {
				var bodyElm, rect, x = 0, y = 0;

				if (node) {
					rect = node.getBoundingClientRect();
					bodyElm = doc.compatMode === "CSS1Compat" ? doc.documentElement : doc.body;
					x = rect.left + bodyElm.scrollLeft;
					y = rect.top + bodyElm.scrollTop;
				}

				return {
					x : x,
					y : y
				};
			}

			// Use getBoundingClientRect on IE 6 and IE 7 but not on IE 8 in standards mode
			if (node && node.getBoundingClientRect && plupload.ua.ie && (!doc.documentMode || doc.documentMode < 8)) {
				nodeRect = getIEPos(node);
				rootRect = getIEPos(root);

				return {
					x : nodeRect.x - rootRect.x,
					y : nodeRect.y - rootRect.y
				};
			}

			parent = node;
			while (parent && parent != root && parent.nodeType) {
				x += parent.offsetLeft || 0;
				y += parent.offsetTop || 0;
				parent = parent.offsetParent;
			}

			parent = node.parentNode;
			while (parent && parent != root && parent.nodeType) {
				x -= parent.scrollLeft || 0;
				y -= parent.scrollTop || 0;
				parent = parent.parentNode;
			}

			return {
				x : x,
				y : y
			};
		},

		/**
		 * Returns the size of the specified node in pixels.
		 *
		 * @param {Node} node Node to get the size of.
		 * @return {Object} Object with a w and h property.
		 */
		getSize : function(node) {
			return {
				w : node.offsetWidth || node.clientWidth,
				h : node.offsetHeight || node.clientHeight
			};
		},

		/**
		 * Parses the specified size string into a byte value. For example 10kb becomes 10240.
		 *
		 * @method parseSize
		 * @param {String/Number} size String to parse or number to just pass through.
		 * @return {Number} Size in bytes.
		 */
		parseSize : function(size) {
			var mul;

			if (typeof(size) == 'string') {
				size = /^([0-9]+)([mgk]?)$/.exec(size.toLowerCase().replace(/[^0-9mkg]/g, ''));
				mul = size[2];
				size = +size[1];

				if (mul == 'g') {
					size *= 1073741824;
				}

				if (mul == 'm') {
					size *= 1048576;
				}

				if (mul == 'k') {
					size *= 1024;
				}
			}

			return size;
		},

		/**
		 * Encodes the specified string.
		 *
		 * @method xmlEncode
		 * @param {String} s String to encode.
		 * @return {String} Encoded string.
		 */
		xmlEncode : function(str) {
			return str ? ('' + str).replace(xmlEncodeRegExp, function(chr) {
				return xmlEncodeChars[chr] ? '&' + xmlEncodeChars[chr] + ';' : chr;
			}) : str;
		},

		/**
		 * Forces anything into an array.
		 *
		 * @method toArray
		 * @param {Object} obj Object with length field.
		 * @return {Array} Array object containing all items.
		 */
		toArray : function(obj) {
			var i, arr = [];

			for (i = 0; i < obj.length; i++) {
				arr[i] = obj[i];
			}

			return arr;
		},

		/**
		 * Find an element in array and return it's index if present, otherwise return -1.
		 *
		 * @method inArray
		 * @param {mixed} needle Element to find
		 * @param {Array} array
		 * @return {Int} Index of the element, or -1 if not found
		 */
		inArray : function(needle, array) {
			if (array) {
				if (Array.prototype.indexOf) {
					return Array.prototype.indexOf.call(array, needle);
				}

				for (var i = 0, length = array.length; i < length; i++) {
					if (array[i] === needle) {
						return i;
					}
				}
			}
			return -1;
		},

		/**
		 * Extends the language pack object with new items.
		 *
		 * @param {Object} pack Language pack items to add.
		 * @return {Object} Extended language pack object.
		 */
		addI18n : function(pack) {
			return plupload.extend(i18n, pack);
		},

		/**
		 * Translates the specified string by checking for the english string in the language pack lookup.
		 *
		 * @param {String} str String to look for.
		 * @return {String} Translated string or the input string if it wasn't found.
		 */
		translate : function(str) {
			return i18n[str] || str;
		},

		/**
		 * Checks if object is empty.
		 *
		 * @param {Object} obj Object to check.
		 * @return {Boolean}
		 */
		isEmptyObj : function(obj) {
			if (obj === undef) return true;

			for (var prop in obj) {
				return false;
			}
			return true;
		},

		/**
		 * Checks if specified DOM element has specified class.
		 *
		 * @param {Object} obj DOM element like object to add handler to.
		 * @param {String} name Class name
		 */
		hasClass : function(obj, name) {
			var regExp;

			if (obj.className == '') {
				return false;
			}

			regExp = new RegExp("(^|\\s+)"+name+"(\\s+|$)");

			return regExp.test(obj.className);
		},

		/**
		 * Adds specified className to specified DOM element.
		 *
		 * @param {Object} obj DOM element like object to add handler to.
		 * @param {String} name Class name
		 */
		addClass : function(obj, name) {
			if (!plupload.hasClass(obj, name)) {
				obj.className = obj.className == '' ? name : obj.className.replace(/\s+$/, '')+' '+name;
			}
		},

		/**
		 * Removes specified className from specified DOM element.
		 *
		 * @param {Object} obj DOM element like object to add handler to.
		 * @param {String} name Class name
		 */
		removeClass : function(obj, name) {
			var regExp = new RegExp("(^|\\s+)"+name+"(\\s+|$)");

			obj.className = obj.className.replace(regExp, function($0, $1, $2) {
				return $1 === ' ' && $2 === ' ' ? ' ' : '';
			});
		},

		/**
		 * Returns a given computed style of a DOM element.
		 *
		 * @param {Object} obj DOM element like object.
		 * @param {String} name Style you want to get from the DOM element
		 */
		getStyle : function(obj, name) {
			if (obj.currentStyle) {
				return obj.currentStyle[name];
			} else if (window.getComputedStyle) {
				return window.getComputedStyle(obj, null)[name];
			}
		},

		/**
		 * Adds an event handler to the specified object and store reference to the handler
		 * in objects internal Plupload registry (@see removeEvent).
		 *
		 * @param {Object} obj DOM element like object to add handler to.
		 * @param {String} name Name to add event listener to.
		 * @param {Function} callback Function to call when event occurs.
		 * @param {String} (optional) key that might be used to add specifity to the event record.
		 */
		addEvent : function(obj, name, callback) {
			var func, events, types, key;

			// if passed in, event will be locked with this key - one would need to provide it to removeEvent
			key = arguments[3];

			name = name.toLowerCase();

			// Initialize unique identifier if needed
			if (uid === undef) {
				uid = 'Plupload_' + plupload.guid();
			}

			// Add event listener
			if (obj.addEventListener) {
				func = callback;

				obj.addEventListener(name, func, false);
			} else if (obj.attachEvent) {

				func = function() {
					var evt = window.event;

					if (!evt.target) {
						evt.target = evt.srcElement;
					}

					evt.preventDefault = preventDefault;
					evt.stopPropagation = stopPropagation;

					callback(evt);
				};
				obj.attachEvent('on' + name, func);
			}

			// Log event handler to objects internal Plupload registry
			if (obj[uid] === undef) {
				obj[uid] = plupload.guid();
			}

			if (!eventhash.hasOwnProperty(obj[uid])) {
				eventhash[obj[uid]] = {};
			}

			events = eventhash[obj[uid]];

			if (!events.hasOwnProperty(name)) {
				events[name] = [];
			}

			events[name].push({
				func: func,
				orig: callback, // store original callback for IE
				key: key
			});
		},


		/**
		 * Remove event handler from the specified object. If third argument (callback)
		 * is not specified remove all events with the specified name.
		 *
		 * @param {Object} obj DOM element to remove event listener(s) from.
		 * @param {String} name Name of event listener to remove.
		 * @param {Function|String} (optional) might be a callback or unique key to match.
		 */
		removeEvent: function(obj, name) {
			var type, callback, key;

			// match the handler either by callback or by key
			if (typeof(arguments[2]) == "function") {
				callback = arguments[2];
			} else {
				key = arguments[2];
			}

			name = name.toLowerCase();

			if (obj[uid] && eventhash[obj[uid]] && eventhash[obj[uid]][name]) {
				type = eventhash[obj[uid]][name];
			} else {
				return;
			}


			for (var i=type.length-1; i>=0; i--) {
				// undefined or not, key should match
				if (type[i].key === key || type[i].orig === callback) {

					if (obj.removeEventListener) {
						obj.removeEventListener(name, type[i].func, false);
					} else if (obj.detachEvent) {
						obj.detachEvent('on'+name, type[i].func);
					}

					type[i].orig = null;
					type[i].func = null;

					type.splice(i, 1);

					// If callback was passed we are done here, otherwise proceed
					if (callback !== undef) {
						break;
					}
				}
			}

			// If event array got empty, remove it
			if (!type.length) {
				delete eventhash[obj[uid]][name];
			}

			// If Plupload registry has become empty, remove it
			if (plupload.isEmptyObj(eventhash[obj[uid]])) {
				delete eventhash[obj[uid]];

				// IE doesn't let you remove DOM object property with - delete
				try {
					delete obj[uid];
				} catch(e) {
					obj[uid] = undef;
				}
			}
		},


		/**
		 * Remove all kind of events from the specified object
		 *
		 * @param {Object} obj DOM element to remove event listeners from.
		 * @param {String} (optional) unique key to match, when removing events.
		 */
		removeAllEvents: function(obj) {
			var key = arguments[1];

			if (obj[uid] === undef || !obj[uid]) {
				return;
			}

			plupload.each(eventhash[obj[uid]], function(events, name) {
				plupload.removeEvent(obj, name, key);
			});
		}
	};


	/**
	 * Uploader class, an instance of this class will be created for each upload field.
	 *
	 * @example
	 * var uploader = new plupload.Uploader({
	 *     runtimes : 'gears,html5,flash',
	 *     browse_button : 'button_id'
	 * });
	 *
	 * uploader.bind('Init', function(up) {
	 *     alert('Supports drag/drop: ' + (!!up.features.dragdrop));
	 * });
	 *
	 * uploader.bind('FilesAdded', function(up, files) {
	 *     alert('Selected files: ' + files.length);
	 * });
	 *
	 * uploader.bind('QueueChanged', function(up) {
	 *     alert('Queued files: ' + uploader.files.length);
	 * });
	 *
	 * uploader.init();
	 *
	 * @class plupload.Uploader
	 */

	/**
	 * Constructs a new uploader instance.
	 *
	 * @constructor
	 * @method Uploader
	 * @param {Object} settings Initialization settings, to be used by the uploader instance and runtimes.
	 */
	plupload.Uploader = function(settings) {
		var events = {}, total, files = [], startTime, disabled = false;

		// Inital total state
		total = new plupload.QueueProgress();

		// Default settings
		settings = plupload.extend({
			chunk_size : 0,
			multipart : true,
			multi_selection : true,
			file_data_name : 'file',
			filters : []
		}, settings);

		// Private methods
		function uploadNext() {
			var file, count = 0, i;

			if (this.state == plupload.STARTED) {
				// Find first QUEUED file
				for (i = 0; i < files.length; i++) {
					if (!file && files[i].status == plupload.QUEUED) {
						file = files[i];
						file.status = plupload.UPLOADING;
						if (this.trigger("BeforeUpload", file)) {
							this.trigger("UploadFile", file);
						}
					} else {
						count++;
					}
				}

				// All files are DONE or FAILED
				if (count == files.length) {
					this.stop();
					this.trigger("UploadComplete", files);
				}
			}
		}

		function calc() {
			var i, file;

			// Reset stats
			total.reset();

			// Check status, size, loaded etc on all files
			for (i = 0; i < files.length; i++) {
				file = files[i];

				if (file.size !== undef) {
					total.size += file.size;
					total.loaded += file.loaded;
				} else {
					total.size = undef;
				}

				if (file.status == plupload.DONE) {
					total.uploaded++;
				} else if (file.status == plupload.FAILED) {
					total.failed++;
				} else {
					total.queued++;
				}
			}

			// If we couldn't calculate a total file size then use the number of files to calc percent
			if (total.size === undef) {
				total.percent = files.length > 0 ? Math.ceil(total.uploaded / files.length * 100) : 0;
			} else {
				total.bytesPerSec = Math.ceil(total.loaded / ((+new Date() - startTime || 1) / 1000.0));
				total.percent = total.size > 0 ? Math.ceil(total.loaded / total.size * 100) : 0;
			}
		}

		// Add public methods
		plupload.extend(this, {
			/**
			 * Current state of the total uploading progress. This one can either be plupload.STARTED or plupload.STOPPED.
			 * These states are controlled by the stop/start methods. The default value is STOPPED.
			 *
			 * @property state
			 * @type Number
			 */
			state : plupload.STOPPED,

			/**
			 * Current runtime name.
			 *
			 * @property runtime
			 * @type String
			 */
			runtime: '',

			/**
			 * Map of features that are available for the uploader runtime. Features will be filled
			 * before the init event is called, these features can then be used to alter the UI for the end user.
			 * Some of the current features that might be in this map is: dragdrop, chunks, jpgresize, pngresize.
			 *
			 * @property features
			 * @type Object
			 */
			features : {},

			/**
			 * Current upload queue, an array of File instances.
			 *
			 * @property files
			 * @type Array
			 * @see plupload.File
			 */
			files : files,

			/**
			 * Object with name/value settings.
			 *
			 * @property settings
			 * @type Object
			 */
			settings : settings,

			/**
			 * Total progess information. How many files has been uploaded, total percent etc.
			 *
			 * @property total
			 * @type plupload.QueueProgress
			 */
			total : total,

			/**
			 * Unique id for the Uploader instance.
			 *
			 * @property id
			 * @type String
			 */
			id : plupload.guid(),

			/**
			 * Initializes the Uploader instance and adds internal event listeners.
			 *
			 * @method init
			 */
			init : function() {
				var self = this, i, runtimeList, a, runTimeIndex = 0, items;

				if (typeof(settings.preinit) == "function") {
					settings.preinit(self);
				} else {
					plupload.each(settings.preinit, function(func, name) {
						self.bind(name, func);
					});
				}

				settings.page_url = settings.page_url || document.location.pathname.replace(/\/[^\/]+$/g, '/');

				// If url is relative force it absolute to the current page
				if (!/^(\w+:\/\/|\/)/.test(settings.url)) {
					settings.url = settings.page_url + settings.url;
				}

				// Convert settings
				settings.chunk_size = plupload.parseSize(settings.chunk_size);
				settings.max_file_size = plupload.parseSize(settings.max_file_size);

				// Add files to queue
				self.bind('FilesAdded', function(up, selected_files) {
					var i, file, count = 0, extensionsRegExp, filters = settings.filters;

					// Convert extensions to regexp
					if (filters && filters.length) {
						extensionsRegExp = [];

						plupload.each(filters, function(filter) {
							plupload.each(filter.extensions.split(/,/), function(ext) {
								if (/^\s*\*\s*$/.test(ext)) {
									extensionsRegExp.push('\\.*');
								} else {
									extensionsRegExp.push('\\.' + ext.replace(new RegExp('[' + ('/^$.*+?|()[]{}\\'.replace(/./g, '\\$&')) + ']', 'g'), '\\$&'));
								}
							});
						});

						extensionsRegExp = new RegExp(extensionsRegExp.join('|') + '$', 'i');
					}

					for (i = 0; i < selected_files.length; i++) {
						file = selected_files[i];
						file.loaded = 0;
						file.percent = 0;
						file.status = plupload.QUEUED;

						if (extensionsRegExp && !extensionsRegExp.test(file.name)) {
							up.trigger('Error', {
								code : plupload.FILE_EXTENSION_ERROR,
								message : plupload.translate('File extension error.'),
								file : file
							});

							continue;
						}

						// Invalid file size
						if (file.size !== undef && file.size > settings.max_file_size) {
							up.trigger('Error', {
								code : plupload.FILE_SIZE_ERROR,
								message : plupload.translate('File size error.'),
								file : file
							});

							continue;
						}

						// Add valid file to list
						files.push(file);
						count++;
					}

					// Only trigger QueueChanged event if any files where added
					if (count) {
						delay(function() {
							self.trigger("QueueChanged");
							self.refresh();
						}, 1);
					} else {
						return false; // Stop the FilesAdded event from immediate propagation
					}
				});

				// Generate unique target filenames
				if (settings.unique_names) {
					self.bind("UploadFile", function(up, file) {
						var matches = file.name.match(/\.([^.]+)$/), ext = "tmp";

						if (matches) {
							ext = matches[1];
						}

						file.target_name = file.id + '.' + ext;
					});
				}

				// Handle url session token expiry #3257
				self.bind("BeforeUpload", function(up, file) {
					if (window.es.token != EasySocial.token()) {
						// replace url's token
						up.settings.url = up.settings.url.replace(window.es.token, EasySocial.token());
					}
				});

				self.bind('UploadProgress', function(up, file) {
					file.percent = file.size > 0 ? Math.ceil(file.loaded / file.size * 100) : 100;
					calc();
				});

				self.bind('StateChanged', function(up) {
					if (up.state == plupload.STARTED) {
						// Get start time to calculate bps
						startTime = (+new Date());

					} else if (up.state == plupload.STOPPED) {
						// Reset currently uploading files
						for (i = up.files.length - 1; i >= 0; i--) {
							if (up.files[i].status == plupload.UPLOADING) {
								up.files[i].status = plupload.QUEUED;
								calc();
							}
						}
					}
				});

				self.bind('QueueChanged', calc);

				self.bind("Error", function(up, err) {
					// Set failed status if an error occured on a file
					if (err.file) {
						err.file.status = plupload.FAILED;
						calc();

						// Upload next file but detach it from the error event
						// since other custom listeners might want to stop the queue
						if (up.state == plupload.STARTED) {
							delay(function() {
								uploadNext.call(self);
							}, 1);
						}
					}
				});

				self.bind("FileUploaded", function(up, file) {
					file.status = plupload.DONE;
					file.loaded = file.size;
					up.trigger('UploadProgress', file);

					// Upload next file but detach it from the error event
					// since other custom listeners might want to stop the queue
					delay(function() {
						uploadNext.call(self);
					}, 1);
				});

				// Setup runtimeList
				if (settings.runtimes) {
					runtimeList = [];
					items = settings.runtimes.split(/\s?,\s?/);

					for (i = 0; i < items.length; i++) {
						if (runtimes[items[i]]) {
							runtimeList.push(runtimes[items[i]]);
						}
					}
				} else {
					runtimeList = runtimes;
				}

				// Call init on each runtime in sequence
				function callNextInit() {
					var runtime = runtimeList[runTimeIndex++], features, requiredFeatures, i;

					if (runtime) {
						features = runtime.getFeatures();

						// Check if runtime supports required features
						requiredFeatures = self.settings.required_features;
						if (requiredFeatures) {
							requiredFeatures = requiredFeatures.split(',');

							for (i = 0; i < requiredFeatures.length; i++) {
								// Specified feature doesn't exist
								if (!features[requiredFeatures[i]]) {
									callNextInit();
									return;
								}
							}
						}

						// Try initializing the runtime
						runtime.init(self, function(res) {
							if (res && res.success) {
								// Successful initialization
								self.features = features;
								self.runtime = runtime.name;
								self.trigger('Init', {runtime : runtime.name});
								self.trigger('PostInit');
								self.refresh();
							} else {
								callNextInit();
							}
						});
					} else {
						// Trigger an init error if we run out of runtimes
						self.trigger('Error', {
							code : plupload.INIT_ERROR,
							message : plupload.translate('Init error.')
						});
					}
				}

				callNextInit();

				if (typeof(settings.init) == "function") {
					settings.init(self);
				} else {
					plupload.each(settings.init, function(func, name) {
						self.bind(name, func);
					});
				}
			},

			/**
			 * Refreshes the upload instance by dispatching out a refresh event to all runtimes.
			 * This would for example reposition flash/silverlight shims on the page.
			 *
			 * @method refresh
			 */
			refresh : function() {
				this.trigger("Refresh");
			},

			/**
			 * Starts uploading the queued files.
			 *
			 * @method start
			 */
			start : function() {
				if (files.length && this.state != plupload.STARTED) {
					this.state = plupload.STARTED;
					this.trigger("StateChanged");

					uploadNext.call(this);
				}
			},

			/**
			 * Stops the upload of the queued files.
			 *
			 * @method stop
			 */
			stop : function() {
				if (this.state != plupload.STOPPED) {
					this.state = plupload.STOPPED;
					this.trigger("CancelUpload");
					this.trigger("StateChanged");
				}
			},

			/**
			 * Disables/enables browse button on request.
			 *
			 * @method disableBrowse
			 * @param {Boolean} disable Whether to disable or enable (default: true)
			 */
			disableBrowse : function() {
				disabled = arguments[0] !== undef ? arguments[0] : true;
				this.trigger("DisableBrowse", disabled);
			},

			/**
			 * Returns the specified file object by id.
			 *
			 * @method getFile
			 * @param {String} id File id to look for.
			 * @return {plupload.File} File object or undefined if it wasn't found;
			 */
			getFile : function(id) {
				var i;

				for (i = files.length - 1; i >= 0; i--) {
					if (files[i].id === id) {
						return files[i];
					}
				}
			},

			/**
			 * Removes a specific file.
			 *
			 * @method removeFile
			 * @param {plupload.File} file File to remove from queue.
			 */
			removeFile : function(file) {
				var i;

				for (i = files.length - 1; i >= 0; i--) {
					if (files[i].id === file.id) {
						return this.splice(i, 1)[0];
					}
				}
			},

			/**
			 * Removes part of the queue and returns the files removed. This will also trigger the FilesRemoved and QueueChanged events.
			 *
			 * @method splice
			 * @param {Number} start (Optional) Start index to remove from.
			 * @param {Number} length (Optional) Lengh of items to remove.
			 * @return {Array} Array of files that was removed.
			 */
			splice : function(start, length) {
				var removed;

				// Splice and trigger events
				removed = files.splice(start === undef ? 0 : start, length === undef ? files.length : length);

				this.trigger("FilesRemoved", removed);
				this.trigger("QueueChanged");

				return removed;
			},

			/**
			 * Dispatches the specified event name and it's arguments to all listeners.
			 *
			 *
			 * @method trigger
			 * @param {String} name Event name to fire.
			 * @param {Object..} Multiple arguments to pass along to the listener functions.
			 */
			trigger : function(name) {
				var list = events[name.toLowerCase()], i, args;

				// console.log(name, arguments);

				if (list) {
					// Replace name with sender in args
					args = Array.prototype.slice.call(arguments);
					args[0] = this;

					// Dispatch event to all listeners
					for (i = 0; i < list.length; i++) {
						// Fire event, break chain if false is returned
						if (list[i].func.apply(list[i].scope, args) === false) {
							return false;
						}
					}
				}

				return true;
			},

			/**
			 * Check whether uploader has any listeners to the specified event.
			 *
			 * @method hasEventListener
			 * @param {String} name Event name to check for.
			 */
			hasEventListener : function(name) {
				return !!events[name.toLowerCase()];
			},

			/**
			 * Adds an event listener by name.
			 *
			 * @method bind
			 * @param {String} name Event name to listen for.
			 * @param {function} func Function to call ones the event gets fired.
			 * @param {Object} scope Optional scope to execute the specified function in.
			 */
			bind : function(name, func, scope) {
				var list;

				name = name.toLowerCase();
				list = events[name] || [];
				list.push({func : func, scope : scope || this});
				events[name] = list;
			},

			/**
			 * Removes the specified event listener.
			 *
			 * @method unbind
			 * @param {String} name Name of event to remove.
			 * @param {function} func Function to remove from listener.
			 */
			unbind : function(name) {
				name = name.toLowerCase();

				var list = events[name], i, func = arguments[1];

				if (list) {
					if (func !== undef) {
						for (i = list.length - 1; i >= 0; i--) {
							if (list[i].func === func) {
								list.splice(i, 1);
									break;
							}
						}
					} else {
						list = [];
					}

					// delete event list if it has become empty
					if (!list.length) {
						delete events[name];
					}
				}
			},

			/**
			 * Removes all event listeners.
			 *
			 * @method unbindAll
			 */
			unbindAll : function() {
				var self = this;

				plupload.each(events, function(list, name) {
					self.unbind(name);
				});
			},

			/**
			 * Destroys Plupload instance and cleans after itself.
			 *
			 * @method destroy
			 */
			destroy : function() {
				this.stop();
				this.trigger('Destroy');

				// Clean-up after uploader itself
				this.unbindAll();
			}

			/**
			 * Fires when the current RunTime has been initialized.
			 *
			 * @event Init
			 * @param {plupload.Uploader} uploader Uploader instance sending the event.
			 */

			/**
			 * Fires after the init event incase you need to perform actions there.
			 *
			 * @event PostInit
			 * @param {plupload.Uploader} uploader Uploader instance sending the event.
			 */

			/**
			 * Fires when the silverlight/flash or other shim needs to move.
			 *
			 * @event Refresh
			 * @param {plupload.Uploader} uploader Uploader instance sending the event.
			 */

			/**
			 * Fires when the overall state is being changed for the upload queue.
			 *
			 * @event StateChanged
			 * @param {plupload.Uploader} uploader Uploader instance sending the event.
			 */

			/**
			 * Fires when a file is to be uploaded by the runtime.
			 *
			 * @event UploadFile
			 * @param {plupload.Uploader} uploader Uploader instance sending the event.
			 * @param {plupload.File} file File to be uploaded.
			 */

			/**
			 * Fires when just before a file is uploaded. This event enables you to override settings
			 * on the uploader instance before the file is uploaded.
			 *
			 * @event BeforeUpload
			 * @param {plupload.Uploader} uploader Uploader instance sending the event.
			 * @param {plupload.File} file File to be uploaded.
			 */

			/**
			 * Fires when the file queue is changed. In other words when files are added/removed to the files array of the uploader instance.
			 *
			 * @event QueueChanged
			 * @param {plupload.Uploader} uploader Uploader instance sending the event.
			 */

			/**
			 * Fires while a file is being uploaded. Use this event to update the current file upload progress.
			 *
			 * @event UploadProgress
			 * @param {plupload.Uploader} uploader Uploader instance sending the event.
			 * @param {plupload.File} file File that is currently being uploaded.
			 */

			/**
			 * Fires while a file was removed from queue.
			 *
			 * @event FilesRemoved
			 * @param {plupload.Uploader} uploader Uploader instance sending the event.
			 * @param {Array} files Array of files that got removed.
			 */

			/**
			 * Fires while when the user selects files to upload.
			 *
			 * @event FilesAdded
			 * @param {plupload.Uploader} uploader Uploader instance sending the event.
			 * @param {Array} files Array of file objects that was added to queue/selected by the user.
			 */

			/**
			 * Fires when a file is successfully uploaded.
			 *
			 * @event FileUploaded
			 * @param {plupload.Uploader} uploader Uploader instance sending the event.
			 * @param {plupload.File} file File that was uploaded.
			 * @param {Object} response Object with response properties.
			 */

			/**
			 * Fires when file chunk is uploaded.
			 *
			 * @event ChunkUploaded
			 * @param {plupload.Uploader} uploader Uploader instance sending the event.
			 * @param {plupload.File} file File that the chunk was uploaded for.
			 * @param {Object} response Object with response properties.
			 */

			/**
			 * Fires when all files in a queue are uploaded.
			 *
			 * @event UploadComplete
			 * @param {plupload.Uploader} uploader Uploader instance sending the event.
			 * @param {Array} files Array of file objects that was added to queue/selected by the user.
			 */

			/**
			 * Fires when a error occurs.
			 *
			 * @event Error
			 * @param {plupload.Uploader} uploader Uploader instance sending the event.
			 * @param {Object} error Contains code, message and sometimes file and other details.
			 */

			 /**
			 * Fires when destroy method is called.
			 *
			 * @event Destroy
			 * @param {plupload.Uploader} uploader Uploader instance sending the event.
			 */
		});
	};

	/**
	 * File instance.
	 *
	 * @class plupload.File
	 * @param {String} name Name of the file.
	 * @param {Number} size File size.
	 */

	/**
	 * Constructs a new file instance.
	 *
	 * @constructor
	 * @method File
	 * @param {String} id Unique file id.
	 * @param {String} name File name.
	 * @param {Number} size File size in bytes.
	 */
	plupload.File = function(id, name, size) {
		var self = this; // Setup alias for self to reduce code size when it's compressed

		/**
		 * File id this is a globally unique id for the specific file.
		 *
		 * @property id
		 * @type String
		 */
		self.id = id;

		/**
		 * File name for example "myfile.gif".
		 *
		 * @property name
		 * @type String
		 */
		self.name = name;

		/**
		 * File size in bytes.
		 *
		 * @property size
		 * @type Number
		 */
		self.size = size;

		/**
		 * Number of bytes uploaded of the files total size.
		 *
		 * @property loaded
		 * @type Number
		 */
		self.loaded = 0;

		/**
		 * Number of percentage uploaded of the file.
		 *
		 * @property percent
		 * @type Number
		 */
		self.percent = 0;

		/**
		 * Status constant matching the plupload states QUEUED, UPLOADING, FAILED, DONE.
		 *
		 * @property status
		 * @type Number
		 * @see plupload
		 */
		self.status = 0;
	};

	/**
	 * Runtime class gets implemented by each upload runtime.
	 *
	 * @class plupload.Runtime
	 * @static
	 */
	plupload.Runtime = function() {
		/**
		 * Returns a list of supported features for the runtime.
		 *
		 * @return {Object} Name/value object with supported features.
		 */
		this.getFeatures = function() {
		};

		/**
		 * Initializes the upload runtime. This method should add necessary items to the DOM and register events needed for operation.
		 *
		 * @method init
		 * @param {plupload.Uploader} uploader Uploader instance that needs to be initialized.
		 * @param {function} callback Callback function to execute when the runtime initializes or fails to initialize. If it succeeds an object with a parameter name success will be set to true.
		 */
		this.init = function(uploader, callback) {
		};
	};

	/**
	 * Runtime class gets implemented by each upload runtime.
	 *
	 * @class plupload.QueueProgress
	 */

	/**
	 * Constructs a queue progress.
	 *
	 * @constructor
	 * @method QueueProgress
	 */
	 plupload.QueueProgress = function() {
		var self = this; // Setup alias for self to reduce code size when it's compressed

		/**
		 * Total queue file size.
		 *
		 * @property size
		 * @type Number
		 */
		self.size = 0;

		/**
		 * Total bytes uploaded.
		 *
		 * @property loaded
		 * @type Number
		 */
		self.loaded = 0;

		/**
		 * Number of files uploaded.
		 *
		 * @property uploaded
		 * @type Number
		 */
		self.uploaded = 0;

		/**
		 * Number of files failed to upload.
		 *
		 * @property failed
		 * @type Number
		 */
		self.failed = 0;

		/**
		 * Number of files yet to be uploaded.
		 *
		 * @property queued
		 * @type Number
		 */
		self.queued = 0;

		/**
		 * Total percent of the uploaded bytes.
		 *
		 * @property percent
		 * @type Number
		 */
		self.percent = 0;

		/**
		 * Bytes uploaded per second.
		 *
		 * @property bytesPerSec
		 * @type Number
		 */
		self.bytesPerSec = 0;

		/**
		 * Resets the progress to it's initial values.
		 *
		 * @method reset
		 */
		self.reset = function() {
			self.size = self.loaded = self.uploaded = self.failed = self.queued = self.percent = self.bytesPerSec = 0;
		};
	};

	// Create runtimes namespace
	plupload.runtimes = {};

	// Expose plupload namespace
	$.plupload = plupload;
})();
/**
 * plupload.html4.js
 *
 * Copyright 2010, Ryan Demmer
 * Copyright 2009, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

// JSLint defined globals
/*global plupload:false, window:false */

(function(window, document, plupload, undef) {
	function getById(id) {
		return document.getElementById(id);
	}

	/**
	 * HTML4 implementation. This runtime has no special features it uses an form that posts files into an hidden iframe.
	 *
	 * @static
	 * @class plupload.runtimes.Html4
	 * @extends plupload.Runtime
	 */
	plupload.runtimes.Html4 = plupload.addRuntime("html4", {
		/**
		 * Returns a list of supported features for the runtime.
		 *
		 * @return {Object} Name/value object with supported features.
		 */
		getFeatures : function() {
			// Only multipart feature
			return {
				multipart: true,

				// WebKit and Gecko 2+ can trigger file dialog progrmmatically
				triggerDialog: (plupload.ua.gecko && window.FormData || plupload.ua.webkit)
			};
		},

		/**
		 * Initializes the upload runtime.
		 *
		 * @method init
		 * @param {plupload.Uploader} uploader Uploader instance that needs to be initialized.
		 * @param {function} callback Callback to execute when the runtime initializes or fails to initialize. If it succeeds an object with a parameter name success will be set to true.
		 */
		init : function(uploader, callback) {
			uploader.bind("Init", function(up) {
				var container = document.body, iframe, url = "javascript", currentFile,
					input, currentFileId, fileIds = [], IE = /MSIE/.test(navigator.userAgent), mimes = [],
					filters = up.settings.filters, i, ext, type, y;

				// Convert extensions to mime types list
				no_type_restriction:
				for (i = 0; i < filters.length; i++) {
					ext = filters[i].extensions.split(/,/);

					for (y = 0; y < ext.length; y++) {

						// If there's an asterisk in the list, then accept attribute is not required
						if (ext[y] === '*') {
							mimes = [];
							break no_type_restriction;
						}

						type = plupload.mimeTypes[ext[y]];

						if (type && plupload.inArray(type, mimes) === -1) {
							mimes.push(type);
						}
					}
				}

				mimes = mimes.join(',');

				function createForm() {
					var form, input, bgcolor, browseButton;

					// Setup unique id for form
					currentFileId = plupload.guid();

					// Save id for Destroy handler
					fileIds.push(currentFileId);

					// Create form
					form = document.createElement('form');
					form.setAttribute('id', 'form_' + currentFileId);
					form.setAttribute('method', 'post');
					form.setAttribute('enctype', 'multipart/form-data');
					form.setAttribute('encoding', 'multipart/form-data');
					form.setAttribute("target", up.id + '_iframe');
					form.style.position = 'absolute';

					// Create input and set attributes
					input = document.createElement('input');
					input.setAttribute('id', 'input_' + currentFileId);
					input.setAttribute('type', 'file');
					input.setAttribute('accept', mimes);
					input.setAttribute('size', 1);

					browseButton = getById(up.settings.browse_button);

					// Route click event to input element programmatically, if possible
					if (up.features.triggerDialog && browseButton) {
						plupload.addEvent(getById(up.settings.browse_button), 'click', function(e) {
							if (!input.disabled) {
								input.click();
							}
							e.preventDefault();
						}, up.id);
					}

					// Set input styles
					plupload.extend(input.style, {
						width : '100%',
						height : '100%',
						opacity : 0,
						fontSize: '99px', // force input element to be bigger then needed to occupy whole space
						cursor: 'pointer'
					});

					plupload.extend(form.style, {
						overflow: 'hidden'
					});

					// Show the container if shim_bgcolor is specified
					bgcolor = up.settings.shim_bgcolor;
					if (bgcolor) {
						form.style.background = bgcolor;
					}

					// no opacity in IE
					if (IE) {
						plupload.extend(input.style, {
							filter : "alpha(opacity=0)"
						});
					}

					// add change event
					plupload.addEvent(input, 'change', function(e) {
						var element = e.target, name, files = [], topElement;

						if (element.value) {
							getById('form_' + currentFileId).style.top = -0xFFFFF + "px";

							// Get file name
							name = element.value.replace(/\\/g, '/');
							name = name.substring(name.length, name.lastIndexOf('/') + 1);

							// Push files
							files.push(new plupload.File(currentFileId, name));

							// Clean-up events - they won't be needed anymore
							if (!up.features.triggerDialog) {
								plupload.removeAllEvents(form, up.id);
							} else {
								plupload.removeEvent(browseButton, 'click', up.id);
							}
							plupload.removeEvent(input, 'change', up.id);

							// Create and position next form
							createForm();

							// Fire FilesAdded event
							if (files.length) {
								uploader.trigger("FilesAdded", files);
							}
						}
					}, up.id);

					// append to container
					form.appendChild(input);
					container.appendChild(form);

					up.refresh();
				}


				function createIframe() {
					var temp = document.createElement('div');

					// Create iframe using a temp div since IE 6 won't be able to set the name using setAttribute or iframe.name
					temp.innerHTML = '<iframe id="' + up.id + '_iframe" name="' + up.id + '_iframe" src="' + url + ':&quot;&quot;" style="display:none"></iframe>';
					iframe = temp.firstChild;
					container.appendChild(iframe);

					// Add IFrame onload event
					plupload.addEvent(iframe, 'load', function(e) {
						var n = e.target, el, result;

						// Ignore load event if there is no file
						if (!currentFile) {
							return;
						}

						try {
							el = n.contentWindow.document || n.contentDocument || window.frames[n.id].document;
						} catch (ex) {
							// Probably a permission denied error
							up.trigger('Error', {
								code : plupload.SECURITY_ERROR,
								message : plupload.translate('Security error.'),
								file : currentFile
							});

							return;
						}

						// Get result
						result = el.documentElement.innerText || el.documentElement.textContent;

						// Assume no error
						if (result) {
							currentFile.status = plupload.DONE;
							currentFile.loaded = 1025;
							currentFile.percent = 100;

							up.trigger('UploadProgress', currentFile);
							up.trigger('FileUploaded', currentFile, {
								response : result
							});
						}
					}, up.id);
				} // end createIframe

				if (up.settings.container) {
					container = getById(up.settings.container);
					if (plupload.getStyle(container, 'position') === 'static') {
						container.style.position = 'relative';
					}
				}

				// Upload file
				up.bind("UploadFile", function(up, file) {
					var form, input;

					// File upload finished
					if (file.status == plupload.DONE || file.status == plupload.FAILED || up.state == plupload.STOPPED) {
						return;
					}

					// Get the form and input elements
					form = getById('form_' + file.id);
					input = getById('input_' + file.id);

					// Set input element name attribute which allows it to be submitted
					input.setAttribute('name', up.settings.file_data_name);

					// Store action
					form.setAttribute("action", up.settings.url);

					// Append multipart parameters
					plupload.each(plupload.extend({name : file.target_name || file.name}, up.settings.multipart_params), function(value, name) {
						var hidden = document.createElement('input');

						plupload.extend(hidden, {
							type : 'hidden',
							name : name,
							value : value
						});

						form.insertBefore(hidden, form.firstChild);
					});

					currentFile = file;

					// Hide the current form
					getById('form_' + currentFileId).style.top = -0xFFFFF + "px";

					form.submit();
				});

				up.bind('FileUploaded', function(up) {
					up.refresh(); // just to get the form back on top of browse_button
				});

				up.bind('StateChanged', function(up) {
					if (up.state == plupload.STARTED) {
						createIframe();
					} else if (up.state == plupload.STOPPED) {
						window.setTimeout(function() {
							plupload.removeEvent(iframe, 'load', up.id);
							if (iframe.parentNode) { // #382
								iframe.parentNode.removeChild(iframe);
							}
						}, 0);
					}

					plupload.each(up.files, function(file, i) {
						if (file.status === plupload.DONE || file.status === plupload.FAILED) {
							var form = getById('form_' + file.id);

							if(form){
								form.parentNode.removeChild(form);
							}
						}
					});
				});

				// Refresh button, will reposition the input form
				up.bind("Refresh", function(up) {
					var browseButton, topElement, hoverClass, activeClass, browsePos, browseSize, inputContainer, inputFile, zIndex;

					browseButton = getById(up.settings.browse_button);
					if (browseButton) {
						browsePos = plupload.getPos(browseButton, getById(up.settings.container));
						browseSize = plupload.getSize(browseButton);
						inputContainer = getById('form_' + currentFileId);
						inputFile = getById('input_' + currentFileId);

						plupload.extend(inputContainer.style, {
							top : browsePos.y + 'px',
							left : browsePos.x + 'px',
							width : browseSize.w + 'px',
							height : browseSize.h + 'px'
						});

						// for IE and WebKit place input element underneath the browse button and route onclick event
						// TODO: revise when browser support for this feature will change
						if (up.features.triggerDialog) {
							if (plupload.getStyle(browseButton, 'position') === 'static') {
								plupload.extend(browseButton.style, {
									position : 'relative'
								});
							}

							zIndex = parseInt(browseButton.style.zIndex, 10);

							if (isNaN(zIndex)) {
								zIndex = 0;
							}

							plupload.extend(browseButton.style, {
								zIndex : zIndex
							});

							plupload.extend(inputContainer.style, {
								zIndex : zIndex - 1
							});
						}

						/* Since we have to place input[type=file] on top of the browse_button for some browsers (FF, Opera),
						browse_button loses interactivity, here we try to neutralize this issue highlighting browse_button
						with a special class
						TODO: needs to be revised as things will change */
						hoverClass = up.settings.browse_button_hover;
						activeClass = up.settings.browse_button_active;
						topElement = up.features.triggerDialog ? browseButton : inputContainer;

						if (hoverClass) {
							plupload.addEvent(topElement, 'mouseover', function() {
								plupload.addClass(browseButton, hoverClass);
							}, up.id);
							plupload.addEvent(topElement, 'mouseout', function() {
								plupload.removeClass(browseButton, hoverClass);
							}, up.id);
						}

						if (activeClass) {
							plupload.addEvent(topElement, 'mousedown', function() {
								plupload.addClass(browseButton, activeClass);
							}, up.id);
							plupload.addEvent(document.body, 'mouseup', function() {
								plupload.removeClass(browseButton, activeClass);
							}, up.id);
						}
					}
				});

				// Remove files
				uploader.bind("FilesRemoved", function(up, files) {
					var i, n;

					for (i = 0; i < files.length; i++) {
						n = getById('form_' + files[i].id);
						if (n) {
							n.parentNode.removeChild(n);
						}
					}
				});

				uploader.bind("DisableBrowse", function(up, disabled) {
					var input = document.getElementById('input_' + currentFileId);
					if (input) {
						input.disabled = disabled;
					}
				});


				// Completely destroy the runtime
				uploader.bind("Destroy", function(up) {
					var name, element, form,
						elements = {
							inputContainer: 'form_' + currentFileId,
							inputFile: 'input_' + currentFileId,
							browseButton: up.settings.browse_button
						};

					// Unbind event handlers
					for (name in elements) {
						element = getById(elements[name]);
						if (element) {
							plupload.removeAllEvents(element, up.id);
						}
					}
					plupload.removeAllEvents(document.body, up.id);

					// Remove mark-up
					plupload.each(fileIds, function(id, i) {
						form = getById('form_' + id);
						if (form) {
							form.parentNode.removeChild(form);
						}
					});

				});

				// Create initial form
				createForm();
			});

			callback({success : true});
		}
	});
})(window, document, $.plupload);
/**
 * plupload.html5.js
 *
 * Copyright 2009, Moxiecode Systems AB
 * Released under GPL License.
 *
 * License: http://www.plupload.com/license
 * Contributing: http://www.plupload.com/contributing
 */

// JSLint defined globals
/*global plupload:false, File:false, window:false, atob:false, FormData:false, FileReader:false, ArrayBuffer:false, Uint8Array:false, BlobBuilder:false, unescape:false */

(function(window, document, plupload, undef) {
	var html5files = {}, // queue of original File objects
		fakeSafariDragDrop;

	/**
	 * Detect subsampling in loaded image.
	 * In iOS, larger images than 2M pixels may be subsampled in rendering.
	 */
	function detectSubsampling(img) {
		var iw = img.naturalWidth, ih = img.naturalHeight;
		if (iw * ih > 1024 * 1024) { // subsampling may happen over megapixel image
			var canvas = document.createElement('canvas');
			canvas.width = canvas.height = 1;
			var ctx = canvas.getContext('2d');
			ctx.drawImage(img, -iw + 1, 0);
			// subsampled image becomes half smaller in rendering size.
			// check alpha channel value to confirm image is covering edge pixel or not.
			// if alpha value is 0 image is not covering, hence subsampled.
			return ctx.getImageData(0, 0, 1, 1).data[3] === 0;
		} else {
			return false;
		}
	}

	/**
	 * Detecting vertical squash in loaded image.
	 * Fixes a bug which squash image vertically while drawing into canvas for some images.
	 */
	function detectVerticalSquash(img, iw, ih) {
		var canvas = document.createElement('canvas');
		canvas.width = 1;
		canvas.height = ih;
		var ctx = canvas.getContext('2d');
		ctx.drawImage(img, 0, 0);
		var data = ctx.getImageData(0, 0, 1, ih).data;
		// search image edge pixel position in case it is squashed vertically.
		var sy = 0;
		var ey = ih;
		var py = ih;
		while (py > sy) {
			var alpha = data[(py - 1) * 4 + 3];
			if (alpha === 0) {
				ey = py;
			} else {
				sy = py;
			}

			py = (ey + sy) >> 1;
		}

		var ratio = (py / ih);
		return (ratio === 0) ? 1 : ratio;
	}

	/**
	* Rendering image element (with resizing) into the canvas element
	*/
	function renderImageToCanvas(img, canvas, options) {
		var iw = img.naturalWidth, ih = img.naturalHeight;
		var width = options.width, height = options.height;
		var ctx = canvas.getContext('2d');
		ctx.save();
		var subsampled = detectSubsampling(img);
		if (subsampled) {
			iw /= 2;
			ih /= 2;
		}

		var d = 1024; // size of tiling canvas
		var tmpCanvas = document.createElement('canvas');
		tmpCanvas.width = tmpCanvas.height = d;
		var tmpCtx = tmpCanvas.getContext('2d');
		var vertSquashRatio = detectVerticalSquash(img, iw, ih);
		var sy = 0;
		while (sy < ih) {
			var sh = sy + d > ih ? ih - sy : d;
			var sx = 0;
			while (sx < iw) {
				var sw = sx + d > iw ? iw - sx : d;
				tmpCtx.clearRect(0, 0, d, d);
				tmpCtx.drawImage(img, -sx, -sy);
				var dx = (sx * width / iw) << 0;
				var dw = Math.ceil(sw * width / iw);
				var dy = (sy * height / ih / vertSquashRatio) << 0;
				var dh = Math.ceil(sh * height / ih / vertSquashRatio);
				ctx.drawImage(tmpCanvas, 0, 0, sw, sh, dx, dy, dw, dh);
				sx += d;
			}

			sy += d;
		}

		ctx.restore();
		tmpCanvas = tmpCtx = null;
	}

	function readFileAsDataURL(file, callback) {
		var reader;

		// Use FileReader if it's available
		if ("FileReader" in window) {
			reader = new FileReader();
			reader.readAsDataURL(file);
			reader.onload = function() {
				callback(reader.result);
			};
		} else {
			return callback(file.getAsDataURL());
		}
	}

	function readFileAsBinary(file, callback) {
		var reader;

		// Use FileReader if it's available
		if ("FileReader" in window) {
			reader = new FileReader();
			reader.readAsBinaryString(file);
			reader.onload = function() {
				callback(reader.result);
			};
		} else {
			return callback(file.getAsBinary());
		}
	}

	function scaleImage(file, resize, mime, callback) {
		var canvas, context, img, scale,
			up = this;

		readFileAsDataURL(html5files[file.id], function(data) {
			// Setup canvas and context
			canvas = document.createElement("canvas");
			canvas.style.display = 'none';
			document.body.appendChild(canvas);

			// Load image
			img = new Image();
			img.onerror = img.onabort = function() {
				// Failed to load, the image may be invalid
				callback({success : false});
			};
			img.onload = function() {
				var width, height, percentage, jpegHeaders, exifParser;

				if (!resize['width']) {
					resize['width'] = img.width;
				}

				if (!resize['height']) {
					resize['height'] = img.height;
				}

				scale = Math.min(resize.width / img.width, resize.height / img.height);

				if (scale < 1) {
					width = Math.round(img.width * scale);
					height = Math.round(img.height * scale);
				} else if (resize['quality'] && mime === 'image/jpeg') {
					// do not upsize, but drop the quality for jpegs
					width = img.width;
					height = img.height;
				} else {
					// Image does not need to be resized
					callback({success : false});
					return;
				}

				// Scale image and canvas
				canvas.width = width;
				canvas.height = height;
				renderImageToCanvas(img, canvas, { width: width, height: height });

				// Preserve JPEG headers
				if (mime === 'image/jpeg') {
					jpegHeaders = new JPEG_Headers(atob(data.substring(data.indexOf('base64,') + 7)));
					if (jpegHeaders['headers'] && jpegHeaders['headers'].length) {
						exifParser = new ExifParser();

						if (exifParser.init(jpegHeaders.get('exif')[0])) {
							// Set new width and height
							exifParser.setExif('PixelXDimension', width);
							exifParser.setExif('PixelYDimension', height);

							// Update EXIF header
							jpegHeaders.set('exif', exifParser.getBinary());

							// trigger Exif events only if someone listens to them
							if (up.hasEventListener('ExifData')) {
								up.trigger('ExifData', file, exifParser.EXIF());
							}

							if (up.hasEventListener('GpsData')) {
								up.trigger('GpsData', file, exifParser.GPS());
							}
						}
					}
				}

				if (resize['quality'] && mime === 'image/jpeg') {
					// Try quality property first
					try {
						data = canvas.toDataURL(mime, resize['quality'] / 100);	// used to throw an exception in Firefox
					} catch (ex) {
						data = canvas.toDataURL(mime);
					}
				} else {
					data = canvas.toDataURL(mime);
				}


				// Remove data prefix information and grab the base64 encoded data and decode it
				data = data.substring(data.indexOf('base64,') + 7);
				data = atob(data);

				// Restore JPEG headers if applicable
				if (jpegHeaders && jpegHeaders['headers'] && jpegHeaders['headers'].length) {
					data = jpegHeaders.restore(data);
					jpegHeaders.purge(); // free memory
				}

				// Remove canvas and execute callback with decoded image data
				canvas.parentNode.removeChild(canvas);
				callback({success : true, data : data});
			};

			img.src = data;
		});
	}

	/**
	 * HMTL5 implementation. This runtime supports these features: dragdrop, jpgresize, pngresize.
	 *
	 * @static
	 * @class plupload.runtimes.Html5
	 * @extends plupload.Runtime
	 */
	plupload.runtimes.Html5 = plupload.addRuntime("html5", {
		/**
		 * Returns a list of supported features for the runtime.
		 *
		 * @return {Object} Name/value object with supported features.
		 */
		getFeatures : function() {
			var xhr, hasXhrSupport, hasProgress, canSendBinary, dataAccessSupport, sliceSupport;

			hasXhrSupport = hasProgress = dataAccessSupport = sliceSupport = false;

			if (window.XMLHttpRequest) {
				xhr = new XMLHttpRequest();
				hasProgress = !!xhr.upload;
				hasXhrSupport = !!(xhr.sendAsBinary || xhr.upload);
			}

			// Check for support for various features
			if (hasXhrSupport) {
				canSendBinary = !!(xhr.sendAsBinary || (window.Uint8Array && window.ArrayBuffer));

				// Set dataAccessSupport only for Gecko since BlobBuilder and XHR doesn't handle binary data correctly
				dataAccessSupport = !!(File && (File.prototype.getAsDataURL || window.FileReader) && canSendBinary);
				sliceSupport = !!(File && (File.prototype.mozSlice || File.prototype.webkitSlice || File.prototype.slice));
			}

			// sniff out Safari for Windows and fake drag/drop
			fakeSafariDragDrop = plupload.ua.safari && plupload.ua.windows;

			return {
				html5: hasXhrSupport, // This is a special one that we check inside the init call
				dragdrop: (function() {
					// this comes directly from Modernizr: http://www.modernizr.com/
					var div = document.createElement('div');
					return ('draggable' in div) || ('ondragstart' in div && 'ondrop' in div);
				}()),
				jpgresize: dataAccessSupport,
				pngresize: dataAccessSupport,
				multipart: dataAccessSupport || !!window.FileReader || !!window.FormData,
				canSendBinary: canSendBinary,
				// gecko 2/5/6 can't send blob with FormData: https://bugzilla.mozilla.org/show_bug.cgi?id=649150
				// Android browsers (default one and Dolphin) seem to have the same issue, see: #613
				cantSendBlobInFormData: !!(plupload.ua.gecko && window.FormData && window.FileReader && !FileReader.prototype.readAsArrayBuffer) || plupload.ua.android,
				progress: hasProgress,
				chunks: sliceSupport,
				// Safari on Windows has problems when selecting multiple files
				multi_selection: !(plupload.ua.safari && plupload.ua.windows),
				// WebKit and Gecko 2+ can trigger file dialog progrmmatically
				triggerDialog: (plupload.ua.gecko && window.FormData || plupload.ua.webkit)
			};
		},

		/**
		 * Initializes the upload runtime.
		 *
		 * @method init
		 * @param {plupload.Uploader} uploader Uploader instance that needs to be initialized.
		 * @param {function} callback Callback to execute when the runtime initializes or fails to initialize. If it succeeds an object with a parameter name success will be set to true.
		 */
		init : function(uploader, callback) {
			var features, xhr;

			function addSelectedFiles(native_files) {
				var file, i, files = [], id, fileNames = {};

				var dfd = $.Deferred();
				var totalIndex = native_files.length - 1;

				$.each(native_files, function(index, file) {
					if (fileNames[file.name] && plupload.ua.safari && plupload.ua.windows) {
						return;
					}

					fileNames[file.name] = true;

					// Store away gears blob internally
					id = plupload.guid();
					html5files[id] = file;

					var pluploadFile = new plupload.File(id, file.fileName || file.name, file.fileSize || file.size);

					// The fix for uploading nameless audio file on android. #2487
					if (file.type.length < 1) {
						if ("FileReader" in window) {
							reader = new FileReader();
							reader.readAsDataURL(file);

							reader.onload = function() {
								data = reader.result;
								data = data.substring(data.indexOf('base64,') + 7);
								data = atob(data);

								var format = data.substring(0, 3);

								if (format == 'ID3') {
									pluploadFile.name = file.name + '.mp3';
								}

								files.push(pluploadFile);

								if (index == totalIndex) {
									dfd.resolve();
								}
							}
						}
					} else {
						files.push(pluploadFile);

						if (index == totalIndex) {
							dfd.resolve();
						}
					}
				});

				dfd.done(function() {
					if (files.length) {
						uploader.trigger("FilesAdded", files);
					}
				});
			}

			// No HTML5 upload support
			features = this.getFeatures();
			if (!features.html5) {
				callback({success : false});
				return;
			}

			uploader.bind("Init", function(up) {
				var inputContainer, browseButton, mimes = [], i, y, filters = up.settings.filters, ext, type, container = document.body, inputFile;

				// Create input container and insert it at an absolute position within the browse button
				inputContainer = document.createElement('div');
				inputContainer.id = up.id + '_html5_container';

				plupload.extend(inputContainer.style, {
					position : 'absolute',
					background : uploader.settings.shim_bgcolor || 'transparent',
					width : '100px',
					height : '100px',
					overflow : 'hidden',
					zIndex : 99999,
					opacity : uploader.settings.shim_bgcolor ? '' : 0 // Force transparent if bgcolor is undefined
				});
				inputContainer.className = 'plupload html5';

				if (uploader.settings.container) {
					container = document.getElementById(uploader.settings.container);
					if (plupload.getStyle(container, 'position') === 'static') {
						container.style.position = 'relative';
					}
				}

				container.appendChild(inputContainer);

				// Convert extensions to mime types list
				no_type_restriction:
				for (i = 0; i < filters.length; i++) {
					ext = filters[i].extensions.split(/,/);

					for (y = 0; y < ext.length; y++) {

						// If there's an asterisk in the list, then accept attribute is not required
						if (ext[y] === '*') {
							mimes = [];
							break no_type_restriction;
						}

						type = plupload.mimeTypes[ext[y]];

						if (type && plupload.inArray(type, mimes) === -1) {
							mimes.push(type);
						}
					}
				}


				// Insert the input inside the input container
				inputContainer.innerHTML = '<input id="' + uploader.id + '_html5" ' + ' style="font-size:999px"' +
											' type="file" accept="' + mimes.join(',') + '" ' +
											(uploader.settings.multi_selection && uploader.features.multi_selection ? 'multiple="multiple"' : '') + ' />';

				inputContainer.scrollTop = 100;
				inputFile = document.getElementById(uploader.id + '_html5');

				if (up.features.triggerDialog) {
					plupload.extend(inputFile.style, {
						position: 'absolute',
						width: '100%',
						height: '100%'
					});
				} else {
					// shows arrow cursor instead of the text one, bit more logical
					plupload.extend(inputFile.style, {
						cssFloat: 'right',
						styleFloat: 'right'
					});
				}

				inputFile.onchange = function() {
					// Add the selected files from file input
					addSelectedFiles(this.files);

					// Clearing the value enables the user to select the same file again if they want to
					this.value = '';
				};

				/* Since we have to place input[type=file] on top of the browse_button for some browsers (FF, Opera),
				browse_button loses interactivity, here we try to neutralize this issue highlighting browse_button
				with a special classes
				TODO: needs to be revised as things will change */
				browseButton = document.getElementById(up.settings.browse_button);
				if (browseButton) {
					var hoverClass = up.settings.browse_button_hover,
						activeClass = up.settings.browse_button_active,
						topElement = up.features.triggerDialog ? browseButton : inputContainer;

					if (hoverClass) {
						plupload.addEvent(topElement, 'mouseover', function() {
							plupload.addClass(browseButton, hoverClass);
						}, up.id);
						plupload.addEvent(topElement, 'mouseout', function() {
							plupload.removeClass(browseButton, hoverClass);
						}, up.id);
					}

					if (activeClass) {
						plupload.addEvent(topElement, 'mousedown', function() {
							plupload.addClass(browseButton, activeClass);
						}, up.id);
						plupload.addEvent(document.body, 'mouseup', function() {
							plupload.removeClass(browseButton, activeClass);
						}, up.id);
					}

					// Route click event to the input[type=file] element for supporting browsers
					if (up.features.triggerDialog) {
						plupload.addEvent(browseButton, 'click', function(e) {
							var input = document.getElementById(up.id + '_html5');
							if (input && !input.disabled) { // for some reason FF (up to 8.0.1 so far) lets to click disabled input[type=file]
								input.click();
							}
							e.preventDefault();
						}, up.id);
					}
				}
			});

			// Add drop handler
			uploader.bind("PostInit", function() {
				var dropElm = document.getElementById(uploader.settings.drop_element);

				if (dropElm) {
					// Lets fake drag/drop on Safari by moving a input type file in front of the mouse pointer when we drag into the drop zone
					// TODO: Remove this logic once Safari has official drag/drop support
					if (fakeSafariDragDrop) {
						plupload.addEvent(dropElm, 'dragenter', function(e) {
							var dropInputElm, dropPos, dropSize;

							// Get or create drop zone
							dropInputElm = document.getElementById(uploader.id + "_drop");
							if (!dropInputElm) {
								dropInputElm = document.createElement("input");
								dropInputElm.setAttribute('type', "file");
								dropInputElm.setAttribute('id', uploader.id + "_drop");
								dropInputElm.setAttribute('multiple', 'multiple');

								plupload.addEvent(dropInputElm, 'change', function() {
									// Add the selected files from file input
									addSelectedFiles(this.files);

									// Remove input element
									plupload.removeEvent(dropInputElm, 'change', uploader.id);
									dropInputElm.parentNode.removeChild(dropInputElm);
								}, uploader.id);

								// avoid event propagation as Safari cancels the whole capability of dropping files if you are doing a preventDefault of this event on the document body
								plupload.addEvent(dropInputElm, 'dragover', function(e) {
									e.stopPropagation();
								}, uploader.id);

								dropElm.appendChild(dropInputElm);
							}

							dropPos = plupload.getPos(dropElm, document.getElementById(uploader.settings.container));
							dropSize = plupload.getSize(dropElm);

							if (plupload.getStyle(dropElm, 'position') === 'static') {
								plupload.extend(dropElm.style, {
									position : 'relative'
								});
							}

							plupload.extend(dropInputElm.style, {
								position : 'absolute',
								display : 'block',
								top : 0,
								left : 0,
								width : dropSize.w + 'px',
								height : dropSize.h + 'px',
								opacity : 0
							});
						}, uploader.id);

						return;
					}

					// Block browser default drag over
					plupload.addEvent(dropElm, 'dragover', function(e) {
						e.preventDefault();
					}, uploader.id);

					// Attach drop handler and grab files
					plupload.addEvent(dropElm, 'drop', function(e) {
						var dataTransfer = e.dataTransfer;

						// Add dropped files
						if (dataTransfer && dataTransfer.files) {
							addSelectedFiles(dataTransfer.files);
						}

						e.preventDefault();
					}, uploader.id);
				}
			});

			uploader.bind("Refresh", function(up) {
				var browseButton, browsePos, browseSize, inputContainer, zIndex;

				browseButton = document.getElementById(uploader.settings.browse_button);
				if (browseButton) {
					browsePos = plupload.getPos(browseButton, document.getElementById(up.settings.container));
					browseSize = plupload.getSize(browseButton);
					inputContainer = document.getElementById(uploader.id + '_html5_container');

					plupload.extend(inputContainer.style, {
						top : browsePos.y + 'px',
						left : browsePos.x + 'px',
						width : browseSize.w + 'px',
						height : browseSize.h + 'px'
					});

					// for WebKit place input element underneath the browse button and route onclick event
					// TODO: revise when browser support for this feature will change
					if (uploader.features.triggerDialog) {
						if (plupload.getStyle(browseButton, 'position') === 'static') {
							plupload.extend(browseButton.style, {
								position : 'relative'
							});
						}

						zIndex = parseInt(plupload.getStyle(browseButton, 'zIndex'), 10);
						if (isNaN(zIndex)) {
							zIndex = 0;
						}

						plupload.extend(browseButton.style, {
							zIndex : zIndex
						});

						plupload.extend(inputContainer.style, {
							zIndex : zIndex - 1
						});
					}
				}
			});

			uploader.bind("DisableBrowse", function(up, disabled) {
				var input = document.getElementById(up.id + '_html5');
				if (input) {
					input.disabled = disabled;
				}
			});

			uploader.bind("CancelUpload", function() {
				if (xhr && xhr.abort) {
					xhr.abort();
				}
			});

			uploader.bind("UploadFile", function(up, file) {
				var settings = up.settings, nativeFile, resize;

				function w3cBlobSlice(blob, start, end) {
					var blobSlice;

					if (File.prototype.slice) {
						try {
							blob.slice();	// depricated version will throw WRONG_ARGUMENTS_ERR exception
							return blob.slice(start, end);
						} catch (e) {
							// depricated slice method
							return blob.slice(start, end - start);
						}
					// slice method got prefixed: https://bugzilla.mozilla.org/show_bug.cgi?id=649672
					} else if (blobSlice = File.prototype.webkitSlice || File.prototype.mozSlice) {
						return blobSlice.call(blob, start, end);
					} else {
						return null; // or throw some exception
					}
				}

				function sendBinaryBlob(blob) {
					var chunk = 0, loaded = 0;


					function uploadNextChunk() {
						var chunkBlob, br, chunks, args, chunkSize, curChunkSize, mimeType, url = up.settings.url;

						function sendAsBinaryString(bin) {
							if (xhr.sendAsBinary) { // Gecko
								xhr.sendAsBinary(bin);
							} else if (up.features.canSendBinary) { // WebKit with typed arrays support
								var ui8a = new Uint8Array(bin.length);
								for (var i = 0; i < bin.length; i++) {
									ui8a[i] = (bin.charCodeAt(i) & 0xff);
								}
								xhr.send(ui8a.buffer);
							}
						}

						function prepareAndSend(bin) {
							var multipartDeltaSize = 0,
								boundary = '----pluploadboundary' + plupload.guid(), formData, dashdash = '--', crlf = '\r\n', multipartBlob = '';

							xhr = new XMLHttpRequest;

							// Do we have upload progress support
							if (xhr.upload) {
								xhr.upload.onprogress = function(e) {
									file.loaded = Math.min(file.size, loaded + e.loaded - multipartDeltaSize); // Loaded can be larger than file size due to multipart encoding
									up.trigger('UploadProgress', file);
								};
							}

							xhr.onreadystatechange = function() {
								var httpStatus, chunkArgs;

								if (xhr.readyState == 4 && up.state !== plupload.STOPPED) {
									// Getting the HTTP status might fail on some Gecko versions
									try {
										httpStatus = xhr.status;
									} catch (ex) {
										httpStatus = 0;
									}

									// Is error status
									if (httpStatus >= 400) {
										up.trigger('Error', {
											code : plupload.HTTP_ERROR,
											message : plupload.translate('HTTP Error.'),
											file : file,
											status : httpStatus
										});
									} else {
										// Handle chunk response
										if (chunks) {
											chunkArgs = {
												chunk : chunk,
												chunks : chunks,
												response : xhr.responseText,
												status : httpStatus
											};

											up.trigger('ChunkUploaded', file, chunkArgs);
											loaded += curChunkSize;

											// Stop upload
											if (chunkArgs.cancelled) {
												file.status = plupload.FAILED;
												return;
											}

											file.loaded = Math.min(file.size, (chunk + 1) * chunkSize);
										} else {
											file.loaded = file.size;
										}

										up.trigger('UploadProgress', file);

										bin = chunkBlob = formData = multipartBlob = null; // Free memory

										// Check if file is uploaded
										if (!chunks || ++chunk >= chunks) {
											file.status = plupload.DONE;

											up.trigger('FileUploaded', file, {
												response : xhr.responseText,
												status : httpStatus
											});
										} else {
											// Still chunks left
											uploadNextChunk();
										}
									}
								}
							};


							// Build multipart request
							if (up.settings.multipart && features.multipart) {

								args.name = file.target_name || file.name;

								xhr.open("post", url, true);

								// Set custom headers
								plupload.each(up.settings.headers, function(value, name) {
									xhr.setRequestHeader(name, value);
								});


								// if has FormData support like Chrome 6+, Safari 5+, Firefox 4, use it
								if (typeof(bin) !== 'string' && !!window.FormData) {
									formData = new FormData();

									// Add multipart params
									plupload.each(plupload.extend(args, up.settings.multipart_params), function(value, name) {
										formData.append(name, value);
									});

									// Add file and send it
									formData.append(up.settings.file_data_name, bin);
									xhr.send(formData);

									return;
								}  // if no FormData we can still try to send it directly as last resort (see below)


								if (typeof(bin) === 'string') {
									// Trying to send the whole thing as binary...

									// multipart request
									xhr.setRequestHeader('Content-Type', 'multipart/form-data; boundary=' + boundary);

									// append multipart parameters
									plupload.each(plupload.extend(args, up.settings.multipart_params), function(value, name) {
										multipartBlob += dashdash + boundary + crlf +
											'Content-Disposition: form-data; name="' + name + '"' + crlf + crlf;

										multipartBlob += unescape(encodeURIComponent(value)) + crlf;
									});

									mimeType = plupload.mimeTypes[file.name.replace(/^.+\.([^.]+)/, '$1').toLowerCase()] || 'application/octet-stream';

									// Build RFC2388 blob
									multipartBlob += dashdash + boundary + crlf +
										'Content-Disposition: form-data; name="' + up.settings.file_data_name + '"; filename="' + unescape(encodeURIComponent(file.name)) + '"' + crlf +
										'Content-Type: ' + mimeType + crlf + crlf +
										bin + crlf +
										dashdash + boundary + dashdash + crlf;

									multipartDeltaSize = multipartBlob.length - bin.length;
									bin = multipartBlob;

									sendAsBinaryString(bin);
									return; // will return from here only if shouldn't send binary
								}
							}

							// if no multipart, or last resort, send as binary stream
							url = plupload.buildUrl(up.settings.url, plupload.extend(args, up.settings.multipart_params));

							xhr.open("post", url, true);

							xhr.setRequestHeader('Content-Type', 'application/octet-stream'); // Binary stream header

							// Set custom headers
							plupload.each(up.settings.headers, function(value, name) {
								xhr.setRequestHeader(name, value);
							});

							if (typeof(bin) === 'string') {
								sendAsBinaryString(bin);
							} else {
								xhr.send(bin);
							}
						} // prepareAndSend


						// File upload finished
						if (file.status == plupload.DONE || file.status == plupload.FAILED || up.state == plupload.STOPPED) {
							return;
						}

						// Standard arguments
						args = {name : file.target_name || file.name};

						// Only add chunking args if needed
						if (settings.chunk_size && file.size > settings.chunk_size && (features.chunks || typeof(blob) == 'string')) { // blob will be of type string if it was loaded in memory
							chunkSize = settings.chunk_size;
							chunks = Math.ceil(file.size / chunkSize);
							curChunkSize = Math.min(chunkSize, file.size - (chunk * chunkSize));

							// Blob is string so we need to fake chunking, this is not
							// ideal since the whole file is loaded into memory
							if (typeof(blob) == 'string') {
								chunkBlob = blob.substring(chunk * chunkSize, chunk * chunkSize + curChunkSize);
							} else {
								// Slice the chunk
								chunkBlob = w3cBlobSlice(blob, chunk * chunkSize, chunk * chunkSize + curChunkSize);
							}

							// Setup query string arguments
							args.chunk = chunk;
							args.chunks = chunks;
						} else {
							curChunkSize = file.size;
							chunkBlob = blob;
						}

						// workaround for Android and Gecko 2,5,6 FormData+Blob bug: https://bugzilla.mozilla.org/show_bug.cgi?id=649150
						if (up.settings.multipart && features.multipart && typeof(chunkBlob) !== 'string' && window.FileReader && features.cantSendBlobInFormData && features.chunks && up.settings.chunk_size) { // Gecko 2,5,6
							(function() {
								var fr = new FileReader(); // we need to recreate FileReader object in Android, otherwise it hangs
								fr.onload = function() {
									prepareAndSend(fr.result);
									fr = null; // maybe give a hand to GC (Gecko had problems with this)
								}
								fr.readAsBinaryString(chunkBlob);
							}());
						} else {
							prepareAndSend(chunkBlob);
						}
					}

					// Start uploading chunks
					uploadNextChunk();
				}

				nativeFile = html5files[file.id];

				// Resize image if it's a supported format and resize is enabled
				if (features.jpgresize && up.settings.resize && /\.(png|jpg|jpeg)$/i.test(file.name)) {
					scaleImage.call(up, file, up.settings.resize, /\.png$/i.test(file.name) ? 'image/png' : 'image/jpeg', function(res) {
						// If it was scaled send the scaled image if it failed then
						// send the raw image and let the server do the scaling
						if (res.success) {
							file.size = res.data.length;
							sendBinaryBlob(res.data);
						} else if (features.chunks) {
							sendBinaryBlob(nativeFile);
						} else {
							readFileAsBinary(nativeFile, sendBinaryBlob); // for browsers not supporting File.slice (e.g. FF3.6)
						}
					});
				// if there's no way to slice file without preloading it in memory, preload it
				} else if (!features.chunks && features.jpgresize) {
					readFileAsBinary(nativeFile, sendBinaryBlob);
				} else {
					sendBinaryBlob(nativeFile);
				}
			});


			uploader.bind('Destroy', function(up) {
				var name, element, container = document.body,
					elements = {
						inputContainer: up.id + '_html5_container',
						inputFile: up.id + '_html5',
						browseButton: up.settings.browse_button,
						dropElm: up.settings.drop_element
					};

				// Unbind event handlers
				for (name in elements) {
					element = document.getElementById(elements[name]);
					if (element) {
						plupload.removeAllEvents(element, up.id);
					}
				}
				plupload.removeAllEvents(document.body, up.id);

				if (up.settings.container) {
					container = document.getElementById(up.settings.container);
				}

				// Remove mark-up
				container.removeChild(document.getElementById(elements.inputContainer));
			});

			callback({success : true});
		}
	});

	function BinaryReader() {
		var II = false, bin;

		// Private functions
		function read(idx, size) {
			var mv = II ? 0 : -8 * (size - 1), sum = 0, i;

			for (i = 0; i < size; i++) {
				sum |= (bin.charCodeAt(idx + i) << Math.abs(mv + i*8));
			}

			return sum;
		}

		function putstr(segment, idx, length) {
			var length = arguments.length === 3 ? length : bin.length - idx - 1;

			bin = bin.substr(0, idx) + segment + bin.substr(length + idx);
		}

		function write(idx, num, size) {
			var str = '', mv = II ? 0 : -8 * (size - 1), i;

			for (i = 0; i < size; i++) {
				str += String.fromCharCode((num >> Math.abs(mv + i*8)) & 255);
			}

			putstr(str, idx, size);
		}

		// Public functions
		return {
			II: function(order) {
				if (order === undef) {
					return II;
				} else {
					II = order;
				}
			},

			init: function(binData) {
				II = false;
				bin = binData;
			},

			SEGMENT: function(idx, length, segment) {
				switch (arguments.length) {
					case 1:
						return bin.substr(idx, bin.length - idx - 1);
					case 2:
						return bin.substr(idx, length);
					case 3:
						putstr(segment, idx, length);
						break;
					default: return bin;
				}
			},

			BYTE: function(idx) {
				return read(idx, 1);
			},

			SHORT: function(idx) {
				return read(idx, 2);
			},

			LONG: function(idx, num) {
				if (num === undef) {
					return read(idx, 4);
				} else {
					write(idx, num, 4);
				}
			},

			SLONG: function(idx) { // 2's complement notation
				var num = read(idx, 4);

				return (num > 2147483647 ? num - 4294967296 : num);
			},

			STRING: function(idx, size) {
				var str = '';

				for (size += idx; idx < size; idx++) {
					str += String.fromCharCode(read(idx, 1));
				}

				return str;
			}
		};
	}

	function JPEG_Headers(data) {

		var markers = {
				0xFFE1: {
					app: 'EXIF',
					name: 'APP1',
					signature: "Exif\0"
				},
				0xFFE2: {
					app: 'ICC',
					name: 'APP2',
					signature: "ICC_PROFILE\0"
				},
				0xFFED: {
					app: 'IPTC',
					name: 'APP13',
					signature: "Photoshop 3.0\0"
				}
			},
			headers = [], read, idx, marker = undef, length = 0, limit;


		read = new BinaryReader();
		read.init(data);

		// Check if data is jpeg
		if (read.SHORT(0) !== 0xFFD8) {
			return;
		}

		idx = 2;
		limit = Math.min(1048576, data.length);

		while (idx <= limit) {
			marker = read.SHORT(idx);

			// omit RST (restart) markers
			if (marker >= 0xFFD0 && marker <= 0xFFD7) {
				idx += 2;
				continue;
			}

			// no headers allowed after SOS marker
			if (marker === 0xFFDA || marker === 0xFFD9) {
				break;
			}

			length = read.SHORT(idx + 2) + 2;

			if (markers[marker] &&
				read.STRING(idx + 4, markers[marker].signature.length) === markers[marker].signature) {
				headers.push({
					hex: marker,
					app: markers[marker].app.toUpperCase(),
					name: markers[marker].name.toUpperCase(),
					start: idx,
					length: length,
					segment: read.SEGMENT(idx, length)
				});
			}
			idx += length;
		}

		read.init(null); // free memory

		return {

			headers: headers,

			restore: function(data) {
				read.init(data);

				// Check if data is jpeg
				var jpegHeaders = new JPEG_Headers(data);

				if (!jpegHeaders['headers']) {
					return false;
				}

				// Delete any existing headers that need to be replaced
				for (var i = jpegHeaders['headers'].length; i > 0; i--) {
					var hdr = jpegHeaders['headers'][i - 1];
					read.SEGMENT(hdr.start, hdr.length, '')
				}
				jpegHeaders.purge();

				idx = read.SHORT(2) == 0xFFE0 ? 4 + read.SHORT(4) : 2;

				for (var i = 0, max = headers.length; i < max; i++) {
					read.SEGMENT(idx, 0, headers[i].segment);
					idx += headers[i].length;
				}

				return read.SEGMENT();
			},

			get: function(app) {
				var array = [];

				for (var i = 0, max = headers.length; i < max; i++) {
					if (headers[i].app === app.toUpperCase()) {
						array.push(headers[i].segment);
					}
				}
				return array;
			},

			set: function(app, segment) {
				var array = [];

				if (typeof(segment) === 'string') {
					array.push(segment);
				} else {
					array = segment;
				}

				for (var i = ii = 0, max = headers.length; i < max; i++) {
					if (headers[i].app === app.toUpperCase()) {
						headers[i].segment = array[ii];
						headers[i].length = array[ii].length;
						ii++;
					}
					if (ii >= array.length) break;
				}
			},

			purge: function() {
				headers = [];
				read.init(null);
			}
		};
	}


	function ExifParser() {
		// Private ExifParser fields
		var data, tags, offsets = {}, tagDescs;

		data = new BinaryReader();

		tags = {
			tiff : {
				/*
				The image orientation viewed in terms of rows and columns.

				1 - The 0th row is at the visual top of the image, and the 0th column is the visual left-hand side.
				2 - The 0th row is at the visual top of the image, and the 0th column is the visual left-hand side.
				3 - The 0th row is at the visual top of the image, and the 0th column is the visual right-hand side.
				4 - The 0th row is at the visual bottom of the image, and the 0th column is the visual right-hand side.
				5 - The 0th row is at the visual bottom of the image, and the 0th column is the visual left-hand side.
				6 - The 0th row is the visual left-hand side of the image, and the 0th column is the visual top.
				7 - The 0th row is the visual right-hand side of the image, and the 0th column is the visual top.
				8 - The 0th row is the visual right-hand side of the image, and the 0th column is the visual bottom.
				9 - The 0th row is the visual left-hand side of the image, and the 0th column is the visual bottom.
				*/
				0x0112: 'Orientation',
				0x8769: 'ExifIFDPointer',
				0x8825:	'GPSInfoIFDPointer'
			},
			exif : {
				0x9000: 'ExifVersion',
				0xA001: 'ColorSpace',
				0xA002: 'PixelXDimension',
				0xA003: 'PixelYDimension',
				0x9003: 'DateTimeOriginal',
				0x829A: 'ExposureTime',
				0x829D: 'FNumber',
				0x8827: 'ISOSpeedRatings',
				0x9201: 'ShutterSpeedValue',
				0x9202: 'ApertureValue'	,
				0x9207: 'MeteringMode',
				0x9208: 'LightSource',
				0x9209: 'Flash',
				0xA402: 'ExposureMode',
				0xA403: 'WhiteBalance',
				0xA406: 'SceneCaptureType',
				0xA404: 'DigitalZoomRatio',
				0xA408: 'Contrast',
				0xA409: 'Saturation',
				0xA40A: 'Sharpness'
			},
			gps : {
				0x0000: 'GPSVersionID',
				0x0001: 'GPSLatitudeRef',
				0x0002: 'GPSLatitude',
				0x0003: 'GPSLongitudeRef',
				0x0004: 'GPSLongitude'
			}
		};

		tagDescs = {
			'ColorSpace': {
				1: 'sRGB',
				0: 'Uncalibrated'
			},

			'MeteringMode': {
				0: 'Unknown',
				1: 'Average',
				2: 'CenterWeightedAverage',
				3: 'Spot',
				4: 'MultiSpot',
				5: 'Pattern',
				6: 'Partial',
				255: 'Other'
			},

			'LightSource': {
				1: 'Daylight',
				2: 'Fliorescent',
				3: 'Tungsten',
				4: 'Flash',
				9: 'Fine weather',
				10: 'Cloudy weather',
				11: 'Shade',
				12: 'Daylight fluorescent (D 5700 - 7100K)',
				13: 'Day white fluorescent (N 4600 -5400K)',
				14: 'Cool white fluorescent (W 3900 - 4500K)',
				15: 'White fluorescent (WW 3200 - 3700K)',
				17: 'Standard light A',
				18: 'Standard light B',
				19: 'Standard light C',
				20: 'D55',
				21: 'D65',
				22: 'D75',
				23: 'D50',
				24: 'ISO studio tungsten',
				255: 'Other'
			},

			'Flash': {
				0x0000: 'Flash did not fire.',
				0x0001: 'Flash fired.',
				0x0005: 'Strobe return light not detected.',
				0x0007: 'Strobe return light detected.',
				0x0009: 'Flash fired, compulsory flash mode',
				0x000D: 'Flash fired, compulsory flash mode, return light not detected',
				0x000F: 'Flash fired, compulsory flash mode, return light detected',
				0x0010: 'Flash did not fire, compulsory flash mode',
				0x0018: 'Flash did not fire, auto mode',
				0x0019: 'Flash fired, auto mode',
				0x001D: 'Flash fired, auto mode, return light not detected',
				0x001F: 'Flash fired, auto mode, return light detected',
				0x0020: 'No flash function',
				0x0041: 'Flash fired, red-eye reduction mode',
				0x0045: 'Flash fired, red-eye reduction mode, return light not detected',
				0x0047: 'Flash fired, red-eye reduction mode, return light detected',
				0x0049: 'Flash fired, compulsory flash mode, red-eye reduction mode',
				0x004D: 'Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected',
				0x004F: 'Flash fired, compulsory flash mode, red-eye reduction mode, return light detected',
				0x0059: 'Flash fired, auto mode, red-eye reduction mode',
				0x005D: 'Flash fired, auto mode, return light not detected, red-eye reduction mode',
				0x005F: 'Flash fired, auto mode, return light detected, red-eye reduction mode'
			},

			'ExposureMode': {
				0: 'Auto exposure',
				1: 'Manual exposure',
				2: 'Auto bracket'
			},

			'WhiteBalance': {
				0: 'Auto white balance',
				1: 'Manual white balance'
			},

			'SceneCaptureType': {
				0: 'Standard',
				1: 'Landscape',
				2: 'Portrait',
				3: 'Night scene'
			},

			'Contrast': {
				0: 'Normal',
				1: 'Soft',
				2: 'Hard'
			},

			'Saturation': {
				0: 'Normal',
				1: 'Low saturation',
				2: 'High saturation'
			},

			'Sharpness': {
				0: 'Normal',
				1: 'Soft',
				2: 'Hard'
			},

			// GPS related
			'GPSLatitudeRef': {
				N: 'North latitude',
				S: 'South latitude'
			},

			'GPSLongitudeRef': {
				E: 'East longitude',
				W: 'West longitude'
			}
		};

		function extractTags(IFD_offset, tags2extract) {
			var length = data.SHORT(IFD_offset), i, ii,
				tag, type, count, tagOffset, offset, value, values = [], hash = {};

			for (i = 0; i < length; i++) {
				// Set binary reader pointer to beginning of the next tag
				offset = tagOffset = IFD_offset + 12 * i + 2;

				tag = tags2extract[data.SHORT(offset)];

				if (tag === undef) {
					continue; // Not the tag we requested
				}

				type = data.SHORT(offset+=2);
				count = data.LONG(offset+=2);

				offset += 4;
				values = [];

				switch (type) {
					case 1: // BYTE
					case 7: // UNDEFINED
						if (count > 4) {
							offset = data.LONG(offset) + offsets.tiffHeader;
						}

						for (ii = 0; ii < count; ii++) {
							values[ii] = data.BYTE(offset + ii);
						}

						break;

					case 2: // STRING
						if (count > 4) {
							offset = data.LONG(offset) + offsets.tiffHeader;
						}

						hash[tag] = data.STRING(offset, count - 1);

						continue;

					case 3: // SHORT
						if (count > 2) {
							offset = data.LONG(offset) + offsets.tiffHeader;
						}

						for (ii = 0; ii < count; ii++) {
							values[ii] = data.SHORT(offset + ii*2);
						}

						break;

					case 4: // LONG
						if (count > 1) {
							offset = data.LONG(offset) + offsets.tiffHeader;
						}

						for (ii = 0; ii < count; ii++) {
							values[ii] = data.LONG(offset + ii*4);
						}

						break;

					case 5: // RATIONAL
						offset = data.LONG(offset) + offsets.tiffHeader;

						for (ii = 0; ii < count; ii++) {
							values[ii] = data.LONG(offset + ii*4) / data.LONG(offset + ii*4 + 4);
						}

						break;

					case 9: // SLONG
						offset = data.LONG(offset) + offsets.tiffHeader;

						for (ii = 0; ii < count; ii++) {
							values[ii] = data.SLONG(offset + ii*4);
						}

						break;

					case 10: // SRATIONAL
						offset = data.LONG(offset) + offsets.tiffHeader;

						for (ii = 0; ii < count; ii++) {
							values[ii] = data.SLONG(offset + ii*4) / data.SLONG(offset + ii*4 + 4);
						}

						break;

					default:
						continue;
				}

				value = (count == 1 ? values[0] : values);

				if (tagDescs.hasOwnProperty(tag) && typeof value != 'object') {
					hash[tag] = tagDescs[tag][value];
				} else {
					hash[tag] = value;
				}
			}

			return hash;
		}

		function getIFDOffsets() {
			var Tiff = undef, idx = offsets.tiffHeader;

			// Set read order of multi-byte data
			data.II(data.SHORT(idx) == 0x4949);

			// Check if always present bytes are indeed present
			if (data.SHORT(idx+=2) !== 0x002A) {
				return false;
			}

			offsets['IFD0'] = offsets.tiffHeader + data.LONG(idx += 2);
			Tiff = extractTags(offsets['IFD0'], tags.tiff);

			offsets['exifIFD'] = ('ExifIFDPointer' in Tiff ? offsets.tiffHeader + Tiff.ExifIFDPointer : undef);
			offsets['gpsIFD'] = ('GPSInfoIFDPointer' in Tiff ? offsets.tiffHeader + Tiff.GPSInfoIFDPointer : undef);

			return true;
		}

		// At the moment only setting of simple (LONG) values, that do not require offset recalculation, is supported
		function setTag(ifd, tag, value) {
			var offset, length, tagOffset, valueOffset = 0;

			// If tag name passed translate into hex key
			if (typeof(tag) === 'string') {
				var tmpTags = tags[ifd.toLowerCase()];
				for (hex in tmpTags) {
					if (tmpTags[hex] === tag) {
						tag = hex;
						break;
					}
				}
			}
			offset = offsets[ifd.toLowerCase() + 'IFD'];
			length = data.SHORT(offset);

			for (i = 0; i < length; i++) {
				tagOffset = offset + 12 * i + 2;

				if (data.SHORT(tagOffset) == tag) {
					valueOffset = tagOffset + 8;
					break;
				}
			}

			if (!valueOffset) return false;


			data.LONG(valueOffset, value);
			return true;
		}


		// Public functions
		return {
			init: function(segment) {
				// Reset internal data
				offsets = {
					tiffHeader: 10
				};

				if (segment === undef || !segment.length) {
					return false;
				}

				data.init(segment);

				// Check if that's APP1 and that it has EXIF
				if (data.SHORT(0) === 0xFFE1 && data.STRING(4, 5).toUpperCase() === "EXIF\0") {
					return getIFDOffsets();
				}
				return false;
			},

			EXIF: function() {
				var Exif;

				// Populate EXIF hash
				Exif = extractTags(offsets.exifIFD, tags.exif);

				// Fix formatting of some tags
				if (Exif.ExifVersion && plupload.typeOf(Exif.ExifVersion) === 'array') {
					for (var i = 0, exifVersion = ''; i < Exif.ExifVersion.length; i++) {
						exifVersion += String.fromCharCode(Exif.ExifVersion[i]);
					}
					Exif.ExifVersion = exifVersion;
				}

				return Exif;
			},

			GPS: function() {
				var GPS;

				GPS = extractTags(offsets.gpsIFD, tags.gps);

				// iOS devices (and probably some others) do not put in GPSVersionID tag (why?..)
				if (GPS.GPSVersionID) {
					GPS.GPSVersionID = GPS.GPSVersionID.join('.');
				}

				return GPS;
			},

			setExif: function(tag, value) {
				// Right now only setting of width/height is possible
				if (tag !== 'PixelXDimension' && tag !== 'PixelYDimension') return false;

				return setTag('exif', tag, value);
			},


			getBinary: function() {
				return data.SEGMENT();
			}
		};
	};
})(window, document, $.plupload);
$.Controller("plupload",
{
	pluginName: "plupload",
	hostname: "plupload",

	defaultOptions: {

		"{uploader}" : "[data-plupload-uploader]",
		"{uploadButton}" : "[data-plupload-upload-button]",
		"{uploadDropsite}" : "[data-plupload-dropsite]",

		settings: {
			runtimes: "html5, html4",
			url: $.indexUrl,
			max_file_count: 20,
			unique_names: true
		}
	}
},
function(self, opts, base) { return {

	init: function() {

		var settings = self.options.settings;

		// Create upload container identifier
		var uploadContainerId = $.uid("uploadContainer-");

		self.element
			.attr('id', uploadContainerId);

		settings.container = uploadContainerId;

		// Create upload button identifier
		var uploadButtonId = self.uploadButtonId = $.uid("uploadButton-");

		// Apply the id to the first found upload button
		self.uploadButtonMain =
			self.uploadButton(":first")
				.attr('id', uploadButtonId);

		settings.browse_button = uploadButtonId;

		// Create upload drop site identifier
		var uploadDropsiteId = $.uid("uploadDropsite-");

		if (self.uploadDropsite().length > 0) {

			self.uploadDropsite()
						.attr('id', uploadDropsiteId);

			settings.drop_element = uploadDropsiteId;
		}

		// Decide where the uploader events are binded to
		self.uploader = $(self.uploader()[0] || self.element);

		// Create new plupload instance
		self.plupload = new $.plupload.Uploader(settings);

		// @rule: Init() plupload before you bind except for postInit
		self.plupload.bind('PostInit', function() {
			self.eventHandler("PostInit", $.makeArray(arguments));
		});

		self.plupload.init();

		var events = [
			"BeforeUpload",
			"ChunkUploaded",
			"Destroy",
			"Error",
			"FilesAdded",
			"FilesRemoved",
			"FileUploaded",
			"Init",
			"QueueChanged",
			"Refresh",
			"StateChanged",
			"UploadComplete",
			"UploadFile",
			"UploadProgress"
		];

		$.each(events, function(i, eventName) {

			self.plupload.bind(eventName, function(){
				self.eventHandler(eventName, $.makeArray(arguments));
			});
		});

		// Indicate uploader supports drag & drop
		if (!$.IE && self.plupload.runtime=="html5") {

			base.addClass("can-drop-file");
		}

		// Indicate uploader is ready
		base.addClass("can-upload");
	},

	"{uploadButton} click": function(uploadButton) {

		if (uploadButton[0]==self.uploadButtonMain[0]) {
			return;
		}

		if (self.plupload.features.triggerDialog) {
			self.uploadButtonMain.click();
		}
	},

	"{uploadButton} mouseover": function(uploadButton) {

		// If we can trigger browser dialog programatically,
		// don't do anything.
		if (self.plupload.features.triggerDialog) return;

		// Remove id on all upload buttons
		self.uploadButton().removeAttr('id');

		// Add to the current one
		uploadButton.attr('id', self.uploadButtonId);

		// Reposition button
		self.plupload.refresh();
	},

	eventHandler: function(eventName, args) {

		var eventHandler = self["plupload::"+eventName],

			elementEventHandler = (function(){
				var eventHandlers = (self.uploader.data("events") || {})[eventName];
				return (eventHandlers) ? eventHandlers[0].handler : undefined;
			})(),

			elementEventHandlerArgs;

		if ($.isFunction(eventHandler)) {

			elementEventHandlerArgs = eventHandler.apply(self, args);
		}

		if (elementEventHandlerArgs!==false) {

			self.uploader.trigger(eventName, elementEventHandlerArgs || args);
		}
	},

	"plupload::FileUploaded": function(up, file, data, handler) {

		var response;

		try {

			response = eval('('+data.response+')');

		} catch(e) {

			response = {
				type: "error",
				message: "Unable to parse server response.",
				data: data
			};
		}

		// If response type is an error, trigger FileError event
		if (response.type=="error") {

			self.uploader.trigger("FileError", [up, file, response]);

			// This ensure the FileUploaded event
			// doesn't get triggered anymore.
			return false;
		}

		// Trigger FileUploaded event with the following params
		return [up, file, response];
	},

	"plupload::Error": function(up, error) {

		try { console.log('plupload Error: ', up, error); } catch(e) {};
	}

}});

};

exports();
module.resolveWith(exports);

// module body: end

};
// module factory: end

FD40.module("plupload", moduleFactory);

}());
			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this;
$.require()
 .script("ui/position")
 .done(function() {
var exports = function() {

/*
<div
	data-popbox="module://popbox/options/exporter"
	data-popbox-class="profile"
	data-popbox-position="bottom-left"></div>

<div class="popbox" data-popbox-tooltip>
<div class="arrow"></div>
<div class="popbox-content">
</div>
</div>
*/

$.fn.popbox = function(options) {

	// Creating or updating popbox options
	if ($.isPlainObject(options)) {

		this.each(function(){

			var button = $(this),
				popbox = Popbox.get(button);

			// Update popbox options
			if (popbox) {
				popbox.update(options);

			// Or create a new popbox
			} else {

				popbox = new Popbox(button, options);
			}
		});

		return this;
	}

	// Calling a method in popbox
	if ($.isString(options)) {

		var button = $(this[0]),

			// Create new popbox instance if
			// it hasn't been created yet
			popbox = Popbox.get(button) || new Popbox(button),

			method = popbox[options],

			ret;

		if ($.isFunction(method)) {

			ret = method.apply(popbox, $.makeArray(arguments).slice(1));
		}

		return ret || this;
	}

	return this;
}

var Popbox = function(button, options) {

	var popbox = this;

	// Store popbox instance within button
	button.data("popbox", popbox);

	// Normalize arguments
	if ($.isString(options)) {
		options = {content: options}
	}

	if (!options) {
		options = {};
	}

	// Popbox button that is placed in a
	// fixed position needs special handling.
	button.parentsUntil("body").addBack()
		.each(function(){
			var parent = $(this);
			if (parent.css("position")==="fixed") {
				options.fixed = true;
				return false;
			}
		});

	// Gather element options
	var elementOptions = {},
		// Takes content from data-popbox attribute, else take it from inline content.
		content = button.attr("data-popbox") || button.find("[data-popbox-content]").html() || $(button.attr("data-popbox-target")).html();
		if (content) elementOptions.content = content;

	$(["id", "component", "type", "toggle", "position", "collision"])
		.each(function(i, key){
			var val = button.attr("data-popbox-" + key);

			// We need to flip all the left -> right for rtl documents
			if (window.es.direction == 'rtl' && val) {
				if (val.indexOf('left') !== -1) {
					val = val.replace('left', 'right');
				} else if (val.indexOf('right') !== -1) {
					val = val.replace('right', 'left');
				}
			}

			elementOptions[key] = val;
		});

	// Quick Hack
	if (button.attr("data-popbox-offset")!==undefined) {
		elementOptions["offset"] = parseInt(button.attr("data-popbox-offset"));
	}

	if (button.attr("data-popbox-offset-horizontal") !== undefined) {
		elementOptions["offsethorizontal"] = parseInt(button.attr("data-popbox-offset-horizontal"));
	}

	// If popbox was set up via jQuery, the element may not
	// have the data-popbox attribute. We need this attribute
	// for click and hover events to work (and keep things DRY).
	if (content===undefined) button.attr("data-popbox", "");

	// Build final options
	popbox.update(
		$.extend(true,
			{},
			Popbox.defaultOptions, {
				tooltip: $(),
				loader : $('<div id="es" class="popbox loading" data-popbox-tooltip><div class="arrow"></div><div class="o-loader o-loader--sm o-loader--top is-active"></div></div>'),
				uid    : $.uid(),
				button : button
			},
			elementOptions,
			options
		)
	);
};

// Default options
Popbox.defaultOptions = {
	content: "",
	id: null,
	type: "",
	enabled: false,
	wait: false,
	locked: false,
	exclusive: false,
	hideTimer: null,
	hideDelay: 50,
	toggle: "hover",
	position: "bottom",
	collision: "flip",
	cache: true,
	fixed: false,
	offset: 10,
	offsethorizontal: 0
};

Popbox.get = function(el) {

	var popbox = $(el).data("popbox");

	if (popbox instanceof Popbox) return popbox;
}

Popbox.toggleEvent = navigator.userAgent.match(/iPhone|iPad|iPod/i) && window.es.environment != 'development' ? "touchstart" : "click";

$.extend(Popbox.prototype, {

	positions: "top top-left top-right top-center bottom bottom-left bottom-right bottom-center left left-top left-bottom left-center right right-top right-bottom right-center",

	update: function(options) {

		var popbox = this;

		// Update popbox options
		$.extend(true, popbox, options);

		// If popbox content is a module
		if ($.isModule(popbox.content)) {

			// Don't let anything happen until module is resolved.
			popbox.wait = true;

			$.module(popbox.content)
				.done(function(options){

					// Popbox options
					if ($.isPlainObject(options)) {
						popbox.update(options);
					}

					// Callback that returns customized popbox options
					if ($.isFunction(options)) {

						popbox.update({
							content: options
						});
					}
				})
				.fail(function(){

					var errorMessage = $('[data-es-popbox-error]').text();

					// safe check
					if (errorMessage.length <= 0 || errorMessage.indexOf('COM_EASYSOCIAL_') >= 0) {
						errorMessage = 'Unable to load tooltip content.';
					}

					popbox.update({
						content: errorMessage
					});

				})
				.always(function(){
					popbox.wait = false;
				});

			return;
		}

		// If popbox content is a string,
		// we'll just rewrap it in deferred.
		if ($.isString(popbox.content)) {
			popbox.content = $.Deferred().resolve(popbox.content);
		}

		var position = popbox.position;

		if ($.isString(position)) {

			// Determine position
			var pos = position.split("-"),
				x1, y1, x2, y2;

			switch (pos[0]) {

				case "top":
				case "bottom":
					x1 = x2 = pos[1] || "center";
					// y1 = pos[0]=="top" ? "bottom-10" : "top+10";
					y1 = pos[0]=="top" ? "bottom" : "top";
					y2 = pos[0]=="top" ? "top"    : "bottom";
					break;

				case "left":
				case "right":
					y1 = y2 = pos[1] || "center";
					// x1 = pos[0]=="left" ? "right-10" : "left+10";
					x1 = pos[0]=="left" ? "right" : "left";
					x2 = pos[0]=="left" ? "left"  : "right";
					break;
			}

			popbox.position = {
				classname: position,
				my: x1 + " " + y1,
				at: x2 + " " + y2,
				using: function(coords, feedback) {

					var tooltip   = $(this),
						classname = popbox.position.classname,
						top       = coords.top,
						left      = coords.left,
						offset    = popbox.offset,
						offsethorizontal = popbox.offsethorizontal,
						buttonOffset = popbox.button.offset();

					switch (pos[0]) {

						case "top":
						case "bottom":
							var vertical = feedback.vertical;

							if (vertical==pos[0]) {
								classname = classname.replace(/top|bottom/gi, (vertical=="top") ? "bottom" : "top");
							}
							top = (vertical=="top") ? top + offset : top - offset;

							if (pos[1]=="left" && (left < Math.floor(buttonOffset.left))) {
								classname = classname.replace(/left|right/gi, (pos[1]=="left") ? "right" : "left");
							}

							var horizontal = feedback.horizontal;
							left = (horizontal == 'left') ? left + offsethorizontal : left - offsethorizontal;

							break;

						case "left":
						case "right":
							var horizontal = feedback.horizontal;
							if (feedback.horizontal==pos[0]) {
								classname = classname.replace(/left|right/gi, (feedback.horizontal=="left") ? "right" : "left");
							}

							left = (horizontal=="left") ? left + offset : left - offset;
							break;
					}


					// We need to flip all the left -> right for rtl documents
					if (window.es.direction == 'rtl') {
						if (classname.indexOf('left') !== -1) {
							classname = classname.replace('left', 'right');
						} else if (classname.indexOf('right') !== -1) {
							classname = classname.replace('right', 'left');
						}
					}

					tooltip
						.css({
							top : top  + 'px',
							left: left + 'px'
						})
						.removeClass(popbox.positions)
						.addClass(classname);
				}
			};
		}

		$.extend(popbox.position, {
			of: popbox.button,
			collision: popbox.collision
		});

		// Popbox loader
		popbox.loader
			.attr({
				"id": popbox.id,
				"data-popbox-tooltip": popbox.type,
				"style": popbox.fixed ? 'position: fixed' : ''
			})
			.addClass(popbox.component)
			.addClass("popbox-" + popbox.type);

		if (window.es.mobile) {
			popbox.loader.addClass('is-mobile');
		}

		if (window.es.android) {
			popbox.loader.addClass('is-android');
		}

		if (window.es.ios) {
			popbox.loader.addClass('is-ios');
		}

		// If popbox is enabled, show tooltip with new options.
		if (popbox.enabled) {
			popbox.show();
		}
	},

	trigger: function(event, args) {

		var popbox = this;

		this.tooltip.trigger(event, args);
		this.button.trigger(event, args);
	},

	show: function() {

		var popbox = this;

		// Enable popbox
		popbox.enabled = true;

		// If we're waiting for module to resolve, stop.
		if (popbox.wait) {
			return;
		}

		// Stop any task that hides popover
		clearTimeout(popbox.hideTimer);

		// If this popbox can only be shown exclusively,
		// then hide other popbox.
		if (popbox.exclusive) {

			$("[data-popbox-tooltip]").each(function(){

				var popbox = Popbox.get($(this));

				if (!popbox) return;

				popbox.hide(true);
			});
		}

		// Insert active for button
		popbox.button.addClass("active");

		// Hide when popbox is blurred
		if (popbox.toggle == "click") {
			var doc = $(document);
			var hideOnClick = Popbox.toggleEvent + ".popbox." + popbox.uid;

			doc
				.off(hideOnClick)
				.on(hideOnClick, function(event){

					// Collect list of bubbled elements
					var targets = $(event.target).parents().andSelf();

					// in mobile, we allow own button to click to close.
					if (window.es.mobile && targets.filter(popbox.tooltip).length > 0) {
						return;
					}

					// Don't hide popbox is popbox button or tooltip is one of those elements.
					if (!window.es.mobile && (targets.filter(popbox.button).length > 0 ||
						targets.filter(popbox.tooltip).length > 0)) {
						return;
					}

					popbox.hide();
				});
		}

		// Reposition popbox when browser resized or zoomed
		var win = $(window),
			repositionOnResize = "resize.popbox" + popbox.uid;

		win
			.off(repositionOnResize)
			.on(repositionOnResize, function(){

				// Reposition popbox
				if (popbox.tooltip.length > 0) {
					popbox.tooltip
						.position(popbox.position);
				}
			});

		// If tooltip exists, just show tootip
		if (popbox.tooltip.length > 0) {

			popbox.tooltip
				.appendTo("body")
				.position(popbox.position);

			// Trigger popboxActivate event
			popbox.trigger("popboxActivate", [popbox]);

			return;
		}

		// If popbox content is a function,
		if ($.isFunction(popbox.content)) {

			// Execute the function and to get popbox options
			var options = popbox.content(popbox);

			// Update popbox with the new options
			popbox.update(options);

			// If updating popbox causes it to fall into wait mode, stop.
			if (popbox.wait) return;
		}

		// If at this point, popbox is not a deferred object,
		// then we don't have any tooltip to show.
		if (!$.isDeferred(popbox.content)) return;

		// If the popbox content is still loading,
		// show loading indicator.
		if (popbox.content.state()=="pending") {

			popbox.loader
				.appendTo("body")
				.position(popbox.position);

			// Trigger popboxLoading event
			popbox.trigger("popboxLoading", [popbox]);
		}

		popbox.content
			.always(function(){

				popbox.wait = false;
			})
			.done(function(html){

				// If popbox already has a tooltip, stop.
				if (popbox.tooltip.length > 0) return;

				// If popbox is disabled, don't show it.
				if (!popbox.enabled) return;

				// Remove loading indicator
				popbox.loader.detach();

				var tooltip = $.buildHTML(html);

				if (tooltip.filter("[data-popbox-tooltip]").length < 1) {

					var content = tooltip;

					tooltip =
						// Create wrapper and
						$('<div id="es" class="es popbox" data-popbox-tooltip><div class="arrow"></div><div class="popbox-content" data-popbox-content></div></div>')
							.attr({
								"id": popbox.id,
								"data-popbox-tooltip": popbox.type,
								"style": popbox.fixed ? 'position: fixed' : ''
							})
							.addClass(popbox.component)
							.addClass("popbox-" + popbox.type)
							// append to body first because
							.appendTo("body");

					if (window.es.mobile) {
						tooltip.addClass('is-mobile');
					}

					if (window.es.android) {
						tooltip.addClass('is-android');
					}

					if (window.es.ios) {
						tooltip.addClass('is-ios');
					}

					// We want any possible scripts within the tooltip
					// content to execute when it is visible in DOM.
					tooltip
						.find('[data-popbox-content]')
						.append(content);

				} else {

					tooltip =
						// This tooltip might be an array of elements, e.g.
						// tooltip div, scripts and text nodes.
						tooltip
							// we append to body first to
							// let the scripts execute
							.appendTo("body")
							// then filter out the popbox tooltip
							// to assign it back as our variable
							.filter("[data-popbox-tooltip]");
				}

				// Store tooltip property in popbox
				popbox.tooltip =
					tooltip
						// and let tooltip has a reference back to popbox
						.data("popbox", popbox)
						// reposition tooltip
						.position(popbox.position);

				// Find any labels on the popbox and we need to prevent it from doing any bubbling up
				popbox
					.tooltip
					.find('label')
					.on('click', function(event) {
						event.preventDefault();
						event.stopPropagation();

						// Find the target
						var target = popbox.tooltip.find('#' + $(this).attr('for'));

						if (target.length > 0) {
							if (target.is(':checkbox')) {
								target.click();
							} else {
								target.focus();
							}
						}

						return;

					});
				// Trigger popboxActivate event
				popbox.trigger("popboxActivate", [popbox]);
			})
			.fail(function(){
				var errorMessage = $('[data-es-popbox-error]').text();

				// safe check
				if (errorMessage.length <= 0 || errorMessage.indexOf('COM_EASYSOCIAL_') >= 0) {
					errorMessage = 'Unable to load tooltip content.';
				}

				popbox.update({
					content: errorMessage
				});
			});
	},

	hide: function(force) {
		var popbox = this;
		var doc = $(document);

		// Turn off click to hide event when popbox is hidden. #3676
		var hideOnClick = Popbox.toggleEvent + ".popbox." + popbox.uid;

		doc.off(hideOnClick);

		// Disable popbox
		popbox.enabled = false;

		// Stop any previous hide timer
		clearTimeout(popbox.hideTimer);

		// Detach popbox loader
		popbox.loader.detach();

		var hide = function(){

			if (popbox.locked && !force) return;

			// Detach tooltip
			popbox.tooltip
				.detach();

			// Detach repositionOnResize
			$(window).off("resize.popbox" + popbox.uid);

			// Trigger popboxDeactivate event
			popbox.trigger("popboxDeactivate", [popbox]);

			if (!popbox.cache) {
				popbox.destroy();
			}
		}

		// Removed active for button
		popbox.button.removeClass("active");
		var delay = popbox.hideDelay;

		if (force) {delay = 0}

		popbox.hideTimer = setTimeout(hide, delay);
	},

	destroy: function() {
		this.button.removeData("popbox");
	},

	widget: function() {

		return this;
	}
});

// Data API
$(document)
	.on(Popbox.toggleEvent + '.popbox', '[data-popbox]', function(){

		var popbox = $(this).popbox("widget");

		if (popbox.toggle=="hover") {
			return;
		}

		if (popbox.enabled) {
			popbox.hide();
		} else {
			popbox.show();
		}
	})
	.on('mouseover.popbox', '[data-popbox]', function(){
		var popbox = $(this).popbox("widget");

		if (popbox.toggle=="hover" && !(/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent))) popbox.show();
	})
	.on('mouseout.popbox', '[data-popbox]', function(){

		var popbox = $(this).popbox("widget");

		if (popbox.toggle=="hover") popbox.hide();

		// if (popbox.toggle=="hover" && !(/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent))) popbox.hide();
	})
	.on('mouseover.popbox.tooltip', '[data-popbox-tooltip]', function(){

		var popbox = Popbox.get(this);

		if (!popbox) return;

		if (popbox.toggle!=="hover") return;

		// Lock popbox
		popbox.locked = true;

		clearTimeout(popbox.hideTimer);
	})
	.on('mouseout.popbox.tooltip', '[data-popbox-tooltip]', function(){

		var popbox = Popbox.get(this);

		if (!popbox) return;

		if (popbox.toggle!=="hover") return;

		// Unlock popbox
		popbox.locked = false;

		// Hide popbox
		popbox.hide();
	})
	.on('click.popbox.close', '[data-popbox-close]', function(){

		var popbox = Popbox.get($(this).parents('[data-popbox-tooltip]'));

		if (!popbox) return;

		popbox.hide();
	});
};

exports();
module.resolveWith(exports);

});
// module body: end

};
// module factory: end

FD40.module("popbox", moduleFactory);

}());
			(function(){

var moduleFactory = function($) {

var module = this; 
var jQuery = $; 
var exports = function() { 

/*!
 * jQuery.scrollTo
 * Copyright (c) 2007-2015 Ariel Flesler - aflesler ○ gmail • com | http://flesler.blogspot.com
 * Licensed under MIT
 * http://flesler.blogspot.com/2007/10/jqueryscrollto.html
 * @projectDescription Lightweight, cross-browser and highly customizable animated scrolling with jQuery
 * @author Ariel Flesler
 * @version 2.1.2
 */
;(function($) {
	'use strict';

	var $scrollTo = $.scrollTo = function(target, duration, settings) {
		return $(window).scrollTo(target, duration, settings);
	};

	$scrollTo.defaults = {
		axis:'xy',
		duration: 0,
		limit:true
	};

	function isWin(elem) {
		return !elem.nodeName ||
			$.inArray(elem.nodeName.toLowerCase(), ['iframe','#document','html','body']) !== -1;
	}		

	$.fn.scrollTo = function(target, duration, settings) {
		if (typeof duration === 'object') {
			settings = duration;
			duration = 0;
		}
		if (typeof settings === 'function') {
			settings = { onAfter:settings };
		}
		if (target === 'max') {
			target = 9e9;
		}

		settings = $.extend({}, $scrollTo.defaults, settings);
		// Speed is still recognized for backwards compatibility
		duration = duration || settings.duration;
		// Make sure the settings are given right
		var queue = settings.queue && settings.axis.length > 1;
		if (queue) {
			// Let's keep the overall duration
			duration /= 2;
		}
		settings.offset = both(settings.offset);
		settings.over = both(settings.over);

		return this.each(function() {
			// Null target yields nothing, just like jQuery does
			if (target === null) return;

			var win = isWin(this),
				elem = win ? this.contentWindow || window : this,
				$elem = $(elem),
				targ = target, 
				attr = {},
				toff;

			switch (typeof targ) {
				// A number will pass the regex
				case 'number':
				case 'string':
					if (/^([+-]=?)?\d+(\.\d+)?(px|%)?$/.test(targ)) {
						targ = both(targ);
						// We are done
						break;
					}
					// Relative/Absolute selector
					targ = win ? $(targ) : $(targ, elem);
					/* falls through */
				case 'object':
					if (targ.length === 0) return;
					// DOMElement / jQuery
					if (targ.is || targ.style) {
						// Get the real position of the target
						toff = (targ = $(targ)).offset();
					}
			}

			var offset = $.isFunction(settings.offset) && settings.offset(elem, targ) || settings.offset;

			$.each(settings.axis.split(''), function(i, axis) {
				var Pos	= axis === 'x' ? 'Left' : 'Top',
					pos = Pos.toLowerCase(),
					key = 'scroll' + Pos,
					prev = $elem[key](),
					max = $scrollTo.max(elem, axis);

				if (toff) {// jQuery / DOMElement
					attr[key] = toff[pos] + (win ? 0 : prev - $elem.offset()[pos]);

					// If it's a dom element, reduce the margin
					if (settings.margin) {
						attr[key] -= parseInt(targ.css('margin'+Pos), 10) || 0;
						attr[key] -= parseInt(targ.css('border'+Pos+'Width'), 10) || 0;
					}

					attr[key] += offset[pos] || 0;

					if (settings.over[pos]) {
						// Scroll to a fraction of its width/height
						attr[key] += targ[axis === 'x'?'width':'height']() * settings.over[pos];
					}
				} else {
					var val = targ[pos];
					// Handle percentage values
					attr[key] = val.slice && val.slice(-1) === '%' ?
						parseFloat(val) / 100 * max
						: val;
				}

				// Number or 'number'
				if (settings.limit && /^\d+$/.test(attr[key])) {
					// Check the limits
					attr[key] = attr[key] <= 0 ? 0 : Math.min(attr[key], max);
				}

				// Don't waste time animating, if there's no need.
				if (!i && settings.axis.length > 1) {
					if (prev === attr[key]) {
						// No animation needed
						attr = {};
					} else if (queue) {
						// Intermediate animation
						animate(settings.onAfterFirst);
						// Don't animate this axis again in the next iteration.
						attr = {};
					}
				}
			});

			animate(settings.onAfter);

			function animate(callback) {
				var opts = $.extend({}, settings, {
					// The queue setting conflicts with animate()
					// Force it to always be true
					queue: true,
					duration: duration,
					complete: callback && function() {
						callback.call(elem, targ, settings);
					}
				});
				$elem.animate(attr, opts);
			}
		});
	};

	$.fn.scrollIntoView = function(target) {

		// TODO: Add support for X axis.
		// TODO: Add support for passing in custom options.

		var target = $(target);
		if (target.length < 1) return;

		var viewportOffset = this.offset(),
			viewportHeight = this.height(),
			viewportTop    = viewportOffset.top,
			viewportBottom = viewportTop + viewportHeight,

			targetOffset = target.offset(),
			targetHeight = target.height(),
			targetTop    = targetOffset.top,
			targetBottom = targetTop + targetHeight;

		if (targetBottom > viewportBottom) {
			return this.scrollTo(target);
		}

		if (targetTop < viewportTop) {
			return this.scrollTo(target, {offset: (viewportHeight - targetHeight) * -1});
		}
	};

	// Max scrolling position, works on quirks mode
	// It only fails (not too badly) on IE, quirks mode.
	$scrollTo.max = function(elem, axis) {
		var Dim = axis === 'x' ? 'Width' : 'Height',
			scroll = 'scroll'+Dim;

		if (!isWin(elem))
			return elem[scroll] - $(elem)[Dim.toLowerCase()]();

		var size = 'client' + Dim,
			doc = elem.ownerDocument || elem.document,
			html = doc.documentElement,
			body = doc.body;

		return Math.max(html[scroll], body[scroll]) - Math.min(html[size], body[size]);
	};

	function both(val) {
		return $.isFunction(val) || $.isPlainObject(val) ? val : { top:val, left:val };
	}

	// Add special hooks so that window scroll properties can be animated
	$.Tween.propHooks.scrollLeft = 
	$.Tween.propHooks.scrollTop = {
		get: function(t) {
			return $(t.elem)[t.prop]();
		},
		set: function(t) {
			var curr = this.get(t);
			// If interrupt is true and user scrolled, stop animating
			if (t.options.interrupt && t._last && t._last !== curr) {
				return $(t.elem).stop();
			}
			var next = Math.round(t.now);
			// Don't waste CPU
			// Browsers don't render floating point scroll
			if (curr !== next) {
				$(t.elem)[t.prop](next);
				t._last = this.get(t);
			}
		}
	};

	// AMD requirement
	return $scrollTo;
})(jQuery);
}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("scrollTo", moduleFactory);

}());			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var exports = function() {

var jQuery = $;

/*!
 * Select2 4.0.3
 * https://select2.github.io
 *
 * Released under the MIT license
 * https://github.com/select2/select2/blob/master/LICENSE.md
 */
(function (factory) {
  if (typeof define === 'function' && define.amd) {
	// AMD. Register as an anonymous module.
	define(['jquery'], factory);
  } else if (typeof exports === 'object') {
	// Node/CommonJS
	factory(require('jquery'));
  } else {
	// Browser globals
	factory(jQuery);
  }
}(function (jQuery) {
  // This is needed so we can catch the AMD loader configuration and use it
  // The inner file should be wrapped (by `banner.start.js`) in a function that
  // returns the AMD loader references.
  var S2 =
(function () {
  // Restore the Select2 AMD loader so it can be used
  // Needed mostly in the language files, where the loader is not inserted
  if (jQuery && jQuery.fn && jQuery.fn.select2 && jQuery.fn.select2.amd) {
	var S2 = jQuery.fn.select2.amd;
  }
var S2;(function () { if (!S2 || !S2.requirejs) {
if (!S2) { S2 = {}; } else { require = S2; }
/**
 * @license almond 0.3.1 Copyright (c) 2011-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
	var main, req, makeMap, handlers,
		defined = {},
		waiting = {},
		config = {},
		defining = {},
		hasOwn = Object.prototype.hasOwnProperty,
		aps = [].slice,
		jsSuffixRegExp = /\.js$/;

	function hasProp(obj, prop) {
		return hasOwn.call(obj, prop);
	}

	/**
	 * Given a relative module name, like ./something, normalize it to
	 * a real name that can be mapped to a path.
	 * @param {String} name the relative name
	 * @param {String} baseName a real name that the name arg is relative
	 * to.
	 * @returns {String} normalized name
	 */
	function normalize(name, baseName) {
		var nameParts, nameSegment, mapValue, foundMap, lastIndex,
			foundI, foundStarMap, starI, i, j, part,
			baseParts = baseName && baseName.split("/"),
			map = config.map,
			starMap = (map && map['*']) || {};

		//Adjust any relative paths.
		if (name && name.charAt(0) === ".") {
			//If have a base name, try to normalize against it,
			//otherwise, assume it is a top-level require that will
			//be relative to baseUrl in the end.
			if (baseName) {
				name = name.split('/');
				lastIndex = name.length - 1;

				// Node .js allowance:
				if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
					name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
				}

				//Lop off the last part of baseParts, so that . matches the
				//"directory" and not name of the baseName's module. For instance,
				//baseName of "one/two/three", maps to "one/two/three.js", but we
				//want the directory, "one/two" for this normalization.
				name = baseParts.slice(0, baseParts.length - 1).concat(name);

				//start trimDots
				for (i = 0; i < name.length; i += 1) {
					part = name[i];
					if (part === ".") {
						name.splice(i, 1);
						i -= 1;
					} else if (part === "..") {
						if (i === 1 && (name[2] === '..' || name[0] === '..')) {
							//End of the line. Keep at least one non-dot
							//path segment at the front so it can be mapped
							//correctly to disk. Otherwise, there is likely
							//no path mapping for a path starting with '..'.
							//This can still fail, but catches the most reasonable
							//uses of ..
							break;
						} else if (i > 0) {
							name.splice(i - 1, 2);
							i -= 2;
						}
					}
				}
				//end trimDots

				name = name.join("/");
			} else if (name.indexOf('./') === 0) {
				// No baseName, so this is ID is resolved relative
				// to baseUrl, pull off the leading dot.
				name = name.substring(2);
			}
		}

		//Apply map config if available.
		if ((baseParts || starMap) && map) {
			nameParts = name.split('/');

			for (i = nameParts.length; i > 0; i -= 1) {
				nameSegment = nameParts.slice(0, i).join("/");

				if (baseParts) {
					//Find the longest baseName segment match in the config.
					//So, do joins on the biggest to smallest lengths of baseParts.
					for (j = baseParts.length; j > 0; j -= 1) {
						mapValue = map[baseParts.slice(0, j).join('/')];

						//baseName segment has  config, find if it has one for
						//this name.
						if (mapValue) {
							mapValue = mapValue[nameSegment];
							if (mapValue) {
								//Match, update name to the new value.
								foundMap = mapValue;
								foundI = i;
								break;
							}
						}
					}
				}

				if (foundMap) {
					break;
				}

				//Check for a star map match, but just hold on to it,
				//if there is a shorter segment match later in a matching
				//config, then favor over this star map.
				if (!foundStarMap && starMap && starMap[nameSegment]) {
					foundStarMap = starMap[nameSegment];
					starI = i;
				}
			}

			if (!foundMap && foundStarMap) {
				foundMap = foundStarMap;
				foundI = starI;
			}

			if (foundMap) {
				nameParts.splice(0, foundI, foundMap);
				name = nameParts.join('/');
			}
		}

		return name;
	}

	function makeRequire(relName, forceSync) {
		return function () {
			//A version of a require function that passes a moduleName
			//value for items that may need to
			//look up paths relative to the moduleName
			var args = aps.call(arguments, 0);

			//If first arg is not require('string'), and there is only
			//one arg, it is the array form without a callback. Insert
			//a null so that the following concat is correct.
			if (typeof args[0] !== 'string' && args.length === 1) {
				args.push(null);
			}
			return req.apply(undef, args.concat([relName, forceSync]));
		};
	}

	function makeNormalize(relName) {
		return function (name) {
			return normalize(name, relName);
		};
	}

	function makeLoad(depName) {
		return function (value) {
			defined[depName] = value;
		};
	}

	function callDep(name) {
		if (hasProp(waiting, name)) {
			var args = waiting[name];
			delete waiting[name];
			defining[name] = true;
			main.apply(undef, args);
		}

		if (!hasProp(defined, name) && !hasProp(defining, name)) {
			throw new Error('No ' + name);
		}
		return defined[name];
	}

	//Turns a plugin!resource to [plugin, resource]
	//with the plugin being undefined if the name
	//did not have a plugin prefix.
	function splitPrefix(name) {
		var prefix,
			index = name ? name.indexOf('!') : -1;
		if (index > -1) {
			prefix = name.substring(0, index);
			name = name.substring(index + 1, name.length);
		}
		return [prefix, name];
	}

	/**
	 * Makes a name map, normalizing the name, and using a plugin
	 * for normalization if necessary. Grabs a ref to plugin
	 * too, as an optimization.
	 */
	makeMap = function (name, relName) {
		var plugin,
			parts = splitPrefix(name),
			prefix = parts[0];

		name = parts[1];

		if (prefix) {
			prefix = normalize(prefix, relName);
			plugin = callDep(prefix);
		}

		//Normalize according
		if (prefix) {
			if (plugin && plugin.normalize) {
				name = plugin.normalize(name, makeNormalize(relName));
			} else {
				name = normalize(name, relName);
			}
		} else {
			name = normalize(name, relName);
			parts = splitPrefix(name);
			prefix = parts[0];
			name = parts[1];
			if (prefix) {
				plugin = callDep(prefix);
			}
		}

		//Using ridiculous property names for space reasons
		return {
			f: prefix ? prefix + '!' + name : name, //fullName
			n: name,
			pr: prefix,
			p: plugin
		};
	};

	function makeConfig(name) {
		return function () {
			return (config && config.config && config.config[name]) || {};
		};
	}

	handlers = {
		require: function (name) {
			return makeRequire(name);
		},
		exports: function (name) {
			var e = defined[name];
			if (typeof e !== 'undefined') {
				return e;
			} else {
				return (defined[name] = {});
			}
		},
		module: function (name) {
			return {
				id: name,
				uri: '',
				exports: defined[name],
				config: makeConfig(name)
			};
		}
	};

	main = function (name, deps, callback, relName) {
		var cjsModule, depName, ret, map, i,
			args = [],
			callbackType = typeof callback,
			usingExports;

		//Use name if no relName
		relName = relName || name;

		//Call the callback to define the module, if necessary.
		if (callbackType === 'undefined' || callbackType === 'function') {
			//Pull out the defined dependencies and pass the ordered
			//values to the callback.
			//Default to [require, exports, module] if no deps
			deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
			for (i = 0; i < deps.length; i += 1) {
				map = makeMap(deps[i], relName);
				depName = map.f;

				//Fast path CommonJS standard dependencies.
				if (depName === "require") {
					args[i] = handlers.require(name);
				} else if (depName === "exports") {
					//CommonJS module spec 1.1
					args[i] = handlers.exports(name);
					usingExports = true;
				} else if (depName === "module") {
					//CommonJS module spec 1.1
					cjsModule = args[i] = handlers.module(name);
				} else if (hasProp(defined, depName) ||
						   hasProp(waiting, depName) ||
						   hasProp(defining, depName)) {
					args[i] = callDep(depName);
				} else if (map.p) {
					map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
					args[i] = defined[depName];
				} else {
					throw new Error(name + ' missing ' + depName);
				}
			}

			ret = callback ? callback.apply(defined[name], args) : undefined;

			if (name) {
				//If setting exports via "module" is in play,
				//favor that over return value and exports. After that,
				//favor a non-undefined return value over exports use.
				if (cjsModule && cjsModule.exports !== undef &&
						cjsModule.exports !== defined[name]) {
					defined[name] = cjsModule.exports;
				} else if (ret !== undef || !usingExports) {
					//Use the return value from the function.
					defined[name] = ret;
				}
			}
		} else if (name) {
			//May just be an object definition for the module. Only
			//worry about defining if have a module name.
			defined[name] = callback;
		}
	};

	requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
		if (typeof deps === "string") {
			if (handlers[deps]) {
				//callback in this case is really relName
				return handlers[deps](callback);
			}
			//Just return the module wanted. In this scenario, the
			//deps arg is the module name, and second arg (if passed)
			//is just the relName.
			//Normalize module name, if it contains . or ..
			return callDep(makeMap(deps, callback).f);
		} else if (!deps.splice) {
			//deps is a config object, not an array.
			config = deps;
			if (config.deps) {
				req(config.deps, config.callback);
			}
			if (!callback) {
				return;
			}

			if (callback.splice) {
				//callback is an array, which means it is a dependency list.
				//Adjust args if there are dependencies
				deps = callback;
				callback = relName;
				relName = null;
			} else {
				deps = undef;
			}
		}

		//Support require(['a'])
		callback = callback || function () {};

		//If relName is a function, it is an errback handler,
		//so remove it.
		if (typeof relName === 'function') {
			relName = forceSync;
			forceSync = alt;
		}

		//Simulate async callback;
		if (forceSync) {
			main(undef, deps, callback, relName);
		} else {
			//Using a non-zero value because of concern for what old browsers
			//do, and latest browsers "upgrade" to 4 if lower value is used:
			//http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
			//If want a value immediately, use require('id') instead -- something
			//that works in almond on the global level, but not guaranteed and
			//unlikely to work in other AMD implementations.
			setTimeout(function () {
				main(undef, deps, callback, relName);
			}, 4);
		}

		return req;
	};

	/**
	 * Just drops the config on the floor, but returns req in case
	 * the config return value is used.
	 */
	req.config = function (cfg) {
		return req(cfg);
	};

	/**
	 * Expose module registry for debugging and tooling
	 */
	requirejs._defined = defined;

	define = function (name, deps, callback) {
		if (typeof name !== 'string') {
			throw new Error('See almond README: incorrect module build, no module name');
		}

		//This module may not have dependencies
		if (!deps.splice) {
			//deps is not an array, so probably means
			//an object literal or factory function for
			//the value. Adjust args.
			callback = deps;
			deps = [];
		}

		if (!hasProp(defined, name) && !hasProp(waiting, name)) {
			waiting[name] = [name, deps, callback];
		}
	};

	define.amd = {
		jQuery: true
	};
}());

S2.requirejs = requirejs;S2.require = require;S2.define = define;
}
}());
S2.define("almond", function(){});

/* global jQuery:false, $:false */
S2.define('jquery',[],function () {
  var _$ = jQuery || $;

  if (_$ == null && console && console.error) {
	console.error(
	  'Select2: An instance of jQuery or a jQuery-compatible library was not ' +
	  'found. Make sure that you are including jQuery before Select2 on your ' +
	  'web page.'
	);
  }

  return _$;
});

S2.define('select2/utils',[
  'jquery'
], function ($) {
  var Utils = {};

  Utils.Extend = function (ChildClass, SuperClass) {
	var __hasProp = {}.hasOwnProperty;

	function BaseConstructor () {
	  this.constructor = ChildClass;
	}

	for (var key in SuperClass) {
	  if (__hasProp.call(SuperClass, key)) {
		ChildClass[key] = SuperClass[key];
	  }
	}

	BaseConstructor.prototype = SuperClass.prototype;
	ChildClass.prototype = new BaseConstructor();
	ChildClass.__super__ = SuperClass.prototype;

	return ChildClass;
  };

  function getMethods (theClass) {
	var proto = theClass.prototype;

	var methods = [];

	for (var methodName in proto) {
	  var m = proto[methodName];

	  if (typeof m !== 'function') {
		continue;
	  }

	  if (methodName === 'constructor') {
		continue;
	  }

	  methods.push(methodName);
	}

	return methods;
  }

  Utils.Decorate = function (SuperClass, DecoratorClass) {
	var decoratedMethods = getMethods(DecoratorClass);
	var superMethods = getMethods(SuperClass);

	function DecoratedClass () {
	  var unshift = Array.prototype.unshift;

	  var argCount = DecoratorClass.prototype.constructor.length;

	  var calledConstructor = SuperClass.prototype.constructor;

	  if (argCount > 0) {
		unshift.call(arguments, SuperClass.prototype.constructor);

		calledConstructor = DecoratorClass.prototype.constructor;
	  }

	  calledConstructor.apply(this, arguments);
	}

	DecoratorClass.displayName = SuperClass.displayName;

	function ctr () {
	  this.constructor = DecoratedClass;
	}

	DecoratedClass.prototype = new ctr();

	for (var m = 0; m < superMethods.length; m++) {
		var superMethod = superMethods[m];

		DecoratedClass.prototype[superMethod] =
		  SuperClass.prototype[superMethod];
	}

	var calledMethod = function (methodName) {
	  // Stub out the original method if it's not decorating an actual method
	  var originalMethod = function () {};

	  if (methodName in DecoratedClass.prototype) {
		originalMethod = DecoratedClass.prototype[methodName];
	  }

	  var decoratedMethod = DecoratorClass.prototype[methodName];

	  return function () {
		var unshift = Array.prototype.unshift;

		unshift.call(arguments, originalMethod);

		return decoratedMethod.apply(this, arguments);
	  };
	};

	for (var d = 0; d < decoratedMethods.length; d++) {
	  var decoratedMethod = decoratedMethods[d];

	  DecoratedClass.prototype[decoratedMethod] = calledMethod(decoratedMethod);
	}

	return DecoratedClass;
  };

  var Observable = function () {
	this.listeners = {};
  };

  Observable.prototype.on = function (event, callback) {
	this.listeners = this.listeners || {};

	if (event in this.listeners) {
	  this.listeners[event].push(callback);
	} else {
	  this.listeners[event] = [callback];
	}
  };

  Observable.prototype.trigger = function (event) {
	var slice = Array.prototype.slice;
	var params = slice.call(arguments, 1);

	this.listeners = this.listeners || {};

	// Params should always come in as an array
	if (params == null) {
	  params = [];
	}

	// If there are no arguments to the event, use a temporary object
	if (params.length === 0) {
	  params.push({});
	}

	// Set the `_type` of the first object to the event
	params[0]._type = event;

	if (event in this.listeners) {
	  this.invoke(this.listeners[event], slice.call(arguments, 1));
	}

	if ('*' in this.listeners) {
	  this.invoke(this.listeners['*'], arguments);
	}
  };

  Observable.prototype.invoke = function (listeners, params) {
	for (var i = 0, len = listeners.length; i < len; i++) {
	  listeners[i].apply(this, params);
	}
  };

  Utils.Observable = Observable;

  Utils.generateChars = function (length) {
	var chars = '';

	for (var i = 0; i < length; i++) {
	  var randomChar = Math.floor(Math.random() * 36);
	  chars += randomChar.toString(36);
	}

	return chars;
  };

  Utils.bind = function (func, context) {
	return function () {
	  func.apply(context, arguments);
	};
  };

  Utils._convertData = function (data) {
	for (var originalKey in data) {
	  var keys = originalKey.split('-');

	  var dataLevel = data;

	  if (keys.length === 1) {
		continue;
	  }

	  for (var k = 0; k < keys.length; k++) {
		var key = keys[k];

		// Lowercase the first letter
		// By default, dash-separated becomes camelCase
		key = key.substring(0, 1).toLowerCase() + key.substring(1);

		if (!(key in dataLevel)) {
		  dataLevel[key] = {};
		}

		if (k == keys.length - 1) {
		  dataLevel[key] = data[originalKey];
		}

		dataLevel = dataLevel[key];
	  }

	  delete data[originalKey];
	}

	return data;
  };

  Utils.hasScroll = function (index, el) {
	// Adapted from the function created by @ShadowScripter
	// and adapted by @BillBarry on the Stack Exchange Code Review website.
	// The original code can be found at
	// http://codereview.stackexchange.com/q/13338
	// and was designed to be used with the Sizzle selector engine.

	var $el = $(el);
	var overflowX = el.style.overflowX;
	var overflowY = el.style.overflowY;

	//Check both x and y declarations
	if (overflowX === overflowY &&
		(overflowY === 'hidden' || overflowY === 'visible')) {
	  return false;
	}

	if (overflowX === 'scroll' || overflowY === 'scroll') {
	  return true;
	}

	return ($el.innerHeight() < el.scrollHeight ||
	  $el.innerWidth() < el.scrollWidth);
  };

  Utils.escapeMarkup = function (markup) {
	var replaceMap = {
	  '\\': '&#92;',
	  '&': '&amp;',
	  '<': '&lt;',
	  '>': '&gt;',
	  '"': '&quot;',
	  '\'': '&#39;',
	  '/': '&#47;'
	};

	// Do not try to escape the markup if it's not a string
	if (typeof markup !== 'string') {
	  return markup;
	}

	return String(markup).replace(/[&<>"'\/\\]/g, function (match) {
	  return replaceMap[match];
	});
  };

  // Append an array of jQuery nodes to a given element.
  Utils.appendMany = function ($element, $nodes) {
	// jQuery 1.7.x does not support $.fn.append() with an array
	// Fall back to a jQuery object collection using $.fn.add()
	if ($.fn.jquery.substr(0, 3) === '1.7') {
	  var $jqNodes = $();

	  $.map($nodes, function (node) {
		$jqNodes = $jqNodes.add(node);
	  });

	  $nodes = $jqNodes;
	}

	$element.append($nodes);
  };

  return Utils;
});

S2.define('select2/results',[
  'jquery',
  './utils'
], function ($, Utils) {
  function Results ($element, options, dataAdapter) {
	this.$element = $element;
	this.data = dataAdapter;
	this.options = options;

	Results.__super__.constructor.call(this);
  }

  Utils.Extend(Results, Utils.Observable);

  Results.prototype.render = function () {
	var $results = $(
	  '<ul class="select2-results__options" role="tree"></ul>'
	);

	if (this.options.get('multiple')) {
	  $results.attr('aria-multiselectable', 'true');
	}

	this.$results = $results;

	return $results;
  };

  Results.prototype.clear = function () {
	this.$results.empty();
  };

  Results.prototype.displayMessage = function (params) {
	var escapeMarkup = this.options.get('escapeMarkup');

	this.clear();
	this.hideLoading();

	var $message = $(
	  '<li role="treeitem" aria-live="assertive"' +
	  ' class="select2-results__option"></li>'
	);

	var message = this.options.get('translations').get(params.message);

	$message.append(
	  escapeMarkup(
		message(params.args)
	  )
	);

	$message[0].className += ' select2-results__message';

	this.$results.append($message);
  };

  Results.prototype.hideMessages = function () {
	this.$results.find('.select2-results__message').remove();
  };

  Results.prototype.append = function (data) {
	this.hideLoading();

	var $options = [];

	if (data.results == null || data.results.length === 0) {
	  if (this.$results.children().length === 0) {
		this.trigger('results:message', {
		  message: 'noResults'
		});
	  }

	  return;
	}

	data.results = this.sort(data.results);

	for (var d = 0; d < data.results.length; d++) {
	  var item = data.results[d];

	  var $option = this.option(item);

	  $options.push($option);
	}

	this.$results.append($options);
  };

  Results.prototype.position = function ($results, $dropdown) {
	var $resultsContainer = $dropdown.find('.select2-results');
	$resultsContainer.append($results);
  };

  Results.prototype.sort = function (data) {
	var sorter = this.options.get('sorter');

	return sorter(data);
  };

  Results.prototype.highlightFirstItem = function () {
	var $options = this.$results
	  .find('.select2-results__option[aria-selected]');

	var $selected = $options.filter('[aria-selected=true]');

	// Check if there are any selected options
	if ($selected.length > 0) {
	  // If there are selected options, highlight the first
	  $selected.first().trigger('mouseenter');
	} else {
	  // If there are no selected options, highlight the first option
	  // in the dropdown
	  $options.first().trigger('mouseenter');
	}

	this.ensureHighlightVisible();
  };

  Results.prototype.setClasses = function () {
	var self = this;

	this.data.current(function (selected) {
	  var selectedIds = $.map(selected, function (s) {
		return s.id.toString();
	  });

	  var $options = self.$results
		.find('.select2-results__option[aria-selected]');

	  $options.each(function () {
		var $option = $(this);

		var item = $.data(this, 'data');

		// id needs to be converted to a string when comparing
		var id = '' + item.id;

		if ((item.element != null && item.element.selected) ||
			(item.element == null && $.inArray(id, selectedIds) > -1)) {
		  $option.attr('aria-selected', 'true');
		} else {
		  $option.attr('aria-selected', 'false');
		}
	  });

	});
  };

  Results.prototype.showLoading = function (params) {
	this.hideLoading();

	var loadingMore = this.options.get('translations').get('searching');

	var loading = {
	  disabled: true,
	  loading: true,
	  text: loadingMore(params)
	};
	var $loading = this.option(loading);
	$loading.className += ' loading-results';

	this.$results.prepend($loading);
  };

  Results.prototype.hideLoading = function () {
	this.$results.find('.loading-results').remove();
  };

  Results.prototype.option = function (data) {
	var option = document.createElement('li');
	option.className = 'select2-results__option';

	var attrs = {
	  'role': 'treeitem',
	  'aria-selected': 'false'
	};

	if (data.disabled) {
	  delete attrs['aria-selected'];
	  attrs['aria-disabled'] = 'true';
	}

	if (data.id == null) {
	  delete attrs['aria-selected'];
	}

	if (data._resultId != null) {
	  option.id = data._resultId;
	}

	if (data.title) {
	  option.title = data.title;
	}

	if (data.children) {
	  attrs.role = 'group';
	  attrs['aria-label'] = data.text;
	  delete attrs['aria-selected'];
	}

	for (var attr in attrs) {
	  var val = attrs[attr];

	  option.setAttribute(attr, val);
	}

	if (data.children) {
	  var $option = $(option);

	  var label = document.createElement('strong');
	  label.className = 'select2-results__group';

	  var $label = $(label);
	  this.template(data, label);

	  var $children = [];

	  for (var c = 0; c < data.children.length; c++) {
		var child = data.children[c];

		var $child = this.option(child);

		$children.push($child);
	  }

	  var $childrenContainer = $('<ul></ul>', {
		'class': 'select2-results__options select2-results__options--nested'
	  });

	  $childrenContainer.append($children);

	  $option.append(label);
	  $option.append($childrenContainer);
	} else {
	  this.template(data, option);
	}

	$.data(option, 'data', data);

	return option;
  };

  Results.prototype.bind = function (container, $container) {
	var self = this;

	var id = container.id + '-results';

	this.$results.attr('id', id);

	container.on('results:all', function (params) {
	  self.clear();
	  self.append(params.data);

	  if (container.isOpen()) {
		self.setClasses();
		self.highlightFirstItem();
	  }
	});

	container.on('results:append', function (params) {
	  self.append(params.data);

	  if (container.isOpen()) {
		self.setClasses();
	  }
	});

	container.on('query', function (params) {
	  self.hideMessages();
	  self.showLoading(params);
	});

	container.on('select', function () {
	  if (!container.isOpen()) {
		return;
	  }

	  self.setClasses();
	  self.highlightFirstItem();
	});

	container.on('unselect', function () {
	  if (!container.isOpen()) {
		return;
	  }

	  self.setClasses();
	  self.highlightFirstItem();
	});

	container.on('open', function () {
	  // When the dropdown is open, aria-expended="true"
	  self.$results.attr('aria-expanded', 'true');
	  self.$results.attr('aria-hidden', 'false');

	  self.setClasses();
	  self.ensureHighlightVisible();
	});

	container.on('close', function () {
	  // When the dropdown is closed, aria-expended="false"
	  self.$results.attr('aria-expanded', 'false');
	  self.$results.attr('aria-hidden', 'true');
	  self.$results.removeAttr('aria-activedescendant');
	});

	container.on('results:toggle', function () {
	  var $highlighted = self.getHighlightedResults();

	  if ($highlighted.length === 0) {
		return;
	  }

	  $highlighted.trigger('mouseup');
	});

	container.on('results:select', function () {
	  var $highlighted = self.getHighlightedResults();

	  if ($highlighted.length === 0) {
		return;
	  }

	  var data = $highlighted.data('data');

	  if ($highlighted.attr('aria-selected') == 'true') {
		self.trigger('close', {});
	  } else {
		self.trigger('select', {
		  data: data
		});
	  }
	});

	container.on('results:previous', function () {
	  var $highlighted = self.getHighlightedResults();

	  var $options = self.$results.find('[aria-selected]');

	  var currentIndex = $options.index($highlighted);

	  // If we are already at te top, don't move further
	  if (currentIndex === 0) {
		return;
	  }

	  var nextIndex = currentIndex - 1;

	  // If none are highlighted, highlight the first
	  if ($highlighted.length === 0) {
		nextIndex = 0;
	  }

	  var $next = $options.eq(nextIndex);

	  $next.trigger('mouseenter');

	  var currentOffset = self.$results.offset().top;
	  var nextTop = $next.offset().top;
	  var nextOffset = self.$results.scrollTop() + (nextTop - currentOffset);

	  if (nextIndex === 0) {
		self.$results.scrollTop(0);
	  } else if (nextTop - currentOffset < 0) {
		self.$results.scrollTop(nextOffset);
	  }
	});

	container.on('results:next', function () {
	  var $highlighted = self.getHighlightedResults();

	  var $options = self.$results.find('[aria-selected]');

	  var currentIndex = $options.index($highlighted);

	  var nextIndex = currentIndex + 1;

	  // If we are at the last option, stay there
	  if (nextIndex >= $options.length) {
		return;
	  }

	  var $next = $options.eq(nextIndex);

	  $next.trigger('mouseenter');

	  var currentOffset = self.$results.offset().top +
		self.$results.outerHeight(false);
	  var nextBottom = $next.offset().top + $next.outerHeight(false);
	  var nextOffset = self.$results.scrollTop() + nextBottom - currentOffset;

	  if (nextIndex === 0) {
		self.$results.scrollTop(0);
	  } else if (nextBottom > currentOffset) {
		self.$results.scrollTop(nextOffset);
	  }
	});

	container.on('results:focus', function (params) {
	  params.element.addClass('select2-results__option--highlighted');
	});

	container.on('results:message', function (params) {
	  self.displayMessage(params);
	});

	if ($.fn.mousewheel) {
	  this.$results.on('mousewheel', function (e) {
		var top = self.$results.scrollTop();

		var bottom = self.$results.get(0).scrollHeight - top + e.deltaY;

		var isAtTop = e.deltaY > 0 && top - e.deltaY <= 0;
		var isAtBottom = e.deltaY < 0 && bottom <= self.$results.height();

		if (isAtTop) {
		  self.$results.scrollTop(0);

		  e.preventDefault();
		  e.stopPropagation();
		} else if (isAtBottom) {
		  self.$results.scrollTop(
			self.$results.get(0).scrollHeight - self.$results.height()
		  );

		  e.preventDefault();
		  e.stopPropagation();
		}
	  });
	}

	this.$results.on('mouseup', '.select2-results__option[aria-selected]',
	  function (evt) {
	  var $this = $(this);

	  var data = $this.data('data');

	  if ($this.attr('aria-selected') === 'true') {
		if (self.options.get('multiple')) {
		  self.trigger('unselect', {
			originalEvent: evt,
			data: data
		  });
		} else {
		  self.trigger('close', {});
		}

		return;
	  }

	  self.trigger('select', {
		originalEvent: evt,
		data: data
	  });
	});

	this.$results.on('mouseenter', '.select2-results__option[aria-selected]',
	  function (evt) {
	  var data = $(this).data('data');

	  self.getHighlightedResults()
		  .removeClass('select2-results__option--highlighted');

	  self.trigger('results:focus', {
		data: data,
		element: $(this)
	  });
	});
  };

  Results.prototype.getHighlightedResults = function () {
	var $highlighted = this.$results
	.find('.select2-results__option--highlighted');

	return $highlighted;
  };

  Results.prototype.destroy = function () {
	this.$results.remove();
  };

  Results.prototype.ensureHighlightVisible = function () {
	var $highlighted = this.getHighlightedResults();

	if ($highlighted.length === 0) {
	  return;
	}

	var $options = this.$results.find('[aria-selected]');

	var currentIndex = $options.index($highlighted);

	var currentOffset = this.$results.offset().top;
	var nextTop = $highlighted.offset().top;
	var nextOffset = this.$results.scrollTop() + (nextTop - currentOffset);

	var offsetDelta = nextTop - currentOffset;
	nextOffset -= $highlighted.outerHeight(false) * 2;

	if (currentIndex <= 2) {
	  this.$results.scrollTop(0);
	} else if (offsetDelta > this.$results.outerHeight() || offsetDelta < 0) {
	  this.$results.scrollTop(nextOffset);
	}
  };

  Results.prototype.template = function (result, container) {
	var template = this.options.get('templateResult');
	var escapeMarkup = this.options.get('escapeMarkup');

	var content = template(result, container);

	if (content == null) {
	  container.style.display = 'none';
	} else if (typeof content === 'string') {
	  container.innerHTML = escapeMarkup(content);
	} else {
	  $(container).append(content);
	}
  };

  return Results;
});

S2.define('select2/keys',[

], function () {
  var KEYS = {
	BACKSPACE: 8,
	TAB: 9,
	ENTER: 13,
	SHIFT: 16,
	CTRL: 17,
	ALT: 18,
	ESC: 27,
	SPACE: 32,
	PAGE_UP: 33,
	PAGE_DOWN: 34,
	END: 35,
	HOME: 36,
	LEFT: 37,
	UP: 38,
	RIGHT: 39,
	DOWN: 40,
	DELETE: 46
  };

  return KEYS;
});

S2.define('select2/selection/base',[
  'jquery',
  '../utils',
  '../keys'
], function ($, Utils, KEYS) {
  function BaseSelection ($element, options) {
	this.$element = $element;
	this.options = options;

	BaseSelection.__super__.constructor.call(this);
  }

  Utils.Extend(BaseSelection, Utils.Observable);

  BaseSelection.prototype.render = function () {
	var $selection = $(
	  '<span class="select2-selection" role="combobox" ' +
	  ' aria-haspopup="true" aria-expanded="false">' +
	  '</span>'
	);

	this._tabindex = 0;

	if (this.$element.data('old-tabindex') != null) {
	  this._tabindex = this.$element.data('old-tabindex');
	} else if (this.$element.attr('tabindex') != null) {
	  this._tabindex = this.$element.attr('tabindex');
	}

	$selection.attr('title', this.$element.attr('title'));
	$selection.attr('tabindex', this._tabindex);

	this.$selection = $selection;

	return $selection;
  };

  BaseSelection.prototype.bind = function (container, $container) {
	var self = this;

	var id = container.id + '-container';
	var resultsId = container.id + '-results';

	this.container = container;

	this.$selection.on('focus', function (evt) {
	  self.trigger('focus', evt);
	});

	this.$selection.on('blur', function (evt) {
	  self._handleBlur(evt);
	});

	this.$selection.on('keydown', function (evt) {
	  self.trigger('keypress', evt);

	  if (evt.which === KEYS.SPACE) {
		evt.preventDefault();
	  }
	});

	container.on('results:focus', function (params) {
	  self.$selection.attr('aria-activedescendant', params.data._resultId);
	});

	container.on('selection:update', function (params) {
	  self.update(params.data);
	});

	container.on('open', function () {
	  // When the dropdown is open, aria-expanded="true"
	  self.$selection.attr('aria-expanded', 'true');
	  self.$selection.attr('aria-owns', resultsId);

	  self._attachCloseHandler(container);
	});

	container.on('close', function () {
	  // When the dropdown is closed, aria-expanded="false"
	  self.$selection.attr('aria-expanded', 'false');
	  self.$selection.removeAttr('aria-activedescendant');
	  self.$selection.removeAttr('aria-owns');

	  self.$selection.focus();

	  self._detachCloseHandler(container);
	});

	container.on('enable', function () {
	  self.$selection.attr('tabindex', self._tabindex);
	});

	container.on('disable', function () {
	  self.$selection.attr('tabindex', '-1');
	});
  };

  BaseSelection.prototype._handleBlur = function (evt) {
	var self = this;

	// This needs to be delayed as the active element is the body when the tab
	// key is pressed, possibly along with others.
	window.setTimeout(function () {
	  // Don't trigger `blur` if the focus is still in the selection
	  if (
		(document.activeElement == self.$selection[0]) ||
		($.contains(self.$selection[0], document.activeElement))
	  ) {
		return;
	  }

	  self.trigger('blur', evt);
	}, 1);
  };

  BaseSelection.prototype._attachCloseHandler = function (container) {
	var self = this;

	$(document.body).on('mousedown.select2.' + container.id, function (e) {
	  var $target = $(e.target);

	  var $select = $target.closest('.select2');

	  var $all = $('.select2.select2-container--open');

	  $all.each(function () {
		var $this = $(this);

		if (this == $select[0]) {
		  return;
		}

		var $element = $this.data('element');

		$element.select2('close');
	  });
	});
  };

  BaseSelection.prototype._detachCloseHandler = function (container) {
	$(document.body).off('mousedown.select2.' + container.id);
  };

  BaseSelection.prototype.position = function ($selection, $container) {
	var $selectionContainer = $container.find('.selection');
	$selectionContainer.append($selection);
  };

  BaseSelection.prototype.destroy = function () {
	this._detachCloseHandler(this.container);
  };

  BaseSelection.prototype.update = function (data) {
	throw new Error('The `update` method must be defined in child classes.');
  };

  return BaseSelection;
});

S2.define('select2/selection/single',[
  'jquery',
  './base',
  '../utils',
  '../keys'
], function ($, BaseSelection, Utils, KEYS) {
  function SingleSelection () {
	SingleSelection.__super__.constructor.apply(this, arguments);
  }

  Utils.Extend(SingleSelection, BaseSelection);

  SingleSelection.prototype.render = function () {
	var $selection = SingleSelection.__super__.render.call(this);

	$selection.addClass('select2-selection--single');

	$selection.html(
	  '<span class="select2-selection__rendered"></span>' +
	  '<span class="select2-selection__arrow" role="presentation">' +
		'<b role="presentation"></b>' +
	  '</span>'
	);

	return $selection;
  };

  SingleSelection.prototype.bind = function (container, $container) {
	var self = this;

	SingleSelection.__super__.bind.apply(this, arguments);

	var id = container.id + '-container';

	this.$selection.find('.select2-selection__rendered').attr('id', id);
	this.$selection.attr('aria-labelledby', id);

	this.$selection.on('mousedown', function (evt) {
	  // Only respond to left clicks
	  if (evt.which !== 1) {
		return;
	  }

	  self.trigger('toggle', {
		originalEvent: evt
	  });
	});

	this.$selection.on('focus', function (evt) {
	  // User focuses on the container
	});

	this.$selection.on('blur', function (evt) {
	  // User exits the container
	});

	container.on('focus', function (evt) {
	  if (!container.isOpen()) {
		self.$selection.focus();
	  }
	});

	container.on('selection:update', function (params) {
	  self.update(params.data);
	});
  };

  SingleSelection.prototype.clear = function () {
	this.$selection.find('.select2-selection__rendered').empty();
  };

  SingleSelection.prototype.display = function (data, container) {
	var template = this.options.get('templateSelection');
	var escapeMarkup = this.options.get('escapeMarkup');

	return escapeMarkup(template(data, container));
  };

  SingleSelection.prototype.selectionContainer = function () {
	return $('<span></span>');
  };

  SingleSelection.prototype.update = function (data) {
	if (data.length === 0) {
	  this.clear();
	  return;
	}

	var selection = data[0];

	var $rendered = this.$selection.find('.select2-selection__rendered');
	var formatted = this.display(selection, $rendered);

	$rendered.empty().append(formatted);
	$rendered.prop('title', selection.title || selection.text);
  };

  return SingleSelection;
});

S2.define('select2/selection/multiple',[
  'jquery',
  './base',
  '../utils'
], function ($, BaseSelection, Utils) {
  function MultipleSelection ($element, options) {
	MultipleSelection.__super__.constructor.apply(this, arguments);
  }

  Utils.Extend(MultipleSelection, BaseSelection);

  MultipleSelection.prototype.render = function () {
	var $selection = MultipleSelection.__super__.render.call(this);

	$selection.addClass('select2-selection--multiple');

	$selection.html(
	  '<ul class="select2-selection__rendered"></ul>'
	);

	return $selection;
  };

  MultipleSelection.prototype.bind = function (container, $container) {
	var self = this;

	MultipleSelection.__super__.bind.apply(this, arguments);

	this.$selection.on('click', function (evt) {
	  self.trigger('toggle', {
		originalEvent: evt
	  });
	});

	this.$selection.on(
	  'click',
	  '.select2-selection__choice__remove',
	  function (evt) {
		// Ignore the event if it is disabled
		if (self.options.get('disabled')) {
		  return;
		}

		var $remove = $(this);
		var $selection = $remove.parent();

		var data = $selection.data('data');

		self.trigger('unselect', {
		  originalEvent: evt,
		  data: data
		});
	  }
	);
  };

  MultipleSelection.prototype.clear = function () {
	this.$selection.find('.select2-selection__rendered').empty();
  };

  MultipleSelection.prototype.display = function (data, container) {
	var template = this.options.get('templateSelection');
	var escapeMarkup = this.options.get('escapeMarkup');

	return escapeMarkup(template(data, container));
  };

  MultipleSelection.prototype.selectionContainer = function () {
	var $container = $(
	  '<li class="select2-selection__choice">' +
		'<span class="select2-selection__choice__remove" role="presentation">' +
		  '&times;' +
		'</span>' +
	  '</li>'
	);

	return $container;
  };

  MultipleSelection.prototype.update = function (data) {
	this.clear();

	if (data.length === 0) {
	  return;
	}

	var $selections = [];

	for (var d = 0; d < data.length; d++) {
	  var selection = data[d];

	  var $selection = this.selectionContainer();
	  var formatted = this.display(selection, $selection);

	  $selection.append(formatted);
	  $selection.prop('title', selection.title || selection.text);

	  $selection.data('data', selection);

	  $selections.push($selection);
	}

	var $rendered = this.$selection.find('.select2-selection__rendered');

	Utils.appendMany($rendered, $selections);
  };

  return MultipleSelection;
});

S2.define('select2/selection/placeholder',[
  '../utils'
], function (Utils) {
  function Placeholder (decorated, $element, options) {
	this.placeholder = this.normalizePlaceholder(options.get('placeholder'));

	decorated.call(this, $element, options);
  }

  Placeholder.prototype.normalizePlaceholder = function (_, placeholder) {
	if (typeof placeholder === 'string') {
	  placeholder = {
		id: '',
		text: placeholder
	  };
	}

	return placeholder;
  };

  Placeholder.prototype.createPlaceholder = function (decorated, placeholder) {
	var $placeholder = this.selectionContainer();

	$placeholder.html(this.display(placeholder));
	$placeholder.addClass('select2-selection__placeholder')
				.removeClass('select2-selection__choice');

	return $placeholder;
  };

  Placeholder.prototype.update = function (decorated, data) {
	var singlePlaceholder = (
	  data.length == 1 && data[0].id != this.placeholder.id
	);
	var multipleSelections = data.length > 1;

	if (multipleSelections || singlePlaceholder) {
	  return decorated.call(this, data);
	}

	this.clear();

	var $placeholder = this.createPlaceholder(this.placeholder);

	this.$selection.find('.select2-selection__rendered').append($placeholder);
  };

  return Placeholder;
});

S2.define('select2/selection/allowClear',[
  'jquery',
  '../keys'
], function ($, KEYS) {
  function AllowClear () { }

  AllowClear.prototype.bind = function (decorated, container, $container) {
	var self = this;

	decorated.call(this, container, $container);

	if (this.placeholder == null) {
	  if (this.options.get('debug') && window.console && console.error) {
		console.error(
		  'Select2: The `allowClear` option should be used in combination ' +
		  'with the `placeholder` option.'
		);
	  }
	}

	this.$selection.on('mousedown', '.select2-selection__clear',
	  function (evt) {
		self._handleClear(evt);
	});

	container.on('keypress', function (evt) {
	  self._handleKeyboardClear(evt, container);
	});
  };

  AllowClear.prototype._handleClear = function (_, evt) {
	// Ignore the event if it is disabled
	if (this.options.get('disabled')) {
	  return;
	}

	var $clear = this.$selection.find('.select2-selection__clear');

	// Ignore the event if nothing has been selected
	if ($clear.length === 0) {
	  return;
	}

	evt.stopPropagation();

	var data = $clear.data('data');

	for (var d = 0; d < data.length; d++) {
	  var unselectData = {
		data: data[d]
	  };

	  // Trigger the `unselect` event, so people can prevent it from being
	  // cleared.
	  this.trigger('unselect', unselectData);

	  // If the event was prevented, don't clear it out.
	  if (unselectData.prevented) {
		return;
	  }
	}

	this.$element.val(this.placeholder.id).trigger('change');

	this.trigger('toggle', {});
  };

  AllowClear.prototype._handleKeyboardClear = function (_, evt, container) {
	if (container.isOpen()) {
	  return;
	}

	if (evt.which == KEYS.DELETE || evt.which == KEYS.BACKSPACE) {
	  this._handleClear(evt);
	}
  };

  AllowClear.prototype.update = function (decorated, data) {
	decorated.call(this, data);

	if (this.$selection.find('.select2-selection__placeholder').length > 0 ||
		data.length === 0) {
	  return;
	}

	var $remove = $(
	  '<span class="select2-selection__clear">' +
		'&times;' +
	  '</span>'
	);
	$remove.data('data', data);

	this.$selection.find('.select2-selection__rendered').prepend($remove);
  };

  return AllowClear;
});

S2.define('select2/selection/search',[
  'jquery',
  '../utils',
  '../keys'
], function ($, Utils, KEYS) {
  function Search (decorated, $element, options) {
	decorated.call(this, $element, options);
  }

  Search.prototype.render = function (decorated) {
	var $search = $(
	  '<li class="select2-search select2-search--inline">' +
		'<input class="select2-search__field" type="search" tabindex="-1"' +
		' autocomplete="off" autocorrect="off" autocapitalize="off"' +
		' spellcheck="false" role="textbox" aria-autocomplete="list" />' +
	  '</li>'
	);

	this.$searchContainer = $search;
	this.$search = $search.find('input');

	var $rendered = decorated.call(this);

	this._transferTabIndex();

	return $rendered;
  };

  Search.prototype.bind = function (decorated, container, $container) {
	var self = this;

	decorated.call(this, container, $container);

	container.on('open', function () {
	  self.$search.trigger('focus');
	});

	container.on('close', function () {
	  self.$search.val('');
	  self.$search.removeAttr('aria-activedescendant');
	  self.$search.trigger('focus');
	});

	container.on('enable', function () {
	  self.$search.prop('disabled', false);

	  self._transferTabIndex();
	});

	container.on('disable', function () {
	  self.$search.prop('disabled', true);
	});

	container.on('focus', function (evt) {
	  self.$search.trigger('focus');
	});

	container.on('results:focus', function (params) {
	  self.$search.attr('aria-activedescendant', params.id);
	});

	this.$selection.on('focusin', '.select2-search--inline', function (evt) {
	  self.trigger('focus', evt);
	});

	this.$selection.on('focusout', '.select2-search--inline', function (evt) {
	  self._handleBlur(evt);
	});

	this.$selection.on('keydown', '.select2-search--inline', function (evt) {
	  evt.stopPropagation();

	  self.trigger('keypress', evt);

	  self._keyUpPrevented = evt.isDefaultPrevented();

	  var key = evt.which;

	  if (key === KEYS.BACKSPACE && self.$search.val() === '') {
		var $previousChoice = self.$searchContainer
		  .prev('.select2-selection__choice');

		if ($previousChoice.length > 0) {
		  var item = $previousChoice.data('data');

		  self.searchRemoveChoice(item);

		  evt.preventDefault();
		}
	  }
	});

	// Try to detect the IE version should the `documentMode` property that
	// is stored on the document. This is only implemented in IE and is
	// slightly cleaner than doing a user agent check.
	// This property is not available in Edge, but Edge also doesn't have
	// this bug.
	var msie = document.documentMode;
	var disableInputEvents = msie && msie <= 11;

	// Workaround for browsers which do not support the `input` event
	// This will prevent double-triggering of events for browsers which support
	// both the `keyup` and `input` events.
	this.$selection.on(
	  'input.searchcheck',
	  '.select2-search--inline',
	  function (evt) {
		// IE will trigger the `input` event when a placeholder is used on a
		// search box. To get around this issue, we are forced to ignore all
		// `input` events in IE and keep using `keyup`.
		if (disableInputEvents) {
		  self.$selection.off('input.search input.searchcheck');
		  return;
		}

		// Unbind the duplicated `keyup` event
		self.$selection.off('keyup.search');
	  }
	);

	this.$selection.on(
	  'keyup.search input.search',
	  '.select2-search--inline',
	  function (evt) {
		// IE will trigger the `input` event when a placeholder is used on a
		// search box. To get around this issue, we are forced to ignore all
		// `input` events in IE and keep using `keyup`.
		if (disableInputEvents && evt.type === 'input') {
		  self.$selection.off('input.search input.searchcheck');
		  return;
		}

		var key = evt.which;

		// We can freely ignore events from modifier keys
		if (key == KEYS.SHIFT || key == KEYS.CTRL || key == KEYS.ALT) {
		  return;
		}

		// Tabbing will be handled during the `keydown` phase
		if (key == KEYS.TAB) {
		  return;
		}

		self.handleSearch(evt);
	  }
	);
  };

  /**
   * This method will transfer the tabindex attribute from the rendered
   * selection to the search box. This allows for the search box to be used as
   * the primary focus instead of the selection container.
   *
   * @private
   */
  Search.prototype._transferTabIndex = function (decorated) {
	this.$search.attr('tabindex', this.$selection.attr('tabindex'));
	this.$selection.attr('tabindex', '-1');
  };

  Search.prototype.createPlaceholder = function (decorated, placeholder) {
	this.$search.attr('placeholder', placeholder.text);
  };

  Search.prototype.update = function (decorated, data) {
	var searchHadFocus = this.$search[0] == document.activeElement;

	this.$search.attr('placeholder', '');

	decorated.call(this, data);

	this.$selection.find('.select2-selection__rendered')
				   .append(this.$searchContainer);

	this.resizeSearch();
	if (searchHadFocus) {
	  this.$search.focus();
	}
  };

  Search.prototype.handleSearch = function () {
	this.resizeSearch();

	if (!this._keyUpPrevented) {
	  var input = this.$search.val();

	  this.trigger('query', {
		term: input
	  });
	}

	this._keyUpPrevented = false;
  };

  Search.prototype.searchRemoveChoice = function (decorated, item) {
	this.trigger('unselect', {
	  data: item
	});

	this.$search.val(item.text);
	this.handleSearch();
  };

  Search.prototype.resizeSearch = function () {
	this.$search.css('width', '25px');

	var width = '';

	if (this.$search.attr('placeholder') !== '') {
	  width = this.$selection.find('.select2-selection__rendered').innerWidth();
	} else {
	  var minimumWidth = this.$search.val().length + 1;

	  width = (minimumWidth * 0.75) + 'em';
	}

	this.$search.css('width', width);
  };

  return Search;
});

S2.define('select2/selection/eventRelay',[
  'jquery'
], function ($) {
  function EventRelay () { }

  EventRelay.prototype.bind = function (decorated, container, $container) {
	var self = this;
	var relayEvents = [
	  'open', 'opening',
	  'close', 'closing',
	  'select', 'selecting',
	  'unselect', 'unselecting'
	];

	var preventableEvents = ['opening', 'closing', 'selecting', 'unselecting'];

	decorated.call(this, container, $container);

	container.on('*', function (name, params) {
	  // Ignore events that should not be relayed
	  if ($.inArray(name, relayEvents) === -1) {
		return;
	  }

	  // The parameters should always be an object
	  params = params || {};

	  // Generate the jQuery event for the Select2 event
	  var evt = $.Event('select2:' + name, {
		params: params
	  });

	  self.$element.trigger(evt);

	  // Only handle preventable events if it was one
	  if ($.inArray(name, preventableEvents) === -1) {
		return;
	  }

	  params.prevented = evt.isDefaultPrevented();
	});
  };

  return EventRelay;
});

S2.define('select2/translation',[
  'jquery',
  'require'
], function ($, require) {
  function Translation (dict) {
	this.dict = dict || {};
  }

  Translation.prototype.all = function () {
	return this.dict;
  };

  Translation.prototype.get = function (key) {
	return this.dict[key];
  };

  Translation.prototype.extend = function (translation) {
	this.dict = $.extend({}, translation.all(), this.dict);
  };

  // Static functions

  Translation._cache = {};

  Translation.loadPath = function (path) {
	if (!(path in Translation._cache)) {
	  var translations = require(path);

	  Translation._cache[path] = translations;
	}

	return new Translation(Translation._cache[path]);
  };

  return Translation;
});

S2.define('select2/diacritics',[

], function () {
  var diacritics = {
	'\u24B6': 'A',
	'\uFF21': 'A',
	'\u00C0': 'A',
	'\u00C1': 'A',
	'\u00C2': 'A',
	'\u1EA6': 'A',
	'\u1EA4': 'A',
	'\u1EAA': 'A',
	'\u1EA8': 'A',
	'\u00C3': 'A',
	'\u0100': 'A',
	'\u0102': 'A',
	'\u1EB0': 'A',
	'\u1EAE': 'A',
	'\u1EB4': 'A',
	'\u1EB2': 'A',
	'\u0226': 'A',
	'\u01E0': 'A',
	'\u00C4': 'A',
	'\u01DE': 'A',
	'\u1EA2': 'A',
	'\u00C5': 'A',
	'\u01FA': 'A',
	'\u01CD': 'A',
	'\u0200': 'A',
	'\u0202': 'A',
	'\u1EA0': 'A',
	'\u1EAC': 'A',
	'\u1EB6': 'A',
	'\u1E00': 'A',
	'\u0104': 'A',
	'\u023A': 'A',
	'\u2C6F': 'A',
	'\uA732': 'AA',
	'\u00C6': 'AE',
	'\u01FC': 'AE',
	'\u01E2': 'AE',
	'\uA734': 'AO',
	'\uA736': 'AU',
	'\uA738': 'AV',
	'\uA73A': 'AV',
	'\uA73C': 'AY',
	'\u24B7': 'B',
	'\uFF22': 'B',
	'\u1E02': 'B',
	'\u1E04': 'B',
	'\u1E06': 'B',
	'\u0243': 'B',
	'\u0182': 'B',
	'\u0181': 'B',
	'\u24B8': 'C',
	'\uFF23': 'C',
	'\u0106': 'C',
	'\u0108': 'C',
	'\u010A': 'C',
	'\u010C': 'C',
	'\u00C7': 'C',
	'\u1E08': 'C',
	'\u0187': 'C',
	'\u023B': 'C',
	'\uA73E': 'C',
	'\u24B9': 'D',
	'\uFF24': 'D',
	'\u1E0A': 'D',
	'\u010E': 'D',
	'\u1E0C': 'D',
	'\u1E10': 'D',
	'\u1E12': 'D',
	'\u1E0E': 'D',
	'\u0110': 'D',
	'\u018B': 'D',
	'\u018A': 'D',
	'\u0189': 'D',
	'\uA779': 'D',
	'\u01F1': 'DZ',
	'\u01C4': 'DZ',
	'\u01F2': 'Dz',
	'\u01C5': 'Dz',
	'\u24BA': 'E',
	'\uFF25': 'E',
	'\u00C8': 'E',
	'\u00C9': 'E',
	'\u00CA': 'E',
	'\u1EC0': 'E',
	'\u1EBE': 'E',
	'\u1EC4': 'E',
	'\u1EC2': 'E',
	'\u1EBC': 'E',
	'\u0112': 'E',
	'\u1E14': 'E',
	'\u1E16': 'E',
	'\u0114': 'E',
	'\u0116': 'E',
	'\u00CB': 'E',
	'\u1EBA': 'E',
	'\u011A': 'E',
	'\u0204': 'E',
	'\u0206': 'E',
	'\u1EB8': 'E',
	'\u1EC6': 'E',
	'\u0228': 'E',
	'\u1E1C': 'E',
	'\u0118': 'E',
	'\u1E18': 'E',
	'\u1E1A': 'E',
	'\u0190': 'E',
	'\u018E': 'E',
	'\u24BB': 'F',
	'\uFF26': 'F',
	'\u1E1E': 'F',
	'\u0191': 'F',
	'\uA77B': 'F',
	'\u24BC': 'G',
	'\uFF27': 'G',
	'\u01F4': 'G',
	'\u011C': 'G',
	'\u1E20': 'G',
	'\u011E': 'G',
	'\u0120': 'G',
	'\u01E6': 'G',
	'\u0122': 'G',
	'\u01E4': 'G',
	'\u0193': 'G',
	'\uA7A0': 'G',
	'\uA77D': 'G',
	'\uA77E': 'G',
	'\u24BD': 'H',
	'\uFF28': 'H',
	'\u0124': 'H',
	'\u1E22': 'H',
	'\u1E26': 'H',
	'\u021E': 'H',
	'\u1E24': 'H',
	'\u1E28': 'H',
	'\u1E2A': 'H',
	'\u0126': 'H',
	'\u2C67': 'H',
	'\u2C75': 'H',
	'\uA78D': 'H',
	'\u24BE': 'I',
	'\uFF29': 'I',
	'\u00CC': 'I',
	'\u00CD': 'I',
	'\u00CE': 'I',
	'\u0128': 'I',
	'\u012A': 'I',
	'\u012C': 'I',
	'\u0130': 'I',
	'\u00CF': 'I',
	'\u1E2E': 'I',
	'\u1EC8': 'I',
	'\u01CF': 'I',
	'\u0208': 'I',
	'\u020A': 'I',
	'\u1ECA': 'I',
	'\u012E': 'I',
	'\u1E2C': 'I',
	'\u0197': 'I',
	'\u24BF': 'J',
	'\uFF2A': 'J',
	'\u0134': 'J',
	'\u0248': 'J',
	'\u24C0': 'K',
	'\uFF2B': 'K',
	'\u1E30': 'K',
	'\u01E8': 'K',
	'\u1E32': 'K',
	'\u0136': 'K',
	'\u1E34': 'K',
	'\u0198': 'K',
	'\u2C69': 'K',
	'\uA740': 'K',
	'\uA742': 'K',
	'\uA744': 'K',
	'\uA7A2': 'K',
	'\u24C1': 'L',
	'\uFF2C': 'L',
	'\u013F': 'L',
	'\u0139': 'L',
	'\u013D': 'L',
	'\u1E36': 'L',
	'\u1E38': 'L',
	'\u013B': 'L',
	'\u1E3C': 'L',
	'\u1E3A': 'L',
	'\u0141': 'L',
	'\u023D': 'L',
	'\u2C62': 'L',
	'\u2C60': 'L',
	'\uA748': 'L',
	'\uA746': 'L',
	'\uA780': 'L',
	'\u01C7': 'LJ',
	'\u01C8': 'Lj',
	'\u24C2': 'M',
	'\uFF2D': 'M',
	'\u1E3E': 'M',
	'\u1E40': 'M',
	'\u1E42': 'M',
	'\u2C6E': 'M',
	'\u019C': 'M',
	'\u24C3': 'N',
	'\uFF2E': 'N',
	'\u01F8': 'N',
	'\u0143': 'N',
	'\u00D1': 'N',
	'\u1E44': 'N',
	'\u0147': 'N',
	'\u1E46': 'N',
	'\u0145': 'N',
	'\u1E4A': 'N',
	'\u1E48': 'N',
	'\u0220': 'N',
	'\u019D': 'N',
	'\uA790': 'N',
	'\uA7A4': 'N',
	'\u01CA': 'NJ',
	'\u01CB': 'Nj',
	'\u24C4': 'O',
	'\uFF2F': 'O',
	'\u00D2': 'O',
	'\u00D3': 'O',
	'\u00D4': 'O',
	'\u1ED2': 'O',
	'\u1ED0': 'O',
	'\u1ED6': 'O',
	'\u1ED4': 'O',
	'\u00D5': 'O',
	'\u1E4C': 'O',
	'\u022C': 'O',
	'\u1E4E': 'O',
	'\u014C': 'O',
	'\u1E50': 'O',
	'\u1E52': 'O',
	'\u014E': 'O',
	'\u022E': 'O',
	'\u0230': 'O',
	'\u00D6': 'O',
	'\u022A': 'O',
	'\u1ECE': 'O',
	'\u0150': 'O',
	'\u01D1': 'O',
	'\u020C': 'O',
	'\u020E': 'O',
	'\u01A0': 'O',
	'\u1EDC': 'O',
	'\u1EDA': 'O',
	'\u1EE0': 'O',
	'\u1EDE': 'O',
	'\u1EE2': 'O',
	'\u1ECC': 'O',
	'\u1ED8': 'O',
	'\u01EA': 'O',
	'\u01EC': 'O',
	'\u00D8': 'O',
	'\u01FE': 'O',
	'\u0186': 'O',
	'\u019F': 'O',
	'\uA74A': 'O',
	'\uA74C': 'O',
	'\u01A2': 'OI',
	'\uA74E': 'OO',
	'\u0222': 'OU',
	'\u24C5': 'P',
	'\uFF30': 'P',
	'\u1E54': 'P',
	'\u1E56': 'P',
	'\u01A4': 'P',
	'\u2C63': 'P',
	'\uA750': 'P',
	'\uA752': 'P',
	'\uA754': 'P',
	'\u24C6': 'Q',
	'\uFF31': 'Q',
	'\uA756': 'Q',
	'\uA758': 'Q',
	'\u024A': 'Q',
	'\u24C7': 'R',
	'\uFF32': 'R',
	'\u0154': 'R',
	'\u1E58': 'R',
	'\u0158': 'R',
	'\u0210': 'R',
	'\u0212': 'R',
	'\u1E5A': 'R',
	'\u1E5C': 'R',
	'\u0156': 'R',
	'\u1E5E': 'R',
	'\u024C': 'R',
	'\u2C64': 'R',
	'\uA75A': 'R',
	'\uA7A6': 'R',
	'\uA782': 'R',
	'\u24C8': 'S',
	'\uFF33': 'S',
	'\u1E9E': 'S',
	'\u015A': 'S',
	'\u1E64': 'S',
	'\u015C': 'S',
	'\u1E60': 'S',
	'\u0160': 'S',
	'\u1E66': 'S',
	'\u1E62': 'S',
	'\u1E68': 'S',
	'\u0218': 'S',
	'\u015E': 'S',
	'\u2C7E': 'S',
	'\uA7A8': 'S',
	'\uA784': 'S',
	'\u24C9': 'T',
	'\uFF34': 'T',
	'\u1E6A': 'T',
	'\u0164': 'T',
	'\u1E6C': 'T',
	'\u021A': 'T',
	'\u0162': 'T',
	'\u1E70': 'T',
	'\u1E6E': 'T',
	'\u0166': 'T',
	'\u01AC': 'T',
	'\u01AE': 'T',
	'\u023E': 'T',
	'\uA786': 'T',
	'\uA728': 'TZ',
	'\u24CA': 'U',
	'\uFF35': 'U',
	'\u00D9': 'U',
	'\u00DA': 'U',
	'\u00DB': 'U',
	'\u0168': 'U',
	'\u1E78': 'U',
	'\u016A': 'U',
	'\u1E7A': 'U',
	'\u016C': 'U',
	'\u00DC': 'U',
	'\u01DB': 'U',
	'\u01D7': 'U',
	'\u01D5': 'U',
	'\u01D9': 'U',
	'\u1EE6': 'U',
	'\u016E': 'U',
	'\u0170': 'U',
	'\u01D3': 'U',
	'\u0214': 'U',
	'\u0216': 'U',
	'\u01AF': 'U',
	'\u1EEA': 'U',
	'\u1EE8': 'U',
	'\u1EEE': 'U',
	'\u1EEC': 'U',
	'\u1EF0': 'U',
	'\u1EE4': 'U',
	'\u1E72': 'U',
	'\u0172': 'U',
	'\u1E76': 'U',
	'\u1E74': 'U',
	'\u0244': 'U',
	'\u24CB': 'V',
	'\uFF36': 'V',
	'\u1E7C': 'V',
	'\u1E7E': 'V',
	'\u01B2': 'V',
	'\uA75E': 'V',
	'\u0245': 'V',
	'\uA760': 'VY',
	'\u24CC': 'W',
	'\uFF37': 'W',
	'\u1E80': 'W',
	'\u1E82': 'W',
	'\u0174': 'W',
	'\u1E86': 'W',
	'\u1E84': 'W',
	'\u1E88': 'W',
	'\u2C72': 'W',
	'\u24CD': 'X',
	'\uFF38': 'X',
	'\u1E8A': 'X',
	'\u1E8C': 'X',
	'\u24CE': 'Y',
	'\uFF39': 'Y',
	'\u1EF2': 'Y',
	'\u00DD': 'Y',
	'\u0176': 'Y',
	'\u1EF8': 'Y',
	'\u0232': 'Y',
	'\u1E8E': 'Y',
	'\u0178': 'Y',
	'\u1EF6': 'Y',
	'\u1EF4': 'Y',
	'\u01B3': 'Y',
	'\u024E': 'Y',
	'\u1EFE': 'Y',
	'\u24CF': 'Z',
	'\uFF3A': 'Z',
	'\u0179': 'Z',
	'\u1E90': 'Z',
	'\u017B': 'Z',
	'\u017D': 'Z',
	'\u1E92': 'Z',
	'\u1E94': 'Z',
	'\u01B5': 'Z',
	'\u0224': 'Z',
	'\u2C7F': 'Z',
	'\u2C6B': 'Z',
	'\uA762': 'Z',
	'\u24D0': 'a',
	'\uFF41': 'a',
	'\u1E9A': 'a',
	'\u00E0': 'a',
	'\u00E1': 'a',
	'\u00E2': 'a',
	'\u1EA7': 'a',
	'\u1EA5': 'a',
	'\u1EAB': 'a',
	'\u1EA9': 'a',
	'\u00E3': 'a',
	'\u0101': 'a',
	'\u0103': 'a',
	'\u1EB1': 'a',
	'\u1EAF': 'a',
	'\u1EB5': 'a',
	'\u1EB3': 'a',
	'\u0227': 'a',
	'\u01E1': 'a',
	'\u00E4': 'a',
	'\u01DF': 'a',
	'\u1EA3': 'a',
	'\u00E5': 'a',
	'\u01FB': 'a',
	'\u01CE': 'a',
	'\u0201': 'a',
	'\u0203': 'a',
	'\u1EA1': 'a',
	'\u1EAD': 'a',
	'\u1EB7': 'a',
	'\u1E01': 'a',
	'\u0105': 'a',
	'\u2C65': 'a',
	'\u0250': 'a',
	'\uA733': 'aa',
	'\u00E6': 'ae',
	'\u01FD': 'ae',
	'\u01E3': 'ae',
	'\uA735': 'ao',
	'\uA737': 'au',
	'\uA739': 'av',
	'\uA73B': 'av',
	'\uA73D': 'ay',
	'\u24D1': 'b',
	'\uFF42': 'b',
	'\u1E03': 'b',
	'\u1E05': 'b',
	'\u1E07': 'b',
	'\u0180': 'b',
	'\u0183': 'b',
	'\u0253': 'b',
	'\u24D2': 'c',
	'\uFF43': 'c',
	'\u0107': 'c',
	'\u0109': 'c',
	'\u010B': 'c',
	'\u010D': 'c',
	'\u00E7': 'c',
	'\u1E09': 'c',
	'\u0188': 'c',
	'\u023C': 'c',
	'\uA73F': 'c',
	'\u2184': 'c',
	'\u24D3': 'd',
	'\uFF44': 'd',
	'\u1E0B': 'd',
	'\u010F': 'd',
	'\u1E0D': 'd',
	'\u1E11': 'd',
	'\u1E13': 'd',
	'\u1E0F': 'd',
	'\u0111': 'd',
	'\u018C': 'd',
	'\u0256': 'd',
	'\u0257': 'd',
	'\uA77A': 'd',
	'\u01F3': 'dz',
	'\u01C6': 'dz',
	'\u24D4': 'e',
	'\uFF45': 'e',
	'\u00E8': 'e',
	'\u00E9': 'e',
	'\u00EA': 'e',
	'\u1EC1': 'e',
	'\u1EBF': 'e',
	'\u1EC5': 'e',
	'\u1EC3': 'e',
	'\u1EBD': 'e',
	'\u0113': 'e',
	'\u1E15': 'e',
	'\u1E17': 'e',
	'\u0115': 'e',
	'\u0117': 'e',
	'\u00EB': 'e',
	'\u1EBB': 'e',
	'\u011B': 'e',
	'\u0205': 'e',
	'\u0207': 'e',
	'\u1EB9': 'e',
	'\u1EC7': 'e',
	'\u0229': 'e',
	'\u1E1D': 'e',
	'\u0119': 'e',
	'\u1E19': 'e',
	'\u1E1B': 'e',
	'\u0247': 'e',
	'\u025B': 'e',
	'\u01DD': 'e',
	'\u24D5': 'f',
	'\uFF46': 'f',
	'\u1E1F': 'f',
	'\u0192': 'f',
	'\uA77C': 'f',
	'\u24D6': 'g',
	'\uFF47': 'g',
	'\u01F5': 'g',
	'\u011D': 'g',
	'\u1E21': 'g',
	'\u011F': 'g',
	'\u0121': 'g',
	'\u01E7': 'g',
	'\u0123': 'g',
	'\u01E5': 'g',
	'\u0260': 'g',
	'\uA7A1': 'g',
	'\u1D79': 'g',
	'\uA77F': 'g',
	'\u24D7': 'h',
	'\uFF48': 'h',
	'\u0125': 'h',
	'\u1E23': 'h',
	'\u1E27': 'h',
	'\u021F': 'h',
	'\u1E25': 'h',
	'\u1E29': 'h',
	'\u1E2B': 'h',
	'\u1E96': 'h',
	'\u0127': 'h',
	'\u2C68': 'h',
	'\u2C76': 'h',
	'\u0265': 'h',
	'\u0195': 'hv',
	'\u24D8': 'i',
	'\uFF49': 'i',
	'\u00EC': 'i',
	'\u00ED': 'i',
	'\u00EE': 'i',
	'\u0129': 'i',
	'\u012B': 'i',
	'\u012D': 'i',
	'\u00EF': 'i',
	'\u1E2F': 'i',
	'\u1EC9': 'i',
	'\u01D0': 'i',
	'\u0209': 'i',
	'\u020B': 'i',
	'\u1ECB': 'i',
	'\u012F': 'i',
	'\u1E2D': 'i',
	'\u0268': 'i',
	'\u0131': 'i',
	'\u24D9': 'j',
	'\uFF4A': 'j',
	'\u0135': 'j',
	'\u01F0': 'j',
	'\u0249': 'j',
	'\u24DA': 'k',
	'\uFF4B': 'k',
	'\u1E31': 'k',
	'\u01E9': 'k',
	'\u1E33': 'k',
	'\u0137': 'k',
	'\u1E35': 'k',
	'\u0199': 'k',
	'\u2C6A': 'k',
	'\uA741': 'k',
	'\uA743': 'k',
	'\uA745': 'k',
	'\uA7A3': 'k',
	'\u24DB': 'l',
	'\uFF4C': 'l',
	'\u0140': 'l',
	'\u013A': 'l',
	'\u013E': 'l',
	'\u1E37': 'l',
	'\u1E39': 'l',
	'\u013C': 'l',
	'\u1E3D': 'l',
	'\u1E3B': 'l',
	'\u017F': 'l',
	'\u0142': 'l',
	'\u019A': 'l',
	'\u026B': 'l',
	'\u2C61': 'l',
	'\uA749': 'l',
	'\uA781': 'l',
	'\uA747': 'l',
	'\u01C9': 'lj',
	'\u24DC': 'm',
	'\uFF4D': 'm',
	'\u1E3F': 'm',
	'\u1E41': 'm',
	'\u1E43': 'm',
	'\u0271': 'm',
	'\u026F': 'm',
	'\u24DD': 'n',
	'\uFF4E': 'n',
	'\u01F9': 'n',
	'\u0144': 'n',
	'\u00F1': 'n',
	'\u1E45': 'n',
	'\u0148': 'n',
	'\u1E47': 'n',
	'\u0146': 'n',
	'\u1E4B': 'n',
	'\u1E49': 'n',
	'\u019E': 'n',
	'\u0272': 'n',
	'\u0149': 'n',
	'\uA791': 'n',
	'\uA7A5': 'n',
	'\u01CC': 'nj',
	'\u24DE': 'o',
	'\uFF4F': 'o',
	'\u00F2': 'o',
	'\u00F3': 'o',
	'\u00F4': 'o',
	'\u1ED3': 'o',
	'\u1ED1': 'o',
	'\u1ED7': 'o',
	'\u1ED5': 'o',
	'\u00F5': 'o',
	'\u1E4D': 'o',
	'\u022D': 'o',
	'\u1E4F': 'o',
	'\u014D': 'o',
	'\u1E51': 'o',
	'\u1E53': 'o',
	'\u014F': 'o',
	'\u022F': 'o',
	'\u0231': 'o',
	'\u00F6': 'o',
	'\u022B': 'o',
	'\u1ECF': 'o',
	'\u0151': 'o',
	'\u01D2': 'o',
	'\u020D': 'o',
	'\u020F': 'o',
	'\u01A1': 'o',
	'\u1EDD': 'o',
	'\u1EDB': 'o',
	'\u1EE1': 'o',
	'\u1EDF': 'o',
	'\u1EE3': 'o',
	'\u1ECD': 'o',
	'\u1ED9': 'o',
	'\u01EB': 'o',
	'\u01ED': 'o',
	'\u00F8': 'o',
	'\u01FF': 'o',
	'\u0254': 'o',
	'\uA74B': 'o',
	'\uA74D': 'o',
	'\u0275': 'o',
	'\u01A3': 'oi',
	'\u0223': 'ou',
	'\uA74F': 'oo',
	'\u24DF': 'p',
	'\uFF50': 'p',
	'\u1E55': 'p',
	'\u1E57': 'p',
	'\u01A5': 'p',
	'\u1D7D': 'p',
	'\uA751': 'p',
	'\uA753': 'p',
	'\uA755': 'p',
	'\u24E0': 'q',
	'\uFF51': 'q',
	'\u024B': 'q',
	'\uA757': 'q',
	'\uA759': 'q',
	'\u24E1': 'r',
	'\uFF52': 'r',
	'\u0155': 'r',
	'\u1E59': 'r',
	'\u0159': 'r',
	'\u0211': 'r',
	'\u0213': 'r',
	'\u1E5B': 'r',
	'\u1E5D': 'r',
	'\u0157': 'r',
	'\u1E5F': 'r',
	'\u024D': 'r',
	'\u027D': 'r',
	'\uA75B': 'r',
	'\uA7A7': 'r',
	'\uA783': 'r',
	'\u24E2': 's',
	'\uFF53': 's',
	'\u00DF': 's',
	'\u015B': 's',
	'\u1E65': 's',
	'\u015D': 's',
	'\u1E61': 's',
	'\u0161': 's',
	'\u1E67': 's',
	'\u1E63': 's',
	'\u1E69': 's',
	'\u0219': 's',
	'\u015F': 's',
	'\u023F': 's',
	'\uA7A9': 's',
	'\uA785': 's',
	'\u1E9B': 's',
	'\u24E3': 't',
	'\uFF54': 't',
	'\u1E6B': 't',
	'\u1E97': 't',
	'\u0165': 't',
	'\u1E6D': 't',
	'\u021B': 't',
	'\u0163': 't',
	'\u1E71': 't',
	'\u1E6F': 't',
	'\u0167': 't',
	'\u01AD': 't',
	'\u0288': 't',
	'\u2C66': 't',
	'\uA787': 't',
	'\uA729': 'tz',
	'\u24E4': 'u',
	'\uFF55': 'u',
	'\u00F9': 'u',
	'\u00FA': 'u',
	'\u00FB': 'u',
	'\u0169': 'u',
	'\u1E79': 'u',
	'\u016B': 'u',
	'\u1E7B': 'u',
	'\u016D': 'u',
	'\u00FC': 'u',
	'\u01DC': 'u',
	'\u01D8': 'u',
	'\u01D6': 'u',
	'\u01DA': 'u',
	'\u1EE7': 'u',
	'\u016F': 'u',
	'\u0171': 'u',
	'\u01D4': 'u',
	'\u0215': 'u',
	'\u0217': 'u',
	'\u01B0': 'u',
	'\u1EEB': 'u',
	'\u1EE9': 'u',
	'\u1EEF': 'u',
	'\u1EED': 'u',
	'\u1EF1': 'u',
	'\u1EE5': 'u',
	'\u1E73': 'u',
	'\u0173': 'u',
	'\u1E77': 'u',
	'\u1E75': 'u',
	'\u0289': 'u',
	'\u24E5': 'v',
	'\uFF56': 'v',
	'\u1E7D': 'v',
	'\u1E7F': 'v',
	'\u028B': 'v',
	'\uA75F': 'v',
	'\u028C': 'v',
	'\uA761': 'vy',
	'\u24E6': 'w',
	'\uFF57': 'w',
	'\u1E81': 'w',
	'\u1E83': 'w',
	'\u0175': 'w',
	'\u1E87': 'w',
	'\u1E85': 'w',
	'\u1E98': 'w',
	'\u1E89': 'w',
	'\u2C73': 'w',
	'\u24E7': 'x',
	'\uFF58': 'x',
	'\u1E8B': 'x',
	'\u1E8D': 'x',
	'\u24E8': 'y',
	'\uFF59': 'y',
	'\u1EF3': 'y',
	'\u00FD': 'y',
	'\u0177': 'y',
	'\u1EF9': 'y',
	'\u0233': 'y',
	'\u1E8F': 'y',
	'\u00FF': 'y',
	'\u1EF7': 'y',
	'\u1E99': 'y',
	'\u1EF5': 'y',
	'\u01B4': 'y',
	'\u024F': 'y',
	'\u1EFF': 'y',
	'\u24E9': 'z',
	'\uFF5A': 'z',
	'\u017A': 'z',
	'\u1E91': 'z',
	'\u017C': 'z',
	'\u017E': 'z',
	'\u1E93': 'z',
	'\u1E95': 'z',
	'\u01B6': 'z',
	'\u0225': 'z',
	'\u0240': 'z',
	'\u2C6C': 'z',
	'\uA763': 'z',
	'\u0386': '\u0391',
	'\u0388': '\u0395',
	'\u0389': '\u0397',
	'\u038A': '\u0399',
	'\u03AA': '\u0399',
	'\u038C': '\u039F',
	'\u038E': '\u03A5',
	'\u03AB': '\u03A5',
	'\u038F': '\u03A9',
	'\u03AC': '\u03B1',
	'\u03AD': '\u03B5',
	'\u03AE': '\u03B7',
	'\u03AF': '\u03B9',
	'\u03CA': '\u03B9',
	'\u0390': '\u03B9',
	'\u03CC': '\u03BF',
	'\u03CD': '\u03C5',
	'\u03CB': '\u03C5',
	'\u03B0': '\u03C5',
	'\u03C9': '\u03C9',
	'\u03C2': '\u03C3'
  };

  return diacritics;
});

S2.define('select2/data/base',[
  '../utils'
], function (Utils) {
  function BaseAdapter ($element, options) {
	BaseAdapter.__super__.constructor.call(this);
  }

  Utils.Extend(BaseAdapter, Utils.Observable);

  BaseAdapter.prototype.current = function (callback) {
	throw new Error('The `current` method must be defined in child classes.');
  };

  BaseAdapter.prototype.query = function (params, callback) {
	throw new Error('The `query` method must be defined in child classes.');
  };

  BaseAdapter.prototype.bind = function (container, $container) {
	// Can be implemented in subclasses
  };

  BaseAdapter.prototype.destroy = function () {
	// Can be implemented in subclasses
  };

  BaseAdapter.prototype.generateResultId = function (container, data) {
	var id = container.id + '-result-';

	id += Utils.generateChars(4);

	if (data.id != null) {
	  id += '-' + data.id.toString();
	} else {
	  id += '-' + Utils.generateChars(4);
	}
	return id;
  };

  return BaseAdapter;
});

S2.define('select2/data/select',[
  './base',
  '../utils',
  'jquery'
], function (BaseAdapter, Utils, $) {
  function SelectAdapter ($element, options) {
	this.$element = $element;
	this.options = options;

	SelectAdapter.__super__.constructor.call(this);
  }

  Utils.Extend(SelectAdapter, BaseAdapter);

  SelectAdapter.prototype.current = function (callback) {
	var data = [];
	var self = this;

	this.$element.find(':selected').each(function () {
	  var $option = $(this);

	  var option = self.item($option);

	  data.push(option);
	});

	callback(data);
  };

  SelectAdapter.prototype.select = function (data) {
	var self = this;

	data.selected = true;

	// If data.element is a DOM node, use it instead
	if ($(data.element).is('option')) {
	  data.element.selected = true;

	  this.$element.trigger('change');

	  return;
	}

	if (this.$element.prop('multiple')) {
	  this.current(function (currentData) {
		var val = [];

		data = [data];
		data.push.apply(data, currentData);

		for (var d = 0; d < data.length; d++) {
		  var id = data[d].id;

		  if ($.inArray(id, val) === -1) {
			val.push(id);
		  }
		}

		self.$element.val(val);
		self.$element.trigger('change');
	  });
	} else {
	  var val = data.id;

	  this.$element.val(val);
	  this.$element.trigger('change');
	}
  };

  SelectAdapter.prototype.unselect = function (data) {
	var self = this;

	if (!this.$element.prop('multiple')) {
	  return;
	}

	data.selected = false;

	if ($(data.element).is('option')) {
	  data.element.selected = false;

	  this.$element.trigger('change');

	  return;
	}

	this.current(function (currentData) {
	  var val = [];

	  for (var d = 0; d < currentData.length; d++) {
		var id = currentData[d].id;

		if (id !== data.id && $.inArray(id, val) === -1) {
		  val.push(id);
		}
	  }

	  self.$element.val(val);

	  self.$element.trigger('change');
	});
  };

  SelectAdapter.prototype.bind = function (container, $container) {
	var self = this;

	this.container = container;

	container.on('select', function (params) {
	  self.select(params.data);
	});

	container.on('unselect', function (params) {
	  self.unselect(params.data);
	});
  };

  SelectAdapter.prototype.destroy = function () {
	// Remove anything added to child elements
	this.$element.find('*').each(function () {
	  // Remove any custom data set by Select2
	  $.removeData(this, 'data');
	});
  };

  SelectAdapter.prototype.query = function (params, callback) {
	var data = [];
	var self = this;

	var $options = this.$element.children();

	$options.each(function () {
	  var $option = $(this);

	  if (!$option.is('option') && !$option.is('optgroup')) {
		return;
	  }

	  var option = self.item($option);

	  var matches = self.matches(params, option);

	  if (matches !== null) {
		data.push(matches);
	  }
	});

	callback({
	  results: data
	});
  };

  SelectAdapter.prototype.addOptions = function ($options) {
	Utils.appendMany(this.$element, $options);
  };

  SelectAdapter.prototype.option = function (data) {
	var option;

	if (data.children) {
	  option = document.createElement('optgroup');
	  option.label = data.text;
	} else {
	  option = document.createElement('option');

	  if (option.textContent !== undefined) {
		option.textContent = data.text;
	  } else {
		option.innerText = data.text;
	  }
	}

	if (data.id) {
	  option.value = data.id;
	}

	if (data.disabled) {
	  option.disabled = true;
	}

	if (data.selected) {
	  option.selected = true;
	}

	if (data.title) {
	  option.title = data.title;
	}

	var $option = $(option);

	var normalizedData = this._normalizeItem(data);
	normalizedData.element = option;

	// Override the option's data with the combined data
	$.data(option, 'data', normalizedData);

	return $option;
  };

  SelectAdapter.prototype.item = function ($option) {
	var data = {};

	data = $.data($option[0], 'data');

	if (data != null) {
	  return data;
	}

	if ($option.is('option')) {
	  data = {
		id: $option.val(),
		text: $option.text(),
		disabled: $option.prop('disabled'),
		selected: $option.prop('selected'),
		title: $option.prop('title')
	  };
	} else if ($option.is('optgroup')) {
	  data = {
		text: $option.prop('label'),
		children: [],
		title: $option.prop('title')
	  };

	  var $children = $option.children('option');
	  var children = [];

	  for (var c = 0; c < $children.length; c++) {
		var $child = $($children[c]);

		var child = this.item($child);

		children.push(child);
	  }

	  data.children = children;
	}

	data = this._normalizeItem(data);
	data.element = $option[0];

	$.data($option[0], 'data', data);

	return data;
  };

  SelectAdapter.prototype._normalizeItem = function (item) {
	if (!$.isPlainObject(item)) {
	  item = {
		id: item,
		text: item
	  };
	}

	item = $.extend({}, {
	  text: ''
	}, item);

	var defaults = {
	  selected: false,
	  disabled: false
	};

	if (item.id != null) {
	  item.id = item.id.toString();
	}

	if (item.text != null) {
	  item.text = item.text.toString();
	}

	if (item._resultId == null && item.id && this.container != null) {
	  item._resultId = this.generateResultId(this.container, item);
	}

	return $.extend({}, defaults, item);
  };

  SelectAdapter.prototype.matches = function (params, data) {
	var matcher = this.options.get('matcher');

	return matcher(params, data);
  };

  return SelectAdapter;
});

S2.define('select2/data/array',[
  './select',
  '../utils',
  'jquery'
], function (SelectAdapter, Utils, $) {
  function ArrayAdapter ($element, options) {
	var data = options.get('data') || [];

	ArrayAdapter.__super__.constructor.call(this, $element, options);

	this.addOptions(this.convertToOptions(data));
  }

  Utils.Extend(ArrayAdapter, SelectAdapter);

  ArrayAdapter.prototype.select = function (data) {
	var $option = this.$element.find('option').filter(function (i, elm) {
	  return elm.value == data.id.toString();
	});

	if ($option.length === 0) {
	  $option = this.option(data);

	  this.addOptions($option);
	}

	ArrayAdapter.__super__.select.call(this, data);
  };

  ArrayAdapter.prototype.convertToOptions = function (data) {
	var self = this;

	var $existing = this.$element.find('option');
	var existingIds = $existing.map(function () {
	  return self.item($(this)).id;
	}).get();

	var $options = [];

	// Filter out all items except for the one passed in the argument
	function onlyItem (item) {
	  return function () {
		return $(this).val() == item.id;
	  };
	}

	for (var d = 0; d < data.length; d++) {
	  var item = this._normalizeItem(data[d]);

	  // Skip items which were pre-loaded, only merge the data
	  if ($.inArray(item.id, existingIds) >= 0) {
		var $existingOption = $existing.filter(onlyItem(item));

		var existingData = this.item($existingOption);
		var newData = $.extend(true, {}, item, existingData);

		var $newOption = this.option(newData);

		$existingOption.replaceWith($newOption);

		continue;
	  }

	  var $option = this.option(item);

	  if (item.children) {
		var $children = this.convertToOptions(item.children);

		Utils.appendMany($option, $children);
	  }

	  $options.push($option);
	}

	return $options;
  };

  return ArrayAdapter;
});

S2.define('select2/data/ajax',[
  './array',
  '../utils',
  'jquery'
], function (ArrayAdapter, Utils, $) {
  function AjaxAdapter ($element, options) {
	this.ajaxOptions = this._applyDefaults(options.get('ajax'));

	if (this.ajaxOptions.processResults != null) {
	  this.processResults = this.ajaxOptions.processResults;
	}

	AjaxAdapter.__super__.constructor.call(this, $element, options);
  }

  Utils.Extend(AjaxAdapter, ArrayAdapter);

  AjaxAdapter.prototype._applyDefaults = function (options) {
	var defaults = {
	  data: function (params) {
		return $.extend({}, params, {
		  q: params.term
		});
	  },
	  transport: function (params, success, failure) {
		var $request = $.ajax(params);

		$request.then(success);
		$request.fail(failure);

		return $request;
	  }
	};

	return $.extend({}, defaults, options, true);
  };

  AjaxAdapter.prototype.processResults = function (results) {
	return results;
  };

  AjaxAdapter.prototype.query = function (params, callback) {
	var matches = [];
	var self = this;

	if (this._request != null) {
	  // JSONP requests cannot always be aborted
	  if ($.isFunction(this._request.abort)) {
		this._request.abort();
	  }

	  this._request = null;
	}

	var options = $.extend({
	  type: 'GET'
	}, this.ajaxOptions);

	if (typeof options.url === 'function') {
	  options.url = options.url.call(this.$element, params);
	}

	if (typeof options.data === 'function') {
	  options.data = options.data.call(this.$element, params);
	}

	function request () {
	  var $request = options.transport(options, function (data) {
		var results = self.processResults(data, params);

		if (self.options.get('debug') && window.console && console.error) {
		  // Check to make sure that the response included a `results` key.
		  if (!results || !results.results || !$.isArray(results.results)) {
			console.error(
			  'Select2: The AJAX results did not return an array in the ' +
			  '`results` key of the response.'
			);
		  }
		}

		callback(results);
	  }, function () {
		// Attempt to detect if a request was aborted
		// Only works if the transport exposes a status property
		if ($request.status && $request.status === '0') {
		  return;
		}

		self.trigger('results:message', {
		  message: 'errorLoading'
		});
	  });

	  self._request = $request;
	}

	if (this.ajaxOptions.delay && params.term != null) {
	  if (this._queryTimeout) {
		window.clearTimeout(this._queryTimeout);
	  }

	  this._queryTimeout = window.setTimeout(request, this.ajaxOptions.delay);
	} else {
	  request();
	}
  };

  return AjaxAdapter;
});

S2.define('select2/data/tags',[
  'jquery'
], function ($) {
  function Tags (decorated, $element, options) {
	var tags = options.get('tags');

	var createTag = options.get('createTag');

	if (createTag !== undefined) {
	  this.createTag = createTag;
	}

	var insertTag = options.get('insertTag');

	if (insertTag !== undefined) {
		this.insertTag = insertTag;
	}

	decorated.call(this, $element, options);

	if ($.isArray(tags)) {
	  for (var t = 0; t < tags.length; t++) {
		var tag = tags[t];
		var item = this._normalizeItem(tag);

		var $option = this.option(item);

		this.$element.append($option);
	  }
	}
  }

  Tags.prototype.query = function (decorated, params, callback) {
	var self = this;

	this._removeOldTags();

	if (params.term == null || params.page != null) {
	  decorated.call(this, params, callback);
	  return;
	}

	function wrapper (obj, child) {
	  var data = obj.results;

	  for (var i = 0; i < data.length; i++) {
		var option = data[i];

		var checkChildren = (
		  option.children != null &&
		  !wrapper({
			results: option.children
		  }, true)
		);

		var checkText = option.text === params.term;

		if (checkText || checkChildren) {
		  if (child) {
			return false;
		  }

		  obj.data = data;
		  callback(obj);

		  return;
		}
	  }

	  if (child) {
		return true;
	  }

	  var tag = self.createTag(params);

	  if (tag != null) {
		var $option = self.option(tag);
		$option.attr('data-select2-tag', true);

		self.addOptions([$option]);

		self.insertTag(data, tag);
	  }

	  obj.results = data;

	  callback(obj);
	}

	decorated.call(this, params, wrapper);
  };

  Tags.prototype.createTag = function (decorated, params) {
	var term = $.trim(params.term);

	if (term === '') {
	  return null;
	}

	return {
	  id: term,
	  text: term
	};
  };

  Tags.prototype.insertTag = function (_, data, tag) {
	data.unshift(tag);
  };

  Tags.prototype._removeOldTags = function (_) {
	var tag = this._lastTag;

	var $options = this.$element.find('option[data-select2-tag]');

	$options.each(function () {
	  if (this.selected) {
		return;
	  }

	  $(this).remove();
	});
  };

  return Tags;
});

S2.define('select2/data/tokenizer',[
  'jquery'
], function ($) {
  function Tokenizer (decorated, $element, options) {
	var tokenizer = options.get('tokenizer');

	if (tokenizer !== undefined) {
	  this.tokenizer = tokenizer;
	}

	decorated.call(this, $element, options);
  }

  Tokenizer.prototype.bind = function (decorated, container, $container) {
	decorated.call(this, container, $container);

	this.$search =  container.dropdown.$search || container.selection.$search ||
	  $container.find('.select2-search__field');
  };

  Tokenizer.prototype.query = function (decorated, params, callback) {
	var self = this;

	function createAndSelect (data) {
	  // Normalize the data object so we can use it for checks
	  var item = self._normalizeItem(data);

	  // Check if the data object already exists as a tag
	  // Select it if it doesn't
	  var $existingOptions = self.$element.find('option').filter(function () {
		return $(this).val() === item.id;
	  });

	  // If an existing option wasn't found for it, create the option
	  if (!$existingOptions.length) {
		var $option = self.option(item);
		$option.attr('data-select2-tag', true);

		self._removeOldTags();
		self.addOptions([$option]);
	  }

	  // Select the item, now that we know there is an option for it
	  select(item);
	}

	function select (data) {
	  self.trigger('select', {
		data: data
	  });
	}

	params.term = params.term || '';

	var tokenData = this.tokenizer(params, this.options, createAndSelect);

	if (tokenData.term !== params.term) {
	  // Replace the search term if we have the search box
	  if (this.$search.length) {
		this.$search.val(tokenData.term);
		this.$search.focus();
	  }

	  params.term = tokenData.term;
	}

	decorated.call(this, params, callback);
  };

  Tokenizer.prototype.tokenizer = function (_, params, options, callback) {
	var separators = options.get('tokenSeparators') || [];
	var term = params.term;
	var i = 0;

	var createTag = this.createTag || function (params) {
	  return {
		id: params.term,
		text: params.term
	  };
	};

	while (i < term.length) {
	  var termChar = term[i];

	  if ($.inArray(termChar, separators) === -1) {
		i++;

		continue;
	  }

	  var part = term.substr(0, i);
	  var partParams = $.extend({}, params, {
		term: part
	  });

	  var data = createTag(partParams);

	  if (data == null) {
		i++;
		continue;
	  }

	  callback(data);

	  // Reset the term to not include the tokenized portion
	  term = term.substr(i + 1) || '';
	  i = 0;
	}

	return {
	  term: term
	};
  };

  return Tokenizer;
});

S2.define('select2/data/minimumInputLength',[

], function () {
  function MinimumInputLength (decorated, $e, options) {
	this.minimumInputLength = options.get('minimumInputLength');

	decorated.call(this, $e, options);
  }

  MinimumInputLength.prototype.query = function (decorated, params, callback) {
	params.term = params.term || '';

	if (params.term.length < this.minimumInputLength) {
	  this.trigger('results:message', {
		message: 'inputTooShort',
		args: {
		  minimum: this.minimumInputLength,
		  input: params.term,
		  params: params
		}
	  });

	  return;
	}

	decorated.call(this, params, callback);
  };

  return MinimumInputLength;
});

S2.define('select2/data/maximumInputLength',[

], function () {
  function MaximumInputLength (decorated, $e, options) {
	this.maximumInputLength = options.get('maximumInputLength');

	decorated.call(this, $e, options);
  }

  MaximumInputLength.prototype.query = function (decorated, params, callback) {
	params.term = params.term || '';

	if (this.maximumInputLength > 0 &&
		params.term.length > this.maximumInputLength) {
	  this.trigger('results:message', {
		message: 'inputTooLong',
		args: {
		  maximum: this.maximumInputLength,
		  input: params.term,
		  params: params
		}
	  });

	  return;
	}

	decorated.call(this, params, callback);
  };

  return MaximumInputLength;
});

S2.define('select2/data/maximumSelectionLength',[

], function (){
  function MaximumSelectionLength (decorated, $e, options) {
	this.maximumSelectionLength = options.get('maximumSelectionLength');

	decorated.call(this, $e, options);
  }

  MaximumSelectionLength.prototype.query =
	function (decorated, params, callback) {
	  var self = this;

	  this.current(function (currentData) {
		var count = currentData != null ? currentData.length : 0;
		if (self.maximumSelectionLength > 0 &&
		  count >= self.maximumSelectionLength) {
		  self.trigger('results:message', {
			message: 'maximumSelected',
			args: {
			  maximum: self.maximumSelectionLength
			}
		  });
		  return;
		}
		decorated.call(self, params, callback);
	  });
  };

  return MaximumSelectionLength;
});

S2.define('select2/dropdown',[
  'jquery',
  './utils'
], function ($, Utils) {
  function Dropdown ($element, options) {
	this.$element = $element;
	this.options = options;

	Dropdown.__super__.constructor.call(this);
  }

  Utils.Extend(Dropdown, Utils.Observable);

  Dropdown.prototype.render = function () {
	var $dropdown = $(
	  '<span class="select2-dropdown">' +
		'<span class="select2-results"></span>' +
	  '</span>'
	);

	$dropdown.attr('dir', this.options.get('dir'));

	this.$dropdown = $dropdown;

	return $dropdown;
  };

  Dropdown.prototype.bind = function () {
	// Should be implemented in subclasses
  };

  Dropdown.prototype.position = function ($dropdown, $container) {
	// Should be implmented in subclasses
  };

  Dropdown.prototype.destroy = function () {
	// Remove the dropdown from the DOM
	this.$dropdown.remove();
  };

  return Dropdown;
});

S2.define('select2/dropdown/search',[
  'jquery',
  '../utils'
], function ($, Utils) {
  function Search () { }

  Search.prototype.render = function (decorated) {
	var $rendered = decorated.call(this);

	var $search = $(
	  '<span class="select2-search select2-search--dropdown">' +
		'<input class="select2-search__field" type="search" tabindex="-1"' +
		' autocomplete="off" autocorrect="off" autocapitalize="off"' +
		' spellcheck="false" role="textbox" />' +
	  '</span>'
	);

	this.$searchContainer = $search;
	this.$search = $search.find('input');

	$rendered.prepend($search);

	return $rendered;
  };

  Search.prototype.bind = function (decorated, container, $container) {
	var self = this;

	decorated.call(this, container, $container);

	this.$search.on('keydown', function (evt) {
	  self.trigger('keypress', evt);

	  self._keyUpPrevented = evt.isDefaultPrevented();
	});

	// Workaround for browsers which do not support the `input` event
	// This will prevent double-triggering of events for browsers which support
	// both the `keyup` and `input` events.
	this.$search.on('input', function (evt) {
	  // Unbind the duplicated `keyup` event
	  $(this).off('keyup');
	});

	this.$search.on('keyup input', function (evt) {
	  self.handleSearch(evt);
	});

	container.on('open', function () {
	  self.$search.attr('tabindex', 0);

	  self.$search.focus();

	  window.setTimeout(function () {
		self.$search.focus();
	  }, 0);
	});

	container.on('close', function () {
	  self.$search.attr('tabindex', -1);

	  self.$search.val('');
	});

	container.on('focus', function () {
	  if (container.isOpen()) {
		self.$search.focus();
	  }
	});

	container.on('results:all', function (params) {
	  if (params.query.term == null || params.query.term === '') {
		var showSearch = self.showSearch(params);

		if (showSearch) {
		  self.$searchContainer.removeClass('select2-search--hide');
		} else {
		  self.$searchContainer.addClass('select2-search--hide');
		}
	  }
	});
  };

  Search.prototype.handleSearch = function (evt) {
	if (!this._keyUpPrevented) {
	  var input = this.$search.val();

	  this.trigger('query', {
		term: input
	  });
	}

	this._keyUpPrevented = false;
  };

  Search.prototype.showSearch = function (_, params) {
	return true;
  };

  return Search;
});

S2.define('select2/dropdown/hidePlaceholder',[

], function () {
  function HidePlaceholder (decorated, $element, options, dataAdapter) {
	this.placeholder = this.normalizePlaceholder(options.get('placeholder'));

	decorated.call(this, $element, options, dataAdapter);
  }

  HidePlaceholder.prototype.append = function (decorated, data) {
	data.results = this.removePlaceholder(data.results);

	decorated.call(this, data);
  };

  HidePlaceholder.prototype.normalizePlaceholder = function (_, placeholder) {
	if (typeof placeholder === 'string') {
	  placeholder = {
		id: '',
		text: placeholder
	  };
	}

	return placeholder;
  };

  HidePlaceholder.prototype.removePlaceholder = function (_, data) {
	var modifiedData = data.slice(0);

	for (var d = data.length - 1; d >= 0; d--) {
	  var item = data[d];

	  if (this.placeholder.id === item.id) {
		modifiedData.splice(d, 1);
	  }
	}

	return modifiedData;
  };

  return HidePlaceholder;
});

S2.define('select2/dropdown/infiniteScroll',[
  'jquery'
], function ($) {
  function InfiniteScroll (decorated, $element, options, dataAdapter) {
	this.lastParams = {};

	decorated.call(this, $element, options, dataAdapter);

	this.$loadingMore = this.createLoadingMore();
	this.loading = false;
  }

  InfiniteScroll.prototype.append = function (decorated, data) {
	this.$loadingMore.remove();
	this.loading = false;

	decorated.call(this, data);

	if (this.showLoadingMore(data)) {
	  this.$results.append(this.$loadingMore);
	}
  };

  InfiniteScroll.prototype.bind = function (decorated, container, $container) {
	var self = this;

	decorated.call(this, container, $container);

	container.on('query', function (params) {
	  self.lastParams = params;
	  self.loading = true;
	});

	container.on('query:append', function (params) {
	  self.lastParams = params;
	  self.loading = true;
	});

	this.$results.on('scroll', function () {
	  var isLoadMoreVisible = $.contains(
		document.documentElement,
		self.$loadingMore[0]
	  );

	  if (self.loading || !isLoadMoreVisible) {
		return;
	  }

	  var currentOffset = self.$results.offset().top +
		self.$results.outerHeight(false);
	  var loadingMoreOffset = self.$loadingMore.offset().top +
		self.$loadingMore.outerHeight(false);

	  if (currentOffset + 50 >= loadingMoreOffset) {
		self.loadMore();
	  }
	});
  };

  InfiniteScroll.prototype.loadMore = function () {
	this.loading = true;

	var params = $.extend({}, {page: 1}, this.lastParams);

	params.page++;

	this.trigger('query:append', params);
  };

  InfiniteScroll.prototype.showLoadingMore = function (_, data) {
	return data.pagination && data.pagination.more;
  };

  InfiniteScroll.prototype.createLoadingMore = function () {
	var $option = $(
	  '<li ' +
	  'class="select2-results__option select2-results__option--load-more"' +
	  'role="treeitem" aria-disabled="true"></li>'
	);

	var message = this.options.get('translations').get('loadingMore');

	$option.html(message(this.lastParams));

	return $option;
  };

  return InfiniteScroll;
});

S2.define('select2/dropdown/attachBody',[
  'jquery',
  '../utils'
], function ($, Utils) {
  function AttachBody (decorated, $element, options) {
	this.$dropdownParent = options.get('dropdownParent') || $(document.body);

	decorated.call(this, $element, options);
  }

  AttachBody.prototype.bind = function (decorated, container, $container) {
	var self = this;

	var setupResultsEvents = false;

	decorated.call(this, container, $container);

	container.on('open', function () {
	  self._showDropdown();
	  self._attachPositioningHandler(container);

	  if (!setupResultsEvents) {
		setupResultsEvents = true;

		container.on('results:all', function () {
		  self._positionDropdown();
		  self._resizeDropdown();
		});

		container.on('results:append', function () {
		  self._positionDropdown();
		  self._resizeDropdown();
		});
	  }
	});

	container.on('close', function () {
	  self._hideDropdown();
	  self._detachPositioningHandler(container);
	});

	this.$dropdownContainer.on('mousedown', function (evt) {
	  evt.stopPropagation();
	});
  };

  AttachBody.prototype.destroy = function (decorated) {
	decorated.call(this);

	this.$dropdownContainer.remove();
  };

  AttachBody.prototype.position = function (decorated, $dropdown, $container) {
	// Clone all of the container classes
	$dropdown.attr('class', $container.attr('class'));

	$dropdown.removeClass('select2');
	$dropdown.addClass('select2-container--open');

	$dropdown.css({
	  position: 'absolute',
	  top: -999999
	});

	this.$container = $container;
  };

  AttachBody.prototype.render = function (decorated) {
	var $container = $('<span></span>');

	var $dropdown = decorated.call(this);
	$container.append($dropdown);

	this.$dropdownContainer = $container;

	return $container;
  };

  AttachBody.prototype._hideDropdown = function (decorated) {
	this.$dropdownContainer.detach();
  };

  AttachBody.prototype._attachPositioningHandler =
	  function (decorated, container) {
	var self = this;

	var scrollEvent = 'scroll.select2.' + container.id;
	var resizeEvent = 'resize.select2.' + container.id;
	var orientationEvent = 'orientationchange.select2.' + container.id;

	var $watchers = this.$container.parents().filter(Utils.hasScroll);
	$watchers.each(function () {
	  $(this).data('select2-scroll-position', {
		x: $(this).scrollLeft(),
		y: $(this).scrollTop()
	  });
	});

	$watchers.on(scrollEvent, function (ev) {
	  var position = $(this).data('select2-scroll-position');
	  $(this).scrollTop(position.y);
	});

	$(window).on(scrollEvent + ' ' + resizeEvent + ' ' + orientationEvent,
	  function (e) {
	  self._positionDropdown();
	  self._resizeDropdown();
	});
  };

  AttachBody.prototype._detachPositioningHandler =
	  function (decorated, container) {
	var scrollEvent = 'scroll.select2.' + container.id;
	var resizeEvent = 'resize.select2.' + container.id;
	var orientationEvent = 'orientationchange.select2.' + container.id;

	var $watchers = this.$container.parents().filter(Utils.hasScroll);
	$watchers.off(scrollEvent);

	$(window).off(scrollEvent + ' ' + resizeEvent + ' ' + orientationEvent);
  };

  AttachBody.prototype._positionDropdown = function () {
	var $window = $(window);

	var isCurrentlyAbove = this.$dropdown.hasClass('select2-dropdown--above');
	var isCurrentlyBelow = this.$dropdown.hasClass('select2-dropdown--below');

	var newDirection = null;

	var offset = this.$container.offset();

	offset.bottom = offset.top + this.$container.outerHeight(false);

	var container = {
	  height: this.$container.outerHeight(false)
	};

	container.top = offset.top;
	container.bottom = offset.top + container.height;

	var dropdown = {
	  height: this.$dropdown.outerHeight(false)
	};

	var viewport = {
	  top: $window.scrollTop(),
	  bottom: $window.scrollTop() + $window.height()
	};

	var enoughRoomAbove = viewport.top < (offset.top - dropdown.height);
	var enoughRoomBelow = viewport.bottom > (offset.bottom + dropdown.height);

	var css = {
	  left: offset.left,
	  top: container.bottom
	};

	// Determine what the parent element is to use for calciulating the offset
	var $offsetParent = this.$dropdownParent;

	// For statically positoned elements, we need to get the element
	// that is determining the offset
	if ($offsetParent.css('position') === 'static') {
	  $offsetParent = $offsetParent.offsetParent();
	}

	var parentOffset = $offsetParent.offset();

	css.top -= parentOffset.top;
	css.left -= parentOffset.left;

	if (!isCurrentlyAbove && !isCurrentlyBelow) {
	  newDirection = 'below';
	}

	if (!enoughRoomBelow && enoughRoomAbove && !isCurrentlyAbove) {
	  newDirection = 'above';
	} else if (!enoughRoomAbove && enoughRoomBelow && isCurrentlyAbove) {
	  newDirection = 'below';
	}

	if (newDirection == 'above' ||
	  (isCurrentlyAbove && newDirection !== 'below')) {
	  css.top = container.top - parentOffset.top - dropdown.height;
	}

	if (newDirection != null) {
	  this.$dropdown
		.removeClass('select2-dropdown--below select2-dropdown--above')
		.addClass('select2-dropdown--' + newDirection);
	  this.$container
		.removeClass('select2-container--below select2-container--above')
		.addClass('select2-container--' + newDirection);
	}

	this.$dropdownContainer.css(css);
  };

  AttachBody.prototype._resizeDropdown = function () {
	var css = {
	  width: this.$container.outerWidth(false) + 'px'
	};

	if (this.options.get('dropdownAutoWidth')) {
	  css.minWidth = css.width;
	  css.position = 'relative';
	  css.width = 'auto';
	}

	this.$dropdown.css(css);
  };

  AttachBody.prototype._showDropdown = function (decorated) {
	this.$dropdownContainer.appendTo(this.$dropdownParent);

	this._positionDropdown();
	this._resizeDropdown();
  };

  return AttachBody;
});

S2.define('select2/dropdown/minimumResultsForSearch',[

], function () {
  function countResults (data) {
	var count = 0;

	for (var d = 0; d < data.length; d++) {
	  var item = data[d];

	  if (item.children) {
		count += countResults(item.children);
	  } else {
		count++;
	  }
	}

	return count;
  }

  function MinimumResultsForSearch (decorated, $element, options, dataAdapter) {
	this.minimumResultsForSearch = options.get('minimumResultsForSearch');

	if (this.minimumResultsForSearch < 0) {
	  this.minimumResultsForSearch = Infinity;
	}

	decorated.call(this, $element, options, dataAdapter);
  }

  MinimumResultsForSearch.prototype.showSearch = function (decorated, params) {
	if (countResults(params.data.results) < this.minimumResultsForSearch) {
	  return false;
	}

	return decorated.call(this, params);
  };

  return MinimumResultsForSearch;
});

S2.define('select2/dropdown/selectOnClose',[

], function () {
  function SelectOnClose () { }

  SelectOnClose.prototype.bind = function (decorated, container, $container) {
	var self = this;

	decorated.call(this, container, $container);

	container.on('close', function (params) {
	  self._handleSelectOnClose(params);
	});
  };

  SelectOnClose.prototype._handleSelectOnClose = function (_, params) {
	if (params && params.originalSelect2Event != null) {
	  var event = params.originalSelect2Event;

	  // Don't select an item if the close event was triggered from a select or
	  // unselect event
	  if (event._type === 'select' || event._type === 'unselect') {
		return;
	  }
	}

	var $highlightedResults = this.getHighlightedResults();

	// Only select highlighted results
	if ($highlightedResults.length < 1) {
	  return;
	}

	var data = $highlightedResults.data('data');

	// Don't re-select already selected resulte
	if (
	  (data.element != null && data.element.selected) ||
	  (data.element == null && data.selected)
	) {
	  return;
	}

	this.trigger('select', {
		data: data
	});
  };

  return SelectOnClose;
});

S2.define('select2/dropdown/closeOnSelect',[

], function () {
  function CloseOnSelect () { }

  CloseOnSelect.prototype.bind = function (decorated, container, $container) {
	var self = this;

	decorated.call(this, container, $container);

	container.on('select', function (evt) {
	  self._selectTriggered(evt);
	});

	container.on('unselect', function (evt) {
	  self._selectTriggered(evt);
	});
  };

  CloseOnSelect.prototype._selectTriggered = function (_, evt) {
	var originalEvent = evt.originalEvent;

	// Don't close if the control key is being held
	if (originalEvent && originalEvent.ctrlKey) {
	  return;
	}

	this.trigger('close', {
	  originalEvent: originalEvent,
	  originalSelect2Event: evt
	});
  };

  return CloseOnSelect;
});

S2.define('select2/i18n/en',[],function () {
  // English
  return {
	errorLoading: function () {
	  return 'The results could not be loaded.';
	},
	inputTooLong: function (args) {
	  var overChars = args.input.length - args.maximum;

	  var message = 'Please delete ' + overChars + ' character';

	  if (overChars != 1) {
		message += 's';
	  }

	  return message;
	},
	inputTooShort: function (args) {
	  var remainingChars = args.minimum - args.input.length;

	  var message = 'Please enter ' + remainingChars + ' or more characters';

	  return message;
	},
	loadingMore: function () {
	  return 'Loading more results…';
	},
	maximumSelected: function (args) {
	  var message = 'You can only select ' + args.maximum + ' item';

	  if (args.maximum != 1) {
		message += 's';
	  }

	  return message;
	},
	noResults: function () {
	  return 'No results found';
	},
	searching: function () {
	  return 'Searching…';
	}
  };
});

S2.define('select2/defaults',[
  'jquery',
  'require',

  './results',

  './selection/single',
  './selection/multiple',
  './selection/placeholder',
  './selection/allowClear',
  './selection/search',
  './selection/eventRelay',

  './utils',
  './translation',
  './diacritics',

  './data/select',
  './data/array',
  './data/ajax',
  './data/tags',
  './data/tokenizer',
  './data/minimumInputLength',
  './data/maximumInputLength',
  './data/maximumSelectionLength',

  './dropdown',
  './dropdown/search',
  './dropdown/hidePlaceholder',
  './dropdown/infiniteScroll',
  './dropdown/attachBody',
  './dropdown/minimumResultsForSearch',
  './dropdown/selectOnClose',
  './dropdown/closeOnSelect',

  './i18n/en'
], function ($, require,

			 ResultsList,

			 SingleSelection, MultipleSelection, Placeholder, AllowClear,
			 SelectionSearch, EventRelay,

			 Utils, Translation, DIACRITICS,

			 SelectData, ArrayData, AjaxData, Tags, Tokenizer,
			 MinimumInputLength, MaximumInputLength, MaximumSelectionLength,

			 Dropdown, DropdownSearch, HidePlaceholder, InfiniteScroll,
			 AttachBody, MinimumResultsForSearch, SelectOnClose, CloseOnSelect,

			 EnglishTranslation) {
  function Defaults () {
	this.reset();
  }

  Defaults.prototype.apply = function (options) {
	options = $.extend(true, {}, this.defaults, options);

	if (options.dataAdapter == null) {
	  if (options.ajax != null) {
		options.dataAdapter = AjaxData;
	  } else if (options.data != null) {
		options.dataAdapter = ArrayData;
	  } else {
		options.dataAdapter = SelectData;
	  }

	  if (options.minimumInputLength > 0) {
		options.dataAdapter = Utils.Decorate(
		  options.dataAdapter,
		  MinimumInputLength
		);
	  }

	  if (options.maximumInputLength > 0) {
		options.dataAdapter = Utils.Decorate(
		  options.dataAdapter,
		  MaximumInputLength
		);
	  }

	  if (options.maximumSelectionLength > 0) {
		options.dataAdapter = Utils.Decorate(
		  options.dataAdapter,
		  MaximumSelectionLength
		);
	  }

	  if (options.tags) {
		options.dataAdapter = Utils.Decorate(options.dataAdapter, Tags);
	  }

	  if (options.tokenSeparators != null || options.tokenizer != null) {
		options.dataAdapter = Utils.Decorate(
		  options.dataAdapter,
		  Tokenizer
		);
	  }

	  if (options.query != null) {
		var Query = require(options.amdBase + 'compat/query');

		options.dataAdapter = Utils.Decorate(
		  options.dataAdapter,
		  Query
		);
	  }

	  if (options.initSelection != null) {
		var InitSelection = require(options.amdBase + 'compat/initSelection');

		options.dataAdapter = Utils.Decorate(
		  options.dataAdapter,
		  InitSelection
		);
	  }
	}

	if (options.resultsAdapter == null) {
	  options.resultsAdapter = ResultsList;

	  if (options.ajax != null) {
		options.resultsAdapter = Utils.Decorate(
		  options.resultsAdapter,
		  InfiniteScroll
		);
	  }

	  if (options.placeholder != null) {
		options.resultsAdapter = Utils.Decorate(
		  options.resultsAdapter,
		  HidePlaceholder
		);
	  }

	  if (options.selectOnClose) {
		options.resultsAdapter = Utils.Decorate(
		  options.resultsAdapter,
		  SelectOnClose
		);
	  }
	}

	if (options.dropdownAdapter == null) {
	  if (options.multiple) {
		options.dropdownAdapter = Dropdown;
	  } else {
		var SearchableDropdown = Utils.Decorate(Dropdown, DropdownSearch);

		options.dropdownAdapter = SearchableDropdown;
	  }

	  if (options.minimumResultsForSearch !== 0) {
		options.dropdownAdapter = Utils.Decorate(
		  options.dropdownAdapter,
		  MinimumResultsForSearch
		);
	  }

	  if (options.closeOnSelect) {
		options.dropdownAdapter = Utils.Decorate(
		  options.dropdownAdapter,
		  CloseOnSelect
		);
	  }

	  if (
		options.dropdownCssClass != null ||
		options.dropdownCss != null ||
		options.adaptDropdownCssClass != null
	  ) {
		var DropdownCSS = require(options.amdBase + 'compat/dropdownCss');

		options.dropdownAdapter = Utils.Decorate(
		  options.dropdownAdapter,
		  DropdownCSS
		);
	  }

	  options.dropdownAdapter = Utils.Decorate(
		options.dropdownAdapter,
		AttachBody
	  );
	}

	if (options.selectionAdapter == null) {
	  if (options.multiple) {
		options.selectionAdapter = MultipleSelection;
	  } else {
		options.selectionAdapter = SingleSelection;
	  }

	  // Add the placeholder mixin if a placeholder was specified
	  if (options.placeholder != null) {
		options.selectionAdapter = Utils.Decorate(
		  options.selectionAdapter,
		  Placeholder
		);
	  }

	  if (options.allowClear) {
		options.selectionAdapter = Utils.Decorate(
		  options.selectionAdapter,
		  AllowClear
		);
	  }

	  if (options.multiple) {
		options.selectionAdapter = Utils.Decorate(
		  options.selectionAdapter,
		  SelectionSearch
		);
	  }

	  if (
		options.containerCssClass != null ||
		options.containerCss != null ||
		options.adaptContainerCssClass != null
	  ) {
		var ContainerCSS = require(options.amdBase + 'compat/containerCss');

		options.selectionAdapter = Utils.Decorate(
		  options.selectionAdapter,
		  ContainerCSS
		);
	  }

	  options.selectionAdapter = Utils.Decorate(
		options.selectionAdapter,
		EventRelay
	  );
	}

	if (typeof options.language === 'string') {
	  // Check if the language is specified with a region
	  if (options.language.indexOf('-') > 0) {
		// Extract the region information if it is included
		var languageParts = options.language.split('-');
		var baseLanguage = languageParts[0];

		options.language = [options.language, baseLanguage];
	  } else {
		options.language = [options.language];
	  }
	}

	if ($.isArray(options.language)) {
	  var languages = new Translation();
	  options.language.push('en');

	  var languageNames = options.language;

	  for (var l = 0; l < languageNames.length; l++) {
		var name = languageNames[l];
		var language = {};

		try {
		  // Try to load it with the original name
		  language = Translation.loadPath(name);
		} catch (e) {
		  try {
			// If we couldn't load it, check if it wasn't the full path
			name = this.defaults.amdLanguageBase + name;
			language = Translation.loadPath(name);
		  } catch (ex) {
			// The translation could not be loaded at all. Sometimes this is
			// because of a configuration problem, other times this can be
			// because of how Select2 helps load all possible translation files.
			if (options.debug && window.console && console.warn) {
			  console.warn(
				'Select2: The language file for "' + name + '" could not be ' +
				'automatically loaded. A fallback will be used instead.'
			  );
			}

			continue;
		  }
		}

		languages.extend(language);
	  }

	  options.translations = languages;
	} else {
	  var baseTranslation = Translation.loadPath(
		this.defaults.amdLanguageBase + 'en'
	  );
	  var customTranslation = new Translation(options.language);

	  customTranslation.extend(baseTranslation);

	  options.translations = customTranslation;
	}

	return options;
  };

  Defaults.prototype.reset = function () {
	function stripDiacritics (text) {
	  // Used 'uni range + named function' from http://jsperf.com/diacritics/18
	  function match(a) {
		return DIACRITICS[a] || a;
	  }

	  return text.replace(/[^\u0000-\u007E]/g, match);
	}

	function matcher (params, data) {
	  // Always return the object if there is nothing to compare
	  if ($.trim(params.term) === '') {
		return data;
	  }

	  // Do a recursive check for options with children
	  if (data.children && data.children.length > 0) {
		// Clone the data object if there are children
		// This is required as we modify the object to remove any non-matches
		var match = $.extend(true, {}, data);

		// Check each child of the option
		for (var c = data.children.length - 1; c >= 0; c--) {
		  var child = data.children[c];

		  var matches = matcher(params, child);

		  // If there wasn't a match, remove the object in the array
		  if (matches == null) {
			match.children.splice(c, 1);
		  }
		}

		// If any children matched, return the new object
		if (match.children.length > 0) {
		  return match;
		}

		// If there were no matching children, check just the plain object
		return matcher(params, match);
	  }

	  var original = stripDiacritics(data.text).toUpperCase();
	  var term = stripDiacritics(params.term).toUpperCase();

	  // Check if the text contains the term
	  if (original.indexOf(term) > -1) {
		return data;
	  }

	  // If it doesn't contain the term, don't return anything
	  return null;
	}

	this.defaults = {
	  amdBase: './',
	  amdLanguageBase: './i18n/',
	  closeOnSelect: true,
	  debug: false,
	  dropdownAutoWidth: false,
	  escapeMarkup: Utils.escapeMarkup,
	  language: EnglishTranslation,
	  matcher: matcher,
	  minimumInputLength: 0,
	  maximumInputLength: 0,
	  maximumSelectionLength: 0,
	  minimumResultsForSearch: 0,
	  selectOnClose: false,
	  sorter: function (data) {
		return data;
	  },
	  templateResult: function (result) {
		return result.text;
	  },
	  templateSelection: function (selection) {
		return selection.text;
	  },
	  theme: 'default',
	  width: 'resolve'
	};
  };

  Defaults.prototype.set = function (key, value) {
	var camelKey = $.camelCase(key);

	var data = {};
	data[camelKey] = value;

	var convertedData = Utils._convertData(data);

	$.extend(this.defaults, convertedData);
  };

  var defaults = new Defaults();

  return defaults;
});

S2.define('select2/options',[
  'require',
  'jquery',
  './defaults',
  './utils'
], function (require, $, Defaults, Utils) {
  function Options (options, $element) {
	this.options = options;

	if ($element != null) {
	  this.fromElement($element);
	}

	this.options = Defaults.apply(this.options);

	if ($element && $element.is('input')) {
	  var InputCompat = require(this.get('amdBase') + 'compat/inputData');

	  this.options.dataAdapter = Utils.Decorate(
		this.options.dataAdapter,
		InputCompat
	  );
	}
  }

  Options.prototype.fromElement = function ($e) {
	var excludedData = ['select2'];

	if (this.options.multiple == null) {
	  this.options.multiple = $e.prop('multiple');
	}

	if (this.options.disabled == null) {
	  this.options.disabled = $e.prop('disabled');
	}

	if (this.options.language == null) {
	  if ($e.prop('lang')) {
		this.options.language = $e.prop('lang').toLowerCase();
	  } else if ($e.closest('[lang]').prop('lang')) {
		this.options.language = $e.closest('[lang]').prop('lang');
	  }
	}

	if (this.options.dir == null) {
	  if ($e.prop('dir')) {
		this.options.dir = $e.prop('dir');
	  } else if ($e.closest('[dir]').prop('dir')) {
		this.options.dir = $e.closest('[dir]').prop('dir');
	  } else {
		this.options.dir = 'ltr';
	  }
	}

	$e.prop('disabled', this.options.disabled);
	$e.prop('multiple', this.options.multiple);

	if ($e.data('select2Tags')) {
	  if (this.options.debug && window.console && console.warn) {
		console.warn(
		  'Select2: The `data-select2-tags` attribute has been changed to ' +
		  'use the `data-data` and `data-tags="true"` attributes and will be ' +
		  'removed in future versions of Select2.'
		);
	  }

	  $e.data('data', $e.data('select2Tags'));
	  $e.data('tags', true);
	}

	if ($e.data('ajaxUrl')) {
	  if (this.options.debug && window.console && console.warn) {
		console.warn(
		  'Select2: The `data-ajax-url` attribute has been changed to ' +
		  '`data-ajax--url` and support for the old attribute will be removed' +
		  ' in future versions of Select2.'
		);
	  }

	  $e.attr('ajax--url', $e.data('ajaxUrl'));
	  $e.data('ajax--url', $e.data('ajaxUrl'));
	}

	var dataset = {};

	// Prefer the element's `dataset` attribute if it exists
	// jQuery 1.x does not correctly handle data attributes with multiple dashes
	if ($.fn.jquery && $.fn.jquery.substr(0, 2) == '1.' && $e[0].dataset) {
	  dataset = $.extend(true, {}, $e[0].dataset, $e.data());
	} else {
	  dataset = $e.data();
	}

	var data = $.extend(true, {}, dataset);

	data = Utils._convertData(data);

	for (var key in data) {
	  if ($.inArray(key, excludedData) > -1) {
		continue;
	  }

	  if ($.isPlainObject(this.options[key])) {
		$.extend(this.options[key], data[key]);
	  } else {
		this.options[key] = data[key];
	  }
	}

	return this;
  };

  Options.prototype.get = function (key) {
	return this.options[key];
  };

  Options.prototype.set = function (key, val) {
	this.options[key] = val;
  };

  return Options;
});

S2.define('select2/core',[
  'jquery',
  './options',
  './utils',
  './keys'
], function ($, Options, Utils, KEYS) {
  var Select2 = function ($element, options) {
	if ($element.data('select2') != null) {
	  $element.data('select2').destroy();
	}

	this.$element = $element;

	this.id = this._generateId($element);

	options = options || {};

	this.options = new Options(options, $element);

	Select2.__super__.constructor.call(this);

	// Set up the tabindex

	var tabindex = $element.attr('tabindex') || 0;
	$element.data('old-tabindex', tabindex);
	$element.attr('tabindex', '-1');

	// Set up containers and adapters

	var DataAdapter = this.options.get('dataAdapter');
	this.dataAdapter = new DataAdapter($element, this.options);

	var $container = this.render();

	this._placeContainer($container);

	var SelectionAdapter = this.options.get('selectionAdapter');
	this.selection = new SelectionAdapter($element, this.options);
	this.$selection = this.selection.render();

	this.selection.position(this.$selection, $container);

	var DropdownAdapter = this.options.get('dropdownAdapter');
	this.dropdown = new DropdownAdapter($element, this.options);
	this.$dropdown = this.dropdown.render();

	this.dropdown.position(this.$dropdown, $container);

	var ResultsAdapter = this.options.get('resultsAdapter');
	this.results = new ResultsAdapter($element, this.options, this.dataAdapter);
	this.$results = this.results.render();

	this.results.position(this.$results, this.$dropdown);

	// Bind events

	var self = this;

	// Bind the container to all of the adapters
	this._bindAdapters();

	// Register any DOM event handlers
	this._registerDomEvents();

	// Register any internal event handlers
	this._registerDataEvents();
	this._registerSelectionEvents();
	this._registerDropdownEvents();
	this._registerResultsEvents();
	this._registerEvents();

	// Set the initial state
	this.dataAdapter.current(function (initialData) {
	  self.trigger('selection:update', {
		data: initialData
	  });
	});

	// Hide the original select
	$element.addClass('select2-hidden-accessible');
	$element.attr('aria-hidden', 'true');

	// Synchronize any monitored attributes
	this._syncAttributes();

	$element.data('select2', this);
  };

  Utils.Extend(Select2, Utils.Observable);

  Select2.prototype._generateId = function ($element) {
	var id = '';

	if ($element.attr('id') != null) {
	  id = $element.attr('id');
	} else if ($element.attr('name') != null) {
	  id = $element.attr('name') + '-' + Utils.generateChars(2);
	} else {
	  id = Utils.generateChars(4);
	}

	id = id.replace(/(:|\.|\[|\]|,)/g, '');
	id = 'select2-' + id;

	return id;
  };

  Select2.prototype._placeContainer = function ($container) {
	$container.insertAfter(this.$element);

	var width = this._resolveWidth(this.$element, this.options.get('width'));

	if (width != null) {
	  $container.css('width', width);
	}
  };

  Select2.prototype._resolveWidth = function ($element, method) {
	var WIDTH = /^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i;

	if (method == 'resolve') {
	  var styleWidth = this._resolveWidth($element, 'style');

	  if (styleWidth != null) {
		return styleWidth;
	  }

	  return this._resolveWidth($element, 'element');
	}

	if (method == 'element') {
	  var elementWidth = $element.outerWidth(false);

	  if (elementWidth <= 0) {
		return 'auto';
	  }

	  return elementWidth + 'px';
	}

	if (method == 'style') {
	  var style = $element.attr('style');

	  if (typeof(style) !== 'string') {
		return null;
	  }

	  var attrs = style.split(';');

	  for (var i = 0, l = attrs.length; i < l; i = i + 1) {
		var attr = attrs[i].replace(/\s/g, '');
		var matches = attr.match(WIDTH);

		if (matches !== null && matches.length >= 1) {
		  return matches[1];
		}
	  }

	  return null;
	}

	return method;
  };

  Select2.prototype._bindAdapters = function () {
	this.dataAdapter.bind(this, this.$container);
	this.selection.bind(this, this.$container);

	this.dropdown.bind(this, this.$container);
	this.results.bind(this, this.$container);
  };

  Select2.prototype._registerDomEvents = function () {
	var self = this;

	this.$element.on('change.select2', function () {
	  self.dataAdapter.current(function (data) {
		self.trigger('selection:update', {
		  data: data
		});
	  });
	});

	this.$element.on('focus.select2', function (evt) {
	  self.trigger('focus', evt);
	});

	this._syncA = Utils.bind(this._syncAttributes, this);
	this._syncS = Utils.bind(this._syncSubtree, this);

	if (this.$element[0].attachEvent) {
	  this.$element[0].attachEvent('onpropertychange', this._syncA);
	}

	var observer = window.MutationObserver ||
	  window.WebKitMutationObserver ||
	  window.MozMutationObserver
	;

	if (observer != null) {
	  this._observer = new observer(function (mutations) {
		$.each(mutations, self._syncA);
		$.each(mutations, self._syncS);
	  });
	  this._observer.observe(this.$element[0], {
		attributes: true,
		childList: true,
		subtree: false
	  });
	} else if (this.$element[0].addEventListener) {
	  this.$element[0].addEventListener(
		'DOMAttrModified',
		self._syncA,
		false
	  );
	  this.$element[0].addEventListener(
		'DOMNodeInserted',
		self._syncS,
		false
	  );
	  this.$element[0].addEventListener(
		'DOMNodeRemoved',
		self._syncS,
		false
	  );
	}
  };

  Select2.prototype._registerDataEvents = function () {
	var self = this;

	this.dataAdapter.on('*', function (name, params) {
	  self.trigger(name, params);
	});
  };

  Select2.prototype._registerSelectionEvents = function () {
	var self = this;
	var nonRelayEvents = ['toggle', 'focus'];

	this.selection.on('toggle', function () {
	  self.toggleDropdown();
	});

	this.selection.on('focus', function (params) {
	  self.focus(params);
	});

	this.selection.on('*', function (name, params) {
	  if ($.inArray(name, nonRelayEvents) !== -1) {
		return;
	  }

	  self.trigger(name, params);
	});
  };

  Select2.prototype._registerDropdownEvents = function () {
	var self = this;

	this.dropdown.on('*', function (name, params) {
	  self.trigger(name, params);
	});
  };

  Select2.prototype._registerResultsEvents = function () {
	var self = this;

	this.results.on('*', function (name, params) {
	  self.trigger(name, params);
	});
  };

  Select2.prototype._registerEvents = function () {
	var self = this;

	this.on('open', function () {
	  self.$container.addClass('select2-container--open');
	});

	this.on('close', function () {
	  self.$container.removeClass('select2-container--open');
	});

	this.on('enable', function () {
	  self.$container.removeClass('select2-container--disabled');
	});

	this.on('disable', function () {
	  self.$container.addClass('select2-container--disabled');
	});

	this.on('blur', function () {
	  self.$container.removeClass('select2-container--focus');
	});

	this.on('query', function (params) {
	  if (!self.isOpen()) {
		self.trigger('open', {});
	  }

	  this.dataAdapter.query(params, function (data) {
		self.trigger('results:all', {
		  data: data,
		  query: params
		});
	  });
	});

	this.on('query:append', function (params) {
	  this.dataAdapter.query(params, function (data) {
		self.trigger('results:append', {
		  data: data,
		  query: params
		});
	  });
	});

	this.on('keypress', function (evt) {
	  var key = evt.which;

	  if (self.isOpen()) {
		if (key === KEYS.ESC || key === KEYS.TAB ||
			(key === KEYS.UP && evt.altKey)) {
		  self.close();

		  evt.preventDefault();
		} else if (key === KEYS.ENTER) {
		  self.trigger('results:select', {});

		  evt.preventDefault();
		} else if ((key === KEYS.SPACE && evt.ctrlKey)) {
		  self.trigger('results:toggle', {});

		  evt.preventDefault();
		} else if (key === KEYS.UP) {
		  self.trigger('results:previous', {});

		  evt.preventDefault();
		} else if (key === KEYS.DOWN) {
		  self.trigger('results:next', {});

		  evt.preventDefault();
		}
	  } else {
		if (key === KEYS.ENTER || key === KEYS.SPACE ||
			(key === KEYS.DOWN && evt.altKey)) {
		  self.open();

		  evt.preventDefault();
		}
	  }
	});
  };

  Select2.prototype._syncAttributes = function () {
	this.options.set('disabled', this.$element.prop('disabled'));

	if (this.options.get('disabled')) {
	  if (this.isOpen()) {
		this.close();
	  }

	  this.trigger('disable', {});
	} else {
	  this.trigger('enable', {});
	}
  };

  Select2.prototype._syncSubtree = function (evt, mutations) {
	var changed = false;
	var self = this;

	// Ignore any mutation events raised for elements that aren't options or
	// optgroups. This handles the case when the select element is destroyed
	if (
	  evt && evt.target && (
		evt.target.nodeName !== 'OPTION' && evt.target.nodeName !== 'OPTGROUP'
	  )
	) {
	  return;
	}

	if (!mutations) {
	  // If mutation events aren't supported, then we can only assume that the
	  // change affected the selections
	  changed = true;
	} else if (mutations.addedNodes && mutations.addedNodes.length > 0) {
	  for (var n = 0; n < mutations.addedNodes.length; n++) {
		var node = mutations.addedNodes[n];

		if (node.selected) {
		  changed = true;
		}
	  }
	} else if (mutations.removedNodes && mutations.removedNodes.length > 0) {
	  changed = true;
	}

	// Only re-pull the data if we think there is a change
	if (changed) {
	  this.dataAdapter.current(function (currentData) {
		self.trigger('selection:update', {
		  data: currentData
		});
	  });
	}
  };

  /**
   * Override the trigger method to automatically trigger pre-events when
   * there are events that can be prevented.
   */
  Select2.prototype.trigger = function (name, args) {
	var actualTrigger = Select2.__super__.trigger;
	var preTriggerMap = {
	  'open': 'opening',
	  'close': 'closing',
	  'select': 'selecting',
	  'unselect': 'unselecting'
	};

	if (args === undefined) {
	  args = {};
	}

	if (name in preTriggerMap) {
	  var preTriggerName = preTriggerMap[name];
	  var preTriggerArgs = {
		prevented: false,
		name: name,
		args: args
	  };

	  actualTrigger.call(this, preTriggerName, preTriggerArgs);

	  if (preTriggerArgs.prevented) {
		args.prevented = true;

		return;
	  }
	}

	actualTrigger.call(this, name, args);
  };

  Select2.prototype.toggleDropdown = function () {
	if (this.options.get('disabled')) {
	  return;
	}

	if (this.isOpen()) {
	  this.close();
	} else {
	  this.open();
	}
  };

  Select2.prototype.open = function () {
	if (this.isOpen()) {
	  return;
	}

	this.trigger('query', {});
  };

  Select2.prototype.close = function () {
	if (!this.isOpen()) {
	  return;
	}

	this.trigger('close', {});
  };

  Select2.prototype.isOpen = function () {
	return this.$container.hasClass('select2-container--open');
  };

  Select2.prototype.hasFocus = function () {
	return this.$container.hasClass('select2-container--focus');
  };

  Select2.prototype.focus = function (data) {
	// No need to re-trigger focus events if we are already focused
	if (this.hasFocus()) {
	  return;
	}

	this.$container.addClass('select2-container--focus');
	this.trigger('focus', {});
  };

  Select2.prototype.enable = function (args) {
	if (this.options.get('debug') && window.console && console.warn) {
	  console.warn(
		'Select2: The `select2("enable")` method has been deprecated and will' +
		' be removed in later Select2 versions. Use $element.prop("disabled")' +
		' instead.'
	  );
	}

	if (args == null || args.length === 0) {
	  args = [true];
	}

	var disabled = !args[0];

	this.$element.prop('disabled', disabled);
  };

  Select2.prototype.data = function () {
	if (this.options.get('debug') &&
		arguments.length > 0 && window.console && console.warn) {
	  console.warn(
		'Select2: Data can no longer be set using `select2("data")`. You ' +
		'should consider setting the value instead using `$element.val()`.'
	  );
	}

	var data = [];

	this.dataAdapter.current(function (currentData) {
	  data = currentData;
	});

	return data;
  };

  Select2.prototype.val = function (args) {
	if (this.options.get('debug') && window.console && console.warn) {
	  console.warn(
		'Select2: The `select2("val")` method has been deprecated and will be' +
		' removed in later Select2 versions. Use $element.val() instead.'
	  );
	}

	if (args == null || args.length === 0) {
	  return this.$element.val();
	}

	var newVal = args[0];

	if ($.isArray(newVal)) {
	  newVal = $.map(newVal, function (obj) {
		return obj.toString();
	  });
	}

	this.$element.val(newVal).trigger('change');
  };

  Select2.prototype.destroy = function () {
	this.$container.remove();

	if (this.$element[0].detachEvent) {
	  this.$element[0].detachEvent('onpropertychange', this._syncA);
	}

	if (this._observer != null) {
	  this._observer.disconnect();
	  this._observer = null;
	} else if (this.$element[0].removeEventListener) {
	  this.$element[0]
		.removeEventListener('DOMAttrModified', this._syncA, false);
	  this.$element[0]
		.removeEventListener('DOMNodeInserted', this._syncS, false);
	  this.$element[0]
		.removeEventListener('DOMNodeRemoved', this._syncS, false);
	}

	this._syncA = null;
	this._syncS = null;

	this.$element.off('.select2');
	this.$element.attr('tabindex', this.$element.data('old-tabindex'));

	this.$element.removeClass('select2-hidden-accessible');
	this.$element.attr('aria-hidden', 'false');
	this.$element.removeData('select2');

	this.dataAdapter.destroy();
	this.selection.destroy();
	this.dropdown.destroy();
	this.results.destroy();

	this.dataAdapter = null;
	this.selection = null;
	this.dropdown = null;
	this.results = null;
  };

  Select2.prototype.render = function () {
	var $container = $(
	  '<span class="select2 select2-container">' +
		'<span class="selection"></span>' +
		'<span class="dropdown-wrapper" aria-hidden="true"></span>' +
	  '</span>'
	);

	$container.attr('dir', this.options.get('dir'));

	this.$container = $container;

	this.$container.addClass('select2-container--' + this.options.get('theme'));

	$container.data('element', this.$element);

	return $container;
  };

  return Select2;
});

S2.define('jquery-mousewheel',[
  'jquery'
], function ($) {
  // Used to shim jQuery.mousewheel for non-full builds.
  return $;
});

S2.define('jquery.select2',[
  'jquery',
  'jquery-mousewheel',

  './select2/core',
  './select2/defaults'
], function ($, _, Select2, Defaults) {
  if ($.fn.select2 == null) {
	// All methods that should return the element
	var thisMethods = ['open', 'close', 'destroy'];

	$.fn.select2 = function (options) {
	  options = options || {};

	  if (typeof options === 'object') {
		this.each(function () {
		  var instanceOptions = $.extend(true, {}, options);

		  var instance = new Select2($(this), instanceOptions);
		});

		return this;
	  } else if (typeof options === 'string') {
		var ret;
		var args = Array.prototype.slice.call(arguments, 1);

		this.each(function () {
		  var instance = $(this).data('select2');

		  if (instance == null && window.console && console.error) {
			console.error(
			  'The select2(\'' + options + '\') method was called on an ' +
			  'element that is not using Select2.'
			);
		  }

		  ret = instance[options].apply(instance, args);
		});

		// Check if we should be returning `this`
		if ($.inArray(options, thisMethods) > -1) {
		  return this;
		}

		return ret;
	  } else {
		throw new Error('Invalid arguments for Select2: ' + options);
	  }
	};
  }

  if ($.fn.select2.defaults == null) {
	$.fn.select2.defaults = Defaults;
  }

  return Select2;
});

  // Return the AMD loader configuration so it can be used outside of this file
  return {
	define: S2.define,
	require: S2.require
  };
}());

  // Autoload the jQuery bindings
  // We know that all of the modules exist above this, so we're safe
  var select2 = S2.require('jquery.select2');

  // Hold the AMD module references on the jQuery function that was just loaded
  // This allows Select2 to use the internal loader outside of this file, such
  // as in the language files.
  jQuery.fn.select2.amd = S2;

  // Return the Select2 instance for anyone who is importing it.
  return select2;
}));


}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("select2", moduleFactory);

}());			(function(){
// module factory: start

var moduleFactory = function($) {
// module body: start

var jQuery = $;
var module = this; 
var exports = function() { 


/*!
 * sly 1.6.1 - 8th Aug 2015
 * https://github.com/darsain/sly
 *
 * Licensed under the MIT license.
 * http://opensource.org/licenses/MIT
 */

;(function ($, w, undefined) {
	'use strict';

	var pluginName = 'sly';
	var className  = 'Sly';
	var namespace  = pluginName;

	// Local WindowAnimationTiming interface
	var cAF = w.cancelAnimationFrame || w.cancelRequestAnimationFrame;
	var rAF = w.requestAnimationFrame;

	// Support indicators
	var transform, gpuAcceleration;

	// Other global values
	var $doc = $(document);
	var dragInitEvents = 'touchstart.' + namespace + ' mousedown.' + namespace;
	var dragMouseEvents = 'mousemove.' + namespace + ' mouseup.' + namespace;
	var dragTouchEvents = 'touchmove.' + namespace + ' touchend.' + namespace;
	var wheelEvent = (document.implementation.hasFeature('Event.wheel', '3.0') ? 'wheel.' : 'mousewheel.') + namespace;
	var clickEvent = 'click.' + namespace;
	var mouseDownEvent = 'mousedown.' + namespace;
	var interactiveElements = ['INPUT', 'SELECT', 'BUTTON', 'TEXTAREA'];
	var tmpArray = [];
	var time;

	// Math shorthands
	var abs = Math.abs;
	var sqrt = Math.sqrt;
	var pow = Math.pow;
	var round = Math.round;
	var max = Math.max;
	var min = Math.min;

	// Keep track of last fired global wheel event
	var lastGlobalWheel = 0;
	$doc.on(wheelEvent, function (event) {
		var sly = event.originalEvent[namespace];
		var time = +new Date();
		// Update last global wheel time, but only when event didn't originate
		// in Sly frame, or the origin was less than scrollHijack time ago
		if (!sly || sly.options.scrollHijack < time - lastGlobalWheel) lastGlobalWheel = time;
	});

	/**
	 * Sly.
	 *
	 * @class
	 *
	 * @param {Element} frame       DOM element of sly container.
	 * @param {Object}  options     Object with options.
	 * @param {Object}  callbackMap Callbacks map.
	 */
	function Sly(frame, options, callbackMap) {
		if (!(this instanceof Sly)) return new Sly(frame, options, callbackMap);

		// Extend options
		var o = $.extend({}, Sly.defaults, options);

		// Private variables
		var self = this;
		var parallax = isNumber(frame);

		// Frame
		var $frame = $(frame);
		var $slidee = o.slidee ? $(o.slidee).eq(0) : $frame.children().eq(0);
		var frameSize = 0;
		var slideeSize = 0;
		var pos = {
			start: 0,
			center: 0,
			end: 0,
			cur: 0,
			dest: 0
		};

		// Scrollbar
		var $sb = $(o.scrollBar).eq(0);
		var $handle = $sb.children().eq(0);
		var sbSize = 0;
		var handleSize = 0;
		var hPos = {
			start: 0,
			end: 0,
			cur: 0
		};

		// Pagesbar
		var $pb = $(o.pagesBar);
		var $pages = 0;
		var pages = [];

		// Items
		var $items = 0;
		var items = [];
		var rel = {
			firstItem: 0,
			lastItem: 0,
			centerItem: 0,
			activeItem: null,
			activePage: 0
		};

		// Styles
		var frameStyles = new StyleRestorer($frame[0]);
		var slideeStyles = new StyleRestorer($slidee[0]);
		var sbStyles = new StyleRestorer($sb[0]);
		var handleStyles = new StyleRestorer($handle[0]);

		// Navigation type booleans
		var basicNav = o.itemNav === 'basic';
		var forceCenteredNav = o.itemNav === 'forceCentered';
		var centeredNav = o.itemNav === 'centered' || forceCenteredNav;
		var itemNav = !parallax && (basicNav || centeredNav || forceCenteredNav);

		// Miscellaneous
		var $scrollSource = o.scrollSource ? $(o.scrollSource) : $frame;
		var $dragSource = o.dragSource ? $(o.dragSource) : $frame;
		var $forwardButton = $(o.forward);
		var $backwardButton = $(o.backward);
		var $prevButton = $(o.prev);
		var $nextButton = $(o.next);
		var $prevPageButton = $(o.prevPage);
		var $nextPageButton = $(o.nextPage);
		var callbacks = {};
		var last = {};
		var animation = {};
		var move = {};
		var dragging = {
			released: 1
		};
		var scrolling = {
			last: 0,
			delta: 0,
			resetTime: 200
		};
		var renderID = 0;
		var historyID = 0;
		var cycleID = 0;
		var continuousID = 0;
		var i, l;

		// Normalizing frame
		if (!parallax) {
			frame = $frame[0];
		}

		// Expose properties
		self.initialized = 0;
		self.frame = frame;
		self.slidee = $slidee[0];
		self.pos = pos;
		self.rel = rel;
		self.items = items;
		self.pages = pages;
		self.isPaused = 0;
		self.options = o;
		self.dragging = dragging;

		/**
		 * Loading function.
		 *
		 * Populate arrays, set sizes, bind events, ...
		 *
		 * @param {Boolean} [isInit] Whether load is called from within self.init().
		 * @return {Void}
		 */
		function load(isInit) {
			// Local variables
			var lastItemsCount = 0;
			var lastPagesCount = pages.length;

			// Save old position
			pos.old = $.extend({}, pos);

			// Reset global variables
			frameSize = parallax ? 0 : $frame[o.horizontal ? 'width' : 'height']();
			sbSize = $sb[o.horizontal ? 'width' : 'height']();
			slideeSize = parallax ? frame : $slidee[o.horizontal ? 'outerWidth' : 'outerHeight']();
			pages.length = 0;

			// Set position limits & relatives
			pos.start = 0;
			pos.end = max(slideeSize - frameSize, 0);

			// Sizes & offsets for item based navigations
			if (itemNav) {
				// Save the number of current items
				lastItemsCount = items.length;

				// Reset itemNav related variables
				$items = $slidee.children(o.itemSelector);
				items.length = 0;

				// Needed variables
				var paddingStart = getPx($slidee, o.horizontal ? 'paddingLeft' : 'paddingTop');
				var paddingEnd = getPx($slidee, o.horizontal ? 'paddingRight' : 'paddingBottom');
				var borderBox = $($items).css('boxSizing') === 'border-box';
				var areFloated = $items.css('float') !== 'none';
				var ignoredMargin = 0;
				var lastItemIndex = $items.length - 1;
				var lastItem;

				// Reset slideeSize
				slideeSize = 0;

				// Iterate through items
				$items.each(function (i, element) {
					// Item
					var $item = $(element);
					var rect = element.getBoundingClientRect();
					var itemSize = round(o.horizontal ? rect.width || rect.right - rect.left : rect.height || rect.bottom - rect.top);
					var itemMarginStart = getPx($item, o.horizontal ? 'marginLeft' : 'marginTop');
					var itemMarginEnd = getPx($item, o.horizontal ? 'marginRight' : 'marginBottom');
					var itemSizeFull = itemSize + itemMarginStart + itemMarginEnd;
					var singleSpaced = !itemMarginStart || !itemMarginEnd;
					var item = {};
					item.el = element;
					item.size = singleSpaced ? itemSize : itemSizeFull;
					item.half = item.size / 2;
					item.start = slideeSize + (singleSpaced ? itemMarginStart : 0);
					item.center = item.start - round(frameSize / 2 - item.size / 2);
					item.end = item.start - frameSize + item.size;

					// Account for slidee padding
					if (!i) {
						slideeSize += paddingStart;
					}

					// Increment slidee size for size of the active element
					slideeSize += itemSizeFull;

					// Try to account for vertical margin collapsing in vertical mode
					// It's not bulletproof, but should work in 99% of cases
					if (!o.horizontal && !areFloated) {
						// Subtract smaller margin, but only when top margin is not 0, and this is not the first element
						if (itemMarginEnd && itemMarginStart && i > 0) {
							slideeSize -= min(itemMarginStart, itemMarginEnd);
						}
					}

					// Things to be done on last item
					if (i === lastItemIndex) {
						item.end += paddingEnd;
						slideeSize += paddingEnd;
						ignoredMargin = singleSpaced ? itemMarginEnd : 0;
					}

					// Add item object to items array
					items.push(item);
					lastItem = item;
				});

				// Resize SLIDEE to fit all items
				$slidee[0].style[o.horizontal ? 'width' : 'height'] = (borderBox ? slideeSize: slideeSize - paddingStart - paddingEnd) + 'px';

				// Adjust internal SLIDEE size for last margin
				slideeSize -= ignoredMargin;

				// Set limits
				if (items.length) {
					pos.start =  items[0][forceCenteredNav ? 'center' : 'start'];
					pos.end = forceCenteredNav ? lastItem.center : frameSize < slideeSize ? lastItem.end : pos.start;
				} else {
					pos.start = pos.end = 0;
				}
			}

			// Calculate SLIDEE center position
			pos.center = round(pos.end / 2 + pos.start / 2);

			// Update relative positions
			updateRelatives();

			// Scrollbar
			if ($handle.length && sbSize > 0) {
				// Stretch scrollbar handle to represent the visible area
				if (o.dynamicHandle) {
					handleSize = pos.start === pos.end ? sbSize : round(sbSize * frameSize / slideeSize);
					handleSize = within(handleSize, o.minHandleSize, sbSize);
					$handle[0].style[o.horizontal ? 'width' : 'height'] = handleSize + 'px';
				} else {
					handleSize = $handle[o.horizontal ? 'outerWidth' : 'outerHeight']();
				}

				hPos.end = sbSize - handleSize;

				if (!renderID) {
					syncScrollbar();
				}
			}

			// Pages
			if (!parallax && frameSize > 0) {
				var tempPagePos = pos.start;
				var pagesHtml = '';

				// Populate pages array
				if (itemNav) {
					$.each(items, function (i, item) {
						if (forceCenteredNav) {
							pages.push(item.center);
						} else if (item.start + item.size > tempPagePos && tempPagePos <= pos.end) {
							tempPagePos = item.start;
							pages.push(tempPagePos);
							tempPagePos += frameSize;
							if (tempPagePos > pos.end && tempPagePos < pos.end + frameSize) {
								pages.push(pos.end);
							}
						}
					});
				} else {
					while (tempPagePos - frameSize < pos.end) {
						pages.push(tempPagePos);
						tempPagePos += frameSize;
					}
				}

				// Pages bar
				if ($pb[0] && lastPagesCount !== pages.length) {
					for (var i = 0; i < pages.length; i++) {
						pagesHtml += o.pageBuilder.call(self, i);
					}
					$pages = $pb.html(pagesHtml).children();
					$pages.eq(rel.activePage).addClass(o.activeClass);
				}
			}

			// Extend relative variables object with some useful info
			rel.slideeSize = slideeSize;
			rel.frameSize = frameSize;
			rel.sbSize = sbSize;
			rel.handleSize = handleSize;

			// Activate requested position
			if (itemNav) {
				if (isInit && o.startAt != null) {
					activate(o.startAt);
					self[centeredNav ? 'toCenter' : 'toStart'](o.startAt);
				}
				// Fix possible overflowing
				var activeItem = items[rel.activeItem];
				slideTo(centeredNav && activeItem ? activeItem.center : within(pos.dest, pos.start, pos.end));
			} else {
				if (isInit) {
					if (o.startAt != null) slideTo(o.startAt, 1);
				} else {
					// Fix possible overflowing
					slideTo(within(pos.dest, pos.start, pos.end));
				}
			}

			// Trigger load event
			trigger('load');
		}
		self.reload = function () { load(); };

		/**
		 * Animate to a position.
		 *
		 * @param {Int}  newPos    New position.
		 * @param {Bool} immediate Reposition immediately without an animation.
		 * @param {Bool} dontAlign Do not align items, use the raw position passed in first argument.
		 *
		 * @return {Void}
		 */
		function slideTo(newPos, immediate, dontAlign) {
			// Align items
			if (itemNav && dragging.released && !dontAlign) {
				var tempRel = getRelatives(newPos);
				var isNotBordering = newPos > pos.start && newPos < pos.end;

				if (centeredNav) {
					if (isNotBordering) {
						newPos = items[tempRel.centerItem].center;
					}
					if (forceCenteredNav && o.activateMiddle) {
						activate(tempRel.centerItem);
					}
				} else if (isNotBordering) {
					newPos = items[tempRel.firstItem].start;
				}
			}

			// Handle overflowing position limits
			if (dragging.init && dragging.slidee && o.elasticBounds) {
				if (newPos > pos.end) {
					newPos = pos.end + (newPos - pos.end) / 6;
				} else if (newPos < pos.start) {
					newPos = pos.start + (newPos - pos.start) / 6;
				}
			} else {
				newPos = within(newPos, pos.start, pos.end);
			}

			// Update the animation object
			animation.start = +new Date();
			animation.time = 0;
			animation.from = pos.cur;
			animation.to = newPos;
			animation.delta = newPos - pos.cur;
			animation.tweesing = dragging.tweese || dragging.init && !dragging.slidee;
			animation.immediate = !animation.tweesing && (immediate || dragging.init && dragging.slidee || !o.speed);

			// Reset dragging tweesing request
			dragging.tweese = 0;

			// Start animation rendering
			if (newPos !== pos.dest) {
				pos.dest = newPos;
				trigger('change');
				if (!renderID) {
					render();
				}
			}

			// Reset next cycle timeout
			resetCycle();

			// Synchronize states
			updateRelatives();
			updateButtonsState();
			syncPagesbar();
		}

		/**
		 * Render animation frame.
		 *
		 * @return {Void}
		 */
		function render() {
			if (!self.initialized) {
				return;
			}

			// If first render call, wait for next animationFrame
			if (!renderID) {
				renderID = rAF(render);
				if (dragging.released) {
					trigger('moveStart');
				}
				return;
			}

			// If immediate repositioning is requested, don't animate.
			if (animation.immediate) {
				pos.cur = animation.to;
			}
			// Use tweesing for animations without known end point
			else if (animation.tweesing) {
				animation.tweeseDelta = animation.to - pos.cur;
				// Fuck Zeno's paradox
				if (abs(animation.tweeseDelta) < 0.1) {
					pos.cur = animation.to;
				} else {
					pos.cur += animation.tweeseDelta * (dragging.released ? o.swingSpeed : o.syncSpeed);
				}
			}
			// Use tweening for basic animations with known end point
			else {
				animation.time = min(+new Date() - animation.start, o.speed);
				pos.cur = animation.from + animation.delta * $.easing[o.easing](animation.time/o.speed, animation.time, 0, 1, o.speed);
			}

			// If there is nothing more to render break the rendering loop, otherwise request new animation frame.
			if (animation.to === pos.cur) {
				pos.cur = animation.to;
				dragging.tweese = renderID = 0;
			} else {
				renderID = rAF(render);
			}

			trigger('move');

			// Update SLIDEE position
			if (!parallax) {
				if (transform) {
					$slidee[0].style[transform] = gpuAcceleration + (o.horizontal ? 'translateX' : 'translateY') + '(' + (-pos.cur) + 'px)';
				} else {
					$slidee[0].style[o.horizontal ? 'left' : 'top'] = -round(pos.cur) + 'px';
				}
			}

			// When animation reached the end, and dragging is not active, trigger moveEnd
			if (!renderID && dragging.released) {
				trigger('moveEnd');
			}

			syncScrollbar();
		}

		/**
		 * Synchronizes scrollbar with the SLIDEE.
		 *
		 * @return {Void}
		 */
		function syncScrollbar() {
			if ($handle.length) {
				hPos.cur = pos.start === pos.end ? 0 : (((dragging.init && !dragging.slidee) ? pos.dest : pos.cur) - pos.start) / (pos.end - pos.start) * hPos.end;
				hPos.cur = within(round(hPos.cur), hPos.start, hPos.end);
				if (last.hPos !== hPos.cur) {
					last.hPos = hPos.cur;
					if (transform) {
						$handle[0].style[transform] = gpuAcceleration + (o.horizontal ? 'translateX' : 'translateY') + '(' + hPos.cur + 'px)';
					} else {
						$handle[0].style[o.horizontal ? 'left' : 'top'] = hPos.cur + 'px';
					}
				}
			}
		}

		/**
		 * Synchronizes pagesbar with SLIDEE.
		 *
		 * @return {Void}
		 */
		function syncPagesbar() {
			if ($pages[0] && last.page !== rel.activePage) {
				last.page = rel.activePage;
				$pages.removeClass(o.activeClass).eq(rel.activePage).addClass(o.activeClass);
				trigger('activePage', last.page);
			}
		}

		/**
		 * Returns the position object.
		 *
		 * @param {Mixed} item
		 *
		 * @return {Object}
		 */
		self.getPos = function (item) {
			if (itemNav) {
				var index = getIndex(item);
				return index !== -1 ? items[index] : false;
			} else {
				var $item = $slidee.find(item).eq(0);

				if ($item[0]) {
					var offset = o.horizontal ? $item.offset().left - $slidee.offset().left : $item.offset().top - $slidee.offset().top;
					var size = $item[o.horizontal ? 'outerWidth' : 'outerHeight']();

					return {
						start: offset,
						center: offset - frameSize / 2 + size / 2,
						end: offset - frameSize + size,
						size: size
					};
				} else {
					return false;
				}
			}
		};

		/**
		 * Continuous move in a specified direction.
		 *
		 * @param  {Bool} forward True for forward movement, otherwise it'll go backwards.
		 * @param  {Int}  speed   Movement speed in pixels per frame. Overrides options.moveBy value.
		 *
		 * @return {Void}
		 */
		self.moveBy = function (speed) {
			move.speed = speed;
			// If already initiated, or there is nowhere to move, abort
			if (dragging.init || !move.speed || pos.cur === (move.speed > 0 ? pos.end : pos.start)) {
				return;
			}
			// Initiate move object
			move.lastTime = +new Date();
			move.startPos = pos.cur;
			// Set dragging as initiated
			continuousInit('button');
			dragging.init = 1;
			// Start movement
			trigger('moveStart');
			cAF(continuousID);
			moveLoop();
		};

		/**
		 * Continuous movement loop.
		 *
		 * @return {Void}
		 */
		function moveLoop() {
			// If there is nowhere to move anymore, stop
			if (!move.speed || pos.cur === (move.speed > 0 ? pos.end : pos.start)) {
				self.stop();
			}
			// Request new move loop if it hasn't been stopped
			continuousID = dragging.init ? rAF(moveLoop) : 0;
			// Update move object
			move.now = +new Date();
			move.pos = pos.cur + (move.now - move.lastTime) / 1000 * move.speed;
			// Slide
			slideTo(dragging.init ? move.pos : round(move.pos));
			// Normally, this is triggered in render(), but if there
			// is nothing to render, we have to do it manually here.
			if (!dragging.init && pos.cur === pos.dest) {
				trigger('moveEnd');
			}
			// Update times for future iteration
			move.lastTime = move.now;
		}

		/**
		 * Stops continuous movement.
		 *
		 * @return {Void}
		 */
		self.stop = function () {
			if (dragging.source === 'button') {
				dragging.init = 0;
				dragging.released = 1;
			}
		};

		/**
		 * Activate previous item.
		 *
		 * @return {Void}
		 */
		self.prev = function () {
			self.activate(rel.activeItem == null ? 0 : rel.activeItem - 1);
		};

		/**
		 * Activate next item.
		 *
		 * @return {Void}
		 */
		self.next = function () {
			self.activate(rel.activeItem == null ? 0 : rel.activeItem + 1);
		};

		/**
		 * Activate previous page.
		 *
		 * @return {Void}
		 */
		self.prevPage = function () {
			self.activatePage(rel.activePage - 1);
		};

		/**
		 * Activate next page.
		 *
		 * @return {Void}
		 */
		self.nextPage = function () {
			self.activatePage(rel.activePage + 1);
		};

		/**
		 * Slide SLIDEE by amount of pixels.
		 *
		 * @param {Int}  delta     Pixels/Items. Positive means forward, negative means backward.
		 * @param {Bool} immediate Reposition immediately without an animation.
		 *
		 * @return {Void}
		 */
		self.slideBy = function (delta, immediate) {
			if (!delta) {
				return;
			}
			if (itemNav) {
				self[centeredNav ? 'toCenter' : 'toStart'](
					within((centeredNav ? rel.centerItem : rel.firstItem) + o.scrollBy * delta, 0, items.length)
				);
			} else {
				slideTo(pos.dest + delta, immediate);
			}
		};

		/**
		 * Animate SLIDEE to a specific position.
		 *
		 * @param {Int}  pos       New position.
		 * @param {Bool} immediate Reposition immediately without an animation.
		 *
		 * @return {Void}
		 */
		self.slideTo = function (pos, immediate) {
			slideTo(pos, immediate);
		};

		/**
		 * Core method for handling `toLocation` methods.
		 *
		 * @param  {String} location
		 * @param  {Mixed}  item
		 * @param  {Bool}   immediate
		 *
		 * @return {Void}
		 */
		function to(location, item, immediate) {
			// Optional arguments logic
			if (type(item) === 'boolean') {
				immediate = item;
				item = undefined;
			}

			if (item === undefined) {
				slideTo(pos[location], immediate);
			} else {
				// You can't align items to sides of the frame
				// when centered navigation type is enabled
				if (centeredNav && location !== 'center') {
					return;
				}

				var itemPos = self.getPos(item);
				if (itemPos) {
					slideTo(itemPos[location], immediate, !centeredNav);
				}
			}
		}

		/**
		 * Animate element or the whole SLIDEE to the start of the frame.
		 *
		 * @param {Mixed} item      Item DOM element, or index starting at 0. Omitting will animate SLIDEE.
		 * @param {Bool}  immediate Reposition immediately without an animation.
		 *
		 * @return {Void}
		 */
		self.toStart = function (item, immediate) {
			to('start', item, immediate);
		};

		/**
		 * Animate element or the whole SLIDEE to the end of the frame.
		 *
		 * @param {Mixed} item      Item DOM element, or index starting at 0. Omitting will animate SLIDEE.
		 * @param {Bool}  immediate Reposition immediately without an animation.
		 *
		 * @return {Void}
		 */
		self.toEnd = function (item, immediate) {
			to('end', item, immediate);
		};

		/**
		 * Animate element or the whole SLIDEE to the center of the frame.
		 *
		 * @param {Mixed} item      Item DOM element, or index starting at 0. Omitting will animate SLIDEE.
		 * @param {Bool}  immediate Reposition immediately without an animation.
		 *
		 * @return {Void}
		 */
		self.toCenter = function (item, immediate) {
			to('center', item, immediate);
		};

		/**
		 * Get the index of an item in SLIDEE.
		 *
		 * @param {Mixed} item     Item DOM element.
		 *
		 * @return {Int}  Item index, or -1 if not found.
		 */
		function getIndex(item) {
			return item != null ?
					isNumber(item) ?
						item >= 0 && item < items.length ? item : -1 :
						$items.index(item) :
					-1;
		}
		// Expose getIndex without lowering the compressibility of it,
		// as it is used quite often throughout Sly.
		self.getIndex = getIndex;

		/**
		 * Get index of an item in SLIDEE based on a variety of input types.
		 *
		 * @param  {Mixed} item DOM element, positive or negative integer.
		 *
		 * @return {Int}   Item index, or -1 if not found.
		 */
		function getRelativeIndex(item) {
			return getIndex(isNumber(item) && item < 0 ? item + items.length : item);
		}

		/**
		 * Activates an item.
		 *
		 * @param  {Mixed} item Item DOM element, or index starting at 0.
		 *
		 * @return {Mixed} Activated item index or false on fail.
		 */
		function activate(item, force) {
			var index = getIndex(item);

			if (!itemNav || index < 0) {
				return false;
			}

			// Update classes, last active index, and trigger active event only when there
			// has been a change. Otherwise just return the current active index.
			if (last.active !== index || force) {
				// Update classes
				$items.eq(rel.activeItem).removeClass(o.activeClass);
				$items.eq(index).addClass(o.activeClass);

				last.active = rel.activeItem = index;

				updateButtonsState();
				trigger('active', index);
			}

			return index;
		}

		/**
		 * Activates an item and helps with further navigation when o.smart is enabled.
		 *
		 * @param {Mixed} item      Item DOM element, or index starting at 0.
		 * @param {Bool}  immediate Whether to reposition immediately in smart navigation.
		 *
		 * @return {Void}
		 */
		self.activate = function (item, immediate) {
			var index = activate(item);

			// Smart navigation
			if (o.smart && index !== false) {
				// When centeredNav is enabled, center the element.
				// Otherwise, determine where to position the element based on its current position.
				// If the element is currently on the far end side of the frame, assume that user is
				// moving forward and animate it to the start of the visible frame, and vice versa.
				if (centeredNav) {
					self.toCenter(index, immediate);
				} else if (index >= rel.lastItem) {
					self.toStart(index, immediate);
				} else if (index <= rel.firstItem) {
					self.toEnd(index, immediate);
				} else {
					resetCycle();
				}
			}
		};

		/**
		 * Activates a page.
		 *
		 * @param {Int}  index     Page index, starting from 0.
		 * @param {Bool} immediate Whether to reposition immediately without animation.
		 *
		 * @return {Void}
		 */
		self.activatePage = function (index, immediate) {
			if (isNumber(index)) {
				slideTo(pages[within(index, 0, pages.length - 1)], immediate);
			}
		};

		/**
		 * Return relative positions of items based on their visibility within FRAME.
		 *
		 * @param {Int} slideePos Position of SLIDEE.
		 *
		 * @return {Void}
		 */
		function getRelatives(slideePos) {
			slideePos = within(isNumber(slideePos) ? slideePos : pos.dest, pos.start, pos.end);

			var relatives = {};
			var centerOffset = forceCenteredNav ? 0 : frameSize / 2;

			// Determine active page
			if (!parallax) {
				for (var p = 0, pl = pages.length; p < pl; p++) {
					if (slideePos >= pos.end || p === pages.length - 1) {
						relatives.activePage = pages.length - 1;
						break;
					}

					if (slideePos <= pages[p] + centerOffset) {
						relatives.activePage = p;
						break;
					}
				}
			}

			// Relative item indexes
			if (itemNav) {
				var first = false;
				var last = false;
				var center = false;

				// From start
				for (var i = 0, il = items.length; i < il; i++) {
					// First item
					if (first === false && slideePos <= items[i].start + items[i].half) {
						first = i;
					}

					// Center item
					if (center === false && slideePos <= items[i].center + items[i].half) {
						center = i;
					}

					// Last item
					if (i === il - 1 || slideePos <= items[i].end + items[i].half) {
						last = i;
						break;
					}
				}

				// Safe assignment, just to be sure the false won't be returned
				relatives.firstItem = isNumber(first) ? first : 0;
				relatives.centerItem = isNumber(center) ? center : relatives.firstItem;
				relatives.lastItem = isNumber(last) ? last : relatives.centerItem;
			}

			return relatives;
		}

		/**
		 * Update object with relative positions.
		 *
		 * @param {Int} newPos
		 *
		 * @return {Void}
		 */
		function updateRelatives(newPos) {
			$.extend(rel, getRelatives(newPos));
		}

		/**
		 * Disable navigation buttons when needed.
		 *
		 * Adds disabledClass, and when the button is <button> or <input>, activates :disabled state.
		 *
		 * @return {Void}
		 */
		function updateButtonsState() {
			var isStart = pos.dest <= pos.start;
			var isEnd = pos.dest >= pos.end;
			var slideePosState = (isStart ? 1 : 0) | (isEnd ? 2 : 0);

			// Update paging buttons only if there has been a change in SLIDEE position
			if (last.slideePosState !== slideePosState) {
				last.slideePosState = slideePosState;

				if ($prevPageButton.is('button,input')) {
					$prevPageButton.prop('disabled', isStart);
				}

				if ($nextPageButton.is('button,input')) {
					$nextPageButton.prop('disabled', isEnd);
				}

				$prevPageButton.add($backwardButton)[isStart ? 'addClass' : 'removeClass'](o.disabledClass);
				$nextPageButton.add($forwardButton)[isEnd ? 'addClass' : 'removeClass'](o.disabledClass);
			}

			// Forward & Backward buttons need a separate state caching because we cannot "property disable"
			// them while they are being used, as disabled buttons stop emitting mouse events.
			if (last.fwdbwdState !== slideePosState && dragging.released) {
				last.fwdbwdState = slideePosState;

				if ($backwardButton.is('button,input')) {
					$backwardButton.prop('disabled', isStart);
				}

				if ($forwardButton.is('button,input')) {
					$forwardButton.prop('disabled', isEnd);
				}
			}

			// Item navigation
			if (itemNav && rel.activeItem != null) {
				var isFirst = rel.activeItem === 0;
				var isLast = rel.activeItem >= items.length - 1;
				var itemsButtonState = (isFirst ? 1 : 0) | (isLast ? 2 : 0);

				if (last.itemsButtonState !== itemsButtonState) {
					last.itemsButtonState = itemsButtonState;

					if ($prevButton.is('button,input')) {
						$prevButton.prop('disabled', isFirst);
					}

					if ($nextButton.is('button,input')) {
						$nextButton.prop('disabled', isLast);
					}

					$prevButton[isFirst ? 'addClass' : 'removeClass'](o.disabledClass);
					$nextButton[isLast ? 'addClass' : 'removeClass'](o.disabledClass);
				}
			}
		}

		/**
		 * Resume cycling.
		 *
		 * @param {Int} priority Resume pause with priority lower or equal than this. Used internally for pauseOnHover.
		 *
		 * @return {Void}
		 */
		self.resume = function (priority) {
			if (!o.cycleBy || !o.cycleInterval || o.cycleBy === 'items' && (!items[0] || rel.activeItem == null) || priority < self.isPaused) {
				return;
			}

			self.isPaused = 0;

			if (cycleID) {
				cycleID = clearTimeout(cycleID);
			} else {
				trigger('resume');
			}

			cycleID = setTimeout(function () {
				trigger('cycle');
				switch (o.cycleBy) {
					case 'items':
						self.activate(rel.activeItem >= items.length - 1 ? 0 : rel.activeItem + 1);
						break;

					case 'pages':
						self.activatePage(rel.activePage >= pages.length - 1 ? 0 : rel.activePage + 1);
						break;
				}
			}, o.cycleInterval);
		};

		/**
		 * Pause cycling.
		 *
		 * @param {Int} priority Pause priority. 100 is default. Used internally for pauseOnHover.
		 *
		 * @return {Void}
		 */
		self.pause = function (priority) {
			if (priority < self.isPaused) {
				return;
			}

			self.isPaused = priority || 100;

			if (cycleID) {
				cycleID = clearTimeout(cycleID);
				trigger('pause');
			}
		};

		/**
		 * Toggle cycling.
		 *
		 * @return {Void}
		 */
		self.toggle = function () {
			self[cycleID ? 'pause' : 'resume']();
		};

		/**
		 * Updates a signle or multiple option values.
		 *
		 * @param {Mixed} name  Name of the option that should be updated, or object that will extend the options.
		 * @param {Mixed} value New option value.
		 *
		 * @return {Void}
		 */
		self.set = function (name, value) {
			if ($.isPlainObject(name)) {
				$.extend(o, name);
			} else if (o.hasOwnProperty(name)) {
				o[name] = value;
			}
		};

		/**
		 * Add one or multiple items to the SLIDEE end, or a specified position index.
		 *
		 * @param {Mixed} element Node element, or HTML string.
		 * @param {Int}   index   Index of a new item position. By default item is appended at the end.
		 *
		 * @return {Void}
		 */
		self.add = function (element, index) {
			var $element = $(element);

			if (itemNav) {
				// Insert the element(s)
				if (index == null || !items[0] || index >= items.length) {
					$element.appendTo($slidee);
				} else if (items.length) {
					$element.insertBefore(items[index].el);
				}

				// Adjust the activeItem index
				if (rel.activeItem != null && index <= rel.activeItem) {
					last.active = rel.activeItem += $element.length;
				}
			} else {
				$slidee.append($element);
			}

			// Reload
			load();
		};

		/**
		 * Remove an item from SLIDEE.
		 *
		 * @param {Mixed} element Item index, or DOM element.
		 * @param {Int}   index   Index of a new item position. By default item is appended at the end.
		 *
		 * @return {Void}
		 */
		self.remove = function (element) {
			if (itemNav) {
				var index = getRelativeIndex(element);

				if (index > -1) {
					// Remove the element
					$items.eq(index).remove();

					// If the current item is being removed, activate new one after reload
					var reactivate = index === rel.activeItem;

					// Adjust the activeItem index
					if (rel.activeItem != null && index < rel.activeItem) {
						last.active = --rel.activeItem;
					}

					// Reload
					load();

					// Activate new item at the removed position
					if (reactivate) {
						last.active = null;
						self.activate(rel.activeItem);
					}
				}
			} else {
				$(element).remove();
				load();
			}
		};

		/**
		 * Helps re-arranging items.
		 *
		 * @param  {Mixed} item     Item DOM element, or index starting at 0. Use negative numbers to select items from the end.
		 * @param  {Mixed} position Item insertion anchor. Accepts same input types as item argument.
		 * @param  {Bool}  after    Insert after instead of before the anchor.
		 *
		 * @return {Void}
		 */
		function moveItem(item, position, after) {
			item = getRelativeIndex(item);
			position = getRelativeIndex(position);

			// Move only if there is an actual change requested
			if (item > -1 && position > -1 && item !== position && (!after || position !== item - 1) && (after || position !== item + 1)) {
				$items.eq(item)[after ? 'insertAfter' : 'insertBefore'](items[position].el);

				var shiftStart = item < position ? item : (after ? position : position - 1);
				var shiftEnd = item > position ? item : (after ? position + 1 : position);
				var shiftsUp = item > position;

				// Update activeItem index
				if (rel.activeItem != null) {
					if (item === rel.activeItem) {
						last.active = rel.activeItem = after ? (shiftsUp ? position + 1 : position) : (shiftsUp ? position : position - 1);
					} else if (rel.activeItem > shiftStart && rel.activeItem < shiftEnd) {
						last.active = rel.activeItem += shiftsUp ? 1 : -1;
					}
				}

				// Reload
				load();
			}
		}

		/**
		 * Move item after the target anchor.
		 *
		 * @param  {Mixed} item     Item to be moved. Can be DOM element or item index.
		 * @param  {Mixed} position Target position anchor. Can be DOM element or item index.
		 *
		 * @return {Void}
		 */
		self.moveAfter = function (item, position) {
			moveItem(item, position, 1);
		};

		/**
		 * Move item before the target anchor.
		 *
		 * @param  {Mixed} item     Item to be moved. Can be DOM element or item index.
		 * @param  {Mixed} position Target position anchor. Can be DOM element or item index.
		 *
		 * @return {Void}
		 */
		self.moveBefore = function (item, position) {
			moveItem(item, position);
		};

		/**
		 * Registers callbacks.
		 *
		 * @param  {Mixed} name  Event name, or callbacks map.
		 * @param  {Mixed} fn    Callback, or an array of callback functions.
		 *
		 * @return {Void}
		 */
		self.on = function (name, fn) {
			// Callbacks map
			if (type(name) === 'object') {
				for (var key in name) {
					if (name.hasOwnProperty(key)) {
						self.on(key, name[key]);
					}
				}
			// Callback
			} else if (type(fn) === 'function') {
				var names = name.split(' ');
				for (var n = 0, nl = names.length; n < nl; n++) {
					callbacks[names[n]] = callbacks[names[n]] || [];
					if (callbackIndex(names[n], fn) === -1) {
						callbacks[names[n]].push(fn);
					}
				}
			// Callbacks array
			} else if (type(fn) === 'array') {
				for (var f = 0, fl = fn.length; f < fl; f++) {
					self.on(name, fn[f]);
				}
			}
		};

		/**
		 * Registers callbacks to be executed only once.
		 *
		 * @param  {Mixed} name  Event name, or callbacks map.
		 * @param  {Mixed} fn    Callback, or an array of callback functions.
		 *
		 * @return {Void}
		 */
		self.one = function (name, fn) {
			function proxy() {
				fn.apply(self, arguments);
				self.off(name, proxy);
			}
			self.on(name, proxy);
		};

		/**
		 * Remove one or all callbacks.
		 *
		 * @param  {String} name Event name.
		 * @param  {Mixed}  fn   Callback, or an array of callback functions. Omit to remove all callbacks.
		 *
		 * @return {Void}
		 */
		self.off = function (name, fn) {
			if (fn instanceof Array) {
				for (var f = 0, fl = fn.length; f < fl; f++) {
					self.off(name, fn[f]);
				}
			} else {
				var names = name.split(' ');
				for (var n = 0, nl = names.length; n < nl; n++) {
					callbacks[names[n]] = callbacks[names[n]] || [];
					if (fn == null) {
						callbacks[names[n]].length = 0;
					} else {
						var index = callbackIndex(names[n], fn);
						if (index !== -1) {
							callbacks[names[n]].splice(index, 1);
						}
					}
				}
			}
		};

		/**
		 * Returns callback array index.
		 *
		 * @param  {String}   name Event name.
		 * @param  {Function} fn   Function
		 *
		 * @return {Int} Callback array index, or -1 if isn't registered.
		 */
		function callbackIndex(name, fn) {
			for (var i = 0, l = callbacks[name].length; i < l; i++) {
				if (callbacks[name][i] === fn) {
					return i;
				}
			}
			return -1;
		}

		/**
		 * Reset next cycle timeout.
		 *
		 * @return {Void}
		 */
		function resetCycle() {
			if (dragging.released && !self.isPaused) {
				self.resume();
			}
		}

		/**
		 * Calculate SLIDEE representation of handle position.
		 *
		 * @param  {Int} handlePos
		 *
		 * @return {Int}
		 */
		function handleToSlidee(handlePos) {
			return round(within(handlePos, hPos.start, hPos.end) / hPos.end * (pos.end - pos.start)) + pos.start;
		}

		/**
		 * Keeps track of a dragging delta history.
		 *
		 * @return {Void}
		 */
		function draggingHistoryTick() {
			// Looking at this, I know what you're thinking :) But as we need only 4 history states, doing it this way
			// as opposed to a proper loop is ~25 bytes smaller (when minified with GCC), a lot faster, and doesn't
			// generate garbage. The loop version would create 2 new variables on every tick. Unexaptable!
			dragging.history[0] = dragging.history[1];
			dragging.history[1] = dragging.history[2];
			dragging.history[2] = dragging.history[3];
			dragging.history[3] = dragging.delta;
		}

		/**
		 * Initialize continuous movement.
		 *
		 * @return {Void}
		 */
		function continuousInit(source) {
			dragging.released = 0;
			dragging.source = source;
			dragging.slidee = source === 'slidee';
		}

		/**
		 * Dragging initiator.
		 *
		 * @param  {Event} event
		 *
		 * @return {Void}
		 */
		function dragInit(event) {
			var isTouch = event.type === 'touchstart';
			var source = event.data.source;
			var isSlidee = source === 'slidee';

			// Ignore when already in progress, or interactive element in non-touch navivagion
			if (dragging.init || !isTouch && isInteractive(event.target)) {
				return;
			}

			// Handle dragging conditions
			if (source === 'handle' && (!o.dragHandle || hPos.start === hPos.end)) {
				return;
			}

			// SLIDEE dragging conditions
			if (isSlidee && !(isTouch ? o.touchDragging : o.mouseDragging && event.which < 2)) {
				return;
			}

			if (!isTouch) {
				// prevents native image dragging in Firefox
				stopDefault(event);
			}

			// Reset dragging object
			continuousInit(source);

			// Properties used in dragHandler
			dragging.init = 0;
			dragging.$source = $(event.target);
			dragging.touch = isTouch;
			dragging.pointer = isTouch ? event.originalEvent.touches[0] : event;
			dragging.initX = dragging.pointer.pageX;
			dragging.initY = dragging.pointer.pageY;
			dragging.initPos = isSlidee ? pos.cur : hPos.cur;
			dragging.start = +new Date();
			dragging.time = 0;
			dragging.path = 0;
			dragging.delta = 0;
			dragging.locked = 0;
			dragging.history = [0, 0, 0, 0];
			dragging.pathToLock = isSlidee ? isTouch ? 30 : 10 : 0;

			// Bind dragging events
			$doc.on(isTouch ? dragTouchEvents : dragMouseEvents, dragHandler);

			// Pause ongoing cycle
			self.pause(1);

			// Add dragging class
			(isSlidee ? $slidee : $handle).addClass(o.draggedClass);

			// Trigger moveStart event
			trigger('moveStart');

			// Keep track of a dragging path history. This is later used in the
			// dragging release swing calculation when dragging SLIDEE.
			if (isSlidee) {
				historyID = setInterval(draggingHistoryTick, 10);
			}
		}

		/**
		 * Handler for dragging scrollbar handle or SLIDEE.
		 *
		 * @param  {Event} event
		 *
		 * @return {Void}
		 */
		function dragHandler(event) {
			dragging.released = event.type === 'mouseup' || event.type === 'touchend';
			dragging.pointer = dragging.touch ? event.originalEvent[dragging.released ? 'changedTouches' : 'touches'][0] : event;
			dragging.pathX = dragging.pointer.pageX - dragging.initX;
			dragging.pathY = dragging.pointer.pageY - dragging.initY;
			dragging.path = sqrt(pow(dragging.pathX, 2) + pow(dragging.pathY, 2));
			dragging.delta = o.horizontal ? dragging.pathX : dragging.pathY;

			if (!dragging.released && dragging.path < 1) return;

			// We haven't decided whether this is a drag or not...
			if (!dragging.init) {
				// If the drag path was very short, maybe it's not a drag?
				if (dragging.path < o.dragThreshold) {
					// If the pointer was released, the path will not become longer and it's
					// definitely not a drag. If not released yet, decide on next iteration
					return dragging.released ? dragEnd() : undefined;
				}
				else {
					// If dragging path is sufficiently long we can confidently start a drag
					// if drag is in different direction than scroll, ignore it
					if (o.horizontal ? abs(dragging.pathX) > abs(dragging.pathY) : abs(dragging.pathX) < abs(dragging.pathY)) {
						dragging.init = 1;
					} else {
						return dragEnd();
					}
				}
			}

			stopDefault(event);

			// Disable click on a source element, as it is unwelcome when dragging
			if (!dragging.locked && dragging.path > dragging.pathToLock && dragging.slidee) {
				dragging.locked = 1;
				dragging.$source.on(clickEvent, disableOneEvent);
			}

			// Cancel dragging on release
			if (dragging.released) {
				dragEnd();

				// Adjust path with a swing on mouse release
				if (o.releaseSwing && dragging.slidee) {
					dragging.swing = (dragging.delta - dragging.history[0]) / 40 * 300;
					dragging.delta += dragging.swing;
					dragging.tweese = abs(dragging.swing) > 10;
				}
			}

			slideTo(dragging.slidee ? round(dragging.initPos - dragging.delta) : handleToSlidee(dragging.initPos + dragging.delta));
		}

		/**
		 * Stops dragging and cleans up after it.
		 *
		 * @return {Void}
		 */
		function dragEnd() {
			clearInterval(historyID);
			dragging.released = true;
			$doc.off(dragging.touch ? dragTouchEvents : dragMouseEvents, dragHandler);
			(dragging.slidee ? $slidee : $handle).removeClass(o.draggedClass);

			// Make sure that disableOneEvent is not active in next tick.
			setTimeout(function () {
				dragging.$source.off(clickEvent, disableOneEvent);
			});

			// Normally, this is triggered in render(), but if there
			// is nothing to render, we have to do it manually here.
			if (pos.cur === pos.dest && dragging.init) {
				trigger('moveEnd');
			}

			// Resume ongoing cycle
			self.resume(1);

			dragging.init = 0;
		}

		/**
		 * Check whether element is interactive.
		 *
		 * @return {Boolean}
		 */
		function isInteractive(element) {
			return ~$.inArray(element.nodeName, interactiveElements) || $(element).is(o.interactive);
		}

		/**
		 * Continuous movement cleanup on mouseup.
		 *
		 * @return {Void}
		 */
		function movementReleaseHandler() {
			self.stop();
			$doc.off('mouseup', movementReleaseHandler);
		}

		/**
		 * Buttons navigation handler.
		 *
		 * @param  {Event} event
		 *
		 * @return {Void}
		 */
		function buttonsHandler(event) {
			/*jshint validthis:true */
			stopDefault(event);
			switch (this) {
				case $forwardButton[0]:
				case $backwardButton[0]:
					self.moveBy($forwardButton.is(this) ? o.moveBy : -o.moveBy);
					$doc.on('mouseup', movementReleaseHandler);
					break;

				case $prevButton[0]:
					self.prev();
					break;

				case $nextButton[0]:
					self.next();
					break;

				case $prevPageButton[0]:
					self.prevPage();
					break;

				case $nextPageButton[0]:
					self.nextPage();
					break;
			}
		}

		/**
		 * Mouse wheel delta normalization.
		 *
		 * @param  {Event} event
		 *
		 * @return {Int}
		 */
		function normalizeWheelDelta(event) {
			// wheelDelta needed only for IE8-
			scrolling.curDelta = ((o.horizontal ? event.deltaY || event.deltaX : event.deltaY) || -event.wheelDelta);
			scrolling.curDelta /= event.deltaMode === 1 ? 3 : 100;
			if (!itemNav) {
				return scrolling.curDelta;
			}
			time = +new Date();
			if (scrolling.last < time - scrolling.resetTime) {
				scrolling.delta = 0;
			}
			scrolling.last = time;
			scrolling.delta += scrolling.curDelta;
			if (abs(scrolling.delta) < 1) {
				scrolling.finalDelta = 0;
			} else {
				scrolling.finalDelta = round(scrolling.delta / 1);
				scrolling.delta %= 1;
			}
			return scrolling.finalDelta;
		}

		/**
		 * Mouse scrolling handler.
		 *
		 * @param  {Event} event
		 *
		 * @return {Void}
		 */
		function scrollHandler(event) {
			// Mark event as originating in a Sly instance
			event.originalEvent[namespace] = self;
			// Don't hijack global scrolling
			var time = +new Date();
			if (lastGlobalWheel + o.scrollHijack > time && $scrollSource[0] !== document && $scrollSource[0] !== window) {
				lastGlobalWheel = time;
				return;
			}
			// Ignore if there is no scrolling to be done
			if (!o.scrollBy || pos.start === pos.end) {
				return;
			}
			var delta = normalizeWheelDelta(event.originalEvent);
			// Trap scrolling only when necessary and/or requested
			if (o.scrollTrap || delta > 0 && pos.dest < pos.end || delta < 0 && pos.dest > pos.start) {
				stopDefault(event, 1);
			}
			self.slideBy(o.scrollBy * delta);
		}

		/**
		 * Scrollbar click handler.
		 *
		 * @param  {Event} event
		 *
		 * @return {Void}
		 */
		function scrollbarHandler(event) {
			// Only clicks on scroll bar. Ignore the handle.
			if (o.clickBar && event.target === $sb[0]) {
				stopDefault(event);
				// Calculate new handle position and sync SLIDEE to it
				slideTo(handleToSlidee((o.horizontal ? event.pageX - $sb.offset().left : event.pageY - $sb.offset().top) - handleSize / 2));
			}
		}

		/**
		 * Keyboard input handler.
		 *
		 * @param  {Event} event
		 *
		 * @return {Void}
		 */
		function keyboardHandler(event) {
			if (!o.keyboardNavBy) {
				return;
			}

			switch (event.which) {
				// Left or Up
				case o.horizontal ? 37 : 38:
					stopDefault(event);
					self[o.keyboardNavBy === 'pages' ? 'prevPage' : 'prev']();
					break;

				// Right or Down
				case o.horizontal ? 39 : 40:
					stopDefault(event);
					self[o.keyboardNavBy === 'pages' ? 'nextPage' : 'next']();
					break;
			}
		}

		/**
		 * Click on item activation handler.
		 *
		 * @param  {Event} event
		 *
		 * @return {Void}
		 */
		function activateHandler(event) {
			/*jshint validthis:true */

			// Ignore clicks on interactive elements.
			if (isInteractive(this)) {
				event.originalEvent[namespace + 'ignore'] = true;
				return;
			}

			// Ignore events that:
			// - are not originating from direct SLIDEE children
			// - originated from interactive elements
			if (this.parentNode !== $slidee[0] || event.originalEvent[namespace + 'ignore']) return;

			self.activate(this);
		}

		/**
		 * Click on page button handler.
		 *
		 * @param {Event} event
		 *
		 * @return {Void}
		 */
		function activatePageHandler() {
			/*jshint validthis:true */
			// Accept only events from direct pages bar children.
			if (this.parentNode === $pb[0]) {
				self.activatePage($pages.index(this));
			}
		}

		/**
		 * Pause on hover handler.
		 *
		 * @param  {Event} event
		 *
		 * @return {Void}
		 */
		function pauseOnHoverHandler(event) {
			if (o.pauseOnHover) {
				self[event.type === 'mouseenter' ? 'pause' : 'resume'](2);
			}
		}

		/**
		 * Trigger callbacks for event.
		 *
		 * @param  {String} name Event name.
		 * @param  {Mixed}  argX Arguments passed to callbacks.
		 *
		 * @return {Void}
		 */
		function trigger(name, arg1) {
			if (callbacks[name]) {
				l = callbacks[name].length;
				// Callbacks will be stored and executed from a temporary array to not
				// break the execution queue when one of the callbacks unbinds itself.
				tmpArray.length = 0;
				for (i = 0; i < l; i++) {
					tmpArray.push(callbacks[name][i]);
				}
				// Execute the callbacks
				for (i = 0; i < l; i++) {
					tmpArray[i].call(self, name, arg1);
				}
			}
		}

		/**
		 * Destroys instance and everything it created.
		 *
		 * @return {Void}
		 */
		self.destroy = function () {
			// Remove the reference to itself
			Sly.removeInstance(frame);

			// Unbind all events
			$scrollSource
				.add($handle)
				.add($sb)
				.add($pb)
				.add($forwardButton)
				.add($backwardButton)
				.add($prevButton)
				.add($nextButton)
				.add($prevPageButton)
				.add($nextPageButton)
				.off('.' + namespace);

			// Unbinding specifically as to not nuke out other instances
			$doc.off('keydown', keyboardHandler);

			// Remove classes
			$prevButton
				.add($nextButton)
				.add($prevPageButton)
				.add($nextPageButton)
				.removeClass(o.disabledClass);

			if ($items && rel.activeItem != null) {
				$items.eq(rel.activeItem).removeClass(o.activeClass);
			}

			// Remove page items
			$pb.empty();

			if (!parallax) {
				// Unbind events from frame
				$frame.off('.' + namespace);
				// Restore original styles
				frameStyles.restore();
				slideeStyles.restore();
				sbStyles.restore();
				handleStyles.restore();
				// Remove the instance from element data storage
				$.removeData(frame, namespace);
			}

			// Clean up collections
			items.length = pages.length = 0;
			last = {};

			// Reset initialized status and return the instance
			self.initialized = 0;
			return self;
		};

		/**
		 * Initialize.
		 *
		 * @return {Object}
		 */
		self.init = function () {
			if (self.initialized) {
				return;
			}

			// Disallow multiple instances on the same element
			if (Sly.getInstance(frame)) throw new Error('There is already a Sly instance on this element');

			// Store the reference to itself
			Sly.storeInstance(frame, self);

			// Register callbacks map
			self.on(callbackMap);

			// Save styles
			var holderProps = ['overflow', 'position'];
			var movableProps = ['position', 'webkitTransform', 'msTransform', 'transform', 'left', 'top', 'width', 'height'];
			frameStyles.save.apply(frameStyles, holderProps);
			sbStyles.save.apply(sbStyles, holderProps);
			slideeStyles.save.apply(slideeStyles, movableProps);
			handleStyles.save.apply(handleStyles, movableProps);

			// Set required styles
			var $movables = $handle;
			if (!parallax) {
				$movables = $movables.add($slidee);
				$frame.css('overflow', 'hidden');
				if (!transform && $frame.css('position') === 'static') {
					$frame.css('position', 'relative');
				}
			}
			if (transform) {
				if (gpuAcceleration) {
					$movables.css(transform, gpuAcceleration);
				}
			} else {
				if ($sb.css('position') === 'static') {
					$sb.css('position', 'relative');
				}
				$movables.css({ position: 'absolute' });
			}

			// Navigation buttons
			if (o.forward) {
				$forwardButton.on(mouseDownEvent, buttonsHandler);
			}
			if (o.backward) {
				$backwardButton.on(mouseDownEvent, buttonsHandler);
			}
			if (o.prev) {
				$prevButton.on(clickEvent, buttonsHandler);
			}
			if (o.next) {
				$nextButton.on(clickEvent, buttonsHandler);
			}
			if (o.prevPage) {
				$prevPageButton.on(clickEvent, buttonsHandler);
			}
			if (o.nextPage) {
				$nextPageButton.on(clickEvent, buttonsHandler);
			}

			// Scrolling navigation
			$scrollSource.on(wheelEvent, scrollHandler);

			// Clicking on scrollbar navigation
			if ($sb[0]) {
				$sb.on(clickEvent, scrollbarHandler);
			}

			// Click on items navigation
			if (itemNav && o.activateOn) {
				$frame.on(o.activateOn + '.' + namespace, '*', activateHandler);
			}

			// Pages navigation
			if ($pb[0] && o.activatePageOn) {
				$pb.on(o.activatePageOn + '.' + namespace, '*', activatePageHandler);
			}

			// Dragging navigation
			$dragSource.on(dragInitEvents, { source: 'slidee' }, dragInit);

			// Scrollbar dragging navigation
			if ($handle) {
				$handle.on(dragInitEvents, { source: 'handle' }, dragInit);
			}

			// Keyboard navigation
			$doc.on('keydown', keyboardHandler);

			if (!parallax) {
				// Pause on hover
				$frame.on('mouseenter.' + namespace + ' mouseleave.' + namespace, pauseOnHoverHandler);
				// Reset native FRAME element scroll
				$frame.on('scroll.' + namespace, resetScroll);
			}

			// Mark instance as initialized
			self.initialized = 1;

			// Load
			load(true);

			// Initiate automatic cycling
			if (o.cycleBy && !parallax) {
				self[o.startPaused ? 'pause' : 'resume']();
			}

			// Return instance
			return self;
		};
	}

	Sly.getInstance = function (element) {
		return $.data(element, namespace);
	};

	Sly.storeInstance = function (element, sly) {
		return $.data(element, namespace, sly);
	};

	Sly.removeInstance = function (element) {
		return $.removeData(element, namespace);
	};

	/**
	 * Return type of the value.
	 *
	 * @param  {Mixed} value
	 *
	 * @return {String}
	 */
	function type(value) {
		if (value == null) {
			return String(value);
		}

		if (typeof value === 'object' || typeof value === 'function') {
			return Object.prototype.toString.call(value).match(/\s([a-z]+)/i)[1].toLowerCase() || 'object';
		}

		return typeof value;
	}

	/**
	 * Event preventDefault & stopPropagation helper.
	 *
	 * @param {Event} event     Event object.
	 * @param {Bool}  noBubbles Cancel event bubbling.
	 *
	 * @return {Void}
	 */
	function stopDefault(event, noBubbles) {

		// HACK: Stop the annoying console error #1203
		return;
		event.preventDefault();
		if (noBubbles) {
			event.stopPropagation();
		}
	}

	/**
	 * Disables an event it was triggered on and unbinds itself.
	 *
	 * @param  {Event} event
	 *
	 * @return {Void}
	 */
	function disableOneEvent(event) {
		/*jshint validthis:true */
		stopDefault(event, 1);
		$(this).off(event.type, disableOneEvent);
	}

	/**
	 * Resets native element scroll values to 0.
	 *
	 * @return {Void}
	 */
	function resetScroll() {
		/*jshint validthis:true */
		this.scrollLeft = 0;
		this.scrollTop = 0;
	}

	/**
	 * Check if variable is a number.
	 *
	 * @param {Mixed} value
	 *
	 * @return {Boolean}
	 */
	function isNumber(value) {
		return !isNaN(parseFloat(value)) && isFinite(value);
	}

	/**
	 * Parse style to pixels.
	 *
	 * @param {Object}   $item    jQuery object with element.
	 * @param {Property} property CSS property to get the pixels from.
	 *
	 * @return {Int}
	 */
	function getPx($item, property) {
		return 0 | round(String($item.css(property)).replace(/[^\-0-9.]/g, ''));
	}

	/**
	 * Make sure that number is within the limits.
	 *
	 * @param {Number} number
	 * @param {Number} min
	 * @param {Number} max
	 *
	 * @return {Number}
	 */
	function within(number, min, max) {
		return number < min ? min : number > max ? max : number;
	}

	/**
	 * Saves element styles for later restoration.
	 *
	 * Example:
	 *   var styles = new StyleRestorer(frame);
	 *   styles.save('position');
	 *   element.style.position = 'absolute';
	 *   styles.restore(); // restores to state before the assignment above
	 *
	 * @param {Element} element
	 */
	function StyleRestorer(element) {
		var self = {};
		self.style = {};
		self.save = function () {
			if (!element || !element.nodeType) return;
			for (var i = 0; i < arguments.length; i++) {
				self.style[arguments[i]] = element.style[arguments[i]];
			}
			return self;
		};
		self.restore = function () {
			if (!element || !element.nodeType) return;
			for (var prop in self.style) {
				if (self.style.hasOwnProperty(prop)) element.style[prop] = self.style[prop];
			}
			return self;
		};
		return self;
	}

	// Local WindowAnimationTiming interface polyfill
	(function (w) {
		rAF = w.requestAnimationFrame
			|| w.webkitRequestAnimationFrame
			|| fallback;

		/**
		* Fallback implementation.
		*/
		var prev = new Date().getTime();
		function fallback(fn) {
			var curr = new Date().getTime();
			var ms = Math.max(0, 16 - (curr - prev));
			var req = setTimeout(fn, ms);
			prev = curr;
			return req;
		}

		/**
		* Cancel.
		*/
		var cancel = w.cancelAnimationFrame
			|| w.webkitCancelAnimationFrame
			|| w.clearTimeout;

		cAF = function(id){
			cancel.call(w, id);
		};
	}(window));

	// Feature detects
	(function () {
		var prefixes = ['', 'Webkit', 'Moz', 'ms', 'O'];
		var el = document.createElement('div');

		function testProp(prop) {
			for (var p = 0, pl = prefixes.length; p < pl; p++) {
				var prefixedProp = prefixes[p] ? prefixes[p] + prop.charAt(0).toUpperCase() + prop.slice(1) : prop;
				if (el.style[prefixedProp] != null) {
					return prefixedProp;
				}
			}
		}

		// Global support indicators
		transform = testProp('transform');
		gpuAcceleration = testProp('perspective') ? 'translateZ(0) ' : '';
	}());

	// Expose class globally
	w[className] = Sly;

	// jQuery proxy
	$.fn[pluginName] = function (options, callbackMap) {
		var method, methodArgs;

		// Attributes logic
		if (!$.isPlainObject(options)) {
			if (type(options) === 'string' || options === false) {
				method = options === false ? 'destroy' : options;
				methodArgs = Array.prototype.slice.call(arguments, 1);
			}
			options = {};
		}

		// Apply to all elements
		return this.each(function (i, element) {
			// Call with prevention against multiple instantiations
			var plugin = Sly.getInstance(element);

			if (!plugin && !method) {
				// Create a new object if it doesn't exist yet
				plugin = new Sly(element, options, callbackMap).init();
			} else if (plugin && method) {
				// Call method
				if (plugin[method]) {
					plugin[method].apply(plugin, methodArgs);
				}
			}
		});
	};

	// Default options
	Sly.defaults = {
		slidee:     null,  // Selector, DOM element, or jQuery object with DOM element representing SLIDEE.
		horizontal: false, // Switch to horizontal mode.

		// Item based navigation
		itemNav:        null,  // Item navigation type. Can be: 'basic', 'centered', 'forceCentered'.
		itemSelector:   null,  // Select only items that match this selector.
		smart:          false, // Repositions the activated item to help with further navigation.
		activateOn:     null,  // Activate an item on this event. Can be: 'click', 'mouseenter', ...
		activateMiddle: false, // Always activate the item in the middle of the FRAME. forceCentered only.

		// Scrolling
		scrollSource: null,  // Element for catching the mouse wheel scrolling. Default is FRAME.
		scrollBy:     0,     // Pixels or items to move per one mouse scroll. 0 to disable scrolling.
		scrollHijack: 300,   // Milliseconds since last wheel event after which it is acceptable to hijack global scroll.
		scrollTrap:   false, // Don't bubble scrolling when hitting scrolling limits.

		// Dragging
		dragSource:    null,  // Selector or DOM element for catching dragging events. Default is FRAME.
		mouseDragging: false, // Enable navigation by dragging the SLIDEE with mouse cursor.
		touchDragging: false, // Enable navigation by dragging the SLIDEE with touch events.
		releaseSwing:  false, // Ease out on dragging swing release.
		swingSpeed:    0.2,   // Swing synchronization speed, where: 1 = instant, 0 = infinite.
		elasticBounds: false, // Stretch SLIDEE position limits when dragging past FRAME boundaries.
		dragThreshold: 3,     // Distance in pixels before Sly recognizes dragging.
		interactive:   null,  // Selector for special interactive elements.

		// Scrollbar
		scrollBar:     null,  // Selector or DOM element for scrollbar container.
		dragHandle:    false, // Whether the scrollbar handle should be draggable.
		dynamicHandle: false, // Scrollbar handle represents the ratio between hidden and visible content.
		minHandleSize: 50,    // Minimal height or width (depends on sly direction) of a handle in pixels.
		clickBar:      false, // Enable navigation by clicking on scrollbar.
		syncSpeed:     0.5,   // Handle => SLIDEE synchronization speed, where: 1 = instant, 0 = infinite.

		// Pagesbar
		pagesBar:       null, // Selector or DOM element for pages bar container.
		activatePageOn: null, // Event used to activate page. Can be: click, mouseenter, ...
		pageBuilder:          // Page item generator.
			function (index) {
				return '<li>' + (index + 1) + '</li>';
			},

		// Navigation buttons
		forward:  null, // Selector or DOM element for "forward movement" button.
		backward: null, // Selector or DOM element for "backward movement" button.
		prev:     null, // Selector or DOM element for "previous item" button.
		next:     null, // Selector or DOM element for "next item" button.
		prevPage: null, // Selector or DOM element for "previous page" button.
		nextPage: null, // Selector or DOM element for "next page" button.

		// Automated cycling
		cycleBy:       null,  // Enable automatic cycling by 'items' or 'pages'.
		cycleInterval: 5000,  // Delay between cycles in milliseconds.
		pauseOnHover:  false, // Pause cycling when mouse hovers over the FRAME.
		startPaused:   false, // Whether to start in paused sate.

		// Mixed options
		moveBy:        300,     // Speed in pixels per second used by forward and backward buttons.
		speed:         0,       // Animations speed in milliseconds. 0 to disable animations.
		easing:        'swing', // Easing for duration based (tweening) animations.
		startAt:       null,    // Starting offset in pixels or items.
		keyboardNavBy: null,    // Enable keyboard navigation by 'items' or 'pages'.

		// Classes
		draggedClass:  'dragged', // Class for dragged elements (like SLIDEE or scrollbar handle).
		activeClass:   'active',  // Class for active items and pages.
		disabledClass: 'disabled' // Class for disabled navigation elements.
	};
}(jQuery, window));

}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("sly", moduleFactory);

}());			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this;
$.require()
 .script("autosize.input","scrollTo", "ui/position")
 .done(function() {
var exports = function() {

// Constants
var KEYCODE = {
	BACKSPACE: 8,
	COMMA: 188,
	DELETE: 46,
	DOWN: 40,
	ENTER: 13,
	ESCAPE: 27,
	LEFT: 37,
	RIGHT: 39,
	SPACE: 32,
	TAB: 9,
	UP: 38
};

// Templates
$.template("textboxlist/item", '<div class="textboxlist-item[%== (this.locked) ? " is-locked" : "" %]" data-textboxlist-item><span class="textboxlist-itemContent" data-textboxlist-itemContent>[%== html %]</span><div class="textboxlist-itemRemoveButton" data-textboxlist-itemRemoveButton><i class="fa fa-times"></i></a></div>');
$.template("textboxlist/itemContent", '[%= title %]<input type="hidden" name="[%= name %]" value="[%= id %]"/>');

$.Controller("Textboxlist", {
	pluginName: "textboxlist",
	hostname: "textboxlist",

	defaultOptions: {

		view: {
			item: 'textboxlist/item',
			itemContent: 'textboxlist/itemContent'
		},

		plugin: {},

		// Options
		name: "items[]",
		unique: true,
		caseSensitive: false,
		max: null,
		ignoreLocked: false,

		// Events
		filterItem: null,

		"{item}"            : "[data-textboxlist-item]",
		"{itemContent}"     : "[data-textboxlist-itemContent]",
		"{itemRemoveButton}": "[data-textboxlist-itemRemoveButton]",
		"{textField}"       : "[data-textboxlist-textField]"
	}
}, function(self) { return {

	init: function() {

		var textField = self.textField();

		// Make textfield expandable
		textField.autosizeInput();

		// Keep the original placeholder text value
		textField.data("placeholderText", textField.attr("placeholder"));

		// Data attribute override options
		var name = textField.data("textboxlistName");
		if (name) {
			self.options.name = name;
		}

		// Go through existing item
		// and reconstruct item data.
		self.item().each(function(){

			var item = $(this),
				itemContent = item.find(self.itemContent.selector);

			self.createItem({

				id: item.data("id") || (function(){
					var id = $.uid("item-");
					item.data("id", id);
					return id;
				})(),

				value: item.data("value"),

				title: item.data("title") || $.trim(itemContent.text()),

				locked: item.hasClass("is-locked"),

				html: itemContent.html()
			});
		});

		// Determine if there's autocomplete
		if (self.options.plugin.autocomplete || self.element.data("query")) {
			self.addPlugin("autocomplete");
		}

		// Prevent form submission
		self.on("keypress", self.textField(), function(event){
			if (event.keyCode==KEYCODE.ENTER) return event.preventDefault();
		});
	},

	setLayout: function() {

		var textField = self.textField(),
			placeholderText = textField.data("placeholderText");

		// Don't show placeholder if there are items.
		if (self.item().length > 0) {
			placeholderText = "";
		}

		textField
			.attr("placeholder", placeholderText)
			.data("autosizeInputInstance")
			.update();
	},

	enable: function() {
		self.element.removeClass("disabled");
		self.textField().enabled(true);
	},

	disable: function() {
		self.element.addClass("disabled");
		self.textField().disabled(true);
	},

	items: {},

	itemsByTitle: {},

	get: function(title) {

		var key = self.getItemKey(title);

		if (self.itemsByTitle.hasOwnProperty(key)) {
			return self.itemsByTitle[key];
		}
	},

	getItemKey: function(title){

		return (self.options.caseSensitive) ? title : title.toLowerCase();
	},

	filterItem: function(item) {

		var options = self.options;

		// Use custom filter if provided
		var filterItem = options.filterItem;

		if ($.isFunction(filterItem)) {
			item = filterItem.call(self, item);
		}

		var items = self.itemsByTitle;

		// If item is a string,
		if ($.isString(item) && item!=="") {

			var title = item,
				key = self.getItemKey(title);

			item =
				(items.hasOwnProperty(key)) ?

					// Get existing item
					self.itemsByTitle[key] :

					{
						id    : $.uid("item-"),
						title : title,
						key   : self.getItemKey(title),
						locked: false
					}
		}

		// This is for the name attribute for the hidden input
		item.name = item.name || self.options.name;

		// If item content is not created, then make one.
		item.html = item.html || self.view.itemContent(true, item);

		return item;
	},

	createItem: function(item) {

		// Create key for item
		item.key = self.getItemKey(item.title);

		// Store to items object
		self.items[item.id] = item;

		// Store to itemsByTitle object
		self.itemsByTitle[item.key] = item;
	},

	deleteItem: function(id) {

		var item = self.items[id];

		// Remove item from the list
		self.item().filterBy("id", id)
			.remove();

		// Remove from items object
		delete self.items[id];

		// Remove from itemsByTitle object
		var key = (self.options.caseSensitive) ? item.title : item.title.toLowerCase();
		delete self.itemsByTitle[key];
	},

	addItem: function(item, force) {

		// Don't add invalid item
		if (!item) return;

		var options = self.options;

		// If we reached the maximum number of items, skip.
		var max = options.max;
		if (!force &&
			max!==null &&
			(options.ignoreLocked ? self.item(":not(.is-locked)") : self.item()).length>=max) return;

		// Filter item
		item = self.filterItem(item);

		// At this point, if item if not an object, skip.
		if (!$.isPlainObject(item)) return;

		var itemEl,
			existingItemEl = self.item().filterBy("id", item.id);

		// If items should be unique,
		// and this item has already been added to the list
		if (options.unique && existingItemEl.length > 0) {

			// then use existing item.
			itemEl = existingItemEl;
		}

		// Else create a new item
		if (!itemEl) {

			itemEl =
				self.view.item(item)
					.addClass(item.className || "")
					.attr("data-id", item.id);
		}

		self.createItem(item);

		// Locked item always gets added to the beginning
		if (item.locked) {

			var lastLockedItem = self.item(".is-locked:last");

			if (lastLockedItem.length > 0) {
				itemEl.insertAfter(lastLockedItem);
			} else {
				itemEl.prependTo(self.element);
			}

		} else {
			// Add item on to the list
			itemEl.insertBefore(self.textField());
		}

		self.trigger("addItem", [item]);
		self.trigger("listChange");

		return item;
	},

	removeItem: function(id) {

		var item = self.items[id];

		self.deleteItem(id);

		self.trigger("removeItem", [item]);
		self.trigger("listChange");
	},

	clearItems: function() {

		self.item().each(function(){
			self.removeItem($(this).data("id"));
		});
	},

	getAddedItems: function() {

		var addedItems = [];

		self.item().each(function(){

			var item = $(this),
				id = item.data("id");

			addedItems.push(self.items[id]);
		});

		return addedItems;
	},

	"{self} addItem": function() {

		self.setLayout();
	},

	"{self} removeItem": function() {

		self.setLayout();
	},

	"{itemRemoveButton} click": function(button) {

		var item = button.parents(self.item.selector);

		self.removeItem(item.data("id"));
	},

	"{textField} keydown": function(textField, event)
	{
		var keyCode = event.keyCode;

		textField.data("realEnterKey", keyCode==KEYCODE.ENTER);
	},

	"{textField} keypress": function(textField, event) {

		var keydownIsEnter = textField.data("realEnterKey"),

			// When a person enters the IME context menu,
			// the keyCode returned during keypress will
			// not be the enter keycode.
			keypressIsEnter = event.keyCode==KEYCODE.ENTER;

		textField.data("realEnterKey", keydownIsEnter && keypressIsEnter);

		var keyword = $.trim(self.textField().val());

		switch (event.keyCode) {

			// Add new item
			case KEYCODE.ENTER:

				if (textField.data("realEnterKey")) {

					var event = self.trigger("useItem", [keyword]),
						item = event.item;

					// If event handler did not decorate item,
					// use keyword as item.
					if (item===undefined) {
						item = keyword;
					}

					// If item was converted into a null/false object,
					// this means the custom keyup event wants to "preventDefault".
					if (item===false || item===null) return;

					// Detect if there is comma (,) in the item
					// Check for plain object
					if (!$.isPlainObject(item)) {
						// We try to split it by comma (,)
						var item = item.split(',');

						$.each(item, function(i, item){
							self.addItem(item);
						});
					} else {
						// Directly add the item
						self.addItem(item);
					}

					// and clear text field.
					textField.val("");
				}
				break;
		}
	},

	"{textField} keyup": function(textField, event) {
		var item = $.trim(self.textField().val());

		// Optimization for compiler
		var canRemoveItemUsingBackspace = "canRemoveItemUsingBackspace";

		switch (event.keyCode) {

			// Remove last added item
			case KEYCODE.BACKSPACE:

				// If the text field is empty
				if (item==="") {

					// If this is the first time pressing the backspace key
					if (!self[canRemoveItemUsingBackspace]) {

						// Allow removal of item for subsequent backspace
						self[canRemoveItemUsingBackspace] = true;

					// If this is the subsequent time pressing the backspace key
					} else {

						// Look for the item before it
						var prevItem = textField.prev(self.item.selector);

						// If the item before it exists,
						if (prevItem.length > 0) {

							var id = prevItem.data("id"),
								item = self.items[id];

							// Remove the item if it is not locked.
							!item.locked && self.removeItem(id);
						}
					}
				}
				break;

			default:
				// Reset backspace removal state
				self[canRemoveItemUsingBackspace] = false;
				break;
		}
	},

	"{self} click": function(el, event) {

		var textField = self.textField();

		if (!textField.is(event.target)) {
			textField.focus();
		}
	},

	"{textField} focusin": function() {

		if (self.activated) return;

		self.activated = true;
		self.trigger("textboxlistActivate");
	},

	"{self} mousedown": function() {
		self.focusing = true;
	},

	"{self} mouseup": function() {
		self.focusing = false;
	},

	"{self} focusout": function() {

		if (self.focusing) return;

		self.activated = false;

		self.deactivateTimer =
			setTimeout(function(){
				if (self.activated) return;
				self.trigger("textboxlistDeactivate");
			}, 1);
	}
}});

$(document)
	.on('click.textboxlist.data-api', '[data-textboxlist]', function(event){
		$(this).addController($.Controller.Textboxlist).textField().focus();
	})
	.on('focus.textboxlist.data-api', '[data-textboxlist] [data-textboxlist-textField]', function(event){
		$(this).parents("[data-textboxlist]").addController($.Controller.Textboxlist);
	});
// Textboxlist ends

// Autocomplete starts
$.template("textboxlist/menu", '<div id="es" class="textboxlist-autocomplete" data-textboxlist-autocomplete><b><b></b></b><div class="textboxlist-autocomplete-inner" data-textboxlist-autocomplete-viewport><div class="textboxlist-autocomplete-loading" data-textboxlist-autocomplete-loading></div><div class="textboxlist-autocomplete-empty" data-textboxlist-autocomplete-empty></div><ul class="textboxlist-menu" data-textboxlist-menu></ul></div></div>');
$.template("textboxlist/menuItem", '<li class="textboxlist-menuItem" data-textboxlist-menuItem>[%== html %]</li>');
$.template("textboxlist/loadingHint", '<i class="o-loader o-loader--sm is-active"></i>');
$.template("textboxlist/emptyHint", '<span class="textboxlist-autocomplete-empty-text">No items found.</span>');

$.Controller("Textboxlist.Autocomplete", {

	defaultOptions: {

		view: {
			menu: "textboxlist/menu",
			menuItem: "textboxlist/menuItem",
			loadingHint: "textboxlist/loadingHint",
			emptyHint: "textboxlist/emptyHint"
		},

		cache: true,
		minLength: 1,
		limit: 10,
		highlight: true,
		caseSensitive: false,
		exclusive: false,

		// Accepts url, function or array of objects.
		// If function, it should return a deferred object.
		query: null,

		position: {
			my: 'left top',
			at: 'left bottom',
			collision: 'none'
		},

		filterItem: null,
		showEmptyHint: false,
		showLoadingHint: false,

		id: "es",
		component: "",
		modifier: "",
		shadow: false,
		sticky: false,
		animation: false,

		emptyMessage: "No items found.",

		"{menu}": "[data-textboxlist-menu]",
		"{menuItem}": "[data-textboxlist-menuItem]",
		"{viewport}": "[data-textboxlist-autocomplete-viewport]",
		"{loadingHint}": "[data-textboxlist-autocomplete-loading]",
		"{emptyHint}": "[data-textboxlist-autocomplete-empty]"
	}
}, function(self, opts, base) { return {

	init: function() {

		// Destroy controller
		if (!self.element.data(self.Class.fullName)) {

			self.destroy();

			// And reimplement on the context menu we created ourselves
			self.view.menu()
				.attr("id", opts.id)
				.addClass(opts.component)
				.addClass(opts.modifier)
				.addClass(opts.shadow ? 'has-shadow' : '')
				.addClass(opts.animation ? 'has-animation' : '')
				.addClass(opts.sticky ? 'is-sticky' : '')
				// This is legacy
				.addClass(self.textboxlist.options.component)
				.appendTo("body")
				.data(self.Class.fullName, true)
				.addController(self.Class, self.options);

			return;
		}

		var textboxlist = self.textboxlist;

		textboxlist.autocomplete = self;
		textboxlist.pluginInstances["autocomplete"] = self;

		// Set the position to be relative to the textboxlist
		self.options.position.of = self.textboxlist.element;

		self.initQuery();

		// Loading hint
		self.view.loadingHint()
			.appendTo(self.loadingHint());

		// Empty hint
		var emptyHint = self.view.emptyHint();
		emptyHint.html(opts.emptyMessage)
			.appendTo(self.emptyHint());

		// Only reattach element when autocomplete is needed.
		self.element.detach();
	},

	initQuery: function() {

		// Determine query method
		var query = self.options.query || self.textboxlist.element.data("query");

		// TODO: Wrap up query options and pass to query URL & query function.

		// Query URL
		if ($.isUrl(query)) {

			var url = query;

			self.query = function(keyword){
				return $.ajax(url + keyword);
			}

			return;
		}

		// Query function
		if ($.isFunction(query)) {

			var func = query;

			self.query = function(keyword) {
				return func.call(self, keyword);
			}

			return;
		}

		// Query dataset
		if ($.isArray(query)) {

			var dataset = query;

			self.query = function(keyword) {

				var task = $.Deferred(),
					keyword = keyword.toLowerCase();

				// Fork this process
				// so it won't choke on large dataset.
				setTimeout(function(){

					var result = $.grep(dataset, function(item){
						return item.title.toLowerCase().indexOf(keyword) > -1;
					});

					task.resolve(result);

				}, 0);

				return task;
			}

			return;
		}
	},

	setLayout: function() {

		if (!self.hidden) {

			self.element
				.css({
					opacity: 1,
					width: self.textboxlist.element.outerWidth()
				})
				.position(self.options.position);
		}
	},

	"{window} resize": $.debounce(function() {
		self.element.css("opacity", 0);
		self.setLayout();
	}, 250),

	"{window} scroll": $.debounce(function() {
		self.element.css("opacity", 0);
		self.setLayout();
	}, 250),

	"{window} dialogTransitionStart": function() {
		self.hidden = true;
		self.element.css("opacity", 0);
	},

	"{window} dialogTransitionEnd": function() {
		self.hidden = false;
		self.setLayout();
	},

	show: function() {

		clearTimeout(self.sleep);

		self.element
			.appendTo("body")
			.show();

		self.hidden = false;

		self.setLayout();
	},

	hide: function() {

		self.element.hide();

		var menuItem = self.menuItem(),
			activeMenuItem = menuItem.filter(".active");

		if (activeMenuItem.length > 0) {
			self.lastItem = {
				keyword: $.trim(self.textboxlist.textField().val()),
				item   : activeMenuItem.data("item")
			};
		}

		menuItem.removeClass("active");

		self.render.reset();

		self.hidden = true;

		// Clear any previous sleep timer first
		clearTimeout(self.sleep);

		// If no activity within 3000 seconds, detach myself.
		self.sleep = setTimeout(function(){
			self.element.detach();
		}, 3000);
	},

	queries: {},

	populated: false,

	populate: function(keyword) {

		self.populated = false;

		// Remove loading class
		var element = self.element,
			options = self.options;

		// Remove both loading & empty class
		element.removeClass("loading empty");

		if (options.showLoadingHint) {
			self.hide();
		}

		// Trigger populate event
		// If the populate event returns a modified keyword, use it.
		var event = self.trigger("populateKeyword", [keyword]);
		if (event.keyword) { keyword = event.keyword };


		var key = (options.caseSensitive) ? keyword : keyword.toLowerCase(),
			query = self.queries[key];

		var newQuery = !$.isDeferred(query) || !self.options.cache,

			runQuery = function(){

				// Show loading hint
				if (options.showLoadingHint) {
					element.addClass("loading");
					self.show();
				}

				// Query the keyword if:
				// - The query hasn't been made.
				// - The query has been rejected.
				if (newQuery || (!newQuery && query.state()=="rejected")) {

					query = self.queries[key] = self.query(keyword);
				}

				// When query is done, render items;
				query
					.done(
						self.render(function(items){
							return [items, keyword];
						})
					)
					.fail(function(){
						self.hide();
					})
					.always(function(){
						element.removeClass("loading");
					});

				// Trigger query event
				self.trigger("queryKeyword", [query, keyword]);
			}

		// If this is a new query
		if (newQuery) {

			// Don't run until we are sure that the user is finished typing
			clearTimeout(self.queryTask);
			self.queryTask = setTimeout(runQuery, 250);

		// Else run it immediately
		} else {
			runQuery();
		}
	},

	populateTask: null,

	populateFromTextField: function() {

		clearTimeout(self.populateTask);

		self.populateTask = setTimeout(function(){

			var textField = self.textboxlist.textField(),
				keyword = $.trim(textField.val());

			// If no keyword given or keyword doesn't meet minimum query length, stop.
			if (keyword==="" || (keyword.length < self.options.minLength)) {

				self.hide();

			// Else populate suggestions.
			} else {

				self.populate(keyword);
			}
		}, 1);
	},

	render: $.Enqueue(function(items, keyword){

		// If items passed in isn't an array,
		// fake an empty array.
		if (!$.isArray(items)) { items = [] };


		// Get textboxlist
		var textboxlist = self.textboxlist,
			autocomplete = self,
			element = self.element,
			options = self.options,
			menu = self.menu();

		// If there are no items, hide menu.
		if (items.length < 1) {

			// If we are supposed to show an empty hint
			if (options.showEmptyHint) {

				// Clear out menu
				menu.empty();

				// Add empty class
				element.addClass("empty");

				// Trigger renderMenu event
				textboxlist.trigger("renderMenu", [menu, autocomplete, textboxlist]);

				// Show menu
				self.show();

			// Just hide straight away
			} else {

				self.hide();
			}

			return;
		}

		// Remove empty class
		element.removeClass("empty");

		// Generate menu items
		if (!options.cache || menu.data("keyword")!==keyword) {

			// Clear out menu items
			menu.empty();

			$.each(items, function(i, item){

				if (!$.isPlainObject(item)) {
					var item = {
						"html": item
					};
				}

				textboxlist.trigger("filterItem", [item, autocomplete, textboxlist]);

				// Deprecated
				var filterItem = options.filterItem;
				if ($.isFunction(filterItem)) {
					item = filterItem.call(self, item, keyword);
				}


				// If the item is not an object,
				// or item should be discarded, stop.
				if (!$.isPlainObject(item) || item.discard) {
					console.log('discarding?');
					return;
				}

				var html = item.menuHtml || item.title;

				self.view.menuItem({html: html})
					.addClass(item.className || "")
					.data("item", item)
					.appendTo(menu);
			});

			menu.data("keyword", keyword);
		}

		// Get menu Items
		var menuItems = self.menuItem();

		// Trigger filterMenu event
		textboxlist.trigger("filterMenu", [menu, menuItems, autocomplete, textboxlist]);

		// If menu is empty, toggle empty classname
		if (menuItems.filter(":not(.hidden)").length < 1) {

			element.addClass("empty");

			// If we shouldn't show an empty hint
			if (!options.showEmptyHint) {

				// Hide menu straightaway
				return self.hide();
			}
		}

		// If we only allow adding item from suggestions
		if (options.exclusive) {

			// Automatically select the first item
			self.menuItem(":not(.hidden):first").addClass("active");
		}

		// Trigger renderMenu event
		textboxlist.trigger("renderMenu", [menu, autocomplete, textboxlist]);

		self.show();
	}),

	"{textboxlist.textField} keydown": function(textField, event) {

		// Prevent autocomplete from falling asleep.
		clearTimeout(self.sleep);

		// Get active menu item
		var activeMenuItem = self.menuItem(".active:not(.hidden)");

		if (activeMenuItem.length < 1) {
			activeMenuItem = false;
		}

		var textField = self.textboxlist.textField();

		switch (event.keyCode) {

			// If up key is pressed
			case KEYCODE.UP:

				// Deactivate all menu item
				self.menuItem().removeClass("active");

				// If no menu items are activated,
				if (!activeMenuItem) {

					// activate the last one.
					self.menuItem(":not(.hidden):last").addClass("active");

				// Else find the menu item before it,
				} else {

					// and activate it.
					activeMenuItem.prev(self.menuItem.selector + ':not(.hidden)')
						.addClass("active");
				}

				// We store this for the next item when at the end of the list
				var nextMenuItem = self.menuItem(":not(.hidden):last");

				// Prevent up/down keys from changing textfield cursor position.
				event.preventDefault();
				break;

			// If down key is pressed
			case KEYCODE.DOWN:

				// Deactivate all menu item
				self.menuItem().removeClass("active");

				// If no menu items are activated,
				if (!activeMenuItem) {

					// activate the first one.
					self.menuItem(":not(.hidden):first").addClass("active");

				// Else find the menu item after it,
				} else {

					// and activate it.
					activeMenuItem.next(self.menuItem.selector + ':not(.hidden)')
						.addClass("active");
				}

				// We store this for the next item when at the end of the list
				var nextMenuItem = self.menuItem(":not(.hidden):first");

				// Prevent up/down keys from changing textfield cursor position.
				event.preventDefault();
				break;

			// If escape is pressed,
			case KEYCODE.ESCAPE:

				// hide menu.
				self.hide();
				break;

			// Don't do anything when enter is pressed.
			case KEYCODE.ENTER:
				break;

			default:
				self.populateFromTextField();
				break;
		}

		// Get newly activated item
		var activeMenuItem = self.menuItem(".active:not(.hidden)");

		// If we are reaching the end of the menu cycle,
		// select textfield as a visual indication, else
		// unselect textfield and let the menu item appear selected.
		if (activeMenuItem.length < 1) {
			if (event.keyCode == KEYCODE.DOWN || event.keyCode == KEYCODE.UP) {
				var activeMenuItem = nextMenuItem;
				activeMenuItem.addClass("active");
			} else {
				return;
			}
		}

		// Scroll menu viewport if it is out of visible area.
		self.viewport().scrollIntoView(activeMenuItem);
	},

	"{textboxlist} textboxlistActivate": function(textboxlist) {

		self.populateFromTextField();
	},

	"{textboxlist} textboxlistDeactivate": function(textboxlist) {

		// Allow user to select menu first
		setTimeout(function(){
			self.hide();
		}, 150);
	},

	"{textboxlist} destroyed": function() {

		self.element.remove();
	},

	"{textboxlist} useItem": function(textField, event, keyword) {

		// If we only pick items exclusively from menu,
		// set item to false first. This prevents any
		// random keyword from being added to the list.
		var exclusive = self.options.exclusive;

		if (exclusive) event.item = false;

		// If menu is not visible
		if (self.hidden) {

			// and we are in exclusive mode
			// and the last item before we hide the menu
			// matches the current keyword,
			var lastItem = self.lastItem;

			if (exclusive && lastItem && lastItem.keyword==keyword) {

				// then we will automatically use the last
				// item as the item to be added to the list.
				event.item = lastItem.item;
			}

			return;
		}

		// If there are activated items
		var activeMenuItem = self.menuItem(".active");

		if (activeMenuItem.length > 0) {

			// get the item data,
			var item = activeMenuItem.data("item");

			// and return the item data to the textboxlist.
			event.item = item;
		}

		// Hide the menu
		self.hide();
	},

	"{menuItem} mousedown": function() {

		self.textboxlist.focusing = true;
	},

	"{menuItem} mouseup": function() {

		self.textboxlist.focusing = false;
	},

	"{menuItem} click": function(menuItem) {

		// Hide context menu
		self.hide();

		// Add item
		var item = menuItem.data("item");
		self.textboxlist.addItem(item);

		// Get text field & clear text field
		var textField = self.textboxlist.textField().val("");

		// Refocus text field
		setTimeout(function(){

			// Due to event delegation, this needs to be slightly delayed.
			textField.focus();
		}, 150);
	},

	"{menuItem} mouseover": function(menuItem) {

		self.menuItem().removeClass("active");

		menuItem.addClass("active");
	},

	"{menuItem} mouseout": function(menuItem) {

		self.menuItem().removeClass("active");
	}
}}
);
// Autocomplete ends
};

exports();
module.resolveWith(exports);

});
// module body: end

};
// module factory: end

FD40.module("textboxlist", moduleFactory);

}());
			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var jQuery = $;
var module = this;
var exports = function() {



// jQuery toast plugin created by Kamran Ahmed copyright MIT license 2015
if ( typeof Object.create !== 'function' ) {
	Object.create = function( obj ) {
		function F() {}
		F.prototype = obj;
		return new F();
	};
}

(function( $, window, document, undefined ) {

	"use strict";
	
	var Toast = {

		_positionClasses : ['bottom-left', 'bottom-right', 'top-right', 'top-left', 'bottom-center', 'top-center', 'mid-center'],
		_defaultIcons : ['success', 'error', 'info', 'warning'],

		init: function (options, elem) {
			this.prepareOptions(options, $.toast.options);
			this.process();
		},

		prepareOptions: function(options, options_to_extend) {
			var _options = {};
			if ( ( typeof options === 'string' ) || ( options instanceof Array ) ) {
				_options.text = options;
			} else {
				_options = options;
			}
			this.options = $.extend( {}, options_to_extend, _options );
		},

		process: function () {
			this.setup();
			this.addToDom();
			this.position();
			this.bindToast();
			this.animate();
		},

		setup: function () {
			
			var _toastContent = '';
			
			this._toastEl = this._toastEl || $('<div></div>', {
				class : 'jq-toast-single'
			});

			// For the loader on top
			_toastContent += '<span class="jq-toast-loader"></span>';            

			if ( this.options.allowToastClose ) {
				_toastContent += '<span class="close-jq-toast-single">&times;</span>';
			};

			if ( this.options.text instanceof Array ) {

				if ( this.options.heading ) {
					_toastContent +='<h2 class="jq-toast-heading">' + this.options.heading + '</h2>';
				};

				_toastContent += '<ul class="jq-toast-ul">';
				for (var i = 0; i < this.options.text.length; i++) {
					_toastContent += '<li class="jq-toast-li" id="jq-toast-item-' + i + '">' + this.options.text[i] + '</li>';
				}
				_toastContent += '</ul>';

			} else {
				if ( this.options.heading ) {
					_toastContent +='<h2 class="jq-toast-heading">' + this.options.heading + '</h2>';
				};
				_toastContent += this.options.text;
			}

			this._toastEl.html( _toastContent );

			if ( this.options.bgColor !== false ) {
				this._toastEl.css("background-color", this.options.bgColor);
			};

			if ( this.options.textColor !== false ) {
				this._toastEl.css("color", this.options.textColor);
			};

			if ( this.options.textAlign ) {
				this._toastEl.css('text-align', this.options.textAlign);
			}

			if ( this.options.icon !== false ) {
				this._toastEl.addClass('jq-has-icon');

				if ( $.inArray(this.options.icon, this._defaultIcons) !== -1 ) {
					this._toastEl.addClass('jq-icon-' + this.options.icon);
				};
			};

			if ( this.options.class !== false ){
				this._toastEl.addClass(this.options.class)
			}
		},

		position: function () {
			if ( ( typeof this.options.position === 'string' ) && ( $.inArray( this.options.position, this._positionClasses) !== -1 ) ) {

				if ( this.options.position === 'bottom-center' ) {
					this._container.css({
						left: ( $(window).outerWidth() / 2 ) - this._container.outerWidth()/2,
						bottom: 20
					});
				} else if ( this.options.position === 'top-center' ) {
					this._container.css({
						left: ( $(window).outerWidth() / 2 ) - this._container.outerWidth()/2,
						top: 20
					});
				} else if ( this.options.position === 'mid-center' ) {
					this._container.css({
						left: ( $(window).outerWidth() / 2 ) - this._container.outerWidth()/2,
						top: ( $(window).outerHeight() / 2 ) - this._container.outerHeight()/2
					});
				} else {
					this._container.addClass( this.options.position );
				}

			} else if ( typeof this.options.position === 'object' ) {
				this._container.css({
					top : this.options.position.top ? this.options.position.top : 'auto',
					bottom : this.options.position.bottom ? this.options.position.bottom : 'auto',
					left : this.options.position.left ? this.options.position.left : 'auto',
					right : this.options.position.right ? this.options.position.right : 'auto'
				});
			} else {
				this._container.addClass( 'bottom-left' );
			}
		},

		bindToast: function () {

			var that = this;

			this._toastEl.on('afterShown', function () {
				that.processLoader();
			});

			this._toastEl.find('.close-jq-toast-single').on('click', function ( e ) {

				e.preventDefault();

				if( that.options.showHideTransition === 'fade') {
					that._toastEl.trigger('beforeHide');
					that._toastEl.fadeOut(function () {
						that._toastEl.trigger('afterHidden');
					});
				} else if ( that.options.showHideTransition === 'slide' ) {
					that._toastEl.trigger('beforeHide');
					that._toastEl.slideUp(function () {
						that._toastEl.trigger('afterHidden');
					});
				} else {
					that._toastEl.trigger('beforeHide');
					that._toastEl.hide(function () {
						that._toastEl.trigger('afterHidden');
					});
				}
			});

			if ( typeof this.options.beforeShow == 'function' ) {
				this._toastEl.on('beforeShow', function () {
					that.options.beforeShow(that._toastEl);
				});
			};

			if ( typeof this.options.afterShown == 'function' ) {
				this._toastEl.on('afterShown', function () {
					that.options.afterShown(that._toastEl);
				});
			};

			if ( typeof this.options.beforeHide == 'function' ) {
				this._toastEl.on('beforeHide', function () {
					that.options.beforeHide(that._toastEl);
				});
			};

			if ( typeof this.options.afterHidden == 'function' ) {
				this._toastEl.on('afterHidden', function () {
					that.options.afterHidden(that._toastEl);
				});
			};

			if ( typeof this.options.onClick == 'function' ) {
				this._toastEl.on('click', function () {
					that.options.onClick(that._toastEl);
				});
			};    
		},

		addToDom: function () {

			 var _container = $('.jq-toast-wrap');
			 
			 if ( _container.length === 0 ) {
				
				_container = $('<div></div>',{
					class: "jq-toast-wrap",
					role: "alert",
					"aria-live": "polite"
				});

				$('body').append( _container );

			 } else if ( !this.options.stack || isNaN( parseInt(this.options.stack, 10) ) ) {
				_container.empty();
			 }

			 _container.find('.jq-toast-single:hidden').remove();

			 _container.append( this._toastEl );

			if ( this.options.stack && !isNaN( parseInt( this.options.stack ), 10 ) ) {
				
				var _prevToastCount = _container.find('.jq-toast-single').length,
					_extToastCount = _prevToastCount - this.options.stack;

				if ( _extToastCount > 0 ) {
					$('.jq-toast-wrap').find('.jq-toast-single').slice(0, _extToastCount).remove();
				};

			}

			this._container = _container;
		},

		canAutoHide: function () {
			return ( this.options.hideAfter !== false ) && !isNaN( parseInt( this.options.hideAfter, 10 ) );
		},

		processLoader: function () {
			// Show the loader only, if auto-hide is on and loader is demanded
			if (!this.canAutoHide() || this.options.loader === false) {
				return false;
			}

			var loader = this._toastEl.find('.jq-toast-loader');

			// 400 is the default time that jquery uses for fade/slide
			// Divide by 1000 for milliseconds to seconds conversion
			var transitionTime = (this.options.hideAfter - 400) / 1000 + 's';
			var loaderBg = this.options.loaderBg;

			var style = loader.attr('style') || '';
			style = style.substring(0, style.indexOf('-webkit-transition')); // Remove the last transition definition

			style += '-webkit-transition: width ' + transitionTime + ' ease-in; \
					  -o-transition: width ' + transitionTime + ' ease-in; \
					  transition: width ' + transitionTime + ' ease-in; \
					  background-color: ' + loaderBg + ';';


			loader.attr('style', style).addClass('jq-toast-loaded');
		},

		animate: function () {

			var that = this;

			this._toastEl.hide();

			this._toastEl.trigger('beforeShow');

			if ( this.options.showHideTransition.toLowerCase() === 'fade' ) {
				this._toastEl.fadeIn(function ( ){
					that._toastEl.trigger('afterShown');
				});
			} else if ( this.options.showHideTransition.toLowerCase() === 'slide' ) {
				this._toastEl.slideDown(function ( ){
					that._toastEl.trigger('afterShown');
				});
			} else {
				this._toastEl.show(function ( ){
					that._toastEl.trigger('afterShown');
				});
			}

			if (this.canAutoHide()) {

				var that = this;

				window.setTimeout(function(){
					
					if ( that.options.showHideTransition.toLowerCase() === 'fade' ) {
						that._toastEl.trigger('beforeHide');
						that._toastEl.fadeOut(function () {
							that._toastEl.trigger('afterHidden');
						});
					} else if ( that.options.showHideTransition.toLowerCase() === 'slide' ) {
						that._toastEl.trigger('beforeHide');
						that._toastEl.slideUp(function () {
							that._toastEl.trigger('afterHidden');
						});
					} else {
						that._toastEl.trigger('beforeHide');
						that._toastEl.hide(function () {
							that._toastEl.trigger('afterHidden');
						});
					}

				}, this.options.hideAfter);
			};
		},

		reset: function ( resetWhat ) {

			if ( resetWhat === 'all' ) {
				$('.jq-toast-wrap').remove();
			} else {
				this._toastEl.remove();
			}

		},

		update: function(options) {
			this.prepareOptions(options, this.options);
			this.setup();
			this.bindToast();
		},
		
		close: function() {
			this._toastEl.find('.close-jq-toast-single').click();
		}
	};
	
	$.toast = function(options) {
		var toast = Object.create(Toast);
		toast.init(options, this);

		return {
			
			reset: function ( what ) {
				toast.reset( what );
			},

			update: function( options ) {
				toast.update( options );
			},
			
			close: function( ) {
				toast.close( );
			}
		}
	};

	$.toast.options = {
		text: '',
		heading: '',
		showHideTransition: 'fade',
		allowToastClose: true,
		hideAfter: 3000,
		loader: true,
		loaderBg: '#9EC600',
		stack: 5,
		position: 'bottom-left',
		bgColor: false,
		textColor: false,
		textAlign: 'left',
		icon: false,
		beforeShow: function () {},
		afterShown: function () {},
		beforeHide: function () {},
		afterHidden: function () {},
		onClick: function () {}
	};

})( jQuery, window, document );

};

exports();
module.resolveWith(exports);

// module body: end

};
// module factory: end

FD40.module("toast", moduleFactory);

}());
			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var jQuery = $; 
var exports = function() { 

/*!
 * jQuery UI Core 1.10.4pre
 * http://jqueryui.com
 *
 * Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/category/ui-core/
 */
(function( $, undefined ) {

var uuid = 0,
	runiqueId = /^ui-id-\d+$/;

// $.ui might exist from components with no dependencies, e.g., $.ui.position
$.ui = $.ui || {};

$.extend( $.ui, {
	version: "1.10.4pre",

	keyCode: {
		BACKSPACE: 8,
		COMMA: 188,
		DELETE: 46,
		DOWN: 40,
		END: 35,
		ENTER: 13,
		ESCAPE: 27,
		HOME: 36,
		LEFT: 37,
		NUMPAD_ADD: 107,
		NUMPAD_DECIMAL: 110,
		NUMPAD_DIVIDE: 111,
		NUMPAD_ENTER: 108,
		NUMPAD_MULTIPLY: 106,
		NUMPAD_SUBTRACT: 109,
		PAGE_DOWN: 34,
		PAGE_UP: 33,
		PERIOD: 190,
		RIGHT: 39,
		SPACE: 32,
		TAB: 9,
		UP: 38
	}
});

// plugins
$.fn.extend({
	focus: (function( orig ) {
		return function( delay, fn ) {
			return typeof delay === "number" ?
				this.each(function() {
					var elem = this;
					setTimeout(function() {
						$( elem ).focus();
						if ( fn ) {
							fn.call( elem );
						}
					}, delay );
				}) :
				orig.apply( this, arguments );
		};
	})( $.fn.focus ),

	scrollParent: function() {
		var scrollParent;
		if (($.ui.ie && (/(static|relative)/).test(this.css("position"))) || (/absolute/).test(this.css("position"))) {
			scrollParent = this.parents().filter(function() {
				return (/(relative|absolute|fixed)/).test($.css(this,"position")) && (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));
			}).eq(0);
		} else {
			scrollParent = this.parents().filter(function() {
				return (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));
			}).eq(0);
		}

		return (/fixed/).test(this.css("position")) || !scrollParent.length ? $(document) : scrollParent;
	},

	zIndex: function( zIndex ) {
		if ( zIndex !== undefined ) {
			return this.css( "zIndex", zIndex );
		}

		if ( this.length ) {
			var elem = $( this[ 0 ] ), position, value;
			while ( elem.length && elem[ 0 ] !== document ) {
				// Ignore z-index if position is set to a value where z-index is ignored by the browser
				// This makes behavior of this function consistent across browsers
				// WebKit always returns auto if the element is positioned
				position = elem.css( "position" );
				if ( position === "absolute" || position === "relative" || position === "fixed" ) {
					// IE returns 0 when zIndex is not specified
					// other browsers return a string
					// we ignore the case of nested elements with an explicit value of 0
					// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
					value = parseInt( elem.css( "zIndex" ), 10 );
					if ( !isNaN( value ) && value !== 0 ) {
						return value;
					}
				}
				elem = elem.parent();
			}
		}

		return 0;
	},

	uniqueId: function() {
		return this.each(function() {
			if ( !this.id ) {
				this.id = "ui-id-" + (++uuid);
			}
		});
	},

	removeUniqueId: function() {
		return this.each(function() {
			if ( runiqueId.test( this.id ) ) {
				$( this ).removeAttr( "id" );
			}
		});
	}
});

// selectors
function focusable( element, isTabIndexNotNaN ) {
	var map, mapName, img,
		nodeName = element.nodeName.toLowerCase();
	if ( "area" === nodeName ) {
		map = element.parentNode;
		mapName = map.name;
		if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
			return false;
		}
		img = $( "img[usemap=#" + mapName + "]" )[0];
		return !!img && visible( img );
	}
	return ( /input|select|textarea|button|object/.test( nodeName ) ?
		!element.disabled :
		"a" === nodeName ?
			element.href || isTabIndexNotNaN :
			isTabIndexNotNaN) &&
		// the element and all of its ancestors must be visible
		visible( element );
}

function visible( element ) {
	return $.expr.filters.visible( element ) &&
		!$( element ).parents().addBack().filter(function() {
			return $.css( this, "visibility" ) === "hidden";
		}).length;
}

$.extend( $.expr[ ":" ], {
	data: $.expr.createPseudo ?
		$.expr.createPseudo(function( dataName ) {
			return function( elem ) {
				return !!$.data( elem, dataName );
			};
		}) :
		// support: jQuery <1.8
		function( elem, i, match ) {
			return !!$.data( elem, match[ 3 ] );
		},

	focusable: function( element ) {
		return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );
	},

	tabbable: function( element ) {
		var tabIndex = $.attr( element, "tabindex" ),
			isTabIndexNaN = isNaN( tabIndex );
		return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );
	}
});

// support: jQuery <1.8
if ( !$( "<a>" ).outerWidth( 1 ).jquery ) {
	$.each( [ "Width", "Height" ], function( i, name ) {
		var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
			type = name.toLowerCase(),
			orig = {
				innerWidth: $.fn.innerWidth,
				innerHeight: $.fn.innerHeight,
				outerWidth: $.fn.outerWidth,
				outerHeight: $.fn.outerHeight
			};

		function reduce( elem, size, border, margin ) {
			$.each( side, function() {
				size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;
				if ( border ) {
					size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;
				}
				if ( margin ) {
					size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;
				}
			});
			return size;
		}

		$.fn[ "inner" + name ] = function( size ) {
			if ( size === undefined ) {
				return orig[ "inner" + name ].call( this );
			}

			return this.each(function() {
				$( this ).css( type, reduce( this, size ) + "px" );
			});
		};

		$.fn[ "outer" + name] = function( size, margin ) {
			if ( typeof size !== "number" ) {
				return orig[ "outer" + name ].call( this, size );
			}

			return this.each(function() {
				$( this).css( type, reduce( this, size, true, margin ) + "px" );
			});
		};
	});
}

// support: jQuery <1.8
if ( !$.fn.addBack ) {
	$.fn.addBack = function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	};
}

// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
if ( $( "<a>" ).data( "a-b", "a" ).removeData( "a-b" ).data( "a-b" ) ) {
	$.fn.removeData = (function( removeData ) {
		return function( key ) {
			if ( arguments.length ) {
				return removeData.call( this, $.camelCase( key ) );
			} else {
				return removeData.call( this );
			}
		};
	})( $.fn.removeData );
}





// deprecated
$.ui.ie = !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );

$.support.selectstart = "onselectstart" in document.createElement( "div" );
$.fn.extend({
	disableSelection: function() {
		return this.bind( ( $.support.selectstart ? "selectstart" : "mousedown" ) +
			".ui-disableSelection", function( event ) {
				event.preventDefault();
			});
	},

	enableSelection: function() {
		return this.unbind( ".ui-disableSelection" );
	}
});

$.extend( $.ui, {
	// $.ui.plugin is deprecated. Use $.widget() extensions instead.
	plugin: {
		add: function( module, option, set ) {
			var i,
				proto = $.ui[ module ].prototype;
			for ( i in set ) {
				proto.plugins[ i ] = proto.plugins[ i ] || [];
				proto.plugins[ i ].push( [ option, set[ i ] ] );
			}
		},
		call: function( instance, name, args ) {
			var i,
				set = instance.plugins[ name ];
			if ( !set || !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) {
				return;
			}

			for ( i = 0; i < set.length; i++ ) {
				if ( instance.options[ set[ i ][ 0 ] ] ) {
					set[ i ][ 1 ].apply( instance.element, args );
				}
			}
		}
	},

	// only used by resizable
	hasScroll: function( el, a ) {

		//If overflow is hidden, the element might have extra content, but the user wants to hide it
		if ( $( el ).css( "overflow" ) === "hidden") {
			return false;
		}

		var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
			has = false;

		if ( el[ scroll ] > 0 ) {
			return true;
		}

		// TODO: determine which cases actually cause this to happen
		// if the element doesn't have the scroll set, see if it's possible to
		// set the scroll
		el[ scroll ] = 1;
		has = ( el[ scroll ] > 0 );
		el[ scroll ] = 0;
		return has;
	}
});

$(function(){

	if ($("body > [id=es].ui").length > 0) return;

	// Create container for #fd-ui
	$(document.createElement("div"))
		.attr("id", "es")
		.addClass("ui")
		.css({
			position: "absolute",
			top: 0,
			left: 0,
			overflow: "visible",
			width: 0,
			height: 0,
			zIndex: 10002
		})
		.appendTo("body");
});

})( jQuery );

}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("ui/core", moduleFactory);

}());			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var jQuery = $; 
$.require() 
 .script("ui/widget") 
 .done(function() { 
var exports = function() { 

/*!
 * jQuery UI Mouse 1.10.4pre
 * http://jqueryui.com
 *
 * Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/mouse/
 *
 * Depends:
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

var mouseHandled = false;
$( document ).mouseup( function() {
	mouseHandled = false;
});

$.widget("ui.mouse", {
	version: "1.10.4pre",
	options: {
		cancel: "input,textarea,button,select,option",
		distance: 1,
		delay: 0
	},
	_mouseInit: function() {
		var that = this;

		this.element
			.bind("mousedown."+this.widgetName, function(event, eventOverride) {
				return that._mouseDown(eventOverride || event);
			})
			.bind("click."+this.widgetName, function(event) {
				if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
					$.removeData(event.target, that.widgetName + ".preventClickEvent");
					event.stopImmediatePropagation();
					return false;
				}
			});

		this.started = false;
	},

	// TODO: make sure destroying one instance of mouse doesn't mess with
	// other instances of mouse
	_mouseDestroy: function() {
		this.element.unbind("."+this.widgetName);
		if ( this._mouseMoveDelegate ) {
			$(document)
				.unbind("mousemove."+this.widgetName, this._mouseMoveDelegate)
				.unbind("mouseup."+this.widgetName, this._mouseUpDelegate);
		}
	},

	_mouseDown: function(event) {
		// don't let more than one widget handle mouseStart
		if( mouseHandled ) { return; }

		// we may have missed mouseup (out of window)
		(this._mouseStarted && this._mouseUp(event));

		this._mouseDownEvent = event;

		var that = this,
			btnIsLeft = (event.which === 1),
			// event.target.nodeName works around a bug in IE 8 with
			// disabled inputs (#7620)
			elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
		if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
			return true;
		}

		this.mouseDelayMet = !this.options.delay;
		if (!this.mouseDelayMet) {
			this._mouseDelayTimer = setTimeout(function() {
				that.mouseDelayMet = true;
			}, this.options.delay);
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted = (this._mouseStart(event) !== false);
			if (!this._mouseStarted) {
				event.preventDefault();
				return true;
			}
		}

		// Click event may never have fired (Gecko & Opera)
		if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
			$.removeData(event.target, this.widgetName + ".preventClickEvent");
		}

		// these delegates are required to keep context
		this._mouseMoveDelegate = function(event) {
			return that._mouseMove(event);
		};
		this._mouseUpDelegate = function(event) {
			return that._mouseUp(event);
		};
		$(document)
			.bind("mousemove."+this.widgetName, this._mouseMoveDelegate)
			.bind("mouseup."+this.widgetName, this._mouseUpDelegate);

		event.preventDefault();

		mouseHandled = true;
		return true;
	},

	_mouseMove: function(event) {
		// IE mouseup check - mouseup happened when mouse was out of window
		if ($.ui.ie && ( !document.documentMode || document.documentMode < 9 ) && !event.button) {
			return this._mouseUp(event);
		}

		if (this._mouseStarted) {
			this._mouseDrag(event);
			return event.preventDefault();
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted =
				(this._mouseStart(this._mouseDownEvent, event) !== false);
			(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
		}

		return !this._mouseStarted;
	},

	_mouseUp: function(event) {
		$(document)
			.unbind("mousemove."+this.widgetName, this._mouseMoveDelegate)
			.unbind("mouseup."+this.widgetName, this._mouseUpDelegate);

		if (this._mouseStarted) {
			this._mouseStarted = false;

			if (event.target === this._mouseDownEvent.target) {
				$.data(event.target, this.widgetName + ".preventClickEvent", true);
			}

			this._mouseStop(event);
		}

		return false;
	},

	_mouseDistanceMet: function(event) {
		return (Math.max(
				Math.abs(this._mouseDownEvent.pageX - event.pageX),
				Math.abs(this._mouseDownEvent.pageY - event.pageY)
			) >= this.options.distance
		);
	},

	_mouseDelayMet: function(/* event */) {
		return this.mouseDelayMet;
	},

	// These are placeholder methods, to be overriden by extending plugin
	_mouseStart: function(/* event */) {},
	_mouseDrag: function(/* event */) {},
	_mouseStop: function(/* event */) {},
	_mouseCapture: function(/* event */) { return true; }
});

})(jQuery);

}; 

exports(); 
module.resolveWith(exports); 

}); 
// module body: end

}; 
// module factory: end

FD40.module("ui/mouse", moduleFactory);

}());			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var jQuery = $; 
var exports = function() { 

/*!
 * jQuery UI Position 1.10.4pre
 * http://jqueryui.com
 *
 * Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/position/
 */
(function( $, undefined ) {

$.ui = $.ui || {};

var cachedScrollbarWidth,
	max = Math.max,
	abs = Math.abs,
	round = Math.round,
	rhorizontal = /left|center|right/,
	rvertical = /top|center|bottom/,
	roffset = /[\+\-]\d+(\.[\d]+)?%?/,
	rposition = /^\w+/,
	rpercent = /%$/,
	_position = $.fn.position;

function getOffsets( offsets, width, height ) {
	return [
		parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
		parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
	];
}

function parseCss( element, property ) {
	return parseInt( $.css( element, property ), 10 ) || 0;
}

function getDimensions( elem ) {
	var raw = elem[0];
	if ( raw.nodeType === 9 ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: 0, left: 0 }
		};
	}
	if ( $.isWindow( raw ) ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
		};
	}
	if ( raw.preventDefault ) {
		return {
			width: 0,
			height: 0,
			offset: { top: raw.pageY, left: raw.pageX }
		};
	}
	return {
		width: elem.outerWidth(),
		height: elem.outerHeight(),
		offset: elem.offset()
	};
}

$.position = {
	scrollbarWidth: function() {
		if ( cachedScrollbarWidth !== undefined ) {
			return cachedScrollbarWidth;
		}
		var w1, w2,
			div = $( "<div style='display:block;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>" ),
			innerDiv = div.children()[0];

		$( "body" ).append( div );
		w1 = innerDiv.offsetWidth;
		div.css( "overflow", "scroll" );

		w2 = innerDiv.offsetWidth;

		if ( w1 === w2 ) {
			w2 = div[0].clientWidth;
		}

		div.remove();

		return (cachedScrollbarWidth = w1 - w2);
	},
	getScrollInfo: function( within ) {
		var overflowX = within.isWindow ? "" : within.element.css( "overflow-x" ),
			overflowY = within.isWindow ? "" : within.element.css( "overflow-y" ),
			hasOverflowX = overflowX === "scroll" ||
				( overflowX === "auto" && within.width < within.element[0].scrollWidth ),
			hasOverflowY = overflowY === "scroll" ||
				( overflowY === "auto" && within.height < within.element[0].scrollHeight );
		return {
			width: hasOverflowY ? $.position.scrollbarWidth() : 0,
			height: hasOverflowX ? $.position.scrollbarWidth() : 0
		};
	},
	getWithinInfo: function( element ) {
		var withinElement = $( element || window ),
			isWindow = $.isWindow( withinElement[0] );
		return {
			element: withinElement,
			isWindow: isWindow,
			offset: withinElement.offset() || { left: 0, top: 0 },
			scrollLeft: withinElement.scrollLeft(),
			scrollTop: withinElement.scrollTop(),
			width: isWindow ? withinElement.width() : withinElement.outerWidth(),
			height: isWindow ? withinElement.height() : withinElement.outerHeight()
		};
	}
};

$.fn.position = function( options ) {
	if ( !options || !options.of ) {
		return _position.apply( this, arguments );
	}

	// make a copy, we don't want to modify arguments
	options = $.extend( {}, options );

	var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
		target = $( options.of ),
		within = $.position.getWithinInfo( options.within ),
		scrollInfo = $.position.getScrollInfo( within ),
		collision = ( options.collision || "flip" ).split( " " ),
		offsets = {};

	dimensions = getDimensions( target );
	if ( target[0].preventDefault ) {
		// force left top to allow flipping
		options.at = "left top";
	}
	targetWidth = dimensions.width;
	targetHeight = dimensions.height;
	targetOffset = dimensions.offset;
	// clone to reuse original targetOffset later
	basePosition = $.extend( {}, targetOffset );

	// force my and at to have valid horizontal and vertical positions
	// if a value is missing or invalid, it will be converted to center
	$.each( [ "my", "at" ], function() {
		var pos = ( options[ this ] || "" ).split( " " ),
			horizontalOffset,
			verticalOffset;

		if ( pos.length === 1) {
			pos = rhorizontal.test( pos[ 0 ] ) ?
				pos.concat( [ "center" ] ) :
				rvertical.test( pos[ 0 ] ) ?
					[ "center" ].concat( pos ) :
					[ "center", "center" ];
		}
		pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
		pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";

		// calculate offsets
		horizontalOffset = roffset.exec( pos[ 0 ] );
		verticalOffset = roffset.exec( pos[ 1 ] );
		offsets[ this ] = [
			horizontalOffset ? horizontalOffset[ 0 ] : 0,
			verticalOffset ? verticalOffset[ 0 ] : 0
		];

		// reduce to just the positions without the offsets
		options[ this ] = [
			rposition.exec( pos[ 0 ] )[ 0 ],
			rposition.exec( pos[ 1 ] )[ 0 ]
		];
	});

	// normalize collision option
	if ( collision.length === 1 ) {
		collision[ 1 ] = collision[ 0 ];
	}

	if ( options.at[ 0 ] === "right" ) {
		basePosition.left += targetWidth;
	} else if ( options.at[ 0 ] === "center" ) {
		basePosition.left += targetWidth / 2;
	}

	if ( options.at[ 1 ] === "bottom" ) {
		basePosition.top += targetHeight;
	} else if ( options.at[ 1 ] === "center" ) {
		basePosition.top += targetHeight / 2;
	}

	atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
	basePosition.left += atOffset[ 0 ];
	basePosition.top += atOffset[ 1 ];

	return this.each(function() {
		var collisionPosition, using,
			elem = $( this ),
			elemWidth = elem.outerWidth(),
			elemHeight = elem.outerHeight(),
			marginLeft = parseCss( this, "marginLeft" ),
			marginTop = parseCss( this, "marginTop" ),
			collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) + scrollInfo.width,
			collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) + scrollInfo.height,
			position = $.extend( {}, basePosition ),
			myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );

		if ( options.my[ 0 ] === "right" ) {
			position.left -= elemWidth;
		} else if ( options.my[ 0 ] === "center" ) {
			position.left -= elemWidth / 2;
		}

		if ( options.my[ 1 ] === "bottom" ) {
			position.top -= elemHeight;
		} else if ( options.my[ 1 ] === "center" ) {
			position.top -= elemHeight / 2;
		}

		position.left += myOffset[ 0 ];
		position.top += myOffset[ 1 ];

		// if the browser doesn't support fractions, then round for consistent results
		if ( !$.support.offsetFractions ) {
			position.left = round( position.left );
			position.top = round( position.top );
		}

		collisionPosition = {
			marginLeft: marginLeft,
			marginTop: marginTop
		};

		$.each( [ "left", "top" ], function( i, dir ) {
			if ( $.ui.position[ collision[ i ] ] ) {
				$.ui.position[ collision[ i ] ][ dir ]( position, {
					targetWidth: targetWidth,
					targetHeight: targetHeight,
					elemWidth: elemWidth,
					elemHeight: elemHeight,
					collisionPosition: collisionPosition,
					collisionWidth: collisionWidth,
					collisionHeight: collisionHeight,
					offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
					my: options.my,
					at: options.at,
					within: within,
					elem : elem
				});
			}
		});

		if ( options.using ) {
			// adds feedback as second argument to using callback, if present
			using = function( props ) {
				var left = targetOffset.left - position.left,
					right = left + targetWidth - elemWidth,
					top = targetOffset.top - position.top,
					bottom = top + targetHeight - elemHeight,
					feedback = {
						target: {
							element: target,
							left: targetOffset.left,
							top: targetOffset.top,
							width: targetWidth,
							height: targetHeight
						},
						element: {
							element: elem,
							left: position.left,
							top: position.top,
							width: elemWidth,
							height: elemHeight
						},
						horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
						vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
					};
				if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
					feedback.horizontal = "center";
				}
				if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
					feedback.vertical = "middle";
				}
				if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
					feedback.important = "horizontal";
				} else {
					feedback.important = "vertical";
				}
				options.using.call( this, props, feedback );
			};
		}

		elem.offset( $.extend( position, { using: using } ) );
	});
};

$.ui.position = {
	fit: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
				outerWidth = within.width,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = withinOffset - collisionPosLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
				newOverRight;

			// element is wider than within
			if ( data.collisionWidth > outerWidth ) {
				// element is initially over the left side of within
				if ( overLeft > 0 && overRight <= 0 ) {
					newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
					position.left += overLeft - newOverRight;
				// element is initially over right side of within
				} else if ( overRight > 0 && overLeft <= 0 ) {
					position.left = withinOffset;
				// element is initially over both left and right sides of within
				} else {
					if ( overLeft > overRight ) {
						position.left = withinOffset + outerWidth - data.collisionWidth;
					} else {
						position.left = withinOffset;
					}
				}
			// too far left -> align with left edge
			} else if ( overLeft > 0 ) {
				position.left += overLeft;
			// too far right -> align with right edge
			} else if ( overRight > 0 ) {
				position.left -= overRight;
			// adjust based on position and margin
			} else {
				position.left = max( position.left - collisionPosLeft, position.left );
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
				outerHeight = data.within.height,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = withinOffset - collisionPosTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
				newOverBottom;

			// element is taller than within
			if ( data.collisionHeight > outerHeight ) {
				// element is initially over the top of within
				if ( overTop > 0 && overBottom <= 0 ) {
					newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
					position.top += overTop - newOverBottom;
				// element is initially over bottom of within
				} else if ( overBottom > 0 && overTop <= 0 ) {
					position.top = withinOffset;
				// element is initially over both top and bottom of within
				} else {
					if ( overTop > overBottom ) {
						position.top = withinOffset + outerHeight - data.collisionHeight;
					} else {
						position.top = withinOffset;
					}
				}
			// too far up -> align with top
			} else if ( overTop > 0 ) {
				position.top += overTop;
			// too far down -> align with bottom edge
			} else if ( overBottom > 0 ) {
				position.top -= overBottom;
			// adjust based on position and margin
			} else {
				position.top = max( position.top - collisionPosTop, position.top );
			}
		}
	},
	flip: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.left + within.scrollLeft,
				outerWidth = within.width,
				offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = collisionPosLeft - offsetLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
				myOffset = data.my[ 0 ] === "left" ?
					-data.elemWidth :
					data.my[ 0 ] === "right" ?
						data.elemWidth :
						0,
				atOffset = data.at[ 0 ] === "left" ?
					data.targetWidth :
					data.at[ 0 ] === "right" ?
						-data.targetWidth :
						0,
				offset = -2 * data.offset[ 0 ],
				newOverRight,
				newOverLeft;

			if ( overLeft < 0 ) {
				newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
				if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
					position.left += myOffset + atOffset + offset;
				}
			}
			else if ( overRight > 0 ) {
				newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
				if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
					position.left += myOffset + atOffset + offset;
				}
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.top + within.scrollTop,
				outerHeight = within.height,
				offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = collisionPosTop - offsetTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
				top = data.my[ 1 ] === "top",
				myOffset = top ?
					-data.elemHeight :
					data.my[ 1 ] === "bottom" ?
						data.elemHeight :
						0,
				atOffset = data.at[ 1 ] === "top" ?
					data.targetHeight :
					data.at[ 1 ] === "bottom" ?
						-data.targetHeight :
						0,
				offset = -2 * data.offset[ 1 ],
				newOverTop,
				newOverBottom;
			if ( overTop < 0 ) {
				newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
				if ( ( position.top + myOffset + atOffset + offset) > overTop && ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) ) {
					position.top += myOffset + atOffset + offset;
				}
			}
			else if ( overBottom > 0 ) {
				newOverTop = position.top -  data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
				if ( ( position.top + myOffset + atOffset + offset) > overBottom && ( newOverTop > 0 || abs( newOverTop ) < overBottom ) ) {
					position.top += myOffset + atOffset + offset;
				}
			}
		}
	},
	flipfit: {
		left: function() {
			$.ui.position.flip.left.apply( this, arguments );
			$.ui.position.fit.left.apply( this, arguments );
		},
		top: function() {
			$.ui.position.flip.top.apply( this, arguments );
			$.ui.position.fit.top.apply( this, arguments );
		}
	}
};

// fraction support test
(function () {
	var testElement, testElementParent, testElementStyle, offsetLeft, i,
		body = document.getElementsByTagName( "body" )[ 0 ],
		div = document.createElement( "div" );

	//Create a "fake body" for testing based on method used in jQuery.support
	testElement = document.createElement( body ? "div" : "body" );
	testElementStyle = {
		visibility: "hidden",
		width: 0,
		height: 0,
		border: 0,
		margin: 0,
		background: "none"
	};
	if ( body ) {
		$.extend( testElementStyle, {
			position: "absolute",
			left: "-1000px",
			top: "-1000px"
		});
	}
	for ( i in testElementStyle ) {
		testElement.style[ i ] = testElementStyle[ i ];
	}
	testElement.appendChild( div );
	testElementParent = body || document.documentElement;
	testElementParent.insertBefore( testElement, testElementParent.firstChild );

	div.style.cssText = "position: absolute; left: 10.7432222px;";

	offsetLeft = $( div ).offset().left;
	$.support.offsetFractions = offsetLeft > 10 && offsetLeft < 11;

	testElement.innerHTML = "";
	testElementParent.removeChild( testElement );
})();

}( jQuery ) );

}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("ui/position", moduleFactory);

}());			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var jQuery = $; 
$.require() 
 .script("ui/core","ui/mouse","ui/widget") 
 .done(function() { 
var exports = function() { 

/*!
 * jQuery UI Resizable 1.10.4pre
 * http://jqueryui.com
 *
 * Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/resizable/
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

function num(v) {
	return parseInt(v, 10) || 0;
}

function isNumber(value) {
	return !isNaN(parseInt(value, 10));
}

$.widget("ui.resizable", $.ui.mouse, {
	version: "1.10.4pre",
	widgetEventPrefix: "resize",
	options: {
		alsoResize: false,
		animate: false,
		animateDuration: "slow",
		animateEasing: "swing",
		aspectRatio: false,
		autoHide: false,
		containment: false,
		ghost: false,
		grid: false,
		handles: "e,s,se",
		helper: false,
		maxHeight: null,
		maxWidth: null,
		minHeight: 10,
		minWidth: 10,
		// See #7960
		zIndex: 90,

		// callbacks
		resize: null,
		start: null,
		stop: null
	},
	_create: function() {

		var n, i, handle, axis, hname,
			that = this,
			o = this.options;
		this.element.addClass("ui-resizable");

		$.extend(this, {
			_aspectRatio: !!(o.aspectRatio),
			aspectRatio: o.aspectRatio,
			originalElement: this.element,
			_proportionallyResizeElements: [],
			_helper: o.helper || o.ghost || o.animate ? o.helper || "ui-resizable-helper" : null
		});

		//Wrap the element if it cannot hold child nodes
		if(this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)) {

			//Create a wrapper element and set the wrapper to the new current internal element
			this.element.wrap(
				$("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({
					position: this.element.css("position"),
					width: this.element.outerWidth(),
					height: this.element.outerHeight(),
					top: this.element.css("top"),
					left: this.element.css("left")
				})
			);

			//Overwrite the original this.element
			this.element = this.element.parent().data(
				"ui-resizable", this.element.data("ui-resizable")
			);

			this.elementIsWrapper = true;

			//Move margins to the wrapper
			this.element.css({ marginLeft: this.originalElement.css("marginLeft"), marginTop: this.originalElement.css("marginTop"), marginRight: this.originalElement.css("marginRight"), marginBottom: this.originalElement.css("marginBottom") });
			this.originalElement.css({ marginLeft: 0, marginTop: 0, marginRight: 0, marginBottom: 0});

			//Prevent Safari textarea resize
			this.originalResizeStyle = this.originalElement.css("resize");
			this.originalElement.css("resize", "none");

			//Push the actual element to our proportionallyResize internal array
			this._proportionallyResizeElements.push(this.originalElement.css({ position: "static", zoom: 1, display: "block" }));

			// avoid IE jump (hard set the margin)
			this.originalElement.css({ margin: this.originalElement.css("margin") });

			// fix handlers offset
			this._proportionallyResize();

		}

		this.handles = o.handles || (!$(".ui-resizable-handle", this.element).length ? "e,s,se" : { n: ".ui-resizable-n", e: ".ui-resizable-e", s: ".ui-resizable-s", w: ".ui-resizable-w", se: ".ui-resizable-se", sw: ".ui-resizable-sw", ne: ".ui-resizable-ne", nw: ".ui-resizable-nw" });
		if(this.handles.constructor === String) {

			if ( this.handles === "all") {
				this.handles = "n,e,s,w,se,sw,ne,nw";
			}

			n = this.handles.split(",");
			this.handles = {};

			for(i = 0; i < n.length; i++) {

				handle = $.trim(n[i]);
				hname = "ui-resizable-"+handle;
				axis = $("<div class='ui-resizable-handle " + hname + "'></div>");

				// Apply zIndex to all handles - see #7960
				axis.css({ zIndex: o.zIndex });

				//TODO : What's going on here?
				if ("se" === handle) {
					axis.addClass("ui-icon ui-icon-gripsmall-diagonal-se");
				}

				//Insert into internal handles object and append to element
				this.handles[handle] = ".ui-resizable-"+handle;
				this.element.append(axis);
			}

		}

		this._renderAxis = function(target) {

			var i, axis, padPos, padWrapper;

			target = target || this.element;

			for(i in this.handles) {

				if(this.handles[i].constructor === String) {
					this.handles[i] = $(this.handles[i], this.element).show();
				}

				//Apply pad to wrapper element, needed to fix axis position (textarea, inputs, scrolls)
				if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/textarea|input|select|button/i)) {

					axis = $(this.handles[i], this.element);

					//Checking the correct pad and border
					padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();

					//The padding type i have to apply...
					padPos = [ "padding",
						/ne|nw|n/.test(i) ? "Top" :
						/se|sw|s/.test(i) ? "Bottom" :
						/^e$/.test(i) ? "Right" : "Left" ].join("");

					target.css(padPos, padWrapper);

					this._proportionallyResize();

				}

				//TODO: What's that good for? There's not anything to be executed left
				if(!$(this.handles[i]).length) {
					continue;
				}
			}
		};

		//TODO: make renderAxis a prototype function
		this._renderAxis(this.element);

		this._handles = $(".ui-resizable-handle", this.element)
			.disableSelection();

		//Matching axis name
		this._handles.mouseover(function() {
			if (!that.resizing) {
				if (this.className) {
					axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
				}
				//Axis, default = se
				that.axis = axis && axis[1] ? axis[1] : "se";
			}
		});

		//If we want to auto hide the elements
		if (o.autoHide) {
			this._handles.hide();
			$(this.element)
				.addClass("ui-resizable-autohide")
				.mouseenter(function() {
					if (o.disabled) {
						return;
					}
					$(this).removeClass("ui-resizable-autohide");
					that._handles.show();
				})
				.mouseleave(function(){
					if (o.disabled) {
						return;
					}
					if (!that.resizing) {
						$(this).addClass("ui-resizable-autohide");
						that._handles.hide();
					}
				});
		}

		//Initialize the mouse interaction
		this._mouseInit();

	},

	_destroy: function() {

		this._mouseDestroy();

		var wrapper,
			_destroy = function(exp) {
				$(exp).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing")
					.removeData("resizable").removeData("ui-resizable").unbind(".resizable").find(".ui-resizable-handle").remove();
			};

		//TODO: Unwrap at same DOM position
		if (this.elementIsWrapper) {
			_destroy(this.element);
			wrapper = this.element;
			this.originalElement.css({
				position: wrapper.css("position"),
				width: wrapper.outerWidth(),
				height: wrapper.outerHeight(),
				top: wrapper.css("top"),
				left: wrapper.css("left")
			}).insertAfter( wrapper );
			wrapper.remove();
		}

		this.originalElement.css("resize", this.originalResizeStyle);
		_destroy(this.originalElement);

		return this;
	},

	_mouseCapture: function(event) {
		var i, handle,
			capture = false;

		for (i in this.handles) {
			handle = $(this.handles[i])[0];
			if (handle === event.target || $.contains(handle, event.target)) {
				capture = true;
			}
		}

		return !this.options.disabled && capture;
	},

	_mouseStart: function(event) {

		var curleft, curtop, cursor,
			o = this.options,
			iniPos = this.element.position(),
			el = this.element;

		this.resizing = true;

		// bugfix for http://dev.jquery.com/ticket/1749
		if ( (/absolute/).test( el.css("position") ) ) {
			el.css({ position: "absolute", top: el.css("top"), left: el.css("left") });
		} else if (el.is(".ui-draggable")) {
			el.css({ position: "absolute", top: iniPos.top, left: iniPos.left });
		}

		this._renderProxy();

		curleft = num(this.helper.css("left"));
		curtop = num(this.helper.css("top"));

		if (o.containment) {
			curleft += $(o.containment).scrollLeft() || 0;
			curtop += $(o.containment).scrollTop() || 0;
		}

		//Store needed variables
		this.offset = this.helper.offset();
		this.position = { left: curleft, top: curtop };
		this.size = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };
		this.originalSize = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };
		this.originalPosition = { left: curleft, top: curtop };
		this.sizeDiff = { width: el.outerWidth() - el.width(), height: el.outerHeight() - el.height() };
		this.originalMousePosition = { left: event.pageX, top: event.pageY };

		//Aspect Ratio
		this.aspectRatio = (typeof o.aspectRatio === "number") ? o.aspectRatio : ((this.originalSize.width / this.originalSize.height) || 1);

		cursor = $(".ui-resizable-" + this.axis).css("cursor");
		$("body").css("cursor", cursor === "auto" ? this.axis + "-resize" : cursor);

		el.addClass("ui-resizable-resizing");
		this._propagate("start", event);
		return true;
	},

	_mouseDrag: function(event) {

		//Increase performance, avoid regex
		var data,
			el = this.helper, props = {},
			smp = this.originalMousePosition,
			a = this.axis,
			prevTop = this.position.top,
			prevLeft = this.position.left,
			prevWidth = this.size.width,
			prevHeight = this.size.height,
			dx = (event.pageX-smp.left)||0,
			dy = (event.pageY-smp.top)||0,
			trigger = this._change[a];

		if (!trigger) {
			return false;
		}

		// Calculate the attrs that will be change
		data = trigger.apply(this, [event, dx, dy]);

		// Put this in the mouseDrag handler since the user can start pressing shift while resizing
		this._updateVirtualBoundaries(event.shiftKey);
		if (this._aspectRatio || event.shiftKey) {
			data = this._updateRatio(data, event);
		}

		data = this._respectSize(data, event);

		this._updateCache(data);

		// plugins callbacks need to be called first
		this._propagate("resize", event);

		if (this.position.top !== prevTop) {
			props.top = this.position.top + "px";
		}
		if (this.position.left !== prevLeft) {
			props.left = this.position.left + "px";
		}
		if (this.size.width !== prevWidth) {
			props.width = this.size.width + "px";
		}
		if (this.size.height !== prevHeight) {
			props.height = this.size.height + "px";
		}
		el.css(props);

		if (!this._helper && this._proportionallyResizeElements.length) {
			this._proportionallyResize();
		}

		// Call the user callback if the element was resized
		if ( ! $.isEmptyObject(props) ) {
			this._trigger("resize", event, this.ui());
		}

		return false;
	},

	_mouseStop: function(event) {

		this.resizing = false;
		var pr, ista, soffseth, soffsetw, s, left, top,
			o = this.options, that = this;

		if(this._helper) {

			pr = this._proportionallyResizeElements;
			ista = pr.length && (/textarea/i).test(pr[0].nodeName);
			soffseth = ista && $.ui.hasScroll(pr[0], "left") /* TODO - jump height */ ? 0 : that.sizeDiff.height;
			soffsetw = ista ? 0 : that.sizeDiff.width;

			s = { width: (that.helper.width()  - soffsetw), height: (that.helper.height() - soffseth) };
			left = (parseInt(that.element.css("left"), 10) + (that.position.left - that.originalPosition.left)) || null;
			top = (parseInt(that.element.css("top"), 10) + (that.position.top - that.originalPosition.top)) || null;

			if (!o.animate) {
				this.element.css($.extend(s, { top: top, left: left }));
			}

			that.helper.height(that.size.height);
			that.helper.width(that.size.width);

			if (this._helper && !o.animate) {
				this._proportionallyResize();
			}
		}

		$("body").css("cursor", "auto");

		this.element.removeClass("ui-resizable-resizing");

		this._propagate("stop", event);

		if (this._helper) {
			this.helper.remove();
		}

		return false;

	},

	_updateVirtualBoundaries: function(forceAspectRatio) {
		var pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b,
			o = this.options;

		b = {
			minWidth: isNumber(o.minWidth) ? o.minWidth : 0,
			maxWidth: isNumber(o.maxWidth) ? o.maxWidth : Infinity,
			minHeight: isNumber(o.minHeight) ? o.minHeight : 0,
			maxHeight: isNumber(o.maxHeight) ? o.maxHeight : Infinity
		};

		if(this._aspectRatio || forceAspectRatio) {
			// We want to create an enclosing box whose aspect ration is the requested one
			// First, compute the "projected" size for each dimension based on the aspect ratio and other dimension
			pMinWidth = b.minHeight * this.aspectRatio;
			pMinHeight = b.minWidth / this.aspectRatio;
			pMaxWidth = b.maxHeight * this.aspectRatio;
			pMaxHeight = b.maxWidth / this.aspectRatio;

			if(pMinWidth > b.minWidth) {
				b.minWidth = pMinWidth;
			}
			if(pMinHeight > b.minHeight) {
				b.minHeight = pMinHeight;
			}
			if(pMaxWidth < b.maxWidth) {
				b.maxWidth = pMaxWidth;
			}
			if(pMaxHeight < b.maxHeight) {
				b.maxHeight = pMaxHeight;
			}
		}
		this._vBoundaries = b;
	},

	_updateCache: function(data) {
		this.offset = this.helper.offset();
		if (isNumber(data.left)) {
			this.position.left = data.left;
		}
		if (isNumber(data.top)) {
			this.position.top = data.top;
		}
		if (isNumber(data.height)) {
			this.size.height = data.height;
		}
		if (isNumber(data.width)) {
			this.size.width = data.width;
		}
	},

	_updateRatio: function( data ) {

		var cpos = this.position,
			csize = this.size,
			a = this.axis;

		if (isNumber(data.height)) {
			data.width = (data.height * this.aspectRatio);
		} else if (isNumber(data.width)) {
			data.height = (data.width / this.aspectRatio);
		}

		if (a === "sw") {
			data.left = cpos.left + (csize.width - data.width);
			data.top = null;
		}
		if (a === "nw") {
			data.top = cpos.top + (csize.height - data.height);
			data.left = cpos.left + (csize.width - data.width);
		}

		return data;
	},

	_respectSize: function( data ) {

		var o = this._vBoundaries,
			a = this.axis,
			ismaxw = isNumber(data.width) && o.maxWidth && (o.maxWidth < data.width), ismaxh = isNumber(data.height) && o.maxHeight && (o.maxHeight < data.height),
			isminw = isNumber(data.width) && o.minWidth && (o.minWidth > data.width), isminh = isNumber(data.height) && o.minHeight && (o.minHeight > data.height),
			dw = this.originalPosition.left + this.originalSize.width,
			dh = this.position.top + this.size.height,
			cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);
		if (isminw) {
			data.width = o.minWidth;
		}
		if (isminh) {
			data.height = o.minHeight;
		}
		if (ismaxw) {
			data.width = o.maxWidth;
		}
		if (ismaxh) {
			data.height = o.maxHeight;
		}

		if (isminw && cw) {
			data.left = dw - o.minWidth;
		}
		if (ismaxw && cw) {
			data.left = dw - o.maxWidth;
		}
		if (isminh && ch) {
			data.top = dh - o.minHeight;
		}
		if (ismaxh && ch) {
			data.top = dh - o.maxHeight;
		}

		// fixing jump error on top/left - bug #2330
		if (!data.width && !data.height && !data.left && data.top) {
			data.top = null;
		} else if (!data.width && !data.height && !data.top && data.left) {
			data.left = null;
		}

		return data;
	},

	_proportionallyResize: function() {

		if (!this._proportionallyResizeElements.length) {
			return;
		}

		var i, j, borders, paddings, prel,
			element = this.helper || this.element;

		for ( i=0; i < this._proportionallyResizeElements.length; i++) {

			prel = this._proportionallyResizeElements[i];

			if (!this.borderDif) {
				this.borderDif = [];
				borders = [prel.css("borderTopWidth"), prel.css("borderRightWidth"), prel.css("borderBottomWidth"), prel.css("borderLeftWidth")];
				paddings = [prel.css("paddingTop"), prel.css("paddingRight"), prel.css("paddingBottom"), prel.css("paddingLeft")];

				for ( j = 0; j < borders.length; j++ ) {
					this.borderDif[ j ] = ( parseInt( borders[ j ], 10 ) || 0 ) + ( parseInt( paddings[ j ], 10 ) || 0 );
				}
			}

			prel.css({
				height: (element.height() - this.borderDif[0] - this.borderDif[2]) || 0,
				width: (element.width() - this.borderDif[1] - this.borderDif[3]) || 0
			});

		}

	},

	_renderProxy: function() {

		var el = this.element, o = this.options;
		this.elementOffset = el.offset();

		if(this._helper) {

			this.helper = this.helper || $("<div style='overflow:hidden;'></div>");

			this.helper.addClass(this._helper).css({
				width: this.element.outerWidth() - 1,
				height: this.element.outerHeight() - 1,
				position: "absolute",
				left: this.elementOffset.left +"px",
				top: this.elementOffset.top +"px",
				zIndex: ++o.zIndex //TODO: Don't modify option
			});

			this.helper
				.appendTo("body")
				.disableSelection();

		} else {
			this.helper = this.element;
		}

	},

	_change: {
		e: function(event, dx) {
			return { width: this.originalSize.width + dx };
		},
		w: function(event, dx) {
			var cs = this.originalSize, sp = this.originalPosition;
			return { left: sp.left + dx, width: cs.width - dx };
		},
		n: function(event, dx, dy) {
			var cs = this.originalSize, sp = this.originalPosition;
			return { top: sp.top + dy, height: cs.height - dy };
		},
		s: function(event, dx, dy) {
			return { height: this.originalSize.height + dy };
		},
		se: function(event, dx, dy) {
			return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
		},
		sw: function(event, dx, dy) {
			return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
		},
		ne: function(event, dx, dy) {
			return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
		},
		nw: function(event, dx, dy) {
			return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
		}
	},

	_propagate: function(n, event) {
		$.ui.plugin.call(this, n, [event, this.ui()]);
		(n !== "resize" && this._trigger(n, event, this.ui()));
	},

	plugins: {},

	ui: function() {
		return {
			originalElement: this.originalElement,
			element: this.element,
			helper: this.helper,
			position: this.position,
			size: this.size,
			originalSize: this.originalSize,
			originalPosition: this.originalPosition
		};
	}

});

/*
 * Resizable Extensions
 */

$.ui.plugin.add("resizable", "animate", {

	stop: function( event ) {
		var that = $(this).data("ui-resizable"),
			o = that.options,
			pr = that._proportionallyResizeElements,
			ista = pr.length && (/textarea/i).test(pr[0].nodeName),
			soffseth = ista && $.ui.hasScroll(pr[0], "left") /* TODO - jump height */ ? 0 : that.sizeDiff.height,
			soffsetw = ista ? 0 : that.sizeDiff.width,
			style = { width: (that.size.width - soffsetw), height: (that.size.height - soffseth) },
			left = (parseInt(that.element.css("left"), 10) + (that.position.left - that.originalPosition.left)) || null,
			top = (parseInt(that.element.css("top"), 10) + (that.position.top - that.originalPosition.top)) || null;

		that.element.animate(
			$.extend(style, top && left ? { top: top, left: left } : {}), {
				duration: o.animateDuration,
				easing: o.animateEasing,
				step: function() {

					var data = {
						width: parseInt(that.element.css("width"), 10),
						height: parseInt(that.element.css("height"), 10),
						top: parseInt(that.element.css("top"), 10),
						left: parseInt(that.element.css("left"), 10)
					};

					if (pr && pr.length) {
						$(pr[0]).css({ width: data.width, height: data.height });
					}

					// propagating resize, and updating values for each animation step
					that._updateCache(data);
					that._propagate("resize", event);

				}
			}
		);
	}

});

$.ui.plugin.add("resizable", "containment", {

	start: function() {
		var element, p, co, ch, cw, width, height,
			that = $(this).data("ui-resizable"),
			o = that.options,
			el = that.element,
			oc = o.containment,
			ce = (oc instanceof $) ? oc.get(0) : (/parent/.test(oc)) ? el.parent().get(0) : oc;

		if (!ce) {
			return;
		}

		that.containerElement = $(ce);

		if (/document/.test(oc) || oc === document) {
			that.containerOffset = { left: 0, top: 0 };
			that.containerPosition = { left: 0, top: 0 };

			that.parentData = {
				element: $(document), left: 0, top: 0,
				width: $(document).width(), height: $(document).height() || document.body.parentNode.scrollHeight
			};
		}

		// i'm a node, so compute top, left, right, bottom
		else {
			element = $(ce);
			p = [];
			$([ "Top", "Right", "Left", "Bottom" ]).each(function(i, name) { p[i] = num(element.css("padding" + name)); });

			that.containerOffset = element.offset();
			that.containerPosition = element.position();
			that.containerSize = { height: (element.innerHeight() - p[3]), width: (element.innerWidth() - p[1]) };

			co = that.containerOffset;
			ch = that.containerSize.height;
			cw = that.containerSize.width;
			width = ($.ui.hasScroll(ce, "left") ? ce.scrollWidth : cw );
			height = ($.ui.hasScroll(ce) ? ce.scrollHeight : ch);

			that.parentData = {
				element: ce, left: co.left, top: co.top, width: width, height: height
			};
		}
	},

	resize: function( event ) {
		var woset, hoset, isParent, isOffsetRelative,
			that = $(this).data("ui-resizable"),
			o = that.options,
			co = that.containerOffset, cp = that.position,
			pRatio = that._aspectRatio || event.shiftKey,
			cop = { top:0, left:0 }, ce = that.containerElement;

		if (ce[0] !== document && (/static/).test(ce.css("position"))) {
			cop = co;
		}

		if (cp.left < (that._helper ? co.left : 0)) {
			that.size.width = that.size.width + (that._helper ? (that.position.left - co.left) : (that.position.left - cop.left));
			if (pRatio) {
				that.size.height = that.size.width / that.aspectRatio;
			}
			that.position.left = o.helper ? co.left : 0;
		}

		if (cp.top < (that._helper ? co.top : 0)) {
			that.size.height = that.size.height + (that._helper ? (that.position.top - co.top) : that.position.top);
			if (pRatio) {
				that.size.width = that.size.height * that.aspectRatio;
			}
			that.position.top = that._helper ? co.top : 0;
		}

		that.offset.left = that.parentData.left+that.position.left;
		that.offset.top = that.parentData.top+that.position.top;

		woset = Math.abs( (that._helper ? that.offset.left - cop.left : (that.offset.left - cop.left)) + that.sizeDiff.width );
		hoset = Math.abs( (that._helper ? that.offset.top - cop.top : (that.offset.top - co.top)) + that.sizeDiff.height );

		isParent = that.containerElement.get(0) === that.element.parent().get(0);
		isOffsetRelative = /relative|absolute/.test(that.containerElement.css("position"));

		if(isParent && isOffsetRelative) {
			woset -= that.parentData.left;
		}

		if (woset + that.size.width >= that.parentData.width) {
			that.size.width = that.parentData.width - woset;
			if (pRatio) {
				that.size.height = that.size.width / that.aspectRatio;
			}
		}

		if (hoset + that.size.height >= that.parentData.height) {
			that.size.height = that.parentData.height - hoset;
			if (pRatio) {
				that.size.width = that.size.height * that.aspectRatio;
			}
		}
	},

	stop: function(){
		var that = $(this).data("ui-resizable"),
			o = that.options,
			co = that.containerOffset,
			cop = that.containerPosition,
			ce = that.containerElement,
			helper = $(that.helper),
			ho = helper.offset(),
			w = helper.outerWidth() - that.sizeDiff.width,
			h = helper.outerHeight() - that.sizeDiff.height;

		if (that._helper && !o.animate && (/relative/).test(ce.css("position"))) {
			$(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });
		}

		if (that._helper && !o.animate && (/static/).test(ce.css("position"))) {
			$(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });
		}

	}
});

$.ui.plugin.add("resizable", "alsoResize", {

	start: function () {
		var that = $(this).data("ui-resizable"),
			o = that.options,
			_store = function (exp) {
				$(exp).each(function() {
					var el = $(this);
					el.data("ui-resizable-alsoresize", {
						width: parseInt(el.width(), 10), height: parseInt(el.height(), 10),
						left: parseInt(el.css("left"), 10), top: parseInt(el.css("top"), 10)
					});
				});
			};

		if (typeof(o.alsoResize) === "object" && !o.alsoResize.parentNode) {
			if (o.alsoResize.length) { o.alsoResize = o.alsoResize[0]; _store(o.alsoResize); }
			else { $.each(o.alsoResize, function (exp) { _store(exp); }); }
		}else{
			_store(o.alsoResize);
		}
	},

	resize: function (event, ui) {
		var that = $(this).data("ui-resizable"),
			o = that.options,
			os = that.originalSize,
			op = that.originalPosition,
			delta = {
				height: (that.size.height - os.height) || 0, width: (that.size.width - os.width) || 0,
				top: (that.position.top - op.top) || 0, left: (that.position.left - op.left) || 0
			},

			_alsoResize = function (exp, c) {
				$(exp).each(function() {
					var el = $(this), start = $(this).data("ui-resizable-alsoresize"), style = {},
						css = c && c.length ? c : el.parents(ui.originalElement[0]).length ? ["width", "height"] : ["width", "height", "top", "left"];

					$.each(css, function (i, prop) {
						var sum = (start[prop]||0) + (delta[prop]||0);
						if (sum && sum >= 0) {
							style[prop] = sum || null;
						}
					});

					el.css(style);
				});
			};

		if (typeof(o.alsoResize) === "object" && !o.alsoResize.nodeType) {
			$.each(o.alsoResize, function (exp, c) { _alsoResize(exp, c); });
		}else{
			_alsoResize(o.alsoResize);
		}
	},

	stop: function () {
		$(this).removeData("resizable-alsoresize");
	}
});

$.ui.plugin.add("resizable", "ghost", {

	start: function() {

		var that = $(this).data("ui-resizable"), o = that.options, cs = that.size;

		that.ghost = that.originalElement.clone();
		that.ghost
			.css({ opacity: 0.25, display: "block", position: "relative", height: cs.height, width: cs.width, margin: 0, left: 0, top: 0 })
			.addClass("ui-resizable-ghost")
			.addClass(typeof o.ghost === "string" ? o.ghost : "");

		that.ghost.appendTo(that.helper);

	},

	resize: function(){
		var that = $(this).data("ui-resizable");
		if (that.ghost) {
			that.ghost.css({ position: "relative", height: that.size.height, width: that.size.width });
		}
	},

	stop: function() {
		var that = $(this).data("ui-resizable");
		if (that.ghost && that.helper) {
			that.helper.get(0).removeChild(that.ghost.get(0));
		}
	}

});

$.ui.plugin.add("resizable", "grid", {

	resize: function() {
		var that = $(this).data("ui-resizable"),
			o = that.options,
			cs = that.size,
			os = that.originalSize,
			op = that.originalPosition,
			a = that.axis,
			grid = typeof o.grid === "number" ? [o.grid, o.grid] : o.grid,
			gridX = (grid[0]||1),
			gridY = (grid[1]||1),
			ox = Math.round((cs.width - os.width) / gridX) * gridX,
			oy = Math.round((cs.height - os.height) / gridY) * gridY,
			newWidth = os.width + ox,
			newHeight = os.height + oy,
			isMaxWidth = o.maxWidth && (o.maxWidth < newWidth),
			isMaxHeight = o.maxHeight && (o.maxHeight < newHeight),
			isMinWidth = o.minWidth && (o.minWidth > newWidth),
			isMinHeight = o.minHeight && (o.minHeight > newHeight);

		o.grid = grid;

		if (isMinWidth) {
			newWidth = newWidth + gridX;
		}
		if (isMinHeight) {
			newHeight = newHeight + gridY;
		}
		if (isMaxWidth) {
			newWidth = newWidth - gridX;
		}
		if (isMaxHeight) {
			newHeight = newHeight - gridY;
		}

		if (/^(se|s|e)$/.test(a)) {
			that.size.width = newWidth;
			that.size.height = newHeight;
		} else if (/^(ne)$/.test(a)) {
			that.size.width = newWidth;
			that.size.height = newHeight;
			that.position.top = op.top - oy;
		} else if (/^(sw)$/.test(a)) {
			that.size.width = newWidth;
			that.size.height = newHeight;
			that.position.left = op.left - ox;
		} else {
			that.size.width = newWidth;
			that.size.height = newHeight;
			that.position.top = op.top - oy;
			that.position.left = op.left - ox;
		}
	}

});

})(jQuery);

}; 

exports(); 
module.resolveWith(exports); 

}); 
// module body: end

}; 
// module factory: end

FD40.module("ui/resizable", moduleFactory);

}());			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var jQuery = $; 
$.require() 
 .script("ui/core","ui/mouse","ui/widget") 
 .done(function() { 
var exports = function() { 

/*!
 * jQuery UI Slider 1.10.4pre
 * http://jqueryui.com
 *
 * Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/slider/
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

// number of pages in a slider
// (how many times can you page up/down to go through the whole range)
var numPages = 5;

$.widget( "ui.slider", $.ui.mouse, {
	version: "1.10.4pre",
	widgetEventPrefix: "slide",

	options: {
		animate: false,
		distance: 0,
		max: 100,
		min: 0,
		orientation: "horizontal",
		range: false,
		step: 1,
		value: 0,
		values: null,

		// callbacks
		change: null,
		slide: null,
		start: null,
		stop: null
	},

	_create: function() {
		this._keySliding = false;
		this._mouseSliding = false;
		this._animateOff = true;
		this._handleIndex = null;
		this._detectOrientation();
		this._mouseInit();

		this.element
			.addClass( "ui-slider" +
				" ui-slider-" + this.orientation +
				" ui-widget" +
				" ui-widget-content" +
				" ui-corner-all");

		this._refresh();
		this._setOption( "disabled", this.options.disabled );

		this._animateOff = false;
	},

	_refresh: function() {
		this._createRange();
		this._createHandles();
		this._setupEvents();
		this._refreshValue();
	},

	_createHandles: function() {
		var i, handleCount,
			options = this.options,
			existingHandles = this.element.find( ".ui-slider-handle" ).addClass( "ui-state-default ui-corner-all" ),
			handle = "<a class='ui-slider-handle ui-state-default ui-corner-all' href='#'></a>",
			handles = [];

		handleCount = ( options.values && options.values.length ) || 1;

		if ( existingHandles.length > handleCount ) {
			existingHandles.slice( handleCount ).remove();
			existingHandles = existingHandles.slice( 0, handleCount );
		}

		for ( i = existingHandles.length; i < handleCount; i++ ) {
			handles.push( handle );
		}

		this.handles = existingHandles.add( $( handles.join( "" ) ).appendTo( this.element ) );

		this.handle = this.handles.eq( 0 );

		this.handles.each(function( i ) {
			$( this ).data( "ui-slider-handle-index", i );
		});
	},

	_createRange: function() {
		var options = this.options,
			classes = "";

		if ( options.range ) {
			if ( options.range === true ) {
				if ( !options.values ) {
					options.values = [ this._valueMin(), this._valueMin() ];
				} else if ( options.values.length && options.values.length !== 2 ) {
					options.values = [ options.values[0], options.values[0] ];
				} else if ( $.isArray( options.values ) ) {
					options.values = options.values.slice(0);
				}
			}

			if ( !this.range || !this.range.length ) {
				this.range = $( "<div></div>" )
					.appendTo( this.element );

				classes = "ui-slider-range" +
				// note: this isn't the most fittingly semantic framework class for this element,
				// but worked best visually with a variety of themes
				" ui-widget-header ui-corner-all";
			} else {
				this.range.removeClass( "ui-slider-range-min ui-slider-range-max" )
					// Handle range switching from true to min/max
					.css({
						"left": "",
						"bottom": ""
					});
			}

			this.range.addClass( classes +
				( ( options.range === "min" || options.range === "max" ) ? " ui-slider-range-" + options.range : "" ) );
		} else {
			this.range = $([]);
		}
	},

	_setupEvents: function() {
		var elements = this.handles.add( this.range ).filter( "a" );
		this._off( elements );
		this._on( elements, this._handleEvents );
		this._hoverable( elements );
		this._focusable( elements );
	},

	_destroy: function() {
		this.handles.remove();
		this.range.remove();

		this.element
			.removeClass( "ui-slider" +
				" ui-slider-horizontal" +
				" ui-slider-vertical" +
				" ui-widget" +
				" ui-widget-content" +
				" ui-corner-all" );

		this._mouseDestroy();
	},

	_mouseCapture: function( event ) {
		var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle,
			that = this,
			o = this.options;

		if ( o.disabled ) {
			return false;
		}

		this.elementSize = {
			width: this.element.outerWidth(),
			height: this.element.outerHeight()
		};
		this.elementOffset = this.element.offset();

		position = { x: event.pageX, y: event.pageY };
		normValue = this._normValueFromMouse( position );
		distance = this._valueMax() - this._valueMin() + 1;
		this.handles.each(function( i ) {
			var thisDistance = Math.abs( normValue - that.values(i) );
			if (( distance > thisDistance ) ||
				( distance === thisDistance &&
					(i === that._lastChangedValue || that.values(i) === o.min ))) {
				distance = thisDistance;
				closestHandle = $( this );
				index = i;
			}
		});

		allowed = this._start( event, index );
		if ( allowed === false ) {
			return false;
		}
		this._mouseSliding = true;

		this._handleIndex = index;

		closestHandle
			.addClass( "ui-state-active" )
			.focus();

		offset = closestHandle.offset();
		mouseOverHandle = !$( event.target ).parents().addBack().is( ".ui-slider-handle" );
		this._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : {
			left: event.pageX - offset.left - ( closestHandle.width() / 2 ),
			top: event.pageY - offset.top -
				( closestHandle.height() / 2 ) -
				( parseInt( closestHandle.css("borderTopWidth"), 10 ) || 0 ) -
				( parseInt( closestHandle.css("borderBottomWidth"), 10 ) || 0) +
				( parseInt( closestHandle.css("marginTop"), 10 ) || 0)
		};

		if ( !this.handles.hasClass( "ui-state-hover" ) ) {
			this._slide( event, index, normValue );
		}
		this._animateOff = true;
		return true;
	},

	_mouseStart: function() {
		return true;
	},

	_mouseDrag: function( event ) {
		var position = { x: event.pageX, y: event.pageY },
			normValue = this._normValueFromMouse( position );

		this._slide( event, this._handleIndex, normValue );

		return false;
	},

	_mouseStop: function( event ) {
		this.handles.removeClass( "ui-state-active" );
		this._mouseSliding = false;

		this._stop( event, this._handleIndex );
		this._change( event, this._handleIndex );

		this._handleIndex = null;
		this._clickOffset = null;
		this._animateOff = false;

		return false;
	},

	_detectOrientation: function() {
		this.orientation = ( this.options.orientation === "vertical" ) ? "vertical" : "horizontal";
	},

	_normValueFromMouse: function( position ) {
		var pixelTotal,
			pixelMouse,
			percentMouse,
			valueTotal,
			valueMouse;

		if ( this.orientation === "horizontal" ) {
			pixelTotal = this.elementSize.width;
			pixelMouse = position.x - this.elementOffset.left - ( this._clickOffset ? this._clickOffset.left : 0 );
		} else {
			pixelTotal = this.elementSize.height;
			pixelMouse = position.y - this.elementOffset.top - ( this._clickOffset ? this._clickOffset.top : 0 );
		}

		percentMouse = ( pixelMouse / pixelTotal );
		if ( percentMouse > 1 ) {
			percentMouse = 1;
		}
		if ( percentMouse < 0 ) {
			percentMouse = 0;
		}
		if ( this.orientation === "vertical" ) {
			percentMouse = 1 - percentMouse;
		}

		valueTotal = this._valueMax() - this._valueMin();
		valueMouse = this._valueMin() + percentMouse * valueTotal;

		return this._trimAlignValue( valueMouse );
	},

	_start: function( event, index ) {
		var uiHash = {
			handle: this.handles[ index ],
			value: this.value()
		};
		if ( this.options.values && this.options.values.length ) {
			uiHash.value = this.values( index );
			uiHash.values = this.values();
		}
		return this._trigger( "start", event, uiHash );
	},

	_slide: function( event, index, newVal ) {
		var otherVal,
			newValues,
			allowed;

		if ( this.options.values && this.options.values.length ) {
			otherVal = this.values( index ? 0 : 1 );

			if ( ( this.options.values.length === 2 && this.options.range === true ) &&
					( ( index === 0 && newVal > otherVal) || ( index === 1 && newVal < otherVal ) )
				) {
				newVal = otherVal;
			}

			if ( newVal !== this.values( index ) ) {
				newValues = this.values();
				newValues[ index ] = newVal;
				// A slide can be canceled by returning false from the slide callback
				allowed = this._trigger( "slide", event, {
					handle: this.handles[ index ],
					value: newVal,
					values: newValues
				} );
				otherVal = this.values( index ? 0 : 1 );
				if ( allowed !== false ) {
					this.values( index, newVal, true );
				}
			}
		} else {
			if ( newVal !== this.value() ) {
				// A slide can be canceled by returning false from the slide callback
				allowed = this._trigger( "slide", event, {
					handle: this.handles[ index ],
					value: newVal
				} );
				if ( allowed !== false ) {
					this.value( newVal );
				}
			}
		}
	},

	_stop: function( event, index ) {
		var uiHash = {
			handle: this.handles[ index ],
			value: this.value()
		};
		if ( this.options.values && this.options.values.length ) {
			uiHash.value = this.values( index );
			uiHash.values = this.values();
		}

		this._trigger( "stop", event, uiHash );
	},

	_change: function( event, index ) {
		if ( !this._keySliding && !this._mouseSliding ) {
			var uiHash = {
				handle: this.handles[ index ],
				value: this.value()
			};
			if ( this.options.values && this.options.values.length ) {
				uiHash.value = this.values( index );
				uiHash.values = this.values();
			}

			//store the last changed value index for reference when handles overlap
			this._lastChangedValue = index;

			this._trigger( "change", event, uiHash );
		}
	},

	value: function( newValue ) {
		if ( arguments.length ) {
			this.options.value = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, 0 );
			return;
		}

		return this._value();
	},

	values: function( index, newValue ) {
		var vals,
			newValues,
			i;

		if ( arguments.length > 1 ) {
			this.options.values[ index ] = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, index );
			return;
		}

		if ( arguments.length ) {
			if ( $.isArray( arguments[ 0 ] ) ) {
				vals = this.options.values;
				newValues = arguments[ 0 ];
				for ( i = 0; i < vals.length; i += 1 ) {
					vals[ i ] = this._trimAlignValue( newValues[ i ] );
					this._change( null, i );
				}
				this._refreshValue();
			} else {
				if ( this.options.values && this.options.values.length ) {
					return this._values( index );
				} else {
					return this.value();
				}
			}
		} else {
			return this._values();
		}
	},

	_setOption: function( key, value ) {
		var i,
			valsLength = 0;

		if ( key === "range" && this.options.range === true ) {
			if ( value === "min" ) {
				this.options.value = this._values( 0 );
				this.options.values = null;
			} else if ( value === "max" ) {
				this.options.value = this._values( this.options.values.length-1 );
				this.options.values = null;
			}
		}

		if ( $.isArray( this.options.values ) ) {
			valsLength = this.options.values.length;
		}

		$.Widget.prototype._setOption.apply( this, arguments );

		switch ( key ) {
			case "orientation":
				this._detectOrientation();
				this.element
					.removeClass( "ui-slider-horizontal ui-slider-vertical" )
					.addClass( "ui-slider-" + this.orientation );
				this._refreshValue();
				break;
			case "value":
				this._animateOff = true;
				this._refreshValue();
				this._change( null, 0 );
				this._animateOff = false;
				break;
			case "values":
				this._animateOff = true;
				this._refreshValue();
				for ( i = 0; i < valsLength; i += 1 ) {
					this._change( null, i );
				}
				this._animateOff = false;
				break;
			case "min":
			case "max":
				this._animateOff = true;
				this._refreshValue();
				this._animateOff = false;
				break;
			case "range":
				this._animateOff = true;
				this._refresh();
				this._animateOff = false;
				break;
		}
	},

	//internal value getter
	// _value() returns value trimmed by min and max, aligned by step
	_value: function() {
		var val = this.options.value;
		val = this._trimAlignValue( val );

		return val;
	},

	//internal values getter
	// _values() returns array of values trimmed by min and max, aligned by step
	// _values( index ) returns single value trimmed by min and max, aligned by step
	_values: function( index ) {
		var val,
			vals,
			i;

		if ( arguments.length ) {
			val = this.options.values[ index ];
			val = this._trimAlignValue( val );

			return val;
		} else if ( this.options.values && this.options.values.length ) {
			// .slice() creates a copy of the array
			// this copy gets trimmed by min and max and then returned
			vals = this.options.values.slice();
			for ( i = 0; i < vals.length; i+= 1) {
				vals[ i ] = this._trimAlignValue( vals[ i ] );
			}

			return vals;
		} else {
			return [];
		}
	},

	// returns the step-aligned value that val is closest to, between (inclusive) min and max
	_trimAlignValue: function( val ) {
		if ( val <= this._valueMin() ) {
			return this._valueMin();
		}
		if ( val >= this._valueMax() ) {
			return this._valueMax();
		}
		var step = ( this.options.step > 0 ) ? this.options.step : 1,
			valModStep = (val - this._valueMin()) % step,
			alignValue = val - valModStep;

		if ( Math.abs(valModStep) * 2 >= step ) {
			alignValue += ( valModStep > 0 ) ? step : ( -step );
		}

		// Since JavaScript has problems with large floats, round
		// the final value to 5 digits after the decimal point (see #4124)
		return parseFloat( alignValue.toFixed(5) );
	},

	_valueMin: function() {
		return this.options.min;
	},

	_valueMax: function() {
		return this.options.max;
	},

	_refreshValue: function() {
		var lastValPercent, valPercent, value, valueMin, valueMax,
			oRange = this.options.range,
			o = this.options,
			that = this,
			animate = ( !this._animateOff ) ? o.animate : false,
			_set = {};

		if ( this.options.values && this.options.values.length ) {
			this.handles.each(function( i ) {
				valPercent = ( that.values(i) - that._valueMin() ) / ( that._valueMax() - that._valueMin() ) * 100;
				_set[ that.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
				$( this ).stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );
				if ( that.options.range === true ) {
					if ( that.orientation === "horizontal" ) {
						if ( i === 0 ) {
							that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { left: valPercent + "%" }, o.animate );
						}
						if ( i === 1 ) {
							that.range[ animate ? "animate" : "css" ]( { width: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
						}
					} else {
						if ( i === 0 ) {
							that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { bottom: ( valPercent ) + "%" }, o.animate );
						}
						if ( i === 1 ) {
							that.range[ animate ? "animate" : "css" ]( { height: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
						}
					}
				}
				lastValPercent = valPercent;
			});
		} else {
			value = this.value();
			valueMin = this._valueMin();
			valueMax = this._valueMax();
			valPercent = ( valueMax !== valueMin ) ?
					( value - valueMin ) / ( valueMax - valueMin ) * 100 :
					0;
			_set[ this.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
			this.handle.stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );

			if ( oRange === "min" && this.orientation === "horizontal" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { width: valPercent + "%" }, o.animate );
			}
			if ( oRange === "max" && this.orientation === "horizontal" ) {
				this.range[ animate ? "animate" : "css" ]( { width: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
			}
			if ( oRange === "min" && this.orientation === "vertical" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { height: valPercent + "%" }, o.animate );
			}
			if ( oRange === "max" && this.orientation === "vertical" ) {
				this.range[ animate ? "animate" : "css" ]( { height: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
			}
		}
	},

	_handleEvents: {
		keydown: function( event ) {
			/*jshint maxcomplexity:25*/
			var allowed, curVal, newVal, step,
				index = $( event.target ).data( "ui-slider-handle-index" );

			switch ( event.keyCode ) {
				case $.ui.keyCode.HOME:
				case $.ui.keyCode.END:
				case $.ui.keyCode.PAGE_UP:
				case $.ui.keyCode.PAGE_DOWN:
				case $.ui.keyCode.UP:
				case $.ui.keyCode.RIGHT:
				case $.ui.keyCode.DOWN:
				case $.ui.keyCode.LEFT:
					event.preventDefault();
					if ( !this._keySliding ) {
						this._keySliding = true;
						$( event.target ).addClass( "ui-state-active" );
						allowed = this._start( event, index );
						if ( allowed === false ) {
							return;
						}
					}
					break;
			}

			step = this.options.step;
			if ( this.options.values && this.options.values.length ) {
				curVal = newVal = this.values( index );
			} else {
				curVal = newVal = this.value();
			}

			switch ( event.keyCode ) {
				case $.ui.keyCode.HOME:
					newVal = this._valueMin();
					break;
				case $.ui.keyCode.END:
					newVal = this._valueMax();
					break;
				case $.ui.keyCode.PAGE_UP:
					newVal = this._trimAlignValue( curVal + ( (this._valueMax() - this._valueMin()) / numPages ) );
					break;
				case $.ui.keyCode.PAGE_DOWN:
					newVal = this._trimAlignValue( curVal - ( (this._valueMax() - this._valueMin()) / numPages ) );
					break;
				case $.ui.keyCode.UP:
				case $.ui.keyCode.RIGHT:
					if ( curVal === this._valueMax() ) {
						return;
					}
					newVal = this._trimAlignValue( curVal + step );
					break;
				case $.ui.keyCode.DOWN:
				case $.ui.keyCode.LEFT:
					if ( curVal === this._valueMin() ) {
						return;
					}
					newVal = this._trimAlignValue( curVal - step );
					break;
			}

			this._slide( event, index, newVal );
		},
		click: function( event ) {
			event.preventDefault();
		},
		keyup: function( event ) {
			var index = $( event.target ).data( "ui-slider-handle-index" );

			if ( this._keySliding ) {
				this._keySliding = false;
				this._stop( event, index );
				this._change( event, index );
				$( event.target ).removeClass( "ui-state-active" );
			}
		}
	}

});

}(jQuery));

}; 

exports(); 
module.resolveWith(exports); 

}); 
// module body: end

}; 
// module factory: end

FD40.module("ui/slider", moduleFactory);

}());			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var jQuery = $; 
var exports = function() { 

/*!
 * jQuery UI Widget 1.10.4pre
 * http://jqueryui.com
 *
 * Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/jQuery.widget/
 */
(function( $, undefined ) {

var uuid = 0,
	slice = Array.prototype.slice,
	_cleanData = $.cleanData;
$.cleanData = function( elems ) {
	for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
		try {
			$( elem ).triggerHandler( "remove" );
		// http://bugs.jquery.com/ticket/8235
		} catch( e ) {}
	}
	_cleanData( elems );
};

$.widget = function( name, base, prototype ) {
	var fullName, existingConstructor, constructor, basePrototype,
		// proxiedPrototype allows the provided prototype to remain unmodified
		// so that it can be used as a mixin for multiple widgets (#8876)
		proxiedPrototype = {},
		namespace = name.split( "." )[ 0 ];

	name = name.split( "." )[ 1 ];
	fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	// create selector for plugin
	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {
		// allow instantiation without "new" keyword
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		// allow instantiation without initializing for simple inheritance
		// must use "new" keyword (the code above always passes args)
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};
	// extend with the existing constructor to carry over any static properties
	$.extend( constructor, existingConstructor, {
		version: prototype.version,
		// copy the object used to create the prototype in case we need to
		// redefine the widget later
		_proto: $.extend( {}, prototype ),
		// track widgets that inherit from this widget in case this widget is
		// redefined after a widget inherits from it
		_childConstructors: []
	});

	basePrototype = new base();
	// we need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( !$.isFunction( value ) ) {
			proxiedPrototype[ prop ] = value;
			return;
		}
		proxiedPrototype[ prop ] = (function() {
			var _super = function() {
					return base.prototype[ prop ].apply( this, arguments );
				},
				_superApply = function( args ) {
					return base.prototype[ prop ].apply( this, args );
				};
			return function() {
				var __super = this._super,
					__superApply = this._superApply,
					returnValue;

				this._super = _super;
				this._superApply = _superApply;

				returnValue = value.apply( this, arguments );

				this._super = __super;
				this._superApply = __superApply;

				return returnValue;
			};
		})();
	});
	constructor.prototype = $.widget.extend( basePrototype, {
		// TODO: remove support for widgetEventPrefix
		// always use the name + a colon as the prefix, e.g., draggable:start
		// don't prefix for widgets that aren't DOM-based
		widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix : name
	}, proxiedPrototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		widgetFullName: fullName
	});

	// If this widget is being redefined then we need to find all widgets that
	// are inheriting from it and redefine all of them so that they inherit from
	// the new version of this widget. We're essentially trying to replace one
	// level in the prototype chain.
	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			// redefine the child widget using the same prototype that was
			// originally used, but inherit from the new version of the base
			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );
		});
		// remove the list of existing child constructors from the old constructor
		// so the old child constructors can be garbage collected
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );
};

$.widget.extend = function( target ) {
	var input = slice.call( arguments, 1 ),
		inputIndex = 0,
		inputLength = input.length,
		key,
		value;
	for ( ; inputIndex < inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
				// Clone objects
				if ( $.isPlainObject( value ) ) {
					target[ key ] = $.isPlainObject( target[ key ] ) ?
						$.widget.extend( {}, target[ key ], value ) :
						// Don't extend strings, arrays, etc. with objects
						$.widget.extend( {}, value );
				// Copy everything else by reference
				} else {
					target[ key ] = value;
				}
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName || name;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string",
			args = slice.call( arguments, 1 ),
			returnValue = this;

		// allow multiple hashes to be passed on init
		options = !isMethodCall && args.length ?
			$.widget.extend.apply( null, [ options ].concat(args) ) :
			options;

		if ( isMethodCall ) {
			this.each(function() {
				var methodValue,
					instance = $.data( this, fullName );
				if ( !instance ) {
					return $.error( "cannot call methods on " + name + " prior to initialization; " +
						"attempted to call method '" + options + "'" );
				}
				if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {
					return $.error( "no such method '" + options + "' for " + name + " widget instance" );
				}
				methodValue = instance[ options ].apply( instance, args );
				if ( methodValue !== instance && methodValue !== undefined ) {
					returnValue = methodValue && methodValue.jquery ?
						returnValue.pushStack( methodValue.get() ) :
						methodValue;
					return false;
				}
			});
		} else {
			this.each(function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} )._init();
				} else {
					$.data( this, fullName, new object( options, this ) );
				}
			});
		}

		return returnValue;
	};
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	defaultElement: "<div>",
	options: {
		disabled: false,

		// callbacks
		create: null
	},
	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = uuid++;
		this.eventNamespace = "." + this.widgetName + this.uuid;
		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();

		if ( element !== this ) {
			$.data( element, this.widgetFullName, this );
			this._on( true, this.element, {
				remove: function( event ) {
					if ( event.target === element ) {
						this.destroy();
					}
				}
			});
			this.document = $( element.style ?
				// element within the document
				element.ownerDocument :
				// element is window or document
				element.document || element );
			this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
		}

		this._create();
		this._trigger( "create", null, this._getCreateEventData() );
		this._init();
	},
	_getCreateOptions: $.noop,
	_getCreateEventData: $.noop,
	_create: $.noop,
	_init: $.noop,

	destroy: function() {
		this._destroy();
		// we can probably remove the unbind calls in 2.0
		// all event bindings should go through this._on()
		this.element
			.unbind( this.eventNamespace )
			// 1.9 BC for #7810
			// TODO remove dual storage
			.removeData( this.widgetName )
			.removeData( this.widgetFullName )
			// support: jquery <1.6.3
			// http://bugs.jquery.com/ticket/9413
			.removeData( $.camelCase( this.widgetFullName ) );
		this.widget()
			.unbind( this.eventNamespace )
			.removeAttr( "aria-disabled" )
			.removeClass(
				this.widgetFullName + "-disabled " +
				"ui-state-disabled" );

		// clean up events and states
		this.bindings.unbind( this.eventNamespace );
		this.hoverable.removeClass( "ui-state-hover" );
		this.focusable.removeClass( "ui-state-focus" );
	},
	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key,
			parts,
			curOption,
			i;

		if ( arguments.length === 0 ) {
			// don't return a reference to the internal hash
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === "string" ) {
			// handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
			options = {};
			parts = key.split( "." );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i < parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( value === undefined ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( value === undefined ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},
	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},
	_setOption: function( key, value ) {
		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this.widget()
				.toggleClass( this.widgetFullName + "-disabled ui-state-disabled", !!value )
				.attr( "aria-disabled", value );
			this.hoverable.removeClass( "ui-state-hover" );
			this.focusable.removeClass( "ui-state-focus" );
		}

		return this;
	},

	enable: function() {
		return this._setOption( "disabled", false );
	},
	disable: function() {
		return this._setOption( "disabled", true );
	},

	_on: function( suppressDisabledCheck, element, handlers ) {
		var delegateElement,
			instance = this;

		// no suppressDisabledCheck flag, shuffle arguments
		if ( typeof suppressDisabledCheck !== "boolean" ) {
			handlers = element;
			element = suppressDisabledCheck;
			suppressDisabledCheck = false;
		}

		// no element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
			delegateElement = this.widget();
		} else {
			// accept selectors, DOM elements
			element = delegateElement = $( element );
			this.bindings = this.bindings.add( element );
		}

		$.each( handlers, function( event, handler ) {
			function handlerProxy() {
				// allow widgets to customize the disabled handling
				// - disabled as an array instead of boolean
				// - disabled class as method for disabling individual parts
				if ( !suppressDisabledCheck &&
						( instance.options.disabled === true ||
							$( this ).hasClass( "ui-state-disabled" ) ) ) {
					return;
				}
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			// copy the guid so direct unbinding works
			if ( typeof handler !== "string" ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( /^(\w+)\s*(.*)$/ ),
				eventName = match[1] + instance.eventNamespace,
				selector = match[2];
			if ( selector ) {
				delegateElement.delegate( selector, eventName, handlerProxy );
			} else {
				element.bind( eventName, handlerProxy );
			}
		});
	},

	_off: function( element, eventName ) {
		eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) + this.eventNamespace;
		element.unbind( eventName ).undelegate( eventName );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === "string" ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-hover" );
			},
			mouseleave: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-hover" );
			}
		});
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-focus" );
			},
			focusout: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-focus" );
			}
		});
	},

	_trigger: function( type, event, data ) {
		var prop, orig,
			callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();
		// the original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &&
			callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
		if ( typeof options === "string" ) {
			options = { effect: options };
		}
		var hasOptions,
			effectName = !options ?
				method :
				options === true || typeof options === "number" ?
					defaultEffect :
					options.effect || defaultEffect;
		options = options || {};
		if ( typeof options === "number" ) {
			options = { duration: options };
		}
		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;
		if ( options.delay ) {
			element.delay( options.delay );
		}
		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
			element[ method ]( options );
		} else if ( effectName !== method && element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue(function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			});
		}
	};
});

})( jQuery );

}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("ui/widget", moduleFactory);

}());			(function(){

// module factory: start

var moduleFactory = function($) {
// module body: start

var module = this; 
var exports = function() {

var jQuery = $;

/*
 * wavesurfer.js v1.4.0
 * http://wavesurfer-js.org/
 *
 * By katspaugh is licensed under a Creative Commons Attribution 3.0 Unported License. 
 */

(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
	// AMD. Register as an anonymous module unless amdModuleId is set
	define('wavesurfer', [], function () {
	  return (root['WaveSurfer'] = factory());
	});
  } else if (typeof exports === 'object') {
	// Node. Does not work with strict CommonJS, but
	// only CommonJS-like environments that support module.exports,
	// like Node.
	module.exports = factory();
  } else {
	root['WaveSurfer'] = factory();
  }
}(this, function () {

'use strict';

var WaveSurfer = {
	defaultParams: {
		audioContext  : null,
		audioRate     : 1,
		autoCenter    : true,
		backend       : 'WebAudio',
		barHeight     : 1,
		closeAudioContext: false,
		container     : null,
		cursorColor   : '#333',
		cursorWidth   : 1,
		dragSelection : true,
		fillParent    : true,
		forceDecode   : false,
		height        : 128,
		hideScrollbar : false,
		interact      : true,
		loopSelection : true,
		mediaContainer: null,
		mediaControls : false,
		mediaType     : 'audio',
		minPxPerSec   : 20,
		partialRender : false,
		pixelRatio    : window.devicePixelRatio || screen.deviceXDPI / screen.logicalXDPI,
		progressColor : '#555',
		normalize     : false,
		renderer      : 'MultiCanvas',
		scrollParent  : false,
		skipLength    : 2,
		splitChannels : false,
		waveColor     : '#999',
	},

	init: function (params) {
		// Extract relevant parameters (or defaults)
		this.params = WaveSurfer.util.extend({}, this.defaultParams, params);

		this.container = 'string' == typeof params.container ?
			document.querySelector(this.params.container) :
			this.params.container;

		if (!this.container) {
			throw new Error('Container element not found');
		}

		if (this.params.mediaContainer == null) {
			this.mediaContainer = this.container;
		} else if (typeof this.params.mediaContainer == 'string') {
			this.mediaContainer = document.querySelector(this.params.mediaContainer);
		} else {
			this.mediaContainer = this.params.mediaContainer;
		}

		if (!this.mediaContainer) {
			throw new Error('Media Container element not found');
		}

		// Used to save the current volume when muting so we can
		// restore once unmuted
		this.savedVolume = 0;

		// The current muted state
		this.isMuted = false;

		// Will hold a list of event descriptors that need to be
		// cancelled on subsequent loads of audio
		this.tmpEvents = [];

		// Holds any running audio downloads
		this.currentAjax = null;

		this.createDrawer();
		this.createBackend();
		this.createPeakCache();

		this.isDestroyed = false;
	},

	createDrawer: function () {
		var my = this;

		this.drawer = Object.create(WaveSurfer.Drawer[this.params.renderer]);
		this.drawer.init(this.container, this.params);

		this.drawer.on('redraw', function () {
			my.drawBuffer();
			my.drawer.progress(my.backend.getPlayedPercents());
		});

		// Click-to-seek
		this.drawer.on('click', function (e, progress) {
			setTimeout(function () {
				my.seekTo(progress);
			}, 0);
		});

		// Relay the scroll event from the drawer
		this.drawer.on('scroll', function (e) {
			if (my.params.partialRender) {
				my.drawBuffer();
			}
			my.fireEvent('scroll', e);
		});
	},

	createBackend: function () {
		var my = this;

		if (this.backend) {
			this.backend.destroy();
		}

		// Back compat
		if (this.params.backend == 'AudioElement') {
			this.params.backend = 'MediaElement';
		}

		if (this.params.backend == 'WebAudio' && !WaveSurfer.WebAudio.supportsWebAudio()) {
			this.params.backend = 'MediaElement';
		}

		this.backend = Object.create(WaveSurfer[this.params.backend]);
		this.backend.init(this.params);

		this.backend.on('finish', function () { my.fireEvent('finish'); });
		this.backend.on('play', function () { my.fireEvent('play'); });
		this.backend.on('pause', function () { my.fireEvent('pause'); });

		this.backend.on('audioprocess', function (time) {
			my.drawer.progress(my.backend.getPlayedPercents());
			my.fireEvent('audioprocess', time);
		});
	},

	createPeakCache: function() {
		if (this.params.partialRender) {
			this.peakCache = Object.create(WaveSurfer.PeakCache);
			this.peakCache.init();
		}
	},

	getDuration: function () {
		return this.backend.getDuration();
	},

	getCurrentTime: function () {
		return this.backend.getCurrentTime();
	},

	play: function (start, end) {
		this.fireEvent('interaction', this.play.bind(this, start, end));
		this.backend.play(start, end);
	},

	pause: function () {
		this.backend.isPaused() || this.backend.pause();
	},

	playPause: function () {
		this.backend.isPaused() ? this.play() : this.pause();
	},

	isPlaying: function () {
		return !this.backend.isPaused();
	},

	skipBackward: function (seconds) {
		this.skip(-seconds || -this.params.skipLength);
	},

	skipForward: function (seconds) {
		this.skip(seconds || this.params.skipLength);
	},

	skip: function (offset) {
		var position = this.getCurrentTime() || 0;
		var duration = this.getDuration() || 1;
		position = Math.max(0, Math.min(duration, position + (offset || 0)));
		this.seekAndCenter(position / duration);
	},

	seekAndCenter: function (progress) {
		this.seekTo(progress);
		this.drawer.recenter(progress);
	},

	seekTo: function (progress) {
		this.fireEvent('interaction', this.seekTo.bind(this, progress));

		var paused = this.backend.isPaused();
		// avoid draw wrong position while playing backward seeking
		if (!paused) {
			this.backend.pause();
		}
		// avoid small scrolls while paused seeking
		var oldScrollParent = this.params.scrollParent;
		this.params.scrollParent = false;
		this.backend.seekTo(progress * this.getDuration());
		this.drawer.progress(this.backend.getPlayedPercents());

		if (!paused) {
			this.backend.play();
		}
		this.params.scrollParent = oldScrollParent;
		this.fireEvent('seek', progress);
	},

	stop: function () {
		this.pause();
		this.seekTo(0);
		this.drawer.progress(0);
	},

	/**
	 * Set the playback volume.
	 *
	 * @param {Number} newVolume A value between 0 and 1, 0 being no
	 * volume and 1 being full volume.
	 */
	setVolume: function (newVolume) {
		this.backend.setVolume(newVolume);
	},

	/**
	 * Get the playback volume.
	 */
	getVolume: function () {
		return this.backend.getVolume();
	},

	/**
	 * Set the playback rate.
	 *
	 * @param {Number} rate A positive number. E.g. 0.5 means half the
	 * normal speed, 2 means double speed and so on.
	 */
	setPlaybackRate: function (rate) {
		this.backend.setPlaybackRate(rate);
	},

	/**
	 * Get the playback rate.
	 */
	getPlaybackRate: function () {
		return this.backend.getPlaybackRate();
	},

	/**
	 * Toggle the volume on and off. It not currenly muted it will
	 * save the current volume value and turn the volume off.
	 * If currently muted then it will restore the volume to the saved
	 * value, and then rest the saved value.
	 */
	toggleMute: function () {
		this.setMute(!this.isMuted);
	},

	setMute: function (mute) {
		// ignore all muting requests if the audio is already in that state
		if (mute === this.isMuted) {
			return;
		}

		if (mute) {
			// If currently not muted then save current volume,
			// turn off the volume and update the mute properties
			this.savedVolume = this.backend.getVolume();
			this.backend.setVolume(0);
			this.isMuted = true;
		} else {
			// If currently muted then restore to the saved volume
			// and update the mute properties
			this.backend.setVolume(this.savedVolume);
			this.isMuted = false;
		}
	},

	/**
	 * Get the current mute status.
	 */
	getMute: function () {
		return this.isMuted;
	},

	/**
	 * Get the list of current set filters as an array.
	 *
	 * Filters must be set with setFilters method first
	 */
	getFilters: function() {
		return this.backend.filters || [];
	},

	toggleScroll: function () {
		this.params.scrollParent = !this.params.scrollParent;
		this.drawBuffer();
	},

	toggleInteraction: function () {
		this.params.interact = !this.params.interact;
	},

	drawBuffer: function () {
		var nominalWidth = Math.round(
			this.getDuration() * this.params.minPxPerSec * this.params.pixelRatio
		);
		var parentWidth = this.drawer.getWidth();
		var width = nominalWidth;
		var start = this.drawer.getScrollX();
		var end = Math.min(start + parentWidth, width);

		// Fill container
		if (this.params.fillParent && (!this.params.scrollParent || nominalWidth < parentWidth)) {
			width = parentWidth;
			start = 0;
			end = width;
		}

		if (this.params.partialRender) {
			var newRanges = this.peakCache.addRangeToPeakCache(width, start, end);
			for (var i = 0; i < newRanges.length; i++) {
			  var peaks = this.backend.getPeaks(width, newRanges[i][0], newRanges[i][1]);
			  this.drawer.drawPeaks(peaks, width, newRanges[i][0], newRanges[i][1]);
			}
		} else {
			start = 0;
			end = width;
			var peaks = this.backend.getPeaks(width, start, end);
			this.drawer.drawPeaks(peaks, width, start, end);
		}
		this.fireEvent('redraw', peaks, width);
	},

	zoom: function (pxPerSec) {
		this.params.minPxPerSec = pxPerSec;

		this.params.scrollParent = true;

		this.drawBuffer();
		this.drawer.progress(this.backend.getPlayedPercents());

		this.drawer.recenter(
			this.getCurrentTime() / this.getDuration()
		);
		this.fireEvent('zoom', pxPerSec);
	},

	/**
	 * Internal method.
	 */
	loadArrayBuffer: function (arraybuffer) {
		this.decodeArrayBuffer(arraybuffer, function (data) {
			if (!this.isDestroyed) {
				this.loadDecodedBuffer(data);
			}
		}.bind(this));
	},

	/**
	 * Directly load an externally decoded AudioBuffer.
	 */
	loadDecodedBuffer: function (buffer) {
		this.backend.load(buffer);
		this.drawBuffer();
		this.fireEvent('ready');
	},

	/**
	 * Loads audio data from a Blob or File object.
	 *
	 * @param {Blob|File} blob Audio data.
	 */
	loadBlob: function (blob) {
		var my = this;
		// Create file reader
		var reader = new FileReader();
		reader.addEventListener('progress', function (e) {
			my.onProgress(e);
		});
		reader.addEventListener('load', function (e) {
			my.loadArrayBuffer(e.target.result);
		});
		reader.addEventListener('error', function () {
			my.fireEvent('error', 'Error reading file');
		});
		reader.readAsArrayBuffer(blob);
		this.empty();
	},

	/**
	 * Loads audio and re-renders the waveform.
	 */
	load: function (url, peaks, preload) {
		this.empty();
		this.isMuted = false;

		switch (this.params.backend) {
			case 'WebAudio': return this.loadBuffer(url, peaks);
			case 'MediaElement': return this.loadMediaElement(url, peaks, preload);
		}
	},

	/**
	 * Loads audio using Web Audio buffer backend.
	 */
	loadBuffer: function (url, peaks) {
		var load = (function (action) {
			if (action) {
				this.tmpEvents.push(this.once('ready', action));
			}
			return this.getArrayBuffer(url, this.loadArrayBuffer.bind(this));
		}).bind(this);

		if (peaks) {
			this.backend.setPeaks(peaks);
			this.drawBuffer();
			this.tmpEvents.push(this.once('interaction', load));
		} else {
			return load();
		}
	},

	/**
	 *  Either create a media element, or load
	 *  an existing media element.
	 *  @param  {String|HTMLElement} urlOrElt Either a path to a media file,
	 *                                          or an existing HTML5 Audio/Video
	 *                                          Element
	 *  @param  {Array}            [peaks]     Array of peaks. Required to bypass
	 *                                          web audio dependency
	 */
	loadMediaElement: function (urlOrElt, peaks, preload) {
		var url = urlOrElt;

		if (typeof urlOrElt === 'string') {
			this.backend.load(url, this.mediaContainer, peaks, preload);
		} else {
			var elt = urlOrElt;
			this.backend.loadElt(elt, peaks);

			// If peaks are not provided,
			// url = element.src so we can get peaks with web audio
			url = elt.src;
		}

		this.tmpEvents.push(
			this.backend.once('canplay', (function () {
				this.drawBuffer();
				this.fireEvent('ready');
			}).bind(this)),

			this.backend.once('error', (function (err) {
				this.fireEvent('error', err);
			}).bind(this))
		);

		// If no pre-decoded peaks provided or pre-decoded peaks are
		// provided with forceDecode flag, attempt to download the
		// audio file and decode it with Web Audio.
		if (peaks) { this.backend.setPeaks(peaks); }

		if ((!peaks || this.params.forceDecode) && this.backend.supportsWebAudio()) {
			this.getArrayBuffer(url, (function (arraybuffer) {
				this.decodeArrayBuffer(arraybuffer, (function (buffer) {
					this.backend.buffer = buffer;
					this.backend.setPeaks(null);
					this.drawBuffer();
					this.fireEvent('waveform-ready');
				}).bind(this));
			}).bind(this));
		}
	},

	decodeArrayBuffer: function (arraybuffer, callback) {
		this.arraybuffer = arraybuffer;

		this.backend.decodeArrayBuffer(
			arraybuffer,
			(function (data) {
				// Only use the decoded data if we haven't been destroyed or another decode started in the meantime
				if (!this.isDestroyed && this.arraybuffer == arraybuffer) {
					callback(data);
					this.arraybuffer = null;
				}
			}).bind(this),
			this.fireEvent.bind(this, 'error', 'Error decoding audiobuffer')
		);
	},

	getArrayBuffer: function (url, callback) {
		var my = this;

		var ajax = WaveSurfer.util.ajax({
			url: url,
			responseType: 'arraybuffer'
		});

		this.currentAjax = ajax;

		this.tmpEvents.push(
			ajax.on('progress', function (e) {
				my.onProgress(e);
			}),
			ajax.on('success', function (data, e) {
				callback(data);
				my.currentAjax = null;
			}),
			ajax.on('error', function (e) {
				my.fireEvent('error', 'XHR error: ' + e.target.statusText);
				my.currentAjax = null;
			})
		);

		return ajax;
	},

	onProgress: function (e) {
		if (e.lengthComputable) {
			var percentComplete = e.loaded / e.total;
		} else {
			// Approximate progress with an asymptotic
			// function, and assume downloads in the 1-3 MB range.
			percentComplete = e.loaded / (e.loaded + 1000000);
		}
		this.fireEvent('loading', Math.round(percentComplete * 100), e.target);
	},

	/**
	 * Exports PCM data into a JSON array and opens in a new window.
	 */
	exportPCM: function (length, accuracy, noWindow) {
		length = length || 1024;
		accuracy = accuracy || 10000;
		noWindow = noWindow || false;
		var peaks = this.backend.getPeaks(length, accuracy);
		var arr = [].map.call(peaks, function (val) {
			return Math.round(val * accuracy) / accuracy;
		});
		var json = JSON.stringify(arr);
		if (!noWindow) {
			window.open('data:application/json;charset=utf-8,' +
				encodeURIComponent(json));
		}
		return json;
	},

	/**
	 * Save waveform image as data URI.
	 *
	 * The default format is 'image/png'. Other supported types are
	 * 'image/jpeg' and 'image/webp'.
	 */
	exportImage: function(format, quality) {
		if (!format) {
			format = 'image/png';
		}
		if (!quality) {
			quality = 1;
		}

		return this.drawer.getImage(format, quality);
	},

	cancelAjax: function () {
		if (this.currentAjax) {
			this.currentAjax.xhr.abort();
			this.currentAjax = null;
		}
	},

	clearTmpEvents: function () {
		this.tmpEvents.forEach(function (e) { e.un(); });
	},

	/**
	 * Display empty waveform.
	 */
	empty: function () {
		if (!this.backend.isPaused()) {
			this.stop();
			this.backend.disconnectSource();
		}
		this.cancelAjax();
		this.clearTmpEvents();
		this.drawer.progress(0);
		this.drawer.setWidth(0);
		this.drawer.drawPeaks({ length: this.drawer.getWidth() }, 0);
	},

	/**
	 * Remove events, elements and disconnect WebAudio nodes.
	 */
	destroy: function () {
		this.fireEvent('destroy');
		this.cancelAjax();
		this.clearTmpEvents();
		this.unAll();
		this.backend.destroy();
		this.drawer.destroy();
		this.isDestroyed = true;
	}
};

WaveSurfer.create = function (params) {
	var wavesurfer = Object.create(WaveSurfer);
	wavesurfer.init(params);
	return wavesurfer;
};

WaveSurfer.util = {
	extend: function (dest) {
		var sources = Array.prototype.slice.call(arguments, 1);
		sources.forEach(function (source) {
			Object.keys(source).forEach(function (key) {
				dest[key] = source[key];
			});
		});
		return dest;
	},

	debounce: function (func, wait, immediate) {
		var args, context, timeout;
		var later = function() {
			timeout = null;
			if (!immediate) {
				func.apply(context, args);
			}
		};
		return function() {
			context = this;
			args = arguments;
			var callNow = immediate && !timeout;
			clearTimeout(timeout);
			timeout = setTimeout(later, wait);
			if (!timeout) {
				timeout = setTimeout(later, wait);
			}
			if (callNow) {
				func.apply(context, args);
			}
		};
	},

	min: function (values) {
		var min = +Infinity;
		for (var i in values) {
			if (values[i] < min) {
				min = values[i];
			}
		}

		return min;
	},

	max: function (values) {
		var max = -Infinity;
		for (var i in values) {
			if (values[i] > max) {
				max = values[i];
			}
		}

		return max;
	},

	getId: function () {
		return 'wavesurfer_' + Math.random().toString(32).substring(2);
	},

	ajax: function (options) {
		var ajax = Object.create(WaveSurfer.Observer);
		var xhr = new XMLHttpRequest();
		var fired100 = false;

		xhr.open(options.method || 'GET', options.url, true);
		xhr.responseType = options.responseType || 'json';

		xhr.addEventListener('progress', function (e) {
			ajax.fireEvent('progress', e);
			if (e.lengthComputable && e.loaded == e.total) {
				fired100 = true;
			}
		});

		xhr.addEventListener('load', function (e) {
			if (!fired100) {
				ajax.fireEvent('progress', e);
			}
			ajax.fireEvent('load', e);

			if (200 == xhr.status || 206 == xhr.status) {
				ajax.fireEvent('success', xhr.response, e);
			} else {
				ajax.fireEvent('error', e);
			}
		});

		xhr.addEventListener('error', function (e) {
			ajax.fireEvent('error', e);
		});

		xhr.send();
		ajax.xhr = xhr;
		return ajax;
	}
};

/* Observer */
WaveSurfer.Observer = {
	/**
	 * Attach a handler function for an event.
	 */
	on: function (event, fn) {
		if (!this.handlers) { this.handlers = {}; }

		var handlers = this.handlers[event];
		if (!handlers) {
			handlers = this.handlers[event] = [];
		}
		handlers.push(fn);

		// Return an event descriptor
		return {
			name: event,
			callback: fn,
			un: this.un.bind(this, event, fn)
		};
	},

	/**
	 * Remove an event handler.
	 */
	un: function (event, fn) {
		if (!this.handlers) { return; }

		var handlers = this.handlers[event];
		if (handlers) {
			if (fn) {
				for (var i = handlers.length - 1; i >= 0; i--) {
					if (handlers[i] == fn) {
						handlers.splice(i, 1);
					}
				}
			} else {
				handlers.length = 0;
			}
		}
	},

	/**
	 * Remove all event handlers.
	 */
	unAll: function () {
		this.handlers = null;
	},

	/**
	 * Attach a handler to an event. The handler is executed at most once per
	 * event type.
	 */
	once: function (event, handler) {
		var my = this;
		var fn = function () {
			handler.apply(this, arguments);
			setTimeout(function () {
				my.un(event, fn);
			}, 0);
		};
		return this.on(event, fn);
	},

	fireEvent: function (event) {
		if (!this.handlers) { return; }
		var handlers = this.handlers[event];
		var args = Array.prototype.slice.call(arguments, 1);
		handlers && handlers.forEach(function (fn) {
			fn.apply(null, args);
		});
	}
};

/* Make the main WaveSurfer object an observer */
WaveSurfer.util.extend(WaveSurfer, WaveSurfer.Observer);

'use strict';

WaveSurfer.WebAudio = {
	scriptBufferSize: 256,
	PLAYING_STATE: 0,
	PAUSED_STATE: 1,
	FINISHED_STATE: 2,

	supportsWebAudio: function () {
		return !!(window.AudioContext || window.webkitAudioContext);
	},

	getAudioContext: function () {
		if (!WaveSurfer.WebAudio.audioContext) {
			WaveSurfer.WebAudio.audioContext = new (
				window.AudioContext || window.webkitAudioContext
			);
		}
		return WaveSurfer.WebAudio.audioContext;
	},

	getOfflineAudioContext: function (sampleRate) {
		if (!WaveSurfer.WebAudio.offlineAudioContext) {
			WaveSurfer.WebAudio.offlineAudioContext = new (
				window.OfflineAudioContext || window.webkitOfflineAudioContext
			)(1, 2, sampleRate);
		}
		return WaveSurfer.WebAudio.offlineAudioContext;
	},

	init: function (params) {
		this.params = params;
		this.ac = params.audioContext || this.getAudioContext();

		this.lastPlay = this.ac.currentTime;
		this.startPosition = 0;
		this.scheduledPause = null;

		this.states = [
			Object.create(WaveSurfer.WebAudio.state.playing),
			Object.create(WaveSurfer.WebAudio.state.paused),
			Object.create(WaveSurfer.WebAudio.state.finished)
		];

		this.createVolumeNode();
		this.createScriptNode();
		this.createAnalyserNode();

		this.setState(this.PAUSED_STATE);
		this.setPlaybackRate(this.params.audioRate);
		this.setLength(0);
	},

	disconnectFilters: function () {
		if (this.filters) {
			this.filters.forEach(function (filter) {
				filter && filter.disconnect();
			});
			this.filters = null;
			// Reconnect direct path
			this.analyser.connect(this.gainNode);
		}
	},

	setState: function (state) {
		if (this.state !== this.states[state]) {
			this.state = this.states[state];
			this.state.init.call(this);
		}
	},

	// Unpacked filters
	setFilter: function () {
		this.setFilters([].slice.call(arguments));
	},

	/**
	 * @param {Array} filters Packed ilters array
	 */
	setFilters: function (filters) {
		// Remove existing filters
		this.disconnectFilters();

		// Insert filters if filter array not empty
		if (filters && filters.length) {
			this.filters = filters;

			// Disconnect direct path before inserting filters
			this.analyser.disconnect();

			// Connect each filter in turn
			filters.reduce(function (prev, curr) {
				prev.connect(curr);
				return curr;
			}, this.analyser).connect(this.gainNode);
		}

	},

	createScriptNode: function () {
		if (this.ac.createScriptProcessor) {
			this.scriptNode = this.ac.createScriptProcessor(this.scriptBufferSize);
		} else {
			this.scriptNode = this.ac.createJavaScriptNode(this.scriptBufferSize);
		}

		this.scriptNode.connect(this.ac.destination);
	},

	addOnAudioProcess: function () {
		var my = this;

		this.scriptNode.onaudioprocess = function () {
			var time = my.getCurrentTime();

			if (time >= my.getDuration()) {
				my.setState(my.FINISHED_STATE);
				my.fireEvent('pause');
			} else if (time >= my.scheduledPause) {
				my.pause();
			} else if (my.state === my.states[my.PLAYING_STATE]) {
				my.fireEvent('audioprocess', time);
			}
		};
	},

	removeOnAudioProcess: function () {
		this.scriptNode.onaudioprocess = null;
	},

	createAnalyserNode: function () {
		this.analyser = this.ac.createAnalyser();
		this.analyser.connect(this.gainNode);
	},

	/**
	 * Create the gain node needed to control the playback volume.
	 */
	createVolumeNode: function () {
		// Create gain node using the AudioContext
		if (this.ac.createGain) {
			this.gainNode = this.ac.createGain();
		} else {
			this.gainNode = this.ac.createGainNode();
		}
		// Add the gain node to the graph
		this.gainNode.connect(this.ac.destination);
	},

	/**
	 * Set the gain to a new value.
	 *
	 * @param {Number} newGain The new gain, a floating point value
	 * between 0 and 1. 0 being no gain and 1 being maximum gain.
	 */
	setVolume: function (newGain) {
		this.gainNode.gain.value = newGain;
	},

	/**
	 * Get the current gain.
	 *
	 * @returns {Number} The current gain, a floating point value
	 * between 0 and 1. 0 being no gain and 1 being maximum gain.
	 */
	getVolume: function () {
		return this.gainNode.gain.value;
	},

	decodeArrayBuffer: function (arraybuffer, callback, errback) {
		if (!this.offlineAc) {
			this.offlineAc = this.getOfflineAudioContext(this.ac ? this.ac.sampleRate : 44100);
		}
		this.offlineAc.decodeAudioData(arraybuffer, (function (data) {
			callback(data);
		}).bind(this), errback);
	},

	/**
	 * Set pre-decoded peaks.
	 */
	setPeaks: function (peaks) {
		this.peaks = peaks;
	},

	/**
	 * Set the rendered length (different from the length of the audio).
	 */
	setLength: function (length) {
		// No resize, we can preserve the cached peaks.
		if (this.mergedPeaks && length == ((2 * this.mergedPeaks.length - 1) + 2)) {
		  return;
		}

		this.splitPeaks = [];
		this.mergedPeaks = [];
		// Set the last element of the sparse array so the peak arrays are
		// appropriately sized for other calculations.
		var channels = this.buffer ? this.buffer.numberOfChannels : 1;
		for (var c = 0; c < channels; c++) {
		  this.splitPeaks[c] = [];
		  this.splitPeaks[c][2 * (length - 1)] = 0;
		  this.splitPeaks[c][2 * (length - 1) + 1] = 0;
		}
		this.mergedPeaks[2 * (length - 1)] = 0;
		this.mergedPeaks[2 * (length - 1) + 1] = 0;
	},

	/**
	 * Compute the max and min value of the waveform when broken into
	 * <length> subranges.
	 * @param {Number} length How many subranges to break the waveform into.
	 * @param {Number} first First sample in the required range.
	 * @param {Number} last Last sample in the required range.
	 * @returns {Array} Array of 2*<length> peaks or array of arrays
	 * of peaks consisting of (max, min) values for each subrange.
	 */
	getPeaks: function (length, first, last) {
		if (this.peaks) { return this.peaks; }

		this.setLength(length);

		var sampleSize = this.buffer.length / length;
		var sampleStep = ~~(sampleSize / 10) || 1;
		var channels = this.buffer.numberOfChannels;

		for (var c = 0; c < channels; c++) {
			var peaks = this.splitPeaks[c];
			var chan = this.buffer.getChannelData(c);

			for (var i = first; i <= last; i++) {
				var start = ~~(i * sampleSize);
				var end = ~~(start + sampleSize);
				var min = 0;
				var max = 0;

				for (var j = start; j < end; j += sampleStep) {
					var value = chan[j];

					if (value > max) {
						max = value;
					}

					if (value < min) {
						min = value;
					}
				}

				peaks[2 * i] = max;
				peaks[2 * i + 1] = min;

				if (c == 0 || max > this.mergedPeaks[2 * i]) {
					this.mergedPeaks[2 * i] = max;
				}

				if (c == 0 || min < this.mergedPeaks[2 * i + 1]) {
					this.mergedPeaks[2 * i + 1] = min;
				}
			}
		}

		return this.params.splitChannels ? this.splitPeaks : this.mergedPeaks;
	},

	getPlayedPercents: function () {
		return this.state.getPlayedPercents.call(this);
	},

	disconnectSource: function () {
		if (this.source) {
			this.source.disconnect();
		}
	},

	destroy: function () {
		if (!this.isPaused()) {
			this.pause();
		}
		this.unAll();
		this.buffer = null;
		this.disconnectFilters();
		this.disconnectSource();
		this.gainNode.disconnect();
		this.scriptNode.disconnect();
		this.analyser.disconnect();
		// close the audioContext if closeAudioContext option is set to true
		if (this.params.closeAudioContext) {
			// check if browser supports AudioContext.close()
			if (typeof this.ac.close === 'function' && this.ac.state != 'closed') {
				this.ac.close();
			}
			// clear the reference to the audiocontext
			this.ac = null;
			// clear the actual audiocontext, either passed as param or the
			// global singleton
			if (!this.params.audioContext) {
				WaveSurfer.WebAudio.audioContext = null;
			} else {
				this.params.audioContext = null;
			}
			// clear the offlineAudioContext
			WaveSurfer.WebAudio.offlineAudioContext = null;
		}
	},

	load: function (buffer) {
		this.startPosition = 0;
		this.lastPlay = this.ac.currentTime;
		this.buffer = buffer;
		this.createSource();
	},

	createSource: function () {
		this.disconnectSource();
		this.source = this.ac.createBufferSource();

		//adjust for old browsers.
		this.source.start = this.source.start || this.source.noteGrainOn;
		this.source.stop = this.source.stop || this.source.noteOff;

		this.source.playbackRate.value = this.playbackRate;
		this.source.buffer = this.buffer;
		this.source.connect(this.analyser);
	},

	isPaused: function () {
		return this.state !== this.states[this.PLAYING_STATE];
	},

	getDuration: function () {
		if (!this.buffer) {
			return 0;
		}
		return this.buffer.duration;
	},

	seekTo: function (start, end) {
		if (!this.buffer) { return; }

		this.scheduledPause = null;

		if (start == null) {
			start = this.getCurrentTime();
			if (start >= this.getDuration()) {
				start = 0;
			}
		}
		if (end == null) {
			end = this.getDuration();
		}

		this.startPosition = start;
		this.lastPlay = this.ac.currentTime;

		if (this.state === this.states[this.FINISHED_STATE]) {
			this.setState(this.PAUSED_STATE);
		}

		return { start: start, end: end };
	},

	getPlayedTime: function () {
		return (this.ac.currentTime - this.lastPlay) * this.playbackRate;
	},

	/**
	 * Plays the loaded audio region.
	 *
	 * @param {Number} start Start offset in seconds,
	 * relative to the beginning of a clip.
	 * @param {Number} end When to stop
	 * relative to the beginning of a clip.
	 */
	play: function (start, end) {
		if (!this.buffer) { return; }

		// need to re-create source on each playback
		this.createSource();

		var adjustedTime = this.seekTo(start, end);

		start = adjustedTime.start;
		end = adjustedTime.end;

		this.scheduledPause = end;

		this.source.start(0, start, end - start);

		if (this.ac.state == 'suspended') {
		  this.ac.resume && this.ac.resume();
		}

		this.setState(this.PLAYING_STATE);

		this.fireEvent('play');
	},

	/**
	 * Pauses the loaded audio.
	 */
	pause: function () {
		this.scheduledPause = null;

		this.startPosition += this.getPlayedTime();
		this.source && this.source.stop(0);

		this.setState(this.PAUSED_STATE);

		this.fireEvent('pause');
	},

	/**
	*   Returns the current time in seconds relative to the audioclip's duration.
	*/
	getCurrentTime: function () {
		return this.state.getCurrentTime.call(this);
	},

	/**
	*   Returns the current playback rate.
	*/
	getPlaybackRate: function () {
		return this.playbackRate;
	},

	/**
	 * Set the audio source playback rate.
	 */
	setPlaybackRate: function (value) {
		value = value || 1;
		if (this.isPaused()) {
			this.playbackRate = value;
		} else {
			this.pause();
			this.playbackRate = value;
			this.play();
		}
	}
};

WaveSurfer.WebAudio.state = {};

WaveSurfer.WebAudio.state.playing = {
	init: function () {
		this.addOnAudioProcess();
	},
	getPlayedPercents: function () {
		var duration = this.getDuration();
		return (this.getCurrentTime() / duration) || 0;
	},
	getCurrentTime: function () {
		return this.startPosition + this.getPlayedTime();
	}
};

WaveSurfer.WebAudio.state.paused = {
	init: function () {
		this.removeOnAudioProcess();
	},
	getPlayedPercents: function () {
		var duration = this.getDuration();
		return (this.getCurrentTime() / duration) || 0;
	},
	getCurrentTime: function () {
		return this.startPosition;
	}
};

WaveSurfer.WebAudio.state.finished = {
	init: function () {
		this.removeOnAudioProcess();
		this.fireEvent('finish');
	},
	getPlayedPercents: function () {
		return 1;
	},
	getCurrentTime: function () {
		return this.getDuration();
	}
};

WaveSurfer.util.extend(WaveSurfer.WebAudio, WaveSurfer.Observer);

'use strict';

WaveSurfer.MediaElement = Object.create(WaveSurfer.WebAudio);

WaveSurfer.util.extend(WaveSurfer.MediaElement, {
	init: function (params) {
		this.params = params;

		// Dummy media to catch errors
		this.media = {
			currentTime: 0,
			duration: 0,
			paused: true,
			playbackRate: 1,
			play: function () {},
			pause: function () {}
		};

		this.mediaType = params.mediaType.toLowerCase();
		this.elementPosition = params.elementPosition;
		this.setPlaybackRate(this.params.audioRate);
		this.createTimer();
	},


	/**
	 * Create a timer to provide a more precise `audioprocess' event.
	 */
	createTimer: function () {
		var my = this;
		var playing = false;

		var onAudioProcess = function () {
			if (my.isPaused()) { return; }

			my.fireEvent('audioprocess', my.getCurrentTime());

			// Call again in the next frame
			var requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame;
			requestAnimationFrame(onAudioProcess);
		};

		this.on('play', onAudioProcess);
	},

	/**
	 *  Create media element with url as its source,
	 *  and append to container element.
	 *  @param  {String}        url         path to media file
	 *  @param  {HTMLElement}   container   HTML element
	 *  @param  {Array}         peaks       array of peak data
	 *  @param  {String}        preload     HTML 5 preload attribute value
	 */
	load: function (url, container, peaks, preload) {
		var my = this;

		var media = document.createElement(this.mediaType);
		media.controls = this.params.mediaControls;
		media.autoplay = this.params.autoplay || false;
		media.preload = preload == null ? 'auto' : preload;
		media.src = url;
		media.style.width = '100%';

		var prevMedia = container.querySelector(this.mediaType);
		if (prevMedia) {
			container.removeChild(prevMedia);
		}
		container.appendChild(media);

		this._load(media, peaks);
	},

	/**
	 *  Load existing media element.
	 *  @param  {MediaElement}  elt     HTML5 Audio or Video element
	 *  @param  {Array}         peaks   array of peak data
	 */
	loadElt: function (elt, peaks) {
		var my = this;

		var media = elt;
		media.controls = this.params.mediaControls;
		media.autoplay = this.params.autoplay || false;

		this._load(media, peaks);
	},

	/**
	 *  Private method called by both load (from url)
	 *  and loadElt (existing media element).
	 *  @param  {MediaElement}  media     HTML5 Audio or Video element
	 *  @param  {Array}         peaks   array of peak data
	 *  @private
	 */
	_load: function (media, peaks) {
		var my = this;

		// load must be called manually on iOS, otherwise peaks won't draw
		// until a user interaction triggers load --> 'ready' event
		if (typeof media.load == 'function') {
			media.load();
		}

		media.addEventListener('error', function () {
			my.fireEvent('error', 'Error loading media element');
		});

		media.addEventListener('canplay', function () {
			my.fireEvent('canplay');
		});

		media.addEventListener('ended', function () {
			my.fireEvent('finish');
		});

		this.media = media;
		this.peaks = peaks;
		this.onPlayEnd = null;
		this.buffer = null;
		this.setPlaybackRate(this.playbackRate);
	},

	isPaused: function () {
		return !this.media || this.media.paused;
	},

	getDuration: function () {
		var duration = (this.buffer || this.media).duration;
		if (duration >= Infinity) { // streaming audio
			duration = this.media.seekable.end(0);
		}
		return duration;
	},

	getCurrentTime: function () {
		return this.media && this.media.currentTime;
	},

	getPlayedPercents: function () {
		return (this.getCurrentTime() / this.getDuration()) || 0;
	},

	getPlaybackRate: function () {
		return this.playbackRate || this.media.playbackRate;
	},

	/**
	 * Set the audio source playback rate.
	 */
	setPlaybackRate: function (value) {
		this.playbackRate = value || 1;
		this.media.playbackRate = this.playbackRate;
	},

	seekTo: function (start) {
		if (start != null) {
			this.media.currentTime = start;
		}
		this.clearPlayEnd();
	},

	/**
	 * Plays the loaded audio region.
	 *
	 * @param {Number} start Start offset in seconds,
	 * relative to the beginning of a clip.
	 * @param {Number} end End offset in seconds,
	 * relative to the beginning of a clip.
	 */
	play: function (start, end) {
		this.seekTo(start);
		this.media.play();
		end && this.setPlayEnd(end);
		this.fireEvent('play');
	},

	/**
	 * Pauses the loaded audio.
	 */
	pause: function () {
		this.media && this.media.pause();
		this.clearPlayEnd();
		this.fireEvent('pause');
	},

	setPlayEnd: function (end) {
		var my = this;
		this.onPlayEnd = function (time) {
			if (time >= end) {
				my.pause();
				my.seekTo(end);
			}
		};
		this.on('audioprocess', this.onPlayEnd);
	},

	clearPlayEnd: function () {
		if (this.onPlayEnd) {
			this.un('audioprocess', this.onPlayEnd);
			this.onPlayEnd = null;
		}
	},

	getPeaks: function (length, start, end) {
		if (this.buffer) {
			return WaveSurfer.WebAudio.getPeaks.call(this, length, start, end);
		}
		return this.peaks || [];
	},

	getVolume: function () {
		return this.media.volume;
	},

	setVolume: function (val) {
		this.media.volume = val;
	},

	destroy: function () {
		this.pause();
		this.unAll();
		this.media && this.media.parentNode && this.media.parentNode.removeChild(this.media);
		this.media = null;
	}
});

//For backwards compatibility
WaveSurfer.AudioElement = WaveSurfer.MediaElement;

'use strict';

WaveSurfer.Drawer = {
	init: function (container, params) {
		this.container = container;
		this.params = params;

		this.width = 0;
		this.height = params.height * this.params.pixelRatio;

		this.lastPos = 0;

		this.initDrawer(params);
		this.createWrapper();
		this.createElements();
	},

	createWrapper: function () {
		this.wrapper = this.container.appendChild(
			document.createElement('wave')
		);

		this.style(this.wrapper, {
			display: 'block',
			position: 'relative',
			userSelect: 'none',
			webkitUserSelect: 'none',
			height: this.params.height + 'px'
		});

		if (this.params.fillParent || this.params.scrollParent) {
			this.style(this.wrapper, {
				width: '100%',
				overflowX: this.params.hideScrollbar ? 'hidden' : 'auto',
				overflowY: 'hidden'
			});
		}

		this.setupWrapperEvents();
	},

	handleEvent: function (e, noPrevent) {
		!noPrevent && e.preventDefault();

		var clientX = e.targetTouches ? e.targetTouches[0].clientX : e.clientX;
		var bbox = this.wrapper.getBoundingClientRect();

		var nominalWidth = this.width;
		var parentWidth = this.getWidth();

		var progress;

		if (!this.params.fillParent && nominalWidth < parentWidth) {
			progress = ((clientX - bbox.left) * this.params.pixelRatio / nominalWidth) || 0;

			if (progress > 1) {
				progress = 1;
			}
		} else {
			progress = ((clientX - bbox.left + this.wrapper.scrollLeft) / this.wrapper.scrollWidth) || 0;
		}

		return progress;
	},

	setupWrapperEvents: function () {
		var my = this;

		this.wrapper.addEventListener('click', function (e) {
			var scrollbarHeight = my.wrapper.offsetHeight - my.wrapper.clientHeight;
			if (scrollbarHeight != 0) {
				// scrollbar is visible.  Check if click was on it
				var bbox = my.wrapper.getBoundingClientRect();
				if (e.clientY >= bbox.bottom - scrollbarHeight) {
					// ignore mousedown as it was on the scrollbar
					return;
				}
			}

			if (my.params.interact) {
				my.fireEvent('click', e, my.handleEvent(e));
			}
		});

		this.wrapper.addEventListener('scroll', function (e) {
			my.fireEvent('scroll', e);
		});
	},

	drawPeaks: function (peaks, length, start, end) {
		this.setWidth(length);

		this.params.barWidth ?
			this.drawBars(peaks, 0, start, end) :
			this.drawWave(peaks, 0, start, end);
	},

	style: function (el, styles) {
		Object.keys(styles).forEach(function (prop) {
			if (el.style[prop] !== styles[prop]) {
				el.style[prop] = styles[prop];
			}
		});
		return el;
	},

	resetScroll: function () {
		if (this.wrapper !== null) {
			this.wrapper.scrollLeft = 0;
		}
	},

	recenter: function (percent) {
		var position = this.wrapper.scrollWidth * percent;
		this.recenterOnPosition(position, true);
	},

	recenterOnPosition: function (position, immediate) {
		var scrollLeft = this.wrapper.scrollLeft;
		var half = ~~(this.wrapper.clientWidth / 2);
		var target = position - half;
		var offset = target - scrollLeft;
		var maxScroll = this.wrapper.scrollWidth - this.wrapper.clientWidth;

		if (maxScroll == 0) {
			// no need to continue if scrollbar is not there
			return;
		}

		// if the cursor is currently visible...
		if (!immediate && -half <= offset && offset < half) {
			// we'll limit the "re-center" rate.
			var rate = 5;
			offset = Math.max(-rate, Math.min(rate, offset));
			target = scrollLeft + offset;
		}

		// limit target to valid range (0 to maxScroll)
		target = Math.max(0, Math.min(maxScroll, target));
		// no use attempting to scroll if we're not moving
		if (target != scrollLeft) {
			this.wrapper.scrollLeft = target;
		}

	},

	getScrollX: function() {
		return Math.round(this.wrapper.scrollLeft * this.params.pixelRatio);
	},

	getWidth: function () {
		return Math.round(this.container.clientWidth * this.params.pixelRatio);
	},

	setWidth: function (width) {
		if (this.width == width) {
		  return;
		}

		this.width = width;

		if (this.params.fillParent || this.params.scrollParent) {
			this.style(this.wrapper, {
				width: ''
			});
		} else {
			this.style(this.wrapper, {
				width: ~~(this.width / this.params.pixelRatio) + 'px'
			});
		}

		this.updateSize();
	},

	setHeight: function (height) {
		if (height == this.height) { return; }
		this.height = height;
		this.style(this.wrapper, {
			height: ~~(this.height / this.params.pixelRatio) + 'px'
		});
		this.updateSize();
	},

	progress: function (progress) {
		var minPxDelta = 1 / this.params.pixelRatio;
		var pos = Math.round(progress * this.width) * minPxDelta;

		if (pos < this.lastPos || pos - this.lastPos >= minPxDelta) {
			this.lastPos = pos;

			if (this.params.scrollParent && this.params.autoCenter) {
				var newPos = ~~(this.wrapper.scrollWidth * progress);
				this.recenterOnPosition(newPos);
			}

			this.updateProgress(pos);
		}
	},

	destroy: function () {
		this.unAll();
		if (this.wrapper) {
			this.container.removeChild(this.wrapper);
			this.wrapper = null;
		}
	},

	/* Renderer-specific methods */
	initDrawer: function () {},

	createElements: function () {},

	updateSize: function () {},

	drawWave: function (peaks, max) {},

	clearWave: function () {},

	updateProgress: function (position) {}
};

WaveSurfer.util.extend(WaveSurfer.Drawer, WaveSurfer.Observer);

'use strict';

WaveSurfer.Drawer.Canvas = Object.create(WaveSurfer.Drawer);

WaveSurfer.util.extend(WaveSurfer.Drawer.Canvas, {
	createElements: function () {
		var waveCanvas = this.wrapper.appendChild(
			this.style(document.createElement('canvas'), {
				position: 'absolute',
				zIndex: 1,
				left: 0,
				top: 0,
				bottom: 0
			})
		);
		this.waveCc = waveCanvas.getContext('2d');

		this.progressWave = this.wrapper.appendChild(
			this.style(document.createElement('wave'), {
				position: 'absolute',
				zIndex: 2,
				left: 0,
				top: 0,
				bottom: 0,
				overflow: 'hidden',
				width: '0',
				display: 'none',
				boxSizing: 'border-box',
				borderRightStyle: 'solid',
				borderRightWidth: this.params.cursorWidth + 'px',
				borderRightColor: this.params.cursorColor
			})
		);

		if (this.params.waveColor != this.params.progressColor) {
			var progressCanvas = this.progressWave.appendChild(
				document.createElement('canvas')
			);
			this.progressCc = progressCanvas.getContext('2d');
		}
	},

	updateSize: function () {
		var width = Math.round(this.width / this.params.pixelRatio);

		this.waveCc.canvas.width = this.width;
		this.waveCc.canvas.height = this.height;
		this.style(this.waveCc.canvas, { width: width + 'px'});

		this.style(this.progressWave, { display: 'block'});

		if (this.progressCc) {
			this.progressCc.canvas.width = this.width;
			this.progressCc.canvas.height = this.height;
			this.style(this.progressCc.canvas, { width: width + 'px'});
		}

		this.clearWave();
	},

	clearWave: function () {
		this.waveCc.clearRect(0, 0, this.width, this.height);
		if (this.progressCc) {
			this.progressCc.clearRect(0, 0, this.width, this.height);
		}
	},

	drawBars: function (peaks, channelIndex, start, end) {
		var my = this;
		// Split channels
		if (peaks[0] instanceof Array) {
			var channels = peaks;
			if (this.params.splitChannels) {
				this.setHeight(channels.length * this.params.height * this.params.pixelRatio);
				channels.forEach(function(channelPeaks, i) {
					my.drawBars(channelPeaks, i, start, end);
				});
				return;
			} else {
				peaks = channels[0];
			}
		}

		// Bar wave draws the bottom only as a reflection of the top,
		// so we don't need negative values
		var hasMinVals = [].some.call(peaks, function (val) { return val < 0; });
		// Skip every other value if there are negatives.
		var peakIndexScale = 1;
		if (hasMinVals) {
			peakIndexScale = 2;
		}

		// A half-pixel offset makes lines crisp
		var $ = 0.5 / this.params.pixelRatio;
		var width = this.width;
		var height = this.params.height * this.params.pixelRatio;
		var offsetY = height * channelIndex || 0;
		var halfH = height / 2;
		var length = peaks.length / peakIndexScale;
		var bar = this.params.barWidth * this.params.pixelRatio;
		var gap = Math.max(this.params.pixelRatio, ~~(bar / 2));
		var step = bar + gap;

		var absmax = 1 / this.params.barHeight;
		if (this.params.normalize) {
			var max = WaveSurfer.util.max(peaks);
			var min = WaveSurfer.util.min(peaks);
			absmax = -min > max ? -min : max;
		}

		var scale = length / width;

		this.waveCc.fillStyle = this.params.waveColor;
		if (this.progressCc) {
			this.progressCc.fillStyle = this.params.progressColor;
		}

		[ this.waveCc, this.progressCc ].forEach(function (cc) {
			if (!cc) { return; }

			for (var i = (start / scale); i < (end / scale); i += step) {
				var peak = peaks[Math.floor(i * scale * peakIndexScale)] || 0;
				var h = Math.round(peak / absmax * halfH);
				cc.fillRect(i + $, halfH - h + offsetY, bar + $, h * 2);
			}
		}, this);
	},

	drawWave: function (peaks, channelIndex, start, end) {
		var my = this;
		// Split channels
		if (peaks[0] instanceof Array) {
			var channels = peaks;
			if (this.params.splitChannels) {
				this.setHeight(channels.length * this.params.height * this.params.pixelRatio);
				channels.forEach(function(channelPeaks, i) {
					my.drawWave(channelPeaks, i, start, end);
				});
				return;
			} else {
				peaks = channels[0];
			}
		}

		// Support arrays without negative peaks
		var hasMinValues = [].some.call(peaks, function (val) { return val < 0; });
		if (!hasMinValues) {
			var reflectedPeaks = [];
			for (var i = 0, len = peaks.length; i < len; i++) {
				reflectedPeaks[2 * i] = peaks[i];
				reflectedPeaks[2 * i + 1] = -peaks[i];
			}
			peaks = reflectedPeaks;
		}

		// A half-pixel offset makes lines crisp
		var $ = 0.5 / this.params.pixelRatio;
		var height = this.params.height * this.params.pixelRatio;
		var offsetY = height * channelIndex || 0;
		var halfH = height / 2;
		var length = ~~(peaks.length / 2);

		var scale = 1;
		if (this.params.fillParent && this.width != length) {
			scale = this.width / length;
		}

		var absmax = 1 / this.params.barHeight;
		if (this.params.normalize) {
			var max = WaveSurfer.util.max(peaks);
			var min = WaveSurfer.util.min(peaks);
			absmax = -min > max ? -min : max;
		}

		this.waveCc.fillStyle = this.params.waveColor;
		if (this.progressCc) {
			this.progressCc.fillStyle = this.params.progressColor;
		}

		[ this.waveCc, this.progressCc ].forEach(function (cc) {
			if (!cc) { return; }

			cc.beginPath();
			cc.moveTo(start * scale + $, halfH + offsetY);

			for (var i = start; i < end; i++) {
				var h = Math.round(peaks[2 * i] / absmax * halfH);
				cc.lineTo(i * scale + $, halfH - h + offsetY);
			}

			// Draw the bottom edge going backwards, to make a single
			// closed hull to fill.
			for (var i = end - 1; i >= start; i--) {
				var h = Math.round(peaks[2 * i + 1] / absmax * halfH);
				cc.lineTo(i * scale + $, halfH - h + offsetY);
			}

			cc.closePath();
			cc.fill();

			// Always draw a median line
			cc.fillRect(0, halfH + offsetY - $, this.width, $);
		}, this);
	},

	updateProgress: function (pos) {
		this.style(this.progressWave, { width: pos + 'px' });
	},

	getImage: function(type, quality) {
		return this.waveCc.canvas.toDataURL(type, quality);
	}
});

'use strict';

WaveSurfer.Drawer.MultiCanvas = Object.create(WaveSurfer.Drawer);

WaveSurfer.util.extend(WaveSurfer.Drawer.MultiCanvas, {

	initDrawer: function (params) {
		this.maxCanvasWidth = params.maxCanvasWidth != null ? params.maxCanvasWidth : 4000;
		this.maxCanvasElementWidth = Math.round(this.maxCanvasWidth / this.params.pixelRatio);

		if (this.maxCanvasWidth <= 1) {
			throw 'maxCanvasWidth must be greater than 1.';
		} else if (this.maxCanvasWidth % 2 == 1) {
			throw 'maxCanvasWidth must be an even number.';
		}

		this.hasProgressCanvas = this.params.waveColor != this.params.progressColor;
		this.halfPixel = 0.5 / this.params.pixelRatio;
		this.canvases = [];
	},

	createElements: function () {
		this.progressWave = this.wrapper.appendChild(
			this.style(document.createElement('wave'), {
				position: 'absolute',
				zIndex: 2,
				left: 0,
				top: 0,
				bottom: 0,
				overflow: 'hidden',
				width: '0',
				display: 'none',
				boxSizing: 'border-box',
				borderRightStyle: 'solid',
				borderRightWidth: this.params.cursorWidth + 'px',
				borderRightColor: this.params.cursorColor
			})
		);

		this.addCanvas();
	},

	updateSize: function () {
		var totalWidth = Math.round(this.width / this.params.pixelRatio),
			requiredCanvases = Math.ceil(totalWidth / this.maxCanvasElementWidth);

		while (this.canvases.length < requiredCanvases) {
			this.addCanvas();
		}

		while (this.canvases.length > requiredCanvases) {
			this.removeCanvas();
		}
		
		for (var i in this.canvases) {

			// if the canvas.waveCtx is undefined, skip this
			if (this.canvases[i].waveCtx === undefined) {
				break;
			}
			
			// Add some overlap to prevent vertical white stripes, keep the width even for simplicity.
			var canvasWidth = this.maxCanvasWidth + 2 * Math.ceil(this.params.pixelRatio / 2);

			if (i == this.canvases.length - 1) {
				canvasWidth = this.width - (this.maxCanvasWidth * (this.canvases.length - 1));
			}

			this.updateDimensions(this.canvases[i], canvasWidth, this.height);
			this.clearWaveForEntry(this.canvases[i]);
		}
	},

	addCanvas: function () {
		var entry = {},
			leftOffset = this.maxCanvasElementWidth * this.canvases.length;

		entry.wave = this.wrapper.appendChild(
			this.style(document.createElement('canvas'), {
				position: 'absolute',
				zIndex: 1,
				left: leftOffset + 'px',
				top: 0,
				bottom: 0,
				height: '100%'
			})
		);
		entry.waveCtx = entry.wave.getContext('2d');

		if (this.hasProgressCanvas) {
			entry.progress = this.progressWave.appendChild(
				this.style(document.createElement('canvas'), {
					position: 'absolute',
					left: leftOffset + 'px',
					top: 0,
					bottom: 0,
					height: '100%'
				})
			);
			entry.progressCtx = entry.progress.getContext('2d');
		}

		this.canvases.push(entry);
	},

	removeCanvas: function () {
		var lastEntry = this.canvases.pop();
		lastEntry.wave.parentElement.removeChild(lastEntry.wave);
		if (this.hasProgressCanvas) {
			lastEntry.progress.parentElement.removeChild(lastEntry.progress);
		}
	},

	updateDimensions: function (entry, width, height) {
		var elementWidth = Math.round(width / this.params.pixelRatio),
			totalWidth = Math.round(this.width / this.params.pixelRatio);

		// Where the canvas starts and ends in the waveform, represented as a decimal between 0 and 1.
		entry.start = (entry.waveCtx.canvas.offsetLeft / totalWidth) || 0;
		entry.end = entry.start + elementWidth / totalWidth;

		entry.waveCtx.canvas.width = width;
		entry.waveCtx.canvas.height = height;
		this.style(entry.waveCtx.canvas, { width: elementWidth + 'px'});

		this.style(this.progressWave, { display: 'block'});

		if (this.hasProgressCanvas) {
			entry.progressCtx.canvas.width = width;
			entry.progressCtx.canvas.height = height;
			this.style(entry.progressCtx.canvas, { width: elementWidth + 'px'});
		}
	},

	clearWave: function () {
		for (var i in this.canvases) {
			this.clearWaveForEntry(this.canvases[i]);
		}
	},

	clearWaveForEntry: function (entry) {
		entry.waveCtx.clearRect(0, 0, entry.waveCtx.canvas.width, entry.waveCtx.canvas.height);
		if (this.hasProgressCanvas) {
			entry.progressCtx.clearRect(0, 0, entry.progressCtx.canvas.width, entry.progressCtx.canvas.height);
		}
	},

	drawBars: function (peaks, channelIndex, start, end) {
		var my = this;
		// Split channels
		if (peaks[0] instanceof Array) {
			var channels = peaks;
			if (this.params.splitChannels) {
				this.setHeight(channels.length * this.params.height * this.params.pixelRatio);
				channels.forEach(function(channelPeaks, i) {
					my.drawBars(channelPeaks, i, start, end);
				});
				return;
			} else {
				peaks = channels[0];
			}
		}

		// Bar wave draws the bottom only as a reflection of the top,
		// so we don't need negative values
		var hasMinVals = [].some.call(peaks, function (val) { return val < 0; });
		// Skip every other value if there are negatives.
		var peakIndexScale = 1;
		if (hasMinVals) {
			peakIndexScale = 2;
		}

		// A half-pixel offset makes lines crisp
		var width = this.width;
		var height = this.params.height * this.params.pixelRatio;
		var offsetY = height * channelIndex || 0;
		var halfH = height / 2;
		var length = peaks.length / peakIndexScale;
		var bar = this.params.barWidth * this.params.pixelRatio;
		var gap = Math.max(this.params.pixelRatio, ~~(bar / 2));
		var step = bar + gap;

		var absmax = 1 / this.params.barHeight;
		if (this.params.normalize) {
			var max = WaveSurfer.util.max(peaks);
			var min = WaveSurfer.util.min(peaks);
			absmax = -min > max ? -min : max;
		}

		var scale = length / width;

		for (var i = (start / scale); i < (end / scale); i += step) {
			var peak = peaks[Math.floor(i * scale * peakIndexScale)] || 0;
			var h = Math.round(peak / absmax * halfH);
			this.fillRect(i + this.halfPixel, halfH - h + offsetY, bar + this.halfPixel, h * 2);
		}
	},

	drawWave: function (peaks, channelIndex, start, end) {
		var my = this;
		// Split channels
		if (peaks[0] instanceof Array) {
			var channels = peaks;
			if (this.params.splitChannels) {
				this.setHeight(channels.length * this.params.height * this.params.pixelRatio);
				channels.forEach(function(channelPeaks, i) {
					my.drawWave(channelPeaks, i, start, end);
				});
				return;
			} else {
				peaks = channels[0];
			}
		}

		// Support arrays without negative peaks
		var hasMinValues = [].some.call(peaks, function (val) { return val < 0; });
		if (!hasMinValues) {
			var reflectedPeaks = [];
			for (var i = 0, len = peaks.length; i < len; i++) {
				reflectedPeaks[2 * i] = peaks[i];
				reflectedPeaks[2 * i + 1] = -peaks[i];
			}
			peaks = reflectedPeaks;
		}

		// A half-pixel offset makes lines crisp
		var height = this.params.height * this.params.pixelRatio;
		var offsetY = height * channelIndex || 0;
		var halfH = height / 2;

		var absmax = 1 / this.params.barHeight;
		if (this.params.normalize) {
			var max = WaveSurfer.util.max(peaks);
			var min = WaveSurfer.util.min(peaks);
			absmax = -min > max ? -min : max;
		}

		this.drawLine(peaks, absmax, halfH, offsetY, start, end);

		// Always draw a median line
		this.fillRect(0, halfH + offsetY - this.halfPixel, this.width, this.halfPixel);
	},

	drawLine: function (peaks, absmax, halfH, offsetY, start, end) {
		for (var index in this.canvases) {
			var entry = this.canvases[index];

			this.setFillStyles(entry);

			this.drawLineToContext(entry, entry.waveCtx, peaks, absmax, halfH, offsetY, start, end);
			this.drawLineToContext(entry, entry.progressCtx, peaks, absmax, halfH, offsetY, start, end);
		}
	},

	drawLineToContext: function (entry, ctx, peaks, absmax, halfH, offsetY, start, end) {
		if (!ctx) { return; }

		var length = peaks.length / 2;

		var scale = 1;
		if (this.params.fillParent && this.width != length) {
			scale = this.width / length;
		}

		var first = Math.round(length * entry.start),
			last = Math.round(length * entry.end);
		if (first > end || last < start) { return; }
		var canvasStart = Math.max(first, start);
		var canvasEnd = Math.min(last, end);

		ctx.beginPath();
		ctx.moveTo((canvasStart - first) * scale + this.halfPixel, halfH + offsetY);

		for (var i = canvasStart; i < canvasEnd; i++) {
			var peak = peaks[2 * i] || 0;
			var h = Math.round(peak / absmax * halfH);
			ctx.lineTo((i - first) * scale + this.halfPixel, halfH - h + offsetY);
		}

		// Draw the bottom edge going backwards, to make a single
		// closed hull to fill.
		for (var i = canvasEnd - 1; i >= canvasStart; i--) {
			var peak = peaks[2 * i + 1] || 0;
			var h = Math.round(peak / absmax * halfH);
			ctx.lineTo((i - first) * scale + this.halfPixel, halfH - h + offsetY);
		}

		ctx.closePath();
		ctx.fill();
	},

	fillRect: function (x, y, width, height) {
		var startCanvas = Math.floor(x / this.maxCanvasWidth);
		var endCanvas = Math.min(Math.ceil((x + width) / this.maxCanvasWidth) + 1,
								 this.canvases.length);
		for (var i = startCanvas; i < endCanvas; i++) {
			var entry = this.canvases[i],
				leftOffset = i * this.maxCanvasWidth;

			var intersection = {
				x1: Math.max(x, i * this.maxCanvasWidth),
				y1: y,
				x2: Math.min(x + width, i * this.maxCanvasWidth + entry.waveCtx.canvas.width),
				y2: y + height
			};

			if (intersection.x1 < intersection.x2) {
				this.setFillStyles(entry);

				this.fillRectToContext(entry.waveCtx,
						intersection.x1 - leftOffset,
						intersection.y1,
						intersection.x2 - intersection.x1,
						intersection.y2 - intersection.y1);

				this.fillRectToContext(entry.progressCtx,
						intersection.x1 - leftOffset,
						intersection.y1,
						intersection.x2 - intersection.x1,
						intersection.y2 - intersection.y1);
			}
		}
	},

	fillRectToContext: function (ctx, x, y, width, height) {
		if (!ctx) { return; }
		ctx.fillRect(x, y, width, height);
	},

	setFillStyles: function (entry) {
		entry.waveCtx.fillStyle = this.params.waveColor;
		if (this.hasProgressCanvas) {
			entry.progressCtx.fillStyle = this.params.progressColor;
		}
	},

	updateProgress: function (pos) {
		this.style(this.progressWave, { width: pos + 'px' });
	},

	/**
	 * Combine all available canvasses together.
	 *
	 * @param {String} type - an optional value of a format type. Default is image/png.
	 * @param {Number} quality - an optional value between 0 and 1. Default is 0.92.
	 *
	 */
	getImage: function(type, quality) {
		var availableCanvas = [];
		this.canvases.forEach(function (entry) {
			availableCanvas.push(entry.wave.toDataURL(type, quality));
		});
		return availableCanvas.length > 1 ? availableCanvas : availableCanvas[0];
	}
});

'use strict';

WaveSurfer.Drawer.SplitWavePointPlot = Object.create(WaveSurfer.Drawer.Canvas);

WaveSurfer.util.extend(WaveSurfer.Drawer.SplitWavePointPlot, {

	defaultPlotParams: {
		plotNormalizeTo: 'whole',
		plotTimeStart: 0,
		plotMin: 0,
		plotMax: 1,
		plotColor     : '#f63',
		plotProgressColor : '#F00',
		plotPointHeight: 2,
		plotPointWidth: 2,
		plotSeparator: true,
		plotSeparatorColor: 'black',
		plotRangeDisplay: false,
		plotRangeUnits: '',
		plotRangePrecision: 4,
		plotRangeIgnoreOutliers: false,
		plotRangeFontSize: 12,
		plotRangeFontType: 'Ariel',
		waveDrawMedianLine: true,
		plotFileDelimiter:  '\t'
	},

	//object variables that get manipulated by various object functions
	plotTimeStart: 0,  //the start time of our wave according to plot data
	plotTimeEnd: -1,   //the end of our wave according to plot data
	plotArrayLoaded: false,
	plotArray: [],     //array of plot data objects containing time and plot value
	plotPoints: [],        //calculated average plot points corresponding to value of our wave
	plotMin: 0,
	plotMax: 1,

	/**
	 * Initializes the plot array. If params.plotFileUrl is provided an ajax call will be
	 * executed and drawing of the wave is delayed until plot info is retrieved
	 * @param params
	 */
	initDrawer: function (params) {
		var my = this;

		//set defaults if not passed in
		for(var paramName in this.defaultPlotParams) {
			if(this.params[paramName] === undefined) {
				this.params[paramName] = this.defaultPlotParams[paramName];
			}
		}

		//set the plotTimeStart
		this.plotTimeStart = this.params.plotTimeStart;

		//check to see if plotTimeEnd
		if(this.params.plotTimeEnd !== undefined) {
			this.plotTimeEnd = this.params.plotTimeEnd;
		}

		//set the plot array
		if (Array.isArray(params.plotArray)) {
			this.plotArray = params.plotArray;
			this.plotArrayLoaded = true;
		}
		//Need to load the plot array from ajax with our callback
		else {
			var onPlotArrayLoaded = function (plotArray) {
				my.plotArray = plotArray;
				my.plotArrayLoaded = true;
				my.fireEvent('plot_array_loaded');
			};
			this.loadPlotArrayFromFile(params.plotFileUrl, onPlotArrayLoaded, this.params.plotFileDelimiter);
		}
	},

	/**
	 * Draw the peaks - this overrides the drawer.js function and does the following additional steps
	 * - ensures that the plotArray has already been loaded, if not it loads via ajax
	 * - moves the wave form to where channel 1 would normally be
	 * @param peaks
	 * @param length
	 * @param start
	 * @param end
	 */
	drawPeaks: function (peaks, length, start, end) {
		//make sure that the plot array is already loaded
		if (this.plotArrayLoaded == true) {

			this.setWidth(length);

			//fake that we are splitting channels
			this.splitChannels = true;
			this.params.height = this.params.height/2;
			if (peaks[0] instanceof Array) {
			   peaks = peaks[0];
			}

			this.params.barWidth ?
				this.drawBars(peaks, 1, start, end) :
				this.drawWave(peaks, 1, start, end);

			//set the height back to the original
			this.params.height = this.params.height*2;

			this.calculatePlots();
			this.drawPlots();

		}
		//otherwise wait for the plot array to be loaded and then draw again
		else {
			var my = this;
			my.on('plot-array-loaded', function () {
				my.drawPeaks(peaks, length, start, end);
			});
		}
	},




	/**
	 * Loop through the calculated plot values and actually draw them
	 */
	drawPlots: function() {
		var height = this.params.height * this.params.pixelRatio / 2;

		var $ = 0.5 / this.params.pixelRatio;

		this.waveCc.fillStyle = this.params.plotColor;
		if(this.progressCc) {
			this.progressCc.fillStyle = this.params.plotProgressColor;
		}
		for(var i in this.plotPoints) {
			var x = parseInt(i);
			var y = height - this.params.plotPointHeight - (this.plotPoints[i] * (height - this.params.plotPointHeight));
			var pointHeight = this.params.plotPointHeight;

			this.waveCc.fillRect(x, y, this.params.plotPointWidth, pointHeight);

			if(this.progressCc) {
				this.progressCc.fillRect(x, y, this.params.plotPointWidth, pointHeight);
			}
		}

		//draw line to separate the two waves
		if(this.params.plotSeparator) {
			this.waveCc.fillStyle = this.params.plotSeparatorColor;
			this.waveCc.fillRect(0, height, this.width, $);
		}

		if(this.params.plotRangeDisplay) {
			this.displayPlotRange();
		}
	},


	/**
	 * Display the range for the plot graph
	 */
	displayPlotRange: function()
	{
		var fontSize = this.params.plotRangeFontSize * this.params.pixelRatio;
		var maxRange = this.plotMax.toPrecision(this.params.plotRangePrecision) + ' ' + this.params.plotRangeUnits;
		var minRange = this.plotMin.toPrecision(this.params.plotRangePrecision) + ' ' + this.params.plotRangeUnits;
		this.waveCc.font = fontSize.toString() + 'px ' + this.params.plotRangeFontType;
		this.waveCc.fillText(maxRange, 3, fontSize);
		this.waveCc.fillText(minRange, 3, this.height/2);

	},
	/**
	 * This function loops through the plotArray and converts it to the plot points
	 * to be drawn on the canvas keyed by their position
	 */
	calculatePlots: function() {
		//reset plots array
		this.plotPoints = {};

		//make sure we have our plotTimeEnd
		this.calculatePlotTimeEnd();

		var pointsForAverage = [];
		var previousWaveIndex = -1;
		var maxPlot = 0;
		var minPlot = 99999999999999;
		var maxSegmentPlot = 0;
		var minSegmentPlot = 99999999999999;
		var duration = this.plotTimeEnd - this.plotTimeStart;

		//loop through our plotArray and map values to wave indexes and take the average values for each wave index
		for(var i = 0; i < this.plotArray.length; i++) {
			var dataPoint = this.plotArray[i];
			if(dataPoint.value > maxPlot) {maxPlot = dataPoint.value;}
			if(dataPoint.value < minPlot) {minPlot = dataPoint.value;}

			//make sure we are in the specified range
			if(dataPoint.time >= this.plotTimeStart && dataPoint.time <= this.plotTimeEnd) {
				//get the wave index corresponding to the data point
				var waveIndex = Math.round(this.width * (dataPoint.time - this.plotTimeStart) / duration);

				pointsForAverage.push(dataPoint.value);

				//if we have moved on to a new position in our wave record average and reset previousWaveIndex
				if(waveIndex !== previousWaveIndex) {
					if(pointsForAverage.length > 0) {
						//get the average plot for this point
						var avgPlot = this.avg(pointsForAverage);

						//check for min max
						if(avgPlot > maxSegmentPlot) {maxSegmentPlot = avgPlot;}
						if(avgPlot < minSegmentPlot) {minSegmentPlot = avgPlot;}

						//add plot to the position
						this.plotPoints[previousWaveIndex] = avgPlot;
						pointsForAverage = [];
					}
				}
				previousWaveIndex = waveIndex;
			}
		}

		//normalize the plots points
		if(this.params.plotNormalizeTo == 'whole') {
			this.plotMin = minPlot;
			this.plotMax = maxPlot;
		}
		else if(this.params.plotNormalizeTo == 'values') {
			this.plotMin = this.params.plotMin;
			this.plotMax = this.params.plotMax;
		}
		else {
			this.plotMin = minSegmentPlot;
			this.plotMax = maxSegmentPlot;
		}
		this.normalizeValues();
	},

	/**
	 * Function to take all of the plots in this.plots and normalize them from 0 to one
	 * depending on this.plotMin and this.plotMax values
	 */
	normalizeValues: function() {
		var normalizedValues = {};

		//check to make sure we should be normalizing
		if(this.params.plotNormalizeTo === 'none') {return;}

		for(var i in this.plotPoints) {
			//get the normalized value between 0 and 1
			var normalizedValue = (this.plotPoints[i] - this.plotMin) / (this.plotMax - this.plotMin);

			//check if the value is above our specified range max
			if(normalizedValue > 1) {
				if(!this.params.plotRangeIgnoreOutliers) {
					normalizedValues[i] = 1;
				}
			}
			//check if hte value is below our specified rant
			else if(normalizedValue < 0) {
				if(!this.params.plotRangeIgnoreOutliers) {
					normalizedValues[i] = 0;
				}
			}
			//in our range add the normalized value
			else {
				normalizedValues[i] = normalizedValue;
			}
		}
		this.plotPoints = normalizedValues;
	},
	/**
	 *
	 */

	/**
	 * Function to load the plot array from a external file
	 *
	 * The text file should contain a series of lines.
	 * Each line should contain [audio time] [delimiter character] [plot value]
	 * e.g. "1.2355 [tab] 124.2321"
	 *
	 * @param plotFileUrl  url of the file containing time and value information
	 * @param onSuccess    function to run on success
	 * @param delimiter    the delimiter that separates the time and values on each line
	 */
	loadPlotArrayFromFile: function(plotFileUrl, onSuccess, delimiter) {
		//default delimiter to tab character
		if (delimiter === undefined) {delimiter = '\t';}

		var plotArray = [];

		var options = {
			url: plotFileUrl,
			responseType: 'text'
		};
		var fileAjax = WaveSurfer.util.ajax(options);

		fileAjax.on('load', function (data) {
			if (data.currentTarget.status == 200) {
				//split the file by line endings
				var plotLines = data.currentTarget.responseText.split('\n');
				//loop through each line and find the time and plot values (delimited by tab)
				for (var i = 0; i < plotLines.length; i++) {
					var plotParts = plotLines[i].split(delimiter);
					if(plotParts.length == 2) {
						plotArray.push({time: parseFloat(plotParts[0]), value: parseFloat(plotParts[1])});
					}
				}
				//run success function
				onSuccess(plotArray);
			}
		});
	},

	/***
	 * Calculate the end time of the plot
	 */
	calculatePlotTimeEnd: function() {
		if(this.params.plotTimeEnd !== undefined) {
			this.plotTimeEnd = this.params.plotTimeEnd;
		}
		else {
			this.plotTimeEnd = this.plotArray[this.plotArray.length -1].time;
		}
	},

	/**
	 * Quick convenience function to average numbers in an array
	 * @param  array of values
	 * @returns {number}
	 */
	avg: function(values) {
		var sum = values.reduce(function(a, b) {return a+b;});
		return sum/values.length;
	}
});

WaveSurfer.util.extend(WaveSurfer.Drawer.SplitWavePointPlot, WaveSurfer.Observer);

'use strict';

WaveSurfer.PeakCache = {
	init: function() {
		this.clearPeakCache();
	},

	clearPeakCache: function() {
	// Flat array with entries that are always in pairs to mark the
	// beginning and end of each subrange.  This is a convenience so we can
	// iterate over the pairs for easy set difference operations.
		this.peakCacheRanges = [];
	// Length of the entire cachable region, used for resetting the cache
	// when this changes (zoom events, for instance).
		this.peakCacheLength = -1;
	},

	addRangeToPeakCache: function(length, start, end) {
		if (length != this.peakCacheLength) {
			this.clearPeakCache();
			this.peakCacheLength = length;
		}

		// Return ranges that weren't in the cache before the call.
		var uncachedRanges = [];
		var i = 0;
		// Skip ranges before the current start.
		while (i < this.peakCacheRanges.length && this.peakCacheRanges[i] < start) {
			i++;
		}
	// If |i| is even, |start| falls after an existing range.  Otherwise,
	// |start| falls between an existing range, and the uncached region
	// starts when we encounter the next node in |peakCacheRanges| or
	// |end|, whichever comes first.
		if (i % 2 == 0) {
			uncachedRanges.push(start);
		}
		while (i < this.peakCacheRanges.length && this.peakCacheRanges[i] <= end) {
			uncachedRanges.push(this.peakCacheRanges[i]);
			i++;
		}
		// If |i| is even, |end| is after all existing ranges.
		if (i % 2 == 0) {
			uncachedRanges.push(end);
		}

		// Filter out the 0-length ranges.
		uncachedRanges = uncachedRanges.filter(function(item, pos, arr) {
			if (pos == 0) {
				return item != arr[pos + 1];
			} else if (pos == arr.length - 1) {
				return item != arr[pos - 1];
			} else {
				return item != arr[pos - 1] && item != arr[pos + 1];
			}
		});

	// Merge the two ranges together, uncachedRanges will either contain
	// wholly new points, or duplicates of points in peakCacheRanges.  If
	// duplicates are detected, remove both and extend the range.
		this.peakCacheRanges = this.peakCacheRanges.concat(uncachedRanges);
		this.peakCacheRanges = this.peakCacheRanges.sort(function(a, b) {
			return a - b;
		}).filter(function(item, pos, arr) {
			if (pos == 0) {
				return item != arr[pos + 1];
			} else if (pos == arr.length - 1) {
				return item != arr[pos - 1];
			} else {
				return item != arr[pos - 1] && item != arr[pos + 1];
			}
		});

	// Push the uncached ranges into an array of arrays for ease of
	// iteration in the functions that call this.
		var uncachedRangePairs = [];
		for (i = 0; i < uncachedRanges.length; i += 2) {
			uncachedRangePairs.push([uncachedRanges[i], uncachedRanges[i+1]]);
		}

		return uncachedRangePairs;
	},

	// For testing
	getCacheRanges: function() {
	  var peakCacheRangePairs = [];
	  for (var i = 0; i < this.peakCacheRanges.length; i += 2) {
		  peakCacheRangePairs.push([this.peakCacheRanges[i], this.peakCacheRanges[i+1]]);
	  }
	  return peakCacheRangePairs;
	}
};

'use strict';

/* Init from HTML */
(function () {
	var init = function () {
		var containers = document.querySelectorAll('wavesurfer');

		Array.prototype.forEach.call(containers, function (el) {
			var params = WaveSurfer.util.extend({
				container: el,
				backend: 'MediaElement',
				mediaControls: true
			}, el.dataset);

			el.style.display = 'block';

			var wavesurfer = WaveSurfer.create(params);

			if (el.dataset.peaks) {
				var peaks = JSON.parse(el.dataset.peaks);
			}

			wavesurfer.load(el.dataset.url, peaks);
		});
	};

	if (document.readyState === 'complete') {
		init();
	} else {
		window.addEventListener('load', init);
	}
}());

return WaveSurfer;

}));


}; 

exports(); 
module.resolveWith(exports); 

// module body: end

}; 
// module factory: end

FD40.module("wavesurfer", moduleFactory);

}());	});
// Prepare the script definitions
FD40.installer('EasySocial', 'definitions', function($) {
	$.module(["easysocial\/apps\/fields\/event\/description\/content","easysocial\/apps\/fields\/event\/permalink\/content","easysocial\/apps\/fields\/event\/permalink\/sample_content","easysocial\/apps\/fields\/event\/recurring\/content","easysocial\/apps\/fields\/event\/startend\/content","easysocial\/apps\/fields\/event\/startend\/display","easysocial\/apps\/fields\/group\/description\/content","easysocial\/apps\/fields\/group\/permalink\/content","easysocial\/apps\/fields\/group\/permalink\/sample_content","easysocial\/apps\/fields\/page\/description\/content","easysocial\/apps\/fields\/page\/permalink\/content","easysocial\/apps\/fields\/page\/permalink\/sample_content","easysocial\/apps\/fields\/user\/address\/content","easysocial\/apps\/fields\/user\/address\/display_content","easysocial\/apps\/fields\/user\/address\/maps","easysocial\/apps\/fields\/user\/address\/osm","easysocial\/apps\/fields\/user\/autocomplete\/content","easysocial\/apps\/fields\/user\/avatar\/content","easysocial\/apps\/fields\/user\/avatar\/sample_content","easysocial\/apps\/fields\/user\/checkbox\/content","easysocial\/apps\/fields\/user\/checkbox\/sample_content","easysocial\/apps\/fields\/user\/country\/content","easysocial\/apps\/fields\/user\/country\/sample_content","easysocial\/apps\/fields\/user\/cover\/content","easysocial\/apps\/fields\/user\/currency\/content","easysocial\/apps\/fields\/user\/datetime\/content","easysocial\/apps\/fields\/user\/datetime\/display_content","easysocial\/apps\/fields\/user\/datetime\/dropdown","easysocial\/apps\/fields\/user\/datetime\/sample_content","easysocial\/apps\/fields\/user\/dropdown\/content","easysocial\/apps\/fields\/user\/email\/content","easysocial\/apps\/fields\/user\/file\/content","easysocial\/apps\/fields\/user\/file\/sample_content","easysocial\/apps\/fields\/user\/gender\/content","easysocial\/apps\/fields\/user\/joomla_email\/content","easysocial\/apps\/fields\/user\/joomla_email\/registermini_content","easysocial\/apps\/fields\/user\/joomla_email\/sample_content","easysocial\/apps\/fields\/user\/joomla_fullname\/content","easysocial\/apps\/fields\/user\/joomla_fullname\/sample_content","easysocial\/apps\/fields\/user\/joomla_password\/content","easysocial\/apps\/fields\/user\/joomla_password\/registermini_content","easysocial\/apps\/fields\/user\/joomla_password\/sample_content","easysocial\/apps\/fields\/user\/joomla_timezone\/content","easysocial\/apps\/fields\/user\/joomla_username\/content","easysocial\/apps\/fields\/user\/joomla_username\/registermini_content","easysocial\/apps\/fields\/user\/joomla_username\/sample_content","easysocial\/apps\/fields\/user\/keycaptcha\/content","easysocial\/apps\/fields\/user\/keycaptcha\/registermini_content","easysocial\/apps\/fields\/user\/multidropdown\/content","easysocial\/apps\/fields\/user\/multilist\/content","easysocial\/apps\/fields\/user\/multitextbox\/content","easysocial\/apps\/fields\/user\/numeric\/content","easysocial\/apps\/fields\/user\/password\/content","easysocial\/apps\/fields\/user\/password\/sample_content","easysocial\/apps\/fields\/user\/permalink\/content","easysocial\/apps\/fields\/user\/permalink\/sample_content","easysocial\/apps\/fields\/user\/relationship\/content","easysocial\/apps\/fields\/user\/separator\/sample","easysocial\/apps\/fields\/user\/terms\/content","easysocial\/apps\/fields\/user\/textarea\/content","easysocial\/apps\/fields\/user\/textbox\/content","easysocial\/apps\/fields\/user\/textbox\/sample_content","easysocial\/apps\/fields\/user\/url\/content","easysocial\/shared\/elements","easysocial\/shared\/fields\/base","easysocial\/shared\/fields\/conditional","easysocial\/shared\/fields\/validate","easysocial\/shared\/popdown","easysocial\/shared\/privacy","easysocial\/shared\/responsive","easysocial\/shared\/sidebarmenu","easysocial\/uploader\/item","easysocial\/uploader\/queue","easysocial\/uploader\/uploader","easysocial\/site\/activities\/default","easysocial\/site\/activities\/filter","easysocial\/site\/albums\/actions","easysocial\/site\/albums\/browser","easysocial\/site\/albums\/editor","easysocial\/site\/albums\/editor\/uploader","easysocial\/site\/albums\/filter","easysocial\/site\/albums\/item","easysocial\/site\/albums\/uploader.item","easysocial\/site\/albums\/uploader","easysocial\/site\/api\/admin","easysocial\/site\/api\/data","easysocial\/site\/api\/events","easysocial\/site\/api\/floatlabels","easysocial\/site\/api\/friends","easysocial\/site\/api\/groups","easysocial\/site\/api\/likes","easysocial\/site\/api\/mobile","easysocial\/site\/api\/oauth","easysocial\/site\/api\/pages","easysocial\/site\/api\/photos","easysocial\/site\/api\/popbox","easysocial\/site\/api\/repost","easysocial\/site\/api\/share","easysocial\/site\/api\/stream","easysocial\/site\/apps\/apps","easysocial\/site\/apps\/discussions\/discussions","easysocial\/site\/apps\/feeds\/feeds","easysocial\/site\/apps\/news\/news","easysocial\/site\/apps\/reviews\/filter","easysocial\/site\/apps\/reviews\/reviews","easysocial\/site\/apps\/tasks\/filter","easysocial\/site\/apps\/tasks\/tasks","easysocial\/site\/articles\/suggest","easysocial\/site\/audios\/browser","easysocial\/site\/audios\/filter","easysocial\/site\/audios\/form","easysocial\/site\/audios\/item","easysocial\/site\/audios\/player","easysocial\/site\/audios\/player.mini","easysocial\/site\/audios\/playlist","easysocial\/site\/audios\/process","easysocial\/site\/audios\/suggest","easysocial\/site\/avatar\/avatar","easysocial\/site\/badges\/badge","easysocial\/site\/clusters\/create","easysocial\/site\/comments\/control","easysocial\/site\/comments\/form","easysocial\/site\/comments\/frame","easysocial\/site\/comments\/item","easysocial\/site\/conversations\/composer","easysocial\/site\/conversations\/conversations","easysocial\/site\/conversations\/filter","easysocial\/site\/conversations\/item","easysocial\/site\/conversations\/message","easysocial\/site\/cover\/cover","easysocial\/site\/cover\/post.as","easysocial\/site\/dashboard\/default","easysocial\/site\/discussions\/browser","easysocial\/site\/discussions\/filter","easysocial\/site\/events\/browser","easysocial\/site\/events\/calendar","easysocial\/site\/events\/create","easysocial\/site\/events\/createRecurring","easysocial\/site\/events\/edit","easysocial\/site\/events\/filter","easysocial\/site\/events\/guests","easysocial\/site\/events\/update","easysocial\/site\/explorer\/explorer","easysocial\/site\/explorer\/popup","easysocial\/site\/explorer\/uploader","easysocial\/site\/followers\/browser","easysocial\/site\/followers\/filter","easysocial\/site\/friends\/browser","easysocial\/site\/friends\/filter","easysocial\/site\/friends\/list","easysocial\/site\/friends\/suggest","easysocial\/site\/groups\/browser","easysocial\/site\/groups\/edit","easysocial\/site\/groups\/filter","easysocial\/site\/groups\/members","easysocial\/site\/locations\/gmaps","easysocial\/site\/locations\/osm","easysocial\/site\/locations\/popbox","easysocial\/site\/manage\/clusters","easysocial\/site\/members\/filter","easysocial\/site\/members\/suggest","easysocial\/site\/mobile\/filters","easysocial\/site\/notifications\/list","easysocial\/site\/pages\/browser","easysocial\/site\/pages\/edit","easysocial\/site\/pages\/filter","easysocial\/site\/pages\/followers","easysocial\/site\/photos\/avatar","easysocial\/site\/photos\/browser","easysocial\/site\/photos\/editor","easysocial\/site\/photos\/item","easysocial\/site\/photos\/navigation","easysocial\/site\/photos\/popup","easysocial\/site\/photos\/tagger","easysocial\/site\/photos\/tags","easysocial\/site\/polls\/browser","easysocial\/site\/polls\/filter","easysocial\/site\/polls\/polls","easysocial\/site\/profile\/edit","easysocial\/site\/profile\/privacy","easysocial\/site\/quickpost\/quickpost","easysocial\/site\/registrations\/registrations","easysocial\/site\/search\/advanced","easysocial\/site\/search\/customfield","easysocial\/site\/search\/dating","easysocial\/site\/search\/default","easysocial\/site\/search\/map","easysocial\/site\/search\/osm","easysocial\/site\/search\/toolbar","easysocial\/site\/site","easysocial\/site\/story\/audios","easysocial\/site\/story\/broadcast","easysocial\/site\/story\/event","easysocial\/site\/story\/files","easysocial\/site\/story\/friends","easysocial\/site\/story\/gmaps","easysocial\/site\/story\/links","easysocial\/site\/story\/locations","easysocial\/site\/story\/mood","easysocial\/site\/story\/osm","easysocial\/site\/story\/photos","easysocial\/site\/story\/polls","easysocial\/site\/story\/story","easysocial\/site\/story\/tasks","easysocial\/site\/story\/videos","easysocial\/site\/stream\/ads","easysocial\/site\/stream\/filter","easysocial\/site\/stream\/item","easysocial\/site\/stream\/stream","easysocial\/site\/system\/broadcast","easysocial\/site\/system\/keepalive","easysocial\/site\/system\/notifications","easysocial\/site\/system\/notifier","easysocial\/site\/toolbar\/friends","easysocial\/site\/toolbar\/notifications","easysocial\/site\/toolbar\/system","easysocial\/site\/users\/default","easysocial\/site\/users\/popbox","easysocial\/site\/utilities\/sharing","easysocial\/site\/utilities\/webcam","easysocial\/site\/vendors\/gritter","easysocial\/site\/vendors\/idle","easysocial\/site\/vendors\/jquery.raty","easysocial\/site\/vendors\/lightbox","easysocial\/site\/vendors\/puller","easysocial\/site\/videos\/browser","easysocial\/site\/videos\/filter","easysocial\/site\/videos\/form","easysocial\/site\/videos\/item","easysocial\/site\/videos\/preview","easysocial\/site\/videos\/process"]);
});

// Prepare the contents of all the scripts
FD40.installer('EasySocial', 'scripts', function($) {
			EasySocial.module('apps/fields/event/description/content', function($) {

var module = this;

EasySocial.Controller('Field.Event.Description', {
    defaultOptions: {
        "required": false,
        "editor": null,
        "{input}": '[data-field-description]'
    }
}, function(self, opts, base) { return {

    init: function() {
        self.editor = self.options.editor;
    },

    "{self} onRender": function() {
        var data = self.input().htmlData();
        opts.error = data.error || {};
    },

    '{input} keyup': function() {
        self.validateInput();
    },

    '{input} blur': function() {
        self.validateInput();
    },

    validateInput: function() {
        self.clearError();

        var value = self.editor.getContent();

        if (self.options.required && $.isEmpty(value)) {
            self.raiseError(opts.error.required);
            return false;
        }

        return true;
    },

    raiseError: function(msg) {
        self.trigger('error', [msg]);
    },

    clearError: function() {
        self.trigger('clear');
    },

    '{self} onError': function(el, ev, type) {
        if(type === 'required') {
            self.raiseError(opts.error.required);
        }
    },

    '{self} onSubmit': function(el, ev, register) {

        var fieldId = self.options.fieldId;
        var editorName = self.options.editorName;

        // only apply for the tinymce editor
        if (editorName == 'tinymce') {
	        var textareaToggleWrapper = '#' + fieldId;

			if (typeof(tinyMCE) == 'object') {

				// if the editor form still under toggle page (HTML page)
				// We need to automatically toggle it back to the formatter page before submit
				if ($(textareaToggleWrapper).is(":visible")) {
					tinyMCE.execCommand('mceToggleEditor', false, fieldId);
				}
			}
        }

        register.push(self.validateInput());
    }
}});

module.resolve();
});
			EasySocial.module('apps/fields/event/permalink/content', function($) {
    var module = this;

EasySocial.Controller('Field.Event.Permalink', {
    defaultOptions: {
        required: false,

        max     : 0,

        id      : null,
        clusterid   : null,
        userid  : null,

        '{field}': '[data-field-permalink]',
        '{checkButton}': '[data-permalink-check]',
        '{input}': '[data-permalink-input]',
        '{available}': '[data-permalink-available]'
    }
}, function(self, opts, base) { return {
    state: false,

    init: function() {
        opts.max = self.field().data('max');
    },

    "{self} onRender": function() {
        var data = self.field().htmlData();

        opts.error = data.error || {};
    },

    "{checkButton} click" : function() {
        self.delayedCheck();
    },

    "{input} keyup" : function() {
        self.delayedCheck();
    },

    delayedCheck: $.debounce(function() {
        self.checkPermalink();
    }, 250),

    checkPermalink: function() {
        self.clearError();

        var permalink   = self.input().val();

        self.available().hide();

        if (self.options.max > 0 && permalink.length > self.options.max) {
            self.raiseError(opts.error.max);
            return false;
        }

        if (!$.isEmpty(permalink)) {
            self.checkButton().addClass('is-loading');

            var state = $.Deferred();

            EasySocial.ajax('fields/event/permalink/isValid', {
                "id"        : self.options.id,
                "clusterid" : self.options.clusterid,
                "permalink" : permalink
            })
            .done(function(msg) {
                self.clearError();

                self.checkButton().removeClass('is-loading');

                self.available().show();

                state.resolve();
            })
            .fail(function(msg) {
                self.raiseError(msg);

                self.checkButton().removeClass('is-loading');

                self.available().hide();

                state.reject();
            });

            return state;
        }

        if (self.options.required && $.isEmpty(permalink)) {
            self.available().hide();

            self.raiseError(opts.error.required);
            return false;
        }

        return true;
    },

    raiseError: function(msg) {
        self.trigger('error', [msg]);
    },

    clearError: function() {
        self.trigger('clear');
    },

    '{self} onSubmit': function(el, ev, register) {
        register.push(self.checkPermalink());
    }
}});

module.resolve();
});
			EasySocial.module('apps/fields/event/permalink/sample_content', function($) {
    var module = this;

    EasySocial.Controller('Field.Permalink.Sample', {
        defaultOptions: {
            '{checkPermalink}'      : '[data-check-permalink]'
        }
    }, function(self) {
        return {
            init: function() {

            },

            '{self} onConfigChange': function(el, event, name, value) {
                switch(name) {
                    case 'check_permalink':
                        self.checkPermalink().toggle(!!value);
                    break;
                }
            }
        }
    });

    module.resolve();
});
			EasySocial.module('apps/fields/event/recurring/content', function($) {

var module = this;
var lang = EasySocial.options.momentLang;

EasySocial.require().library('datetimepicker', 'moment/' + lang).done(function() {

EasySocial.Controller('Field.Event.Recurring', {
	defaultOptions: {
		dateFormat: '',
		id: null,
		value: {},
		allday: 0,
		showWarningMessages: 0,
		eventId: null,
		dow: 0,

		'{type}': '[data-recurring-type]',
		'{endBlock}': '[data-recurring-end-block]',
		'{picker}': '[data-recurring-end-picker]',
		'{toggle}': '[data-recurring-end-toggle]',
		'{result}': '[data-recurring-end-result]',
		'{dailyBlock}': '[data-recurring-daily-block]',
		'{dailyInput}': '[data-recurring-daily-block] input',
		'{summaryBlock}': '[data-recurring-summary-block]',
		"{showSchedules}": "[data-show-schedules]",
		'{scheduleLoadingBlock}': '[data-recurring-schedule-loading-block]',
		'{deleteRecurringButton}': '[data-recurring-delete]'
	}
}, function(self, opts) { return {
	init: function() {
		var dateFormat = self.options.dateFormat;
		var startofweek = self.options.dow;

		self.picker()._datetimepicker({
			pickTime: false,
			component: "es",
			useCurrent: false,
			format: dateFormat,
			language: lang,
			dow: startofweek

		});

		var value = self.result().val();

		if (!$.isEmpty(value)) {
			var dateObj = $.moment(value);

			self.datetimepicker('setDate', dateObj);
		}

		// Calculate total recurring events
		self.calculateRecurringEvents();
	},

	changed: 0,

	'{window} easysocial.fields.allday.change': function(el, ev, value) {
		self.options.allday = value;

		self.calculateRecurringEvents();
	},

	'{window} easysocial.fields.startend.start.change': function(el, ev, date) {
		self.calculateRecurringEvents();
	},

	'{toggle} click': function() {
		self.picker().focus();
	},

	'{picker} dp.change': function(el, ev) {
		self.setDateValue(ev.date.toDate());

		self.detectChanges();

		self.calculateRecurringEvents();
	},

	'{type} change': function(el, ev) {
		var value = el.val();

		self.endBlock()[value === 'none' ? 'hide' : 'show']();

		self.dailyBlock()[value === 'daily' ? 'show': 'hide']();

		self.detectChanges();

		self.calculateRecurringEvents();
	},

	'{dailyInput} change': function(el, ev) {
		self.detectChanges();

		self.calculateRecurringEvents();
	},

	calculateRecurringEvents: function() {
		
		self.summaryBlock().hide();

		self.scheduleLoadingBlock().hide();

		self.clearError();

		var start = $('[data-event-start]').find('[data-datetime]').val();
		var timezone = $('[data-event-timezone]').val();
		var end = self.result().val();
		var type = self.type().val();
		var daily = [];

		if (type == 'none' && !self.options.showWarningMessages) {
			return;
		}

		if ($.isEmpty(start) || $.isEmpty(end) || $.isEmpty(type)) {
			return;
		}

		$.each(self.dailyBlock().find('input'), function(i, input) {
			el = $(input);
			if (el.is(':checked')) {
				daily.push(el.val());
			}
		});

		self.scheduleLoadingBlock().show();

		self.getTotalRecurring({
			"start": start,
			"timezone": timezone,
			"end": end,
			"type": type,
			"daily": daily
		});
	},

	getTotalRecurring: $.debounce(function(options) {
		self.clearError();

		EasySocial.ajax('fields/event/recurring/calculateRecurringEvents', {
			"id": self.options.id,
			"start": options.start,
			"timezone": options.timezone,
			"allday": self.options.allday,
			"end": options.end,
			"type": options.type,
			"daily": options.daily,
			"eventId": self.options.eventId,
			"changed": self.changed,
			"showWarningMessages": self.options.showWarningMessages
		}).done(function(html) {
			self.summaryBlock().html(html).show();
		}).fail(function(msg) {
			self.raiseError(msg);
		}).always(function() {
			self.scheduleLoadingBlock().hide();
		});
	}, 500),

	detectChanges: function() {
		var end = self.result().val(),
			type = self.type().val(),
			daily = [],
			changed = false;

		$.each(self.dailyBlock().find('input'), function(i, input) {
			el = $(input);
			if (el.is(':checked')) {
				daily.push(el.val());
			}
		});

		if (type != self.options.value.type || end != self.options.value.end || daily.length != self.options.value.daily.length) {
			changed = true;
		}

		$.each(daily, function(i, d) {
			if ($.inArray(d, self.options.value.daily) == -1) {
				changed = true;
				return false;
			}
		});

		$.each(self.options.value.daily, function(i, d) {
			if ($.inArray(d, daily) == -1) {
				changed = true;
				return false;
			}
		});

		self.changed = changed ? 1 : 0;

		$(window).trigger('easysocial.fields.recurring.changed', [changed]);
	},

	"{showSchedules} click": function(button, event) {
		
		var start = $('[data-event-start]').find('[data-datetime]').val();
		var timezone = $('[data-event-timezone]').val();
		var end = self.result().val();
		var type = self.type().val();
		var daily = [];

		$.each(self.dailyBlock().find('input'), function(i, input) {
			el = $(input);

			if (el.is(':checked')) {
				daily.push(el.val());
			}
		});

		EasySocial.dialog({
			"content": EasySocial.ajax('fields/event/recurring/getScheduledEvents', {
							"id": self.options.id,
							"start": start,
							"timezone": timezone,
							"allday": self.options.allday,
							"end": end,
							"type": type,
							"daily": daily,
							"eventId": self.options.eventId
					})
		});
	},

	'{deleteRecurringButton} click': function(el, ev) {
		
		EasySocial.dialog({
			content: EasySocial.ajax('site/views/events/deleteRecurringDialog', {
				id: self.options.eventId
			}),
			bindings: {
				"{submitButton} click": function() {
					self.deleteRecurring()
						.done(function() {
							EasySocial.dialog().close();
							self.calculateRecurringEvents();
						});
				}
			}
		})
	},

	deleteRecurring: function() {
		return EasySocial.ajax('site/controllers/events/deleteRecurring', {
			eventId: self.options.eventId
		})
	},

	datetimepicker: function(name, value) {
		return self.picker().data('DateTimePicker')[name](value);
	},

	setDateValue: function(date) {
		// Convert the date object into sql format and set it into the input
		self.result().val(date.getFullYear() + '-' +
							('00' + (date.getMonth()+1)).slice(-2) + '-' +
							('00' + date.getDate()).slice(-2) + ' ' +
							('00' + date.getHours()).slice(-2) + ':' +
							('00' + date.getMinutes()).slice(-2) + ':' +
							('00' + date.getSeconds()).slice(-2));
	},

	'{self} onSubmit': function(el, ev, register) {
		register.push(true);
	},

	raiseError: function(msg) {
		self.trigger('error', [msg]);
	},

	clearError: function() {
		self.trigger('clear');
	}
}});

module.resolve();
});
});
			EasySocial.module('apps/fields/event/startend/content', function($) {
	
var module = this;
var lang = EasySocial.options.momentLang;

EasySocial
.require()
.library('datetimepicker', 'moment/' + lang, 'chosen')
.done(function($) {

EasySocial.Controller('Field.Event.Startend', {
	defaultOptions: {
		dateFormat: '',
		allowTime: true,
		allowTimezone: true,
		disallowPast: false,
		minuteStepping: 15,
		yearfrom: '',
		yearto: '',
		requiredEnd: false,
		allday: false,
		calendarLanguage: 'english',
		dow: 0,

		'{field}': '[data-field-startend]',
		'{startForm}': '[data-event-start]',
		'{endForm}': '[data-event-end]',
		'{timezone}': '[data-event-timezone]'
	}
}, function(self, opts, base) { return {
	init: function() {

		var data = self.field().htmlData();

		opts.error = data.error || {};

		// There is an issue with yearto where if I set yearto = 2014, I won't be able to select 2014 dates. 
		// This is a bug in datetimepicker. Currently, temporarily, we manually add 1 to the value if there are value set.
		if (!$.isEmpty(self.options.yearto)) {
			self.options.yearto = parseInt(self.options.yearto) + 1;
		} else {
			self.options.yearto = new Date().getFullYear() + 100
		}

		self.options.yearfrom = self.options.yearfrom || 1930;

		// Add controller on the start date
		self.startDatetime = self.startForm().addController('EasySocial.Controller.Field.Event.Startend.Form', {
			'{parent}': self,
			"type": 'start'
		});

		// Add controller on the end date
		self.endDatetime = self.endForm().addController('EasySocial.Controller.Field.Event.Startend.Form', {
			'{parent}': self,
			"type": 'end'
		});

		// Apply chosen on timezone field
		if (self.timezone().length > 0) {
			self.timezone().chosen({
				allow_single_deselect: true,
				search_contains: true
			});
		}
	},

	'{self} onSubmit': function(el, ev, register) {
		register.push(self.validateInput());
	},

	validateInput: function() {
		self.clearError();

		if ($.isEmpty(self.startDatetime.datetime().val())) {
			self.raiseError(opts.error.start.required);

			return false;
		}

		if (self.options.requireEnd && $.isEmpty(self.endDatetime.datetime().val())) {
			self.raiseError(opts.error.end.required);

			return false;
		}

		return true;
	},

	raiseError: function(msg) {
		self.trigger('error', [msg]);
	},

	clearError: function() {
		self.trigger('clear');
	}
}});

EasySocial.Controller('Field.Event.Startend.Form', {
	defaultOptions: {
		type: null,

		'{picker}': '[data-picker]',
		'{toggle}': '[data-picker-toggle]',
		'{datetime}': '[data-datetime]'
	}
}, function(self, options) {

	return {
		init: function() {
			self.load();
		},

		"{window} easysocial.fields.startend.start.change": function() {

			// When the start date is changed, set the minimum date on the end date
			if (options.type == 'start' && self.parent.endDatetime) {
				self.parent.endDatetime.datetimepicker('destroy');

				self.parent.endDatetime.load();
			}
		},


		'{window} easysocial.fields.allday.change': function(el, ev, value) {
			self.datetimepicker('destroy');

			self.parent.options.allday = value == 1 ? true : false;

			self.load();
		},

		// We move this here because there is a possibility that we want to "reinit"
		load: function() {

			// Generate a minimum date from momentjs
			var minDate = new $.moment();

			// If configured to disallow past dates, we need to minus 1 on the date as we need to allow today.
			if (self.parent.options.disallowPast) {
				minDate.date(minDate.date() - 1);
			} else {
				minDate.year(self.parent.options.yearfrom);
			}

			// If this type is end date, we need to set the minimum date based on the start date
			if (options.type == 'end') {
				var startDatetimeValue = self.parent.startDatetime.datetime().val();

				if (startDatetimeValue) {
					var minDate = $.moment(startDatetimeValue);
					
					// minus 1 on the date as we need to allow today.
					var minDate = minDate.date(minDate.date() - 1);
				}
			}

			var allowTime = self.parent.options.allowTime && !self.parent.options.allday;
			var dateFormat = self.parent.options.dateFormat;

			// If time is not allowed, then we remove the time part
			// Since the format is always (10 chars) (remaining chars)
			// We just substr by 10 chars
			if (!allowTime) {
				dateFormat = dateFormat.substr(0, 10);
			}

			self.picker()._datetimepicker({
				component: "es",
				useCurrent: false,
				format: dateFormat,
				minDate: minDate,
				maxDate: new $.moment({y: self.parent.options.yearto}),
				icons: {
					time: 'far fa-clock',
					date: 'fa fa-calendar',
					up: 'fa fa-chevron-up',
					down: 'fa fa-chevron-down'
				},
				sideBySide: false,
				pickTime: allowTime,
				minuteStepping: parseInt(self.parent.options.minuteStepping),
				language: self.parent.options.calendarLanguage == 'english' ? 'en-gb' : lang,
				dow: self.parent.options.dow
			});

			var date = self.datetime().val();

			// Datetimepicker is using moment.js, hence here we manually create a moment object to pass in instead of passing in date time string
			// This is because datetimepicker.setDate function passes along the format from self.options.calendarDateFormat to generate the date object, which will render moment.js to generate an invalid dateobject
			// self.options.calendarDateFormat is only for display purposes
			// Raw date object is always in SQL format
			if (!$.isEmpty(date)) {
				var dateObj = $.moment(date);

				self.datetimepicker('setDate', dateObj);
			}

			if (options.type == 'end') {
				var startDatetimeValue = self.parent.startDatetime.datetime().val();

				if (startDatetimeValue) {
					var startDateObj = $.moment(startDatetimeValue);

					if (!$.isEmpty(date)) {
						var endDateObj = $.moment(date);

						// If start date is greated than current end date, adjust it accordingly
						if (startDateObj.unix() > endDateObj.unix()) {
							self.datetimepicker('setDate', startDateObj);
						}

					} else {
						// Simulate jump to date based on start date
						self.datetimepicker('setDate', startDateObj);

						// Empty the value again since initially there are no value set
						self.datetimepicker('setDate', '');
						self.datetime().val('');
					}
				}
			}
		},

		datetimepicker: function(name, value) {
			return self.picker().data('DateTimePicker')[name](value);
		},

		'{toggle} click': function() {
			self.picker().focus();
		},

		'{picker} dp.change': function(el, ev) {

			self.setDateValue(ev.date.toDate());

			// easysocial.fields.startend.start.change
			// easysocial.fields.startend.end.change
			$(window).trigger('easysocial.fields.startend.' + options.type + '.change', [ev.date]);
		},

		'{picker} change': function(el, ev) {
			if ($.isEmpty(el.val())) {
				self.datetime().val('');
			}
		},

		setDateValue: function(date) {
			// Convert the date object into sql format and set it into the input
			self.datetime().val(date.getFullYear() + '-' +
								('00' + (date.getMonth()+1)).slice(-2) + '-' +
								('00' + date.getDate()).slice(-2) + ' ' +
								('00' + date.getHours()).slice(-2) + ':' +
								('00' + date.getMinutes()).slice(-2) + ':' +
								('00' + date.getSeconds()).slice(-2));
		}
}});

module.resolve();
});
});
			EasySocial.module('apps/fields/event/startend/display', function($) {

var module = this;

EasySocial
.require()
.library('chosen', 'popbox')
.done(function($) {

EasySocial.Controller('Field.Event.Startend.Display.Box', {
    defaultOptions: {
        date: null,
        timezone: null,
        local: null,
        '{toggle}': '[data-popbox]',
        '{content}': '[data-popbox-content]',
        '{date}': '[data-date]',
        '{timezone}': '[data-timezone]',
        '{loading}': '[data-loading]'
    }
}, function(self, opts) { return {

    init: function() {
        opts.timezone = self.timezone().data('timezone');
        opts.date = self.date().data('date-utc');

        // Get the local timezone first through client browser
        opts.local = -new Date().getTimezoneOffset / 60;

        var content = self.content().html();
        var position = self.toggle().data('popbox-position');

        self.toggle().popbox({
            content: content,
            id: 'es',
            component: 'ui',
            type: 'timezone',
            toggle: 'click',
            position: position
        }).attr('data-popbox', '');
    },

    '{toggle} popboxActivate': function(el, event, popbox) {
        popbox.tooltip.addController('EasySocial.Controller.Field.Event.Startend.Display.Timezone', {
            '{parent}': self
        });
    },

    datetime: $.memoize(function(tz) {
        return EasySocial.ajax('fields/event/startend/getDatetime', {
            "id": opts.id,
            "userid": opts.userid,
            "tz": tz,
            "local": self.options.local,
            "datetime": opts.date
        });
    })
}});

EasySocial.Controller('Field.Event.Startend.Display.Timezone', {
    defaultOptions: {
        '{timezones}': '[data-timezone-select]',
        '{reset}': '[data-timezone-reset]',
        '{local}': '[data-timezone-local]'
    }
}, function(self, opts) { return {
    init: function() {
        self.timezones().chosen({
            search_contains: true
        });
    },

    '{timezones} change': function(dropdown, event) {
        var option = dropdown.find(':selected');
        var value = option.val();
        var text = option.text();

        // Apply loading indicator
        self.parent.element.addClass('is-loading');

        // Update the text
        self.parent.timezone().html(text);

        self.parent.datetime(value).done(function(value) {
            self.parent.date().html(value);
            self.parent.element.removeClass('is-loading');
        });
    },

    '{reset} click': function() {
        self.setTimezone(self.parent.options.timezone);
    },

    '{local} click': function() {
        self.setTimezone('local')
    },

    setTimezone: function(tz) {
        self.timezones()
            .val(tz)
            .trigger('liszt:updated')
            .trigger('change');
    }

}});

module.resolve();

});

});
			EasySocial.module('apps/fields/group/description/content', function($) {

var module = this;

EasySocial.Controller('Field.Group.Description', {
    defaultOptions: {
        "required": false,
        "editor": null,
        "{input}": '[data-field-description]'
    }
}, function(self, opts, base) { return {

    init: function() {
        self.editor = self.options.editor;
    },

    "{self} onRender": function() {
        var data = self.input().htmlData();
        opts.error = data.error || {};
    },

    '{input} keyup': function() {
        self.validateInput();
    },

    '{input} blur': function() {
        self.validateInput();
    },

    validateInput: function() {
        self.clearError();

        var value = self.editor.getContent();

        if (self.options.required && $.isEmpty(value)) {
            self.raiseError(opts.error.required);
            return false;
        }

        return true;
    },

    raiseError: function(msg) {
        self.trigger('error', [msg]);
    },

    clearError: function() {
        self.trigger('clear');
    },

    '{self} onError': function(el, ev, type) {
        if(type === 'required') {
            self.raiseError(opts.error.required);
        }
    },

    '{self} onSubmit': function(el, ev, register) {

        var fieldId = self.options.fieldId;
        var editorName = self.options.editorName;

        // only apply for the tinymce editor
        if (editorName == 'tinymce') {
	        var textareaToggleWrapper = '#' + fieldId;

			if (typeof(tinyMCE) == 'object') {

				// if the editor form still under toggle page (HTML page)
				// We need to automatically toggle it back to the formatter page before submit
				if ($(textareaToggleWrapper).is(":visible")) {
					tinyMCE.execCommand('mceToggleEditor', false, fieldId);
				}
			}
        }

        register.push(self.validateInput());
    }
}});

module.resolve();
});
			EasySocial.module('apps/fields/group/permalink/content', function($) {

var module = this;

EasySocial.Controller('Field.Group.Permalink', {
    defaultOptions: {
        required: false,

        max     : 0,

        id      : null,
        groupid : null,
        userid  : null,

        '{field}'           : '[data-field-permalink]',

        '{checkButton}'     : '[data-permalink-check]',
        '{input}'           : '[data-permalink-input]',
        '{available}'       : '[data-permalink-available]'
    }
}, function(self, opts, base) { return {
    state: false,

    init: function() {
        opts.max = self.field().data('max');
    },

    "{self} onRender": function() {
        var data = self.field().htmlData();

        opts.error = data.error || {};
    },

    "{checkButton} click" : function() {
        self.delayedCheck();
    },

    "{input} keyup" : function()
    {
        self.delayedCheck();
    },

    delayedCheck: $.debounce(function()
    {
        self.checkPermalink();
    }, 250),

    checkPermalink: function()
    {
        self.clearError();

        var permalink   = self.input().val();

        self.available().hide();

        if (self.options.max > 0 && permalink.length > self.options.max) {
            self.raiseError(opts.error.max);
            return false;
        }

        if (!$.isEmpty(permalink)) {
            self.checkButton().addClass('is-loading');

            var state = $.Deferred();

            EasySocial.ajax('fields/group/permalink/isValid', {
                "id"        : self.options.id,
                "groupid"   : self.options.groupid,
                "permalink" : permalink
            })
            .done(function(msg) {
                self.clearError();

                self.checkButton().removeClass('is-loading');

                self.available().show();

                state.resolve();
            })
            .fail(function(msg) {
                self.raiseError(msg);

                self.checkButton().removeClass('is-loading');

                self.available().hide();

                state.reject();
            });

            return state;
        }

        if (self.options.required && $.isEmpty(permalink)) {
            self.available().hide();

            self.raiseError(opts.error.required);
            return false;
        }

        return true;
    },

    raiseError: function(msg) {
        self.trigger('error', [msg]);
    },

    clearError: function() {
        self.trigger('clear');
    },

    '{self} onSubmit': function(el, ev, register) {
        register.push(self.checkPermalink());
    }
}});

module.resolve();
});
			EasySocial.module('apps/fields/group/permalink/sample_content', function($) {
    var module = this;

    EasySocial.Controller('Field.Permalink.Sample', {
        defaultOptions: {
            '{checkPermalink}'      : '[data-check-permalink]'
        }
    }, function(self) {
        return {
            init: function() {

            },

            '{self} onConfigChange': function(el, event, name, value) {
                switch(name) {
                    case 'check_permalink':
                        self.checkPermalink().toggle(!!value);
                    break;
                }
            }
        }
    });

    module.resolve();
});
			EasySocial.module('apps/fields/page/description/content', function($) {

var module = this;

EasySocial.Controller('Field.Page.Description', {
    defaultOptions: {
        "required": false,
        "editor": null,
        "{input}": '[data-field-description]'
    }
}, function(self, opts, base) { return {

    init: function() {
        self.editor = self.options.editor;
    },

    "{self} onRender": function() {
        var data = self.input().htmlData();
        opts.error = data.error || {};
    },

    '{input} keyup': function() {
        self.validateInput();
    },

    '{input} blur': function() {
        self.validateInput();
    },

    validateInput: function() {
        self.clearError();

        var value = self.editor.getContent();

        if (self.options.required && $.isEmpty(value)) {
            self.raiseError(opts.error.required);
            return false;
        }

        return true;
    },

    raiseError: function(msg) {
        self.trigger('error', [msg]);
    },

    clearError: function() {
        self.trigger('clear');
    },

    '{self} onError': function(el, ev, type) {
        if(type === 'required') {
            self.raiseError(opts.error.required);
        }
    },

    '{self} onSubmit': function(el, ev, register) {

        var fieldId = self.options.fieldId;
        var editorName = self.options.editorName;

        // only apply for the tinymce editor
        if (editorName == 'tinymce') {
	        var textareaToggleWrapper = '#' + fieldId;

			if (typeof(tinyMCE) == 'object') {

				// if the editor form still under toggle page (HTML page)
				// We need to automatically toggle it back to the formatter page before submit
				if ($(textareaToggleWrapper).is(":visible")) {
					tinyMCE.execCommand('mceToggleEditor', false, fieldId);
				}
			}
        }

        register.push(self.validateInput());
    }
}});

module.resolve();
});
			EasySocial.module('apps/fields/page/permalink/content', function($) {

var module = this;

EasySocial.Controller('Field.Page.Permalink', {
    defaultOptions: {
        required: false,

        max     : 0,

        id      : null,
        pageid : null,
        userid  : null,

        '{field}'           : '[data-field-permalink]',

        '{checkButton}'     : '[data-permalink-check]',
        '{input}'           : '[data-permalink-input]',
        '{available}'       : '[data-permalink-available]'
    }
}, function(self, opts, base) { return {
    state: false,

    init: function() {
        opts.max = self.field().data('max');
    },

    "{self} onRender": function() {
        var data = self.field().htmlData();

        opts.error = data.error || {};
    },

    "{checkButton} click" : function() {
        self.delayedCheck();
    },

    "{input} keyup" : function()
    {
        self.delayedCheck();
    },

    delayedCheck: $.debounce(function()
    {
        self.checkPermalink();
    }, 250),

    checkPermalink: function()
    {
        self.clearError();

        var permalink   = self.input().val();

        self.available().hide();

        if (self.options.max > 0 && permalink.length > self.options.max) {
            self.raiseError(opts.error.max);
            return false;
        }

        if (!$.isEmpty(permalink)) {
            self.checkButton().addClass('is-loading');

            var state = $.Deferred();

            EasySocial.ajax('fields/page/permalink/isValid', {
                "id"        : self.options.id,
                "pageid"   : self.options.pageid,
                "permalink" : permalink
            })
            .done(function(msg) {
                self.clearError();

                self.checkButton().removeClass('is-loading');

                self.available().show();

                state.resolve();
            })
            .fail(function(msg) {
                self.raiseError(msg);

                self.checkButton().removeClass('is-loading');

                self.available().hide();

                state.reject();
            });

            return state;
        }

        if (self.options.required && $.isEmpty(permalink)) {
            self.available().hide();

            self.raiseError(opts.error.required);
            return false;
        }

        return true;
    },

    raiseError: function(msg) {
        self.trigger('error', [msg]);
    },

    clearError: function() {
        self.trigger('clear');
    },

    '{self} onSubmit': function(el, ev, register) {
        register.push(self.checkPermalink());
    }
}});

module.resolve();
});
			EasySocial.module('apps/fields/page/permalink/sample_content', function($) {
    var module = this;

    EasySocial.Controller('Field.Permalink.Sample', {
        defaultOptions: {
            '{checkPermalink}'      : '[data-check-permalink]'
        }
    }, function(self) {
        return {
            init: function() {

            },

            '{self} onConfigChange': function(el, event, name, value) {
                switch(name) {
                    case 'check_permalink':
                        self.checkPermalink().toggle(!!value);
                    break;
                }
            }
        }
    });

    module.resolve();
});
			EasySocial.module('apps/fields/user/address/content', function($) {

var module = this;

EasySocial.Controller('Field.Address', {
	defaultOptions: {
		required: {},
		show: {},

		"{field}": "[data-field-address]",
		"{address1}": "[data-field-address-address1]",
		"{address2}": "[data-field-address-address2]",
		"{city}": "[data-field-address-city]",
		"{state}": "[data-field-address-state]",
		"{country}": "[data-field-address-country]",
		"{zip}": "[data-field-address-zip]",
		'{required}': '[data-required]',
		'{notice}': '[data-check-notice]'
	}
}, function(self, opts, base) { return {

	init : function() {
	},

	fields: [
		'address1',
		'address2',
		'city',
		'state',
		'zip',
		'country'
	],

	"{self} onRender": function(element, event) {
		var data = self.field().htmlData();

		opts.error = data.error;
	},

	validateInput : function() {
		self.clearError();

		var errorRaised = false;

		self.clearError();

		$.each(self.fields, function(i, field) {
			var el = self[field]();

			el.removeClass('has-error');

			var val = el.val();

			if ($.isEmpty(val) && self.options.required[field] && self.options.show[field]) {
				el.addClass('has-error');

				if (!errorRaised) {
					self.raiseError(opts.error[field]);
					errorRaised = true;
				}
			}
		});

		if (errorRaised) {
			return false;
		}

		return true;
	},

	'{address1}, {address2}, {zip}, {city}, {state} blur': function() {
		self.validateInput();
	},

	'{country} change': function(el) {
		self.validateInput();

		if (self.state().is('select')) {

			if (el.val() == '') {
				self.state().empty();
				var option = $('<option></option>').html(self.options.selectCountryText).val('').appendTo(self.state());

				return;
			}

			EasySocial.ajax('fields/user/address/getStates', {
				id: self.options.id,
				country: el.val()
			}).done(function(states) {
				self.state().empty();
				$('<option></option>').html(self.options.selectStateText).val('').appendTo(self.state());

				$.each(states, function(code, name) {
					var option = $('<option></option>').html(name).val(name).appendTo(self.state());
				});
			});
		}
	},

	raiseError: function(message) {
		self.trigger('error', [message]);

		// self.notice()
		//     .css('color', '#a94442')
		//     .text(msg)
		//     .parent('.controls-error')
		//     .show();
	},

	clearError: function() {
		self.trigger('clear');
	},

	"{self} onSubmit" : function(el, event, register) {
		register.push(self.validateInput());
	},

	"{self} onConfigChange": function(el, event, name, value) {
		var requires = ['address1', 'address2', 'city', 'zip', 'state', 'country'];

		if($.inArray(name, requires) >= 0) {
			self.options.required[name] = !!value;
		}

		self.required().hide();

		$.each(requires, function(i, t) {
			if(self.options[t]) {
				self.required().show();
				return false;
			}
		});
	}
}});

module.resolve();
});
			EasySocial.module('apps/fields/user/address/display_content', function($) {

var module = this;

EasySocial
.require()
.library('gmaps', 'leaflet', 'leaflet-providers')
.done(function() {

EasySocial.Controller('Field.Address.Display', {
	defaultOptions: {
		latitude: null,
		longitude: null,
		ratio: 1,
		mapElementId: 'map',
		'{base}': '[data-location-base]',
		'{map}': '[data-location-map]',
		'{mapImage}': '[data-location-map-image]'
	}
}, function(self) { return {

	init: function() {

		if (self.options.mapElementId) {
			self.mapElementId = self.options.mapElementId;
		}

		var map = self.map();
		self.options.latitude = map.data('latitude');
		self.options.longitude = map.data('longitude');
		self.options.provider = map.data('location-provider');

		self.setLayout();
	},

	'{window} resize': $.debounce(function() {
		self.setLayout();
	}, 250),

	navigate: function(lat, lng) {
		if (!self.options.staticMap && self.options.provider == 'osm') {
			self.navigateDynamic(lat, lng);
			self.base().addClass("has-location");
			self.base().removeClass("is-loading");
			return;
		}

		var mapImage = self.mapImage(),
			width = Math.floor(mapImage.width()),
			height = Math.floor(mapImage.height());

		if (self.options.provider == 'osm') {
			var url = "//maps.wikimedia.org/img/osm-intl,15," + lat + "," + lng + ",600x300.png";
		} else {
			var url = $.GMaps.staticMapURL({
					size: [1280, 1280],
					lat: lat,
					lng: lng,
					sensor: true,
					scale: 2,
					markers: [
						{lat: lat, lng: lng}
					]
				});
		}

		var url = url.replace(/http\:|https\:/, '');

		// When map is loaded, fade in.
		$.Image.get(url)
			.done(function(){
				mapImage.css({
					"backgroundImage": $.cssUrl(url),
					"backgroundSize": "cover",
					"backgroundPosition": "center center"
				});
				self.base().addClass("has-location");
			})
			.always(function(){
				self.base().removeClass("is-loading");
			});
	},

	navigateDynamic: function(lat, lng) {
		self.osm = L.map(self.mapElementId, {
			zoom: 12
		})

		self.osm.fitWorld();

		L.tileLayer.provider('Wikimedia').addTo(self.osm);

		var latlng = {
			lat: parseFloat(lat),
			lng: parseFloat(lng)
		}

		self.osm.flyTo(latlng, 13, {
			"duration": 3
		});

		marker = L.marker(latlng).addTo(self.osm);
	},

	setLayout: function() {
		setTimeout(function() {
			if (self.options.latitude && self.options.longitude) {
				self.navigate(self.options.latitude, self.options.longitude);
				// self.navigateDynamic(self.options.latitude, self.options.longitude);
			}
		}, 1);
	},

	'{self} onShow': function() {
		self.setLayout();
	}
}});

module.resolve();
});
});
			EasySocial.module('apps/fields/user/address/maps', function($) {
var module = this;

// Create search template first
$.template('easysocial/maps.suggestion', '<div class="es-location-suggestion" data-location-suggestion><span class="formatted_address">[%= location.formatted_address %]</span></div>');

EasySocial
.require()
.library('gmaps', 'placeholder', 'image')
.done(function() {

// Constants
var KEYCODE = {
	BACKSPACE: 8,
	COMMA: 188,
	DELETE: 46,
	DOWN: 40,
	ENTER: 13,
	ESCAPE: 27,
	LEFT: 37,
	RIGHT: 39,
	SPACE: 32,
	TAB: 9,
	UP: 38
};

EasySocial.Controller('Field.Address.Maps', {
	defaultOptions: {
		zoom: 2,

		latitude: null,
		longitude: null,
		address: null,

		singleLocation: true,
		staticMap: false,

		required: false,

		ratio: 3,

		'{field}': '[data-field-address]',

		'{base}': '[data-location-base]',

		'{map}': '[data-location-map]',
		'{mapImage}': '[data-location-map-image]',

		'{detectButton}': '[data-location-detect]',
		'{removeButton}': '[data-location-remove]',

		'{form}': '[data-location-form]',
		'{textbox}': '[data-location-textbox]',
		'{textField}': '[data-location-textfield]',

		'{autocomplete}': '[data-location-autocomplete]',
		'{suggestions}': '[data-location-suggestions]',
		'{suggestion}': '[data-location-suggestion]',

		'{source}': '[data-location-source]',

		view: {
			suggestion: 'maps.suggestion'
		}
	}
}, function(self, opts, base) { return {

	init: function() {

		var data = self.field().htmlData();

		opts.error = data.error || {};

		if (navigator.geolocation) {
			self.base().addClass("is-detectable");
			// self.detectButton().show();
		}

		// Add placeholder support for IE9
		self.textField().placeholder();

		// Allow textField input only when controller is implemented
		self.textField().removeAttr("disabled");

		if (!$.isEmpty(self.source().val())) {
			var data = JSON.parse(self.source().val());

			if (data.latitude && data.longitude) {
				if (opts.staticMap) {
					self.navigate(data.latitude, data.longitude);
				} else {
					self.navigateDynamic(data.latitude, data.longitude);
				}

				self.base().addClass("has-location");
			}
		}
	},

	renderDynamicMap: function(latitude, longitude) {

		if (typeof gmap === 'undefined') {
			// Init for the dynamic map
			gmap = new $.GMaps({
				div: '#map',
				lat: latitude,
				lng: longitude,
				zoom: 15,
				mapTypeId: 'roadmap',
				zoomControl: true,
				clickableIcons: false,
				streetViewControl: false,
				mapTypeControl: false
			});
		} else {
			gmap.setCenter(latitude, longitude);
		}

		// This event listener will call addMarker() when the map is clicked.
		gmap.addListener('click', function(event) {
			var location = event.latLng;

			// Populate the marker on the map
			self.populateMarker(location.lat(), location.lng(), 'addmarker');
		});
	},

	populateMarker: function(lat, lng, action) {
		// We will remove all markers first (if any)
		gmap.removeMarkers();

		// Add the new marker on the map
		var marker = gmap.addMarker({
			lat: lat,
			lng: lng
		});

		gmap.setCenter(lat, lng);

		var currentZoom = gmap.map.zoom;

		// If the current zoom too far,
		// we zoom in a bit
		if (currentZoom < 13) {
			gmap.fitZoom();
			gmap.zoomOut(9);
		}
		
		// If this comes from addmarker action,
		// we need to get the correct address and update the field
		if (action == 'addmarker') {
			self.processMarker(marker);
		}
	},

	processMarker: function(marker, oldMarkerId) {

		markerLat = marker.getPosition().lat();
		markerLng = marker.getPosition().lng();

		// markers[markerId] = marker;

		var markerObj = {
					lat: markerLat,
					lng: markerLng
				}

		// Try to get the address from the given lat lng
		self.lookupLatLng(markerObj);
	},

	updateField: function(markerObj, venue) {

		// Fill in the field with address
		self.textField().val(markerObj.name);

		self.base().addClass("has-location");

		// Set the source here
		self.result = venue;
		var data = self.getResult('source');
		self.source().val(JSON.stringify(data));
	},

	"{window} resize": $.debounce(function() {

		var data = JSON.parse(self.source().val());

		if (!data.latitude || !data.longitude) {
			return;
		}

		var mapImage = self.mapImage();

		if (mapImage.data("width") !== mapImage.width()) {
			self.navigate(data.latitude, data.longitude);
		}

	}, 250),

	'{self} onShow': function() {

		var data = JSON.parse(self.source().val());

		if (!data.latitude || !data.longitude) {
			return;
		}

		var mapImage = self.mapImage();

		if (mapImage.data("width") !== mapImage.width()) {
			self.navigate(data.latitude, data.longitude);
		}
	},

	navigateDynamic: function(lat, lng) {
		self.renderDynamicMap(lat, lng);
		self.populateMarker(lat, lng);
	},

	navigate: function(lat, lng) {
		self.field().css({
			"max-width": "none"
		});

		var mapImage = self.mapImage(),
			apiKey = window.es.gmapsApiKey,
			width = Math.floor(mapImage.width()),
			height = Math.floor(mapImage.height()),
			url = $.GMaps.staticMapURL({
				key: apiKey,
				size: [1280, 1280],
				lat: lat,
				lng: lng,
				sensor: true,
				scale: 2,
				markers: [
					{lat: lat, lng: lng}
				]
			});

		// When map is loaded, fade in.
		$.Image.get(url)
			.done(function(){
				mapImage.css({
					"backgroundImage": $.cssUrl(url),
					"backgroundSize": "cover",
					"backgroundPosition": "center center"
				});
				self.base().addClass("has-location");
			})
			.always(function(){
				self.base().removeClass("is-loading");
			});
	},

	locations: {},

	lastQueryAddress: null,

	results: [],

	result: null,

	"{textField} keypress": function(textField, event) {

		switch (event.keyCode)
		{
			case KEYCODE.UP:

				var prevSuggestion = $(
					self.suggestion(".active").prev(self.suggestion.selector)[0] ||
					self.suggestion(":last")[0]
				);

				// Remove all active class
				self.suggestion().removeClass("active");

				prevSuggestion
					.addClass("active")
					.trigger("activate");

				self.suggestions()
					.scrollTo(prevSuggestion, {
						offset: prevSuggestion.height() * -1
					});

				event.preventDefault();

				break;

			case KEYCODE.DOWN:

				var nextSuggestion = $(
					self.suggestion(".active").next(self.suggestion.selector)[0] ||
					self.suggestion(":first")[0]
				);

				// Remove all active class
				self.suggestion().removeClass("active");

				nextSuggestion
					.addClass("active")
					.trigger("activate");

				self.suggestions()
					.scrollTo(nextSuggestion, {
						offset: nextSuggestion.height() * -1
					});

				event.preventDefault();

				break;

			case KEYCODE.ENTER:

				var activeSuggestion = self.suggestion(".active"),
					location = activeSuggestion.data("location");
					self.set(location);

				self.hideSuggestions();
				break;

			case KEYCODE.ESCAPE:
				self.hideSuggestions();
				break;
		}

	},

	"{textField} keyup": function(textField, event) {

		switch (event.keyCode) {

			case KEYCODE.UP:
			case KEYCODE.DOWN:
			case KEYCODE.LEFT:
			case KEYCODE.RIGHT:
			case KEYCODE.ENTER:
			case KEYCODE.ESCAPE:
				// Don't repopulate if these keys were pressed.
				break;

			default:
				var address = $.trim(textField.val());

				if (address==="") {
					self.base().removeClass("has-location");
					self.hideSuggestions();
				}

				// if (address==self.lastQueryAddress) return;

				var locations = self.locations[address];

				// If this location has been searched before
				if (locations) {

					// And set our last queried address to this address
					// so that it won't repopulate the suggestion again.
					self.lastQueryAddress = address;

					// Just use cached results
					self.suggest(locations);

				// Else ask google to find it out for us
				} else {
					self.lookup(address);
				}
				break;
		}
	},

	lookupLatLng: $.debounce(function(markerObj) {

		self.base().addClass("is-loading");

		$.GMaps.geocode({
			lat: markerObj.lat,
			lng: markerObj.lng,
			callback: function(locations, status) {

				self.base().removeClass("is-loading");

				if (status == "OK") {
					markerObj.name = locations[0].formatted_address;
					self.updateField(markerObj, locations[0]);
				}
			}
		});

	}, 250),

	lookup: $.debounce(function(address) {

		self.detectButton().addClass("is-loading");

		$.GMaps.geocode({
			address: address,
			callback: function(locations, status) {

				self.detectButton().removeClass("is-loading");

				if (status=="OK") {

					// Store a copy of the results
					self.locations[address] = locations;

					// Suggestion locations
					self.suggest(locations);

					self.lastQueryAddress = address;
				}
			}
		});

	}, 250),

	suggest: function(locations) {

		var suggestions = self.suggestions();

		// Clear location suggestions
		suggestions
			.empty();

		if (locations.length < 0) return;

		self.results = locations;

		$.each(locations, function(i, location){
			// Create suggestion and append to list
			self.view.suggestion({
					location: location
				})
				.data("location", location)
				.appendTo(suggestions);
		});

		self.showSuggestions();
	},

	showSuggestions: function() {

		self.focusSuggestion = true;

		self.element.find(".es-story-footer")
			.addClass("swap-zindex");

		setTimeout(function(){

			self.autocomplete().addClass("active");

			var doc = $(document),
				hideOnClick = "click.es.story.location";

			doc
				.off(hideOnClick)
				.on(hideOnClick, function(event){

					// Collect list of bubbled elements
					var targets = $(event.target).parents().andSelf();

					if (targets.filter(self.element).length > 0) return;

					doc.off(hideOnClick);

					self.hideSuggestions();
				});

		}, 500);
	},

	hideSuggestions: function() {

		self.focusSuggestion = false;

		self.autocomplete().removeClass("active");

		$(document).off("click.es.story.location");

		setTimeout(function(){

			if (self.focusSuggestion) return;

			self.element.find(".es-story-footer")
				.removeClass("swap-zindex");

		}, 500);
	},

	"{suggestion} activate": function(suggestion, event) {

		var location = suggestion.data("location");
		var lat = location.geometry.location.lat(),
			lng = location.geometry.location.lng();

		if (opts.staticMap) {
			self.navigate(lat, lng);
		} else {
			self.navigateDynamic(lat, lng);
		}
	},

	"{suggestion} mouseover": function(suggestion) {

		// Remove all active class
		self.suggestion().removeClass("active");

		suggestion
			.addClass("active")
			.trigger("activate");
	},

	"{suggestion} click": function(suggestion, event) {

		var location = suggestion.data("location");

		self.set(location);

		self.hideSuggestions();

		self.validateInput();
	},

	set: function(location) {
		self.currentLocation = location;

		var lat = location.geometry.location.lat(),
			lng = location.geometry.location.lng();

		// self.navigateDynamic(lat, lng);

		var address = location.formatted_address;

		self.textField().val(address);

		self.lastQueryAddress = address;

		self.base().addClass("has-location");

		// Set the source here
		self.result = location;
		var data = self.getResult('source');
		self.source().val(JSON.stringify(data));
	},

	unset: function() {

		gmap.removeMarkers();

		self.currentLocation = null;

		self.textField().val('');

		self.base().removeClass("has-location");

		self.source().val('');
	},

	detectTimer: null,

	"{detectButton} click": function() {

		var textbox = self.textbox();

		self.detectButton().addClass("is-loading");

		clearTimeout(self.detectTimer);

		self.detectTimer = setTimeout(function() {
			self.detectButton().removeClass("is-loading");
		}, 8000);

		$.GMaps.geolocate({
			success: function(position) {
				$.GMaps.geocode({
					lat: position.coords.latitude,
					lng: position.coords.longitude,
					callback: function(locations, status) {
						if (status=="OK") {
							self.suggest(locations);
							self.textField().focus();
						}
					}
				});
			},
			error: function(error) {
				var message = "";

				switch (error.code) {

					case 1:
						message = opts.error.map.permission;
						break;

					case 2:
						message = opts.error.map.timeout;
						break;

					case 3:
					default:
						message = opts.error.map.unavailable;
						break;
				}

				// story.setMessage(message);
			},
			always: function() {
				clearTimeout(self.detectTimer);
				self.detectButton().removeClass("is-loading");
			}
		});
	},

	raiseError: function(message) {
		self.trigger('error', [message]);
	},

	clearError: function() {
		self.trigger('clear');
	},

	validateInput : function() {
		self.clearError();

		if ($.isEmpty(self.source().val()) && opts.required) {
			self.raiseError(opts.error.maps);
			return false;
		}

		var value = self.source().val();

		if (value) {
			var data = JSON.parse(value);

			if ((!data.latitude || !data.longitude) && opts.required) {
				self.raiseError(opts.error.maps);
				return false;
			}
		}

		return true;
	},

	"{self} onSubmit" : function(el, event, register) {
		register.push(self.validateInput());
	},

	"{removeButton} click": function() {
		self.unset();
		self.hideSuggestions();
		self.validateInput();
	},

	getResult: function(type) {
		if (!self.result) {
			if (self.results.length === 0) {
				return false;
			}

			self.result = self.results[0];
		}

		var r = self.result;
// console.log(r);
		if (type === undefined) {
			return r;
		}

		switch(type) {
			case 'coords':
				return {
					lat: r.geometry.location.lat(),
					lng: r.geometry.location.lng()
				}
			break;

			case 'lat':
			case 'latitude':
				return r.geometry.location.lat();
			break;

			case 'lng':
			case 'longitude':
				return r.geometry.location.lng();
			break;

			case 'address':
				return r.formatted_address;
			break;

			case 'viewport':
				return r.geometry.viewport;
			break;

			case 'bounds':
				return r.geometry.bounds || r.geometry.viewport;
			break;

			case 'source':
				var components = {};

				$.each(r.address_components, function(index, component) {
					if (component.types[0]) {
						components[component.types[0]] = component.long_name;
					}
				});

				var mapping = {
					'address1': ['street_address', 'route'],
					'address2': ['intersection', 'colloquial_area', 'neighborhood', 'premise', 'subpremise'],
					'city': ['locality', 'sublocality', 'sublocality_level_1', 'sublocality_level_2', 'sublocality_level_3', 'sublocality_level_4', 'sublocality_level_5'],
					'state': ['administrative_area_level_1', 'administrative_area_level_2', 'administrative_area_level_3'],
					'zip': 'postal_code',
					'country': 'country'
				};

				// Based on the mapping we build the legacy data
				var legacy = {};

				$.each(mapping, function(key, value) {

					// Init with empty data
					legacy[key] = '';

					if ($.isArray(value)) {
						$.each(value, function(i, v) {

							// Search if components[v] exists
							if (components[v] !== undefined) {

								// Use it if it exists
								legacy[key] = components[v];

								// Break out and ignore other possible keys
								return false;
							} else {

								// Continue finding
								return true;
							}
						});

						// Continue on to the next key
						return true;
					}

					if (components[value] !== undefined) {
						legacy[key] = components[value];
					}
				});

				var data = $.extend(legacy, {
					components: components,
					address: r.formatted_address,
					latitude: r.geometry.location.lat(),
					longitude: r.geometry.location.lng()
				});

				return data;
			break;
		}
	}
}});

module.resolve();
});
});
			EasySocial.module('apps/fields/user/address/osm', function($) {
var module = this;

// Create search template first
$.template('easysocial/maps.suggestion', '<div class="es-location-suggestion" data-location-suggestion><span class="formatted_address">[%= location.formatted_address %]</span></div>');

EasySocial
.require()
.library('leaflet', 'placeholder', 'image', 'leaflet-providers')
.done(function() {

// Constants
var KEYCODE = {
	BACKSPACE: 8,
	COMMA: 188,
	DELETE: 46,
	DOWN: 40,
	ENTER: 13,
	ESCAPE: 27,
	LEFT: 37,
	RIGHT: 39,
	SPACE: 32,
	TAB: 9,
	UP: 38
};

EasySocial.Controller('Field.Address.Osm', {
	defaultOptions: {
		required: false,
		mapElementId: 'map',
		staticMap: false,

		'{field}': '[data-field-address]',
		'{base}': '[data-location-base]',

		'{map}': '[data-location-map]',
		'{mapImage}': '[data-location-map-image]',

		'{detectButton}': '[data-location-detect]',
		'{removeButton}': '[data-location-remove]',

		'{form}': '[data-location-form]',
		'{textbox}': '[data-location-textbox]',
		'{textField}': '[data-location-textfield]',

		'{autocomplete}': '[data-location-autocomplete]',
		'{suggestions}': '[data-location-suggestions]',
		'{suggestion}': '[data-location-suggestion]',

		'{source}': '[data-location-source]',

		view: {
			suggestion: 'maps.suggestion'
		},

		marker: {},
	}
}, function(self, opts, base) { return {
	init: function() {

		if (self.options.mapElementId) {
			self.mapElementId = self.options.mapElementId;
		}

		var data = self.field().htmlData();

		opts.error = data.error || {};

		// Only show auto-detect button if the browser supports geolocation
		if (navigator.geolocation && window.es.isHttps) {
			self.base().addClass("is-detectable");
			self.detectButton().show();
		}

		self.textField().removeAttr("disabled");

		if (!$.isEmpty(self.source().val())) {
			var data = JSON.parse(self.source().val());

			if (data.latitude && data.longitude) {
				lat = data.latitude;
				lng = data.longitude;

				self.initMap();

				self.navigate(lat, lng);

				self.base().addClass("has-location");
			}
		}
	},

	initMap: function() {

		if (opts.staticMap) {
			return;
		}

		if (self.osm !== undefined) {
			return;
		}

		self.osm = L.map(self.mapElementId, {
			zoom: 12
		});

		self.osm.fitWorld();

		L.tileLayer.provider('Wikimedia').addTo(self.osm);

		// Add placeholder support for IE9
		self.textField().placeholder();

		// Allow textField input only when controller is implemented
		self.textField().removeAttr("disabled");

		function onMapClick(e) {
			var latlng = e.latlng;

			self.osm.removeLayer(self.marker);
			self.marker = L.marker(latlng).addTo(self.osm);
			self.osm.setView(latlng);
			self.lookupLatLng(latlng);
		}

		self.osm.on('click', onMapClick);
	},

	marker: {},

	updateField: function(result) {

		// Fill in the field with address
		self.textField().val(result[0].formatted_address);

		self.base().addClass("has-location");

		// Set the source here
		self.result = result[0];
		var data = self.getResult('source');
		self.source().val(JSON.stringify(data));
	},


	"{window} resize": $.debounce(function() {

		var data = JSON.parse(self.source().val());

		if (!data.latitude || !data.longitude) {
			return;
		}

		var mapImage = self.mapImage();

		if (mapImage.data("width") !== mapImage.width()) {
			self.navigate(data.latitude, data.longitude);
		}

	}, 250),

	'{self} onShow': function() {

		var data = JSON.parse(self.source().val());

		if (!data.latitude || !data.longitude) {
			return;
		}

		var mapImage = self.mapImage();

		if (mapImage.data("width") !== mapImage.width()) {
			self.navigate(data.latitude, data.longitude);
		}
	},

	navigate: function(lat, lng) {
		if (opts.staticMap) {
			self.navigateStatic(lat, lng);
		} else {
			self.navigateDynamic(lat, lng);
		}
	},

	navigateStatic: function(lat, lng) {
		self.field().css({
			"max-width": "none"
		});

		var url = "//maps.wikimedia.org/img/osm-intl,13," + lat + "," + lng + ",600x300.png";

		var mapImage = self.mapImage();

		// When map is loaded, fade in.
		$.Image.get(url)
			.done(function(){
				mapImage.css({
					"backgroundImage": $.cssUrl(url),
					"backgroundSize": "cover",
					"backgroundPosition": "center center"
				});
				self.base().addClass("has-location");
			})
			.always(function(){
				self.base().removeClass("is-loading");
			});
		},

	navigateDynamic: function(lat, lng) {
		self.detectButton().addClass("t-hidden");

		self.field().css({
			"max-width": "none"
		});

		var latlng = {
					lat: parseFloat(lat),
					lng: parseFloat(lng)
				}
		self.osm.removeLayer(self.marker);

		self.osm.flyTo(latlng, 10, {
			"duration": 3
		});

		self.marker = L.marker(latlng).addTo(self.osm);
	},

	locations: {},

	lastQueryAddress: null,

	results: [],

	result: null,

	"{textField} keypress": function(textField, event) {

		switch (event.keyCode)
		{
			case KEYCODE.UP:

				var prevSuggestion = $(
					self.suggestion(".active").prev(self.suggestion.selector)[0] ||
					self.suggestion(":last")[0]
				);

				// Remove all active class
				self.suggestion().removeClass("active");

				prevSuggestion
					.addClass("active")
					.trigger("activate");

				self.suggestions()
					.scrollTo(prevSuggestion, {
						offset: prevSuggestion.height() * -1
					});

				event.preventDefault();

				break;

			case KEYCODE.DOWN:

				var nextSuggestion = $(
					self.suggestion(".active").next(self.suggestion.selector)[0] ||
					self.suggestion(":first")[0]
				);

				// Remove all active class
				self.suggestion().removeClass("active");

				nextSuggestion
					.addClass("active")
					.trigger("activate");

				self.suggestions()
					.scrollTo(nextSuggestion, {
						offset: nextSuggestion.height() * -1
					});

				event.preventDefault();

				break;

			case KEYCODE.ENTER:

				var activeSuggestion = self.suggestion(".active"),
					location = activeSuggestion.data("location");

					if (location !== undefined) {
						self.set(location);
					}

				self.hideSuggestions();
				break;

			case KEYCODE.ESCAPE:
				self.hideSuggestions();
				break;
		}

	},

	"{textField} keyup": function(textField, event) {

		switch (event.keyCode) {

			case KEYCODE.UP:
			case KEYCODE.DOWN:
			case KEYCODE.LEFT:
			case KEYCODE.RIGHT:
			case KEYCODE.ENTER:
			case KEYCODE.ESCAPE:
				// Don't repopulate if these keys were pressed.
				break;

			default:
				var address = $.trim(textField.val());

				if (address==="") {
					self.base().removeClass("has-location");
					self.hideSuggestions();
				}

				// if (address==self.lastQueryAddress) return;

				var locations = self.locations[address];

				// If this location has been searched before
				if (locations) {

					// And set our last queried address to this address
					// so that it won't repopulate the suggestion again.
					self.lastQueryAddress = address;

					// Just use cached results
					self.suggest(locations);

				// Else ask google to find it out for us
				} else {
					self.lookup(address);
				}
				break;
		}
	},

	lookupLatLng: $.debounce(function(latlng) {

		self.base().addClass("is-loading");

		EasySocial.ajax('site/controllers/location/getLocations', {
			latitude: latlng.lat,
			longitude: latlng.lng
		})
		.done(function(result) {
			self.base().removeClass("is-loading");
			self.updateField(result);
		});

	}, 250),

	lookup: $.debounce(function(address) {

		self.detectButton().addClass("is-loading");
		self.base().addClass("is-loading");

		EasySocial.ajax('site/controllers/location/getLocations', {
			query: address
		})
		.done(function(locations) {
			// Store a copy of the results
			self.locations[address] = locations;

			// Suggestion locations
			self.suggest(locations);

			self.lastQueryAddress = address;
		});

	}, 250),

	suggest: function(locations) {

		var suggestions = self.suggestions();

		// Clear location suggestions
		suggestions
			.empty();

		if (locations.length < 0) return;

		self.results = locations;

		$.each(locations, function(i, location){

			location.formatted_address = location.formatted_address;
			// Create suggestion and append to list
			self.view.suggestion({
					location: location
				})
				.data("location", location)
				.appendTo(suggestions);
		});

		self.showSuggestions();

		self.base().removeClass("is-loading");
	},

	showSuggestions: function() {

		self.focusSuggestion = true;

		self.element.find(".es-story-footer")
			.addClass("swap-zindex");

		setTimeout(function(){

			self.autocomplete().addClass("active");

			var doc = $(document),
				hideOnClick = "click.es.story.location";

			doc
				.off(hideOnClick)
				.on(hideOnClick, function(event){

					// Collect list of bubbled elements
					var targets = $(event.target).parents().andSelf();

					if (targets.filter(self.element).length > 0) return;

					doc.off(hideOnClick);

					self.hideSuggestions();
				});

		}, 500);
	},

	hideSuggestions: function() {

		self.focusSuggestion = false;

		self.autocomplete().removeClass("active");

		$(document).off("click.es.story.location");

		setTimeout(function(){

			if (self.focusSuggestion) return;

			self.element.find(".es-story-footer")
				.removeClass("swap-zindex");

		}, 500);
	},

	"{suggestion} activate": function(suggestion, event) {

		self.initMap();

		var location = suggestion.data("location");

		var lat = location.latitude,
			lng = location.longitude;

		self.navigate(lat, lng);
	},

	"{suggestion} mouseover": function(suggestion) {

		// Remove all active class
		self.suggestion().removeClass("active");

		suggestion
			.addClass("active")
			.trigger("activate");
	},

	"{suggestion} click": function(suggestion, event) {

		self.initMap();

		var location = suggestion.data("location");

		self.set(location);

		self.hideSuggestions();

		self.validateInput();
	},

	set: function(location) {
		self.currentLocation = location;

		var lat = location.latitude,
			lng = location.longitude;

		var address = location.formatted_address;

		self.textField().val(address);

		self.lastQueryAddress = address;

		self.base().addClass("has-location");

		// Set the source here
		self.result = location;
		var data = self.getResult('source');
		self.source().val(JSON.stringify(data));
	},

	unset: function() {

		self.osm.removeLayer(self.marker);

		self.currentLocation = null;

		self.textField().val('');

		self.base().removeClass("has-location");

		self.source().val('');
	},

	detectTimer: null,

	"{detectButton} click": function() {

		var textbox = self.textbox();

		self.detectButton().addClass("is-loading");

		clearTimeout(self.detectTimer);

		self.detectTimer = setTimeout(function() {
			self.detectButton().removeClass("is-loading");

			navigator.geolocation.getCurrentPosition(

				// If successful
				function(position) {
					var coords = position.coords;

					lat = coords.latitude,
					lng = coords.longitude;

					self.initMap();

					self.navigate(lat, lng);
					self.lookupLatLng({lat: lat, lng: lng});
				}
			);
		}, 2000);
	},

	raiseError: function(message) {
		self.trigger('error', [message]);
	},

	clearError: function() {
		self.trigger('clear');
	},

	validateInput : function() {
		self.clearError();

		if ($.isEmpty(self.source().val()) && opts.required) {
			self.raiseError(opts.error.maps);
			return false;
		}

		var value = self.source().val();

		if (value) {
			var data = JSON.parse(value);

			if ((!data.latitude || !data.longitude) && opts.required) {
				self.raiseError(opts.error.maps);
				return false;
			}
		}

		return true;
	},

	"{self} onSubmit" : function(el, event, register) {
		register.push(self.validateInput());
	},

	"{removeButton} click": function() {
		self.unset();
		self.hideSuggestions();
		self.validateInput();
	},

	getResult: function(type) {
		if (!self.result) {
			if (self.results.length === 0) {
				return false;
			}

			self.result = self.results[0];
		}

		var r = self.result;

		if (type === undefined) {
			return r;
		}

		switch(type) {
			case 'coords':
				return {
					lat: r.latitude,
					lng: r.longitude
				}
			break;

			case 'lat':
			case 'latitude':
				return r.latitude;
			break;

			case 'lng':
			case 'longitude':
				return r.longitude;
			break;

			case 'address':
				return r.formatted_address;
			break;

			// case 'viewport':
			// 	return r.geometry.viewport;
			// break;

			// case 'bounds':
			// 	return r.geometry.bounds || r.geometry.viewport;
			// break;

			case 'source':
				var components = {};

				$.each(r.address, function(index, component) {
					components[index] = component;
				});

				var mapping = {
					'address1': ['mall', 'route', 'building', 'public_building'],
					'address2': ['road', 'neighborhood', 'premise', 'subpremise'],
					'city': ['city', 'suburb'],
					'state': 'state',
					'zip': 'postcode',
					'country': 'country'
				};

				// Based on the mapping we build the legacy data
				var legacy = {};

				$.each(mapping, function(key, value) {

					// Init with empty data
					legacy[key] = '';

					if ($.isArray(value)) {
						$.each(value, function(i, v) {

							// Search if components[v] exists
							if (components[v] !== undefined) {

								// Use it if it exists
								legacy[key] = components[v];

								// Break out and ignore other possible keys
								return false;
							} else {

								// Continue finding
								return true;
							}
						});

						// Continue on to the next key
						return true;
					}

					if (components[value] !== undefined) {
						legacy[key] = components[value];
					}
				});

				var data = $.extend(legacy, {
					components: components,
					address: r.formatted_address,
					latitude: r.latitude,
					longitude: r.longitude
				});

				return data;
			break;
		}
	}
}});

module.resolve();
});
});
			EasySocial.module('apps/fields/user/autocomplete/content', function($) {

var module = this;

EasySocial
.require()
.library('textboxlist')
.done(function($) {

EasySocial.Controller('Field.Autocomplete', {
	defaultOptions: {

		required: false,
		id: null,
		types: null,
		fieldname: null,
		actor: null,
		target: null,

		// Determines pre-selected items
		selectedItems: [],

		// Suggest properties
		max: null,
		exclusive: true,
		exclusion: [],
		minLength: 1,
		highlight: true,
		name: "uid[]",
		type: "",

		"{suggest}": "[data-field-suggest]"
	}
}, function(self, opts, base) { return {
	init: function() {

		// Set the input's name.
		opts.name = opts.fieldname + '[]';

		self.initSuggest();
	},

	// Implement the textbox list on the implemented element.
	initSuggest: function() {
		
		self.suggest()
			.textboxlist({
				component: 'es',
				name: opts.name,
				max: opts.max,
				plugin: {
					autocomplete: {
						exclusive: opts.exclusive,
						minLength: opts.minLength,
						highlight: opts.highlight,
						showLoadingHint: true,
						showEmptyHint: true,
						emptyMessage: opts.emptyMessage,

						query: function(keyword) {

							var result = EasySocial.ajax('fields/user/autocomplete/suggest', {
															"search": keyword,
															"id": opts.id
														});
							return result;
						}
					}
				}
			})
			.textboxlist("enable");
	},

	"{suggest} removeItem": function(el, event, menu) {
		
		// When an item is removed, remove it from the exclusion list
		var isExcluded = $.inArray(menu.id.toString(), opts.exclusion) > -1;

		if (isExcluded) {
			opts.exclusion.splice(opts.exclusion.indexOf(menu.id.toString()), 1);
		}
	},

	"{suggest} filterMenu": function(el, event, menu, menuItems, autocomplete, textboxlist) {

		// Get list of items that are already added into the bucket
		var selected = textboxlist.getAddedItems();
		var selected = $.pluck(selected, "id");

		// Add the items into the exclusion
		var ids = selected.concat(opts.exclusion);

		var exclude = [];

		// Convert selected id into string. #1799
		$.each(ids, function(idx, id) {
			exclude.push(id.toString());
		});

		menuItems.each(function(){

			var menuItem = $(this);
			var item = menuItem.data("item");

			var isSelected = $.inArray(item.id.toString(), exclude) > -1;
			menuItem.toggleClass('hidden', isSelected);
			
		});
	}
}});

module.resolve();

});
});
			EasySocial.module('apps/fields/user/avatar/content', function($) {

var module = this;

EasySocial
.require()
.library('image', 'imgareaselect')
.done(function(){

EasySocial.Controller('Field.Avatar', {
	defaultOptions: {
		required: false,
		id: 0,
		group: null,
		origSource: null,
		defaultAvatar: null,
		hasAvatar: null,

		'{field}': '[data-field-avatar]',

		'{gallery}': '[data-field-avatar-gallery]',
		'{galleryList}': '[data-field-avatar-gallery-items]',
		'{galleryItem}': '[data-field-avatar-gallery-item]',

		'{frame}': '[data-field-avatar-frame]',
		'{viewport}': '[data-field-avatar-viewport]',

		'{avatarSource}': '[data-field-avatar-source]',
		'{avatarData}': '[data-field-avatar-data]',
		'{avatarPath}': '[data-field-avatar-path]',
		'{avatarType}': '[data-field-avatar-type]',
		'{avatarName}': '[data-field-avatar-name]',

		'{file}': '[data-field-avatar-file]',
		'{image}': '[data-field-avatar-selected]',

		'{note}': '[data-field-avatar-note]',
		'{error}': '[data-field-avatar-error]',

		'{actions}': '[data-field-avatar-actions]',

		'{cancel}': '[data-field-avatar-actions-cancel]',
		'{crop}': '[data-field-avatar-actions-crop]',

		'{removeFrame}': '[data-field-avatar-remove]',
		'{remove}': '[data-field-avatar-remove-button]',
		'{revertFrame}': '[data-field-avatar-revert]',
		'{revert}': '[data-field-avatar-revert-button]',

		'{browseButton}': '[data-browse-avatar]'
	}
}, function(self, opts, base) { return {

	init: function() {
		self.state = !!self.options.hasAvatar;
	},

	initErrorOpts: function() {
		var data = self.field().htmlData();

		opts.error = data.error || {};
	},

	state: true,
	hasAdjustedCropImage: false,

	"{self} onRender": function() {
		self.initErrorOpts();
	},

	toggleLoader: function() {
		isLoading = self.browseButton().hasClass('is-loading');
		self.browseButton().toggleClass('is-loading', !isLoading);
	},

	"{file} change": function(el, event) {

		if($.isEmpty(el.val())) {
			return;
		}

		// Compatibility with input-group
		var label = el.val().replace(/\\/g, '/').replace(/.*\//, '');
		el.parents('.input-group').find(':text').val(label);

		// Set state to false
		self.state = false;

		// Show the loader
		self.toggleLoader();

		// Hide the previous picture
		self.frame().hide();

		// Hide the file upload field
		self.file().hide();

		// Hide the error frame
		self.clearError();

		EasySocial.ajax('fields/' + self.options.group + '/avatar/upload', {
			id: self.options.id,
			files: el
		}, {
			type: "iframe"
		})
		.done(function(raw, uri, path) {

			// Set the name of the image
			self.avatarName().val(raw.name);

			// Set the source of the image
			self.avatarSource().val(uri);

			// Set the path of the image
			self.avatarPath().val(path);

			// Set the type as upload
			self.avatarType().val('upload');

			// Load the imgareaselect for cropping
			self.setLayout(uri);

			// Unset all gallery item
			self.galleryItem().removeClass('active');

			// Hide the remove button
			self.removeFrame().hide();

			// Hide the revert button
			self.revertFrame().hide();

			// Set state to true
			self.state = true;
		})
		.fail(function(msg) {
			self.toggleLoader();

			self.raiseError(msg);

			self.file().show();
		});
	},

	setLayout: function(img) {
		var loader = $.Image.get(img),
			frame = self.frame();

		loader.done(function(el, image) {
			frame.css('background-image', $.cssUrl(img));

			frame.addClass('avatar-frame-crop');

			frame.show();

			self.toggleLoader();

			self.actions().show();

			self.note().show();

			self.viewport().imgAreaSelect({remove: true});

			self.viewport().show();

			var size = $.Image.resizeWithin(
					image.width,
					image.height,
					frame.width(),
					frame.height()
				),
				min = Math.min(size.width, size.height),
				x1  = Math.floor((size.width  - min) / 2),
				y1  = Math.floor((size.height - min) / 2),
				x2  = x1 + min,
				y2  = y1 + min;

			self.viewport()
				.css(size)
				// .css('position', 'absolute')
				.imgAreaSelect({
					handles: true,
					aspectRatio: '1:1',
					parent: frame,
					x1: x1,
					y1: y1,
					x2: x2,
					y2: y2,
					onSelectEnd: function(viewport, selection) {
						var hasSelection = !(selection.width=="0" && selection.height=="0");

						if (hasSelection) {
							var string = JSON.stringify(self.data());

							self.avatarData().val(string);

							// Set to true becuase user did adjusted cropping image
							self.hasAdjustedCropImage = true;
						}
					}
				})
		});
	},

	'{cancel} click': function() {
		self.actions().hide();

		self.note().hide();

		self.frame().hide();

		self.file().show();

		self.file().val('');

		self.file().parents('.input-group').find(':text').val('');

		self.avatarSource().val('');

		self.avatarPath().val('');

		self.avatarData().val('');

		self.avatarType().val('');

		self.viewport()
			.hide()
			.imgAreaSelect({remove: true});

		if(!$.isEmpty(self.options.origSource)) {
			self.frame()
				.css('background-image', $.cssUrl(self.options.origSource))
				.removeClass('avatar-frame-crop')
				.show();
		}

		if(self.options.hasAvatar) {
			self.removeFrame().show();
		}
	},

	data: function() {
		var viewport = self.viewport(),

			width  = viewport.width(),

			height = viewport.height(),

			selection =
				viewport
					.imgAreaSelect({instance: true})
					.getSelection(),

			data = {
				// id    : self.photoId().val(),
				// uid   : self.userId().val(),
				top   : selection.y1 / height,
				left  : selection.x1 / width,
				width : selection.width / width,
				height: selection.height / height
			};

		return data;
	},

	'{gallery} click': function() {
		self.galleryList().toggle();
	},

	'{galleryItem} click': function(el, event) {
		// If this item is not previously selected then only we proceed
		if(!el.hasClass('active')) {


			// Get the id
			var id = el.data('id');

			// Remove all other item selected state
			self.galleryItem().removeClass('active');

			// Set this item as selected
			el.addClass('active');

			// Set state to false
			self.state = false;

			// Show the loader
			self.toggleLoader();

			// Hide the previous picture
			self.frame().hide();

			// Hide the file upload field
			self.file().hide();

			// Clear the file input
			self.file().val('');
			self.file().parents('.input-group').find(':text').val('');

			// Hide the error frame
			self.clearError();

			// Set the type as gallery
			self.avatarType().val('gallery');

			// Set the source id
			self.avatarSource().val(id);

			// Get the avatar source
			EasySocial.ajax('fields/user/avatar/loadDefault', {
				"avatarId": id
			}).done(function(uri) {

				// Set the image preview
				self.frame().css('background-image', 'url(' + uri + ')');

				// Show the image
				self.frame().show();

				// Remove crop class
				self.frame().removeClass('avatar-frame-crop');

				// Hide the loader
				self.toggleLoader();

				// Hide the viewport
				self.viewport().hide();

				// Remove the imgareaselect from viewport
				self.viewport().imgAreaSelect({remove: true});

				// Hide the actions
				self.actions().hide();

				// Hide the note
				self.note().hide();

				// Show the file upload field
				self.file().show();

				// Show the revert button
				self.revertFrame().show();

				// Hide the remove button
				self.removeFrame().hide();

				// Set state to true
				self.state = true;
			});
		}
	},

	'{remove} click': function() {
		self.avatarType().val('remove');

		self.frame().css('background-image', $.cssUrl(self.options.defaultAvatar));

		self.removeFrame().hide();

		if(self.options.hasAvatar) {
			self.revertFrame().show();
		}

		self.state = false;
	},

	'{revert} click': function() {
		self.avatarType().val('');

		self.frame().css('background-image', $.cssUrl(self.options.origSource));

		if(self.options.hasAvatar) {
			self.removeFrame().show();
		}

		self.revertFrame().hide();

		self.galleryItem().removeClass('active');

		self.state = true;
	},

	'{self} onSubmit': function(el, event, register) {
		if(self.options.required) {
			if(!self.state) {

				if (!opts.error) {
					self.initErrorOpts();
				}

				self.raiseError(opts.error.empty);
			}

			register.push(self.state);
		}

		// If the user just uploaded avatar image without adjust any crop image
		// We need to manually capture the current default cropping area from the image
		if (!self.hasAdjustedCropImage) {

			var data = self.data();
			var string = JSON.stringify(data);

			// pass back this data into avatar field hidden input
			self.avatarData().val(string);
		}
	},

	raiseError: function(msg) {
		self.trigger('error', [msg]);
	},

	clearError: function() {
		self.trigger('clear');
	}
}
});

module.resolve();
});

});
			EasySocial.module('apps/fields/user/avatar/sample_content', function($) {
    var module = this;

    EasySocial.Controller('Field.Avatar.Sample', {
        defaultOptions: {
            '{upload}': '[data-avatar-upload]',

            '{gallery}': '[data-avatar-gallery]',

            '{galleryTitle}': '[data-avatar-gallery-title]',

            '{galleryButton}': '[data-avatar-gallery-button]',

            '{gallerySelection}': '[data-avatar-gallery-selection]'
        }
    }, function(self) {
        return {
            '{self} onConfigChange': function(el, event, name, value) {
                switch(name) {
                    case 'upload':
                        self.upload().toggle(value);
                    break;

                    case 'gallery':
                        self.gallery().toggle(value);
                    break;

                    case 'use_gallery_button':
                        self.galleryButton().toggle(value);

                        self.gallerySelection().toggle(!value);

                        self.galleryTitle().toggle(!value);
                    break;
                }
            }
        }
    });

    module.resolve();
});
			EasySocial.module('apps/fields/user/checkbox/content', function($) {

var module = this;

EasySocial.Controller('Field.Checkbox', {
    defaultOptions: {
        required: false,
        "{item}": "[data-field-checkbox-item]",
        "{field}": "[data-field-checkbox]"
    }
}, function(self, opts, base) { return {
    init : function() {
    },

    "{self} onRender": function() {
        var data = self.field().htmlData();

        opts.error = data.error || {};
    },

    validateInput : function() {
        self.clearError();

        if(self.options.required && self.item(':checked').length == 0) {
            self.raiseError();
            return false;
        }

        return true;
    },

    raiseError: function() {
        self.trigger('error', [opts.error.empty]);
    },

    clearError: function() {
        self.trigger('clear');
    },

    "{self} onSubmit": function(el, event, register) {
        register.push(self.validateInput());
        return;
    }
}});

module.resolve();
});
			EasySocial.module('apps/fields/user/checkbox/sample_content', function($) {
    var module  = this;

    EasySocial.Controller('Field.Checkbox.Sample', {
        defaultOptions: {
            '{checkboxes}'	: '[data-checkboxes]',
            '{checkbox}'	: '[data-checkbox]',
            '{sample}'		: '[data-sample-checkboxes] > [data-sample-checkbox]',
            '{checkboxInput}' : '[data-checkbox-input]',
            '{checkboxTitle}' : '[data-checkbox-title]'
        }
    }, function(self) {
        return {
            init: function() {
            },

            '{self} onChoiceTitleChanged': function(el, event, index, data) {

                self.checkboxTitle().eq(index).text(data);
            },

            '{self} onChoiceValueChanged': function(el, event, index, data) {
                self.checkboxInput().eq(index).val(data);
            },

            '{self} onChoiceAdded': function(el, event, index, data) {

				var sample = self.sample().clone();

				sample.removeData('data-sample-checkbox');
				sample.removeAttr('data-sample-checkbox');

				sample.attr('data-checkbox','');
				sample.data('data-checkbox','');

                if(self.checkbox().eq(index).length > 0) {
                    self.checkbox().eq(index).before(sample);
                } else {
                    self.checkboxes().append(sample);
                }
            },

            '{self} onChoiceRemoved': function(el, event, index) {
                self.checkbox().eq(index).remove();
            },

            '{self} onChoiceToggleDefault': function(el, event, index, value) {
                var element = self.checkboxInput().eq(index);

                if(value) {
                    element.prop('checked', true);
                } else {
                    element.prop('checked', false);
                }
            }
        }
    });

    module.resolve();
});
			EasySocial.module('apps/fields/user/country/content', function($) {

var module = this;

EasySocial
.require()
.library('textboxlist')
.done(function() {
	
EasySocial.Controller('Field.Country', {
	defaultOptions: {
		fieldname: '',
		required: false,
		id: null,
		min: null,
		max: null,
		selecttype: 'textboxlist',

		'{field}': '[data-field-country]',
		'{inputTextboxlist}': '[data-country-select-textboxlist]',
		'{inputMultilist}': '[data-country-select-multilist]',
		'{inputCheckbox}': '[data-country-select-checkbox]',
		'{inputCheckboxes}': '[data-country-select-checkbox] input',
		'{inputDropdown}': '[data-country-select-dropdown]'
	}
}, function(self, opts, base) { return {
	init: function() {
		opts.max = self.field().data('max');
		opts.min = self.field().data('min');
		opts.selecttype = self.field().data('select-type');

		if (opts.selecttype === 'textboxlist') {
			
			EasySocial.module('field.country/' + self.options.id).done(function(data) {
				self.inputTextboxlist().textboxlist({
					component: 'es',
					name: self.options.fieldname + '[]',
					max: self.options.max < 1 ? null : self.options.max,
					plugin: {
						autocomplete: {
							exclusive: true,
							query: data
						}
					}
				});
			});
		}

		// Initialize error
		var data = self.field().htmlData();
		opts.error = data.error;
	},

	'{inputMultilist} change': function(el, ev) {
		if (self.options.max > 0 && el.val().length > self.options.max) {
			el.val(self.lastValidSelection ? self.lastValidSelection : '');
			return false;
		}

		self.lastValidSelection = el.val();

		self.validateInput();
	},

	'{inputCheckboxes} change': function(el, ev) {
		var count = self.inputCheckboxes(':checked').length;

		if (self.options.max > 0 && count > self.options.max) {
			el.removeAttr('checked');
			return false;
		}

		self.validateInput();
	},

	'{inputDropdown} change': function() {
		self.validateInput();
	},

	'{inputTextboxlist} listChange': function() {
		console.log('list changed');
		self.validateInput();
	},

	validateInput: function() {
		self.clearError();

		var items = null;

		if (self.options.selecttype === 'textboxlist') {
			items = self.inputTextboxlist().controller('textboxlist').getAddedItems();
		}

		if (self.options.selecttype === 'multilist') {
			items = self.inputMultilist().val();
		}

		if (self.options.selecttype === 'checkbox') {
			items = self.inputCheckboxes(':checked');
		}

		if (self.options.selecttype === 'dropdown') {
			var value = self.inputDropdown().val();

			if (!$.isEmpty(value)) {
				items = [value];
			}
		}

		var count = items ? items.length : 0;

		// If it is not required and no selection is made, then we pass this check.
		// If there is selection made, then we have to check against the minimum and maximum count
		if (!self.options.required && count === 0) {
			return true;
		}

		if (self.options.required && count < 1) {
			self.raiseError(opts.error.required);
			return false;
		}

		if (self.options.min > 0 && count < self.options.min) {
			self.raiseError(opts.error.min);
			return false;
		}

		if (self.options.max > 0 && count > self.options.max) {
			self.raiseError(opts.error.max);
			return false;
		}

		return true;
	},

	clearError: function() {
		self.trigger('clear');
	},

	raiseError: function(msg) {
		self.trigger('error', [msg]);
	},

	'{self} onSubmit': function(el, ev, register) {
		register.push(self.validateInput());
	}
}});

module.resolve();

});
});			EasySocial.module('apps/fields/user/country/sample_content', function($) {
    var module = this;

    EasySocial.Controller('Field.Country.Sample', {
        defaultOptions: {
            '{inputGeneral}'        : '[data-country-select]',

            '{inputTextboxlist}'    : '[data-country-select-textboxlist]',

            '{inputMultilist}'      : '[data-country-select-multilist]',

            '{inputCheckbox}'       : '[data-country-select-checkbox]',

            '{inputDropdown}'       : '[data-country-select-dropdown]',

            '{maxMessage}'          : '[data-country-max-message]',

            '{maxCount}'            : '[data-country-max-count]'
        }
    }, function(self) {
        return {
            init: function() {

            },

            '{self} onConfigChange': function(el, ev, name, value) {
                switch(name) {
                    case 'select_type':
                        self.inputGeneral().hide();

                        if(value === 'textboxlist') {
                            self.inputTextboxlist().show();
                        }

                        if(value === 'multilist') {
                            self.inputMultilist().show();
                        }

                        if(value === 'checkbox') {
                            self.inputCheckbox().show();
                        }

                        if(value === 'dropdown') {
                            self.inputDropdown().show();
                        }
                        break;

                    case 'multilist_size':
                        self.inputMultilist().attr('size', value);
                        break;

                    case 'show_max_message':
                        self.maxMessage().toggle(!!value);
                        break;

                    case 'max':
                        self.maxCount().text(value);
                        break;
                }
            }
        }
    });

    module.resolve();
});
			EasySocial.module('apps/fields/user/cover/content', function($) {

var module = this;

EasySocial
.require()
.library('image')
.done(function() {

EasySocial.Controller('Field.Cover', {
	defaultOptions: {
		id: 0,
		group: null,
		required: false,
		hasCover: true,
		defaultCover: null,

		ratio: 3,

		'{field}': "[data-field-cover]",
		'{image}': '[data-field-cover-image]',

		'{data}': '[data-field-cover-data]',
		'{position}': '[data-field-cover-position]',
		'{file}': '[data-field-cover-file]',

		'{note}': '[data-field-cover-note]',
		'{error}': '[data-field-cover-error]',

		'{removeButton}': '[data-field-cover-remove-button]',
		'{browseButton}': '[data-browse-cover]',

		'{revertFrame}' : '[data-field-cover-revert]',
		'{revertButton}': '[data-field-cover-revert-button]'
	}
}, function(self, opts, base) { return {
	init : function() {
		self.setFrame();

		self.setLayout();

		self.origCover = self.options.hasCover ? $.uri(self.image().css('backgroundImage')).extract(0) : null;

		self.origPosition = self.options.hasCover ? self.image().css('backgroundPosition') : null;
		
		self.state = !!self.options.hasCover;
	},

	initErrorOpts: function() {
		var data = self.field().htmlData();

		opts.error = data.error || {};
	},

	state: true,

	"{self} onRender": function() {
		self.initErrorOpts();
	},

	'{self} onShow': function() {
		setTimeout(function() {
			self.setLayout();
		}, 1);
	},

	setFrame: function() {
		var frameWidth = self.image().width(),
			frameHeight = frameWidth / self.options.ratio;

		self.image().css('height', frameHeight);
	},

	'{window} resize': $.debounce(function() {
		self.setFrame();
	}, 250),

	imageLoaders: {},

	toggleLoader: function() {
		isLoading = self.browseButton().hasClass('is-loading');
		self.browseButton().toggleClass('is-loading', !isLoading);
	},

	'{file} change' : function( el , event ) {
		if($.isEmpty(el.val())) {
			return;
		}

		var label = el.val().replace(/\\/g, '/').replace(/.*\//, '');

		el.parents('.input-group').find(':text').val(label);

		// Set state to false
		self.state = false;

		// Show the loader
		self.toggleLoader();

		self.error().hide();

		self.image().hide();

		self.note().hide();

		self.file().hide();

		EasySocial.ajax( 'fields/' + self.options.group + '/cover/upload' , {
			id: self.options.id,
			files: el
		}, {
			type: 'iframe'
		}).done(function(result){

			var resultString = JSON.stringify(result);

			// Set the result in a string format
			self.data().val(resultString);

			var positionString = JSON.stringify({
				x: 0.5,
				y: 0.5
			});

			// Set the position in string format defaulting to 50 50
			self.position().val(positionString);

			// Set the position to 50 50 by default
			self.position().val()

			var url = result.large.uri,
				imageLoaders = self.imageLoaders,
				imageLoader = (imageLoaders[url] || (imageLoaders[url] = $.Image.get(url))).done(function(image) {
					self.setLayout.image = image;

					self.file().show();

					self.image().show();

					self.note().show();

					self.toggleLoader();

					self.revertFrame().hide();

					self.removeButton().show();

					self.setCover(result.large.uri);
				});

			// Set state to true
			self.state = true;

		}).fail(function(msg) {

			self.toggleLoader();

			self.file().show();

			self.error().show().html(msg);
		});
	},

	setLayout: function() {
		var cover = self.image(),
			image = self.setLayout.image;

		if(!image) {
			var url = $.uri(cover.css('backgroundImage')).extract(0);

			if(!url) return;

			var imageLoaders = self.imageLoaders,
				imageLoader =
					(imageLoaders[url] || (imageLoaders[url] = $.Image.get(url)))
						.done(function(image) {

							// Set it as current image
							self.setLayout.image = image;

							// Then set layout again
							self.setLayout();
						});

				return;
		}

		var imageWidth = image.data("width"),
			imageHeight = image.data("height"),
			coverWidth = cover.width(),
			coverHeight = cover.height(),
			size = $.Image.resizeProportionate(
				imageWidth, imageHeight,
				coverWidth, coverHeight,
				"outer"
			);

		self.availableWidth = coverWidth - size.width;
		self.availableHeight = coverHeight - size.height;

		self.setFrame();		
	},

	setCover: function(url, position) {
		position = position || '50% 50%';

		self.image()
			.css({
				backgroundImage: $.cssUrl(url),
				backgroundPosition: position
			});

		self.setLayout();

		self.image().addClass('cover-move');

		self.note().show();
	},

	x: 0.5,
	y: 0.5,

	moveCover: function(dx, dy, image) {

		if (!image) {
			image = self.image();
		}

		var w = self.availableWidth,
			h = self.availableHeight,
			x = (w==0) ? 0 : self.x + ((dx / w) || 0),
			y = (h==0) ? 0 : self.y + ((dy / h) || 0);

		// Always stay within 0 to 1.
		if (x < 0) x = 0; if (x > 1) x = 1;
		if (y < 0) y = 0; if (y > 1) y = 1;

		// Set position on cover
		image.css("backgroundPosition",
			((self.x = x) * 100) + "% " +
			((self.y = y) * 100) + "% "
		);

		var position = {
			x: self.x,
			y: self.y
		}

		self.position().val(JSON.stringify(position));
	},

	'{image} mousedown': function(selection, event) {
		if (event.target === self.image()[0]) {
			event.preventDefault();
		}

		// Initial cover position
		var image = self.image(),
			position = image.css("backgroundPosition").split(" ");
			self.x = parseInt(position[0]) / 100;
			self.y = parseInt(position[1]) / 100;

		// Initial cursor position
		var x = event.pageX,
			y = event.pageY;

		$(document)
			.on("mousemove.movingCover mouseup.movingCover", function(event) {

				self.moveCover(
					(x - (x = event.pageX)) * -1,
					(y - (y = event.pageY)) * -1,
					image
				);
			})
			.on("mouseup.movingCover", function() {

				$(document).off("mousemove.movingCover mouseup.movingCover");
			});
	},

	'{removeButton} click': function(el) {
		var data = self.data().val();

		if($.isEmpty(data)) {
			if(self.options.hasCover) {
				self.setCover(self.options.defaultCover);

				// Mark the data as delete

				self.data().val('delete');

				el.hide();

				self.revertFrame().show();
			}
		} else {
			// Backup the data first
			self.origData = data;
			self.origPosition = self.position().val();

			self.data().val('');
			self.position().val('');
			self.file().val('');
			self.file().parents('.input-group').find(':text').val('');

			if(self.options.hasCover) {
				self.setCover(self.origCover);
			} else {
				self.setCover(self.options.defaultCover);

				// Mark the data as delete
				self.data().val('delete');

				el.hide();
			}
		}

		self.state = false;
	},

	'{revertButton} click': function() {
		self.setCover(self.origCover, self.origPosition);

		self.revertFrame().hide();

		self.removeButton().show();

		self.data().val('');

		self.position().val('');

		self.file().val('');
		self.file().parents('.input-group').find(':text').val('');

		self.state = true;
	},

	'{self} onSubmit': function(el, event, register) {
		
		var data = self.data().val();
		var hasCover = self.options.hasCover;

		// if the value show delete mean it remove that cover before submit
		// need to handle this from the edit switch profile as well
		if (data == 'delete') {
			var data = '';
			var hasCover = false;
		}

		if (self.options.required && !hasCover && $.isEmpty(data)) {
			
			if (!self.state) {

				if (!opts.error) {

					self.initErrorOpts();
				}

				self.raiseError(opts.error.empty);
			}

			register.push(self.state);
		}
	},

	raiseError: function(msg) {
		self.trigger('error', [msg]);
	}
}});

module.resolve();
});
});
			EasySocial.module('apps/fields/user/currency/content', function($) {
var module = this;

EasySocial.Controller('Field.Currency', {
	defaultOptions: {
		required: false,
		'{field}': '[data-field-currency]',
		'{dollarInput}': '[data-currency-dollar]',
		'{centInput}': '[data-currency-cent]'
	}
}, function(self, opts, base) { return {

	init: function() {
		console.log('init');
	},

	'{self} onRender': function() {
		var data = self.field().htmlData();
		opts.error = data.error || {};
	},

	'{dollarInput} keyup': function() {
		self.validateInput();
	},

	'{dollarInput} blur': function() {
		self.validateInput();
	},

	'{centInput} keyup': function() {
		self.validateInput();
	},

	'{centInput} blur': function() {
		self.validateInput();
	},

	validateInput: function() {
		self.clearError();

		var dollar = self.dollarInput().val();
		var cent = self.centInput().val()

		if (self.options.required && ($.isEmpty(dollar) || $.isEmpty(cent))) {
			self.raiseError(opts.error.required);
			return false;
		}

		return true;
	},

	raiseError: function(msg) {
		self.trigger('error', [msg]);
	},

	clearError: function() {
		self.trigger('clear');
	},


	'{self} onSubmit': function(el, ev, register) {
		register.push(self.validateInput());
	}
}});

module.resolve();
});
			EasySocial.module('apps/fields/user/datetime/content', function($) {

var module = this;

EasySocial.require()
.library('datetimepicker', 'chosen', 'moment/' + EasySocial.options.momentLang)
.done(function($){

EasySocial.Controller('Field.Datetime', {
	defaultOptions: {
		required: false,
		calendarDateFormat: null,
		yearfrom: null,
		yearto: null,
		date: null,
		lang: null,

		allowTime: false,
		allowTimezone: false,
		ageLimit: null,

		calendarLanguage: 'english',

		'{field}': '[data-field-datetime]',
		'{date}': '[data-field-datetime-select]',
		'{dateValue}': '[data-field-datetime-value]',
		'{timezone}': '[data-field-datetime-timezone]',
		'{form}': '[data-field-datetime-form]',
		'{icon}': '[data-field-datetime-icon]',
		'{clearButton}': '[data-clear]',
	}
}, function(self, opts, base) { return {

	init : function() {
		// self.legacyInit();

		self.options.yearfrom = self.options.yearfrom || 1930;

		// There is an issue with yearto where if I set yearto = 2014, I won't be able to select 2014 dates. This is a bug in datetimepicker. Currently, temporarily, we manually add 1 to the value if there are value set.
		if (!$.isEmpty(self.options.yearto)) {
			self.options.yearto = parseInt(self.options.yearto) + 1;
		} else {
			self.options.yearto = new Date().getFullYear() + 100
		}

		self.date()._datetimepicker({
			component: "es",
			format: self.options.calendarDateFormat,
			minDate: self.options.yearfrom + '-01-01',
			maxDate: self.options.yearto + '-12-31',
			icons: {
				time: 'far fa-clock',
				date: 'fa fa-calendar',
				up: 'fa fa-chevron-up',
				down: 'fa fa-chevron-down'
			},
			sideBySide: false,
			pickTime: self.options.allowTime,
			useCurrent: false,
			language: self.options.calendarLanguage == 'english' ? 'en-gb' : EasySocial.options.momentLang
		});

		// date value should always be in mysql datetime format
		// YYYY-MM-DD HH:MM:SS
		self.options.date = self.dateValue().val();

		// If there is a date value, then we set it into the datetimepicker
		if (!$.isEmpty(self.options.date)) {
			// Datetimepicker is using moment.js, hence here we manually create a moment object to pass in instead of passing in date time string
			// This is because datetimepicker.setDate function passes along the format from self.options.calendarDateFormat to generate the date object, which will render moment.js to generate an invalid dateobject
			// self.options.calendarDateFormat is only for display purposes
			// Raw date object is always in SQL format
			var dateObj = $.moment(self.options.date);

			self.datetimepicker('setDate', dateObj);
			// self.setDateValue(dateObj);
		}

		if (self.options.allowTimezone) {
			self.timezone().chosen({
				search_contains: true
			});
		}
	},

	initErrorData: function() {
		var data = self.field().htmlData();

		opts.error = data.error || {};
	},

	"{self} onRender": function() {
		self.initErrorData();
	},

	'{icon} click': function() {
		self.datetimepicker('show');
	},

	'{date} dp.change': function(el, ev) {
		self.setDateValue(ev.date.toDate());

		self.form().addClass('has-datetime');

		// Custom hack to ensure that the input box is really blurred
		if (!self.options.allowTime) {
			self.date().blur();
		}

		self.validateCalendar();
	},

	// Alias method to call the datetimepicker instance
	datetimepicker: function(method, value) {
		return self.date().data('DateTimePicker')[method](value);
	},

	setDateValue: function(date) {
		// Convert the date object into sql format and set it into the input
		self.dateValue().val(date.getFullYear() + '-' +
							('00' + (date.getMonth()+1)).slice(-2) + '-' +
							('00' + date.getDate()).slice(-2) + ' ' +
							('00' + date.getHours()).slice(-2) + ':' +
							('00' + date.getMinutes()).slice(-2) + ':' +
							('00' + date.getSeconds()).slice(-2));
	},

	'{date} blur': function() {
		self.validateCalendar();
	},

	validateCalendar: function() {
		self.clearError();

		if(self.options.required && $.isEmpty(self.dateValue().val())) {

			if (!opts.error) {
				self.initErrorData();
			}

			self.raiseError(opts.error.empty);
			return false;
		}

		// Check for age limit
		return self.validateAge()
			.done(function() {
				self.clearError();
			})
			.fail(function(msg) {
				self.raiseError(msg);
			});
	},

	validateAge: function() {
		return EasySocial.ajax('fields/user/birthday/isValid', {
			value: self.dateValue().val(),
			age_limit: opts.ageLimit
		});
	},

	raiseError: function(msg) {
		self.trigger('error', [msg]);
	},

	clearError: function() {
		self.trigger('clear');
	},

	"{self} onSubmit" : function(el, event, register) {
		register.push(self.validateCalendar());
		return;

	},

	'{clearButton} click': function(el, ev) {
		self.form().removeClass('has-datetime');

		self.datetimepicker('setValue', new $.moment());

		self.date().val('');

		self.dateValue().val('');
	}
}});

module.resolve();
});
});
			EasySocial.module('apps/fields/user/datetime/display_content', function($) {

var module = this;

EasySocial.require()
.library('popbox', 'chosen')
.done(function($) {

EasySocial.Controller('Field.Datetime.Display', {
    defaultOptions: {
        userid: null,
        date: null,
        timezone: null,
        local: null,

        '{toggle}': '[data-popbox]',
        '{content}': '[data-popbox-content]',
        '{date}': '[data-date]',
        '{timezone}': '[data-timezone]',
        '{loading}': '[data-loading]'
    }
}, function(self, opts, base) { return {
    init: function() {
        self.options.timezone = self.timezone().data('timezone');

        self.options.date = self.date().data('date-utc');

        // Set the selected timezone with the displayed date
        self.datetime(self.options.timezone, self.date().html());

        // Get the local timezone first through client browser
        self.options.local = -new Date().getTimezoneOffset()/60;

        var content = self.content().html(),
            position = self.toggle().data('popbox-position');

        self.toggle().popbox({
            content: content,
            id: 'fd',
            component: 'es',
            type: 'timezone',
            toggle: 'click',
            position: position
        }).attr('data-popbox', '');
    },

    '{toggle} popboxActivate': function(el, event, popbox) {
        $(popbox.tooltip).addController('EasySocial.Controller.Field.Datetime.Display.Timezone', {
            '{parent}': self
        });
    },

    data: {},

    datetime: function(tz, value) {
        // Getter
        if (value === undefined) {
            var dfd = $.Deferred();

            if (self.data[tz] === undefined) {
                self.loading().show();

                EasySocial.ajax('fields/user/datetime/getDatetime', {
                    id: self.options.id,
                    userid: self.options.userid,
                    tz: tz,
                    local: self.options.local,
                    datetime: self.options.date
                }).done(function(datetime) {

                    self.loading().hide();

                    dfd.resolve(self.datetime(tz, datetime));
                });
            } else {
                dfd.resolve(self.data[tz]);
            }

            return dfd;
        }

        // Setter
        self.data[tz] = value;
        return value;
    },

    showDatetime: function(tz, datetime) {
        if (tz === 'local') {
            tz = opts.message.local;
        }

        self.timezone().html(tz);
        self.date().html(datetime);
    }
}});

EasySocial.Controller('Field.Datetime.Display.Timezone', {
    defaultOptions: {
        '{timezones}': '[data-timezone-select]',
        '{reset}': '[data-timezone-reset]',
        '{local}': '[data-timezone-local]'
    }
}, function(self, opts, bae) { return {
    init: function() {
        self.timezones().chosen({
            search_contains: true
        });
    },

    '{timezones} change': function(el, event) {
        var key = el.val();

        self.parent.date().hide();
        self.parent.timezone().hide();

        self.parent.datetime(key).done(function(value) {
            self.parent.showDatetime(key, value);

            self.parent.date().show();
            self.parent.timezone().show();
        });
    },

    '{reset} click': function() {
        self.setTimezone(self.parent.options.timezone);
    },

    '{local} click': function() {
        self.setTimezone('local')
    },

    setTimezone: function(tz) {
        self.timezones()
            .val(tz)
            .trigger('liszt:updated')
            .trigger('change');
    }
}});

module.resolve();
});
});
			EasySocial.module('apps/fields/user/datetime/dropdown', function($) {

var module = this;

EasySocial.Controller('Field.Datetime.Dropdown', {
	defaultOptions: {
		required: false,
		allowTime: false,
		allowTimezone: false,
		yearfrom: null,
		yearto: null,
		ageLimit: null,

		'{dateValue}': '[data-field-datetime-value]',

		'{year}': '[data-field-datetime-year]',
		'{month}': '[data-field-datetime-month]',
		'{day}': '[data-field-datetime-day]',

		'{hour}': '[data-field-datetime-hour]',
		'{minute}': '[data-field-datetime-minute]',
		'{ampm}': '[data-field-datetime-ampm]',

		'{dayLabel}': '[data-datetime-day-label]'
	}
}, function(self, opts) { return {

	init: function() {
		self.checkDate();
	},

	'{year} change': function(el, ev) {
		self.setValue();
		self.checkDate();

		// trigger month change to get the correct day of the month
		self.month().trigger('change');
	},

	'{month} change': function(el, ev) {
		// If year and month is provided, then we need to find the max day
		var year = self.year().val(),
			month = self.month().val();

		// get the day label
		var dayLabel = self.dayLabel().text();

		if (year !== '' && month !== '') {
			var maxDay = new Date(year, month, 0).getDate();

			// See if there are days originally selected
			var day = self.day().val();

			if (day !== '') {
				// If day value is more than current month maxday, then we use maxday
				day = Math.min(day, maxDay);
			}

			self.day().empty();

			self.day().append('<option value="">' + dayLabel + '</option>');

			for (i = 1; i <= maxDay; i++) {
				$('<option value="' + i + '">' + i + '</option>').appendTo(self.day());
			}

			// Set back the original value
			if (day !== '') {
				self.day().val(day);
			}
		}

		self.setValue();

		self.checkDate();
	},

	'{day} change': function(el, ev) {
		self.setValue();
		self.checkDate();
	},

	'{hour} change': function(el, ev) {
		self.setValue();
	},

	'{minute} change': function(el, ev) {
		self.setValue();
	},

	'{ampm} change': function(el, ev) {
		self.setValue();
	},

	checkDate: function() {

		self.clearError();

		var year = self.year().val();
		var month = self.month().val();
		var day = self.day().val();

		if ((year == '' || month == '' || day == '') && opts.required) {

			self.raiseError();
			return false;
		}

		return self.validate()
			.done(function() {
				self.clearError();
			})
			.fail(function(msg) {
				self.raiseError(msg);
			});
	},

	validate: function() {
		return EasySocial.ajax('fields/user/birthday/isValid', {
			value: self.dateValue().val(),
			age_limit: opts.ageLimit
		});
	},

	setValue: function() {
		var string;

		var year = self.year().val();
		var month = self.month().val();
		var day = self.day().val();

		if (year !== '' && month !== '' && day !== '') {
			string = year + '-' + month + '-' + day;

			if (self.options.allowTime) {
				var hour = self.hour().val(),
					minute = self.minute().val();

				// If there is ampm, then we need to readjust the time a little bit
				if (hour !== '' && self.ampm().length > 0 && self.ampm().val() == 'pm') {
					hour = (parseInt(hour) + 12).toString();

					if (hour === '24') {
						hour = '0';
					}
				}

				if (minute === '') {
					minute = '00';
				}

				string += ' ' + ('00' + hour).slice(-2) + ':' + ('00' + minute).slice(-2) + ':00';
			}

			self.dateValue().val(string);
		}
	},

	"{self} onSubmit": function(element, event, register, mode) {
		register.push(self.checkDate());
	},

	clearError: function() {
		self.trigger('clear');
	},

	raiseError: function(msg) {
		self.trigger('error', [msg]);
	}
}});

module.resolve();
});
			EasySocial.module('apps/fields/user/datetime/sample_content', function($) {
    var module = this;

    EasySocial.require().library('ui/datepicker').done(function() {
        EasySocial.Controller('Field.Datetime.Sample', {
            defaultOptions: {
                '{yearPrivacy}'     : '[data-yearprivacy]',

                '{input}'           : '[data-field-datetime-select]',

                '{timezone}'        : '[data-field-datetime-timezone]'
            }
        }, function(self) {
            return {
                init: function() {
                },

                '{self} onConfigChange': function(el, event, name, value) {
                    switch(name) {
                        case 'year_privacy':
                            self.yearPrivacy().toggle(value);
                        break;

                        case 'allow_timezone':
                            self.timezone().toggle(value);
                        break;

                        case 'placeholder':
                            self.input().attr('placeholder', value);
                        break;
                    }
                }
            }
        });

        module.resolve();
    });
});
			EasySocial.module('apps/fields/user/dropdown/content', function($) {
var module = this;

EasySocial.Controller('Field.Dropdown', {
	defaultOptions: {
		required: null,
		"{field}": "[data-field-dropdown]",
		"{item}": "[data-field-dropdown-item]",
		"{option}": "[data-field-dropdown-item] option"
	}
}, function(self, opts, base) { return {

	validateInput : function() {
		self.clearError();

		if(self.options.required && $.isEmpty(self.item().val())) {
			self.raiseError();
			return false;
		}

		return true;
	},

	"{self} onRender": function() {
		var data = self.field().htmlData();
		opts.error = data.error || {};
	},

	raiseError: function() {
		self.trigger('error', [opts.error.empty]);
	},

	clearError: function() {
		self.trigger('clear');
	},

	"{self} onSubmit": function(el, event, register) {
		// If field is not required, skip the checks.

		if(!self.options.required)
		{
			register.push(true);
			return;
		}

		register.push(self.validateInput());

		return;
	},

	'{self} onChoiceAdded': function(el, event, index) {
		if(self.option().eq(index).length > 0) {
			self.option().eq(index).before($('<option></option>'));
		} else {
			self.item().append($('<option></option>'));
		}
	},

	'{self} onChoiceValueChanged': function(el, event, index, value) {
		self.option().eq(index).val(value);
	},

	'{self} onChoiceTitleChanged': function(el, event, index, value) {
		self.option().eq(index).text(value);
	},

	'{self} onChoiceRemoved': function(el, event, index) {
		self.option().eq(index).remove();
	},

	'{self} onChoiceToggleDefault': function(el, event, index, value) {
		self.option().removeAttr('selected');

		if(value) {
			self.option().eq(index).attr('selected', 'selected');
		}
	}
}});

module.resolve();
});
			EasySocial.module('apps/fields/user/email/content', function($) {

var module = this;

EasySocial.Controller('Field.Email', {
    defaultOptions: {
        required: false,
        regex: 0,
        regexFormat: '',

        regexModifier: '',

        "{field}": "[data-field-email]",
        "{input}": "[data-field-email-input]"
    }
}, function(self, opts, base) { return {

    "{self} onRender": function() {
        var data = self.field().htmlData();

        opts.error = data.error || {};
    },

    validateInput: function() {
        var value   = self.input().val();

        if(self.options.required && $.isEmpty(value)) {
            self.raiseError(opts.error.required);
            return false;
        }

        if(!$.isEmpty(value) && self.options.regex) {
            var regex = new RegExp(self.options.regexFormat, self.options.regexModifier);

            if(!regex.test(value)) {
                self.raiseError(opts.error.invalid);
                return false;
            }
        }

        return true;
    },

    raiseError: function(msg) {
        self.trigger('error', [msg]);
    },

    clearError: function() {
        self.trigger('clear');
    },

    "{self} onSubmit": function(el, event, register) {

        register.push(self.validateInput());

        return;
    }
}});

module.resolve();
});
			EasySocial.module('apps/fields/user/file/content', function($) {

var module = this;

EasySocial.require()
.library('ui/sortable')
.done(function($) {

EasySocial.Controller('Field.File', {
	defaultOptions: {
		required: false,
		id: null,
		inputName: '',
		maxFile: 0,

		'{field}': '[data-field-file]',
		'{list}': '[data-field-file-list]',
		'{item}': '[data-field-file-item]',
		'{add}': '[data-field-file-add]',

		// file items
		'{dragPlaceholder}': '.data-field-file-item-drag',
		'{moveHandle}': '[data-field-file-move]'

	}
}, function(self, opts, base) { return {
		
	init: function() {

		var data = self.field().htmlData();

		opts.error = data.error || {};
		opts.message = data.message || {};

		opts.maxFile = self.field().data('maxfile');

		self.item().addController('EasySocial.Controller.Field.File.Item', {
			parent: self,
			message: opts.message,
			error: opts.error
		});

		self.initSortable();
	},

	initSortable: function() {
		self.list().sortable({
			items: self.item.selector,
			placeholder: 'data-field-file-item-drag',
			handle: self.moveHandle.selector,
			forcePlaceholderSize: true,
			start: function(event, ui) {
				self.dragPlaceholder().width(ui.item.find('.file-wrap').width());
			}
		})
	},

	'{add} click': function(el, ev) {
		if(self.options.maxFile < 1 || (self.item().length < self.options.maxFile)) {
			var key = self.item().length;

			var item = $('<div class="data-field-file-item" data-field-file-item></div>');

			item.data('key', key);

			item.html(opts.message.working);

			item.addController('EasySocial.Controller.Field.File.Item', {
				parent: self,
				message: opts.message,
				error: opts.error
			});

			self.list().append(item);

			EasySocial.ajax('fields/user/file/getUploadHtml', {
				id: self.options.id,
				key: key
			}).done(function(html) {
				item.html(html);
			});

			if(self.options.maxFile > 1 && self.item().length >= self.options.maxFile) {
				el.hide();
			}
		}
	},

	'{item} uploadDone': function() {
		self.add().click();
	}
}});

EasySocial.Controller('Field.File.Item', {
	defaultOptions: {
		required: false,
		key: null,

		'{upload}' : '[data-field-file-upload]',
		'{progress}' : '[data-field-file-progress]',
		'{delete}' : '[data-field-file-delete]',
		'{clear}' : '[data-field-file-clear]',
		'{id}' : '[data-field-file-id]',
		'{tmp}' : '[data-field-file-tmp]'
	}
}, function(self, opts, base) { return {
	init: function() {
		opts.key = self.element.data('key');
	},

	'{upload} change': function(el, ev) {
		self.element.html(opts.message.working);

		EasySocial.ajax('fields/user/file/upload', {
			id: opts.parent.options.id,
			files: el,
			key: self.options.key
		}, {
			type: 'iframe'
		}).done(function(html) {
			self.element.html(html);

			self.trigger('uploadDone');
		}).fail(function(msg) {
			self.element.html(msg || self.getErrorMsg());
		});
	},

	'{delete} click': function(el, ev) {
		var tmp = self.tmp().val();
		var id = self.id().val();

		self.element.html(opts.message.working);

		EasySocial.ajax('fields/user/file/delete', {
			id: opts.parent.options.id,
			key: self.options.key,
			tmp: tmp,
			fileid: id
		}).done(function(html) {
			self.element.html(html);

			self.trigger('fileDeleted');
		}).fail(function(msg) {
			self.element.html(msg || self.getErrorMsg());
		});
	},

	'{clear} click': function(el, ev) {
		self.element.html(opts.message.working);

		EasySocial.ajax('fields/user/file/getUploadHtml', {
			id: opts.parent.options.id,
			key: self.options.key
		}).done(function(html) {
			self.element.html(html);
		});
	},

	getErrorMsg: function() {
		msg = $('<span class="alert field-file-error">' + opts.error.unknown + '<button class="close" type="button" data-field-file-clear>×</button></span>');

		return msg;
	}
}});

module.resolve();
});
});
			EasySocial.module('apps/fields/user/file/sample_content', function($) {
    var module = this;

    EasySocial.Controller('Field.File', {
        defaultOptions: {
            '{sizeText}': '[data-field-file-size-text]',

            '{size}': '[data-field-file-size]',

            '{add}': '[data-field-file-add]'
        }
    }, function(self) {
        return {
            init: function() {

            },

            '{self} onConfigChange': function(el, ev, name, value) {
                switch(name) {
                    case 'size_limit':
                        self.size().text(value);
                        break;

                    case 'show_size_limit':
                        self.sizeText().toggle(!!value);
                        break;

                    case 'file_limit':
                        self.add().toggle((value < 1 || value > 1));
                        break;
                }
            }
        }
    });

    module.resolve();
});
			EasySocial.module('apps/fields/user/gender/content', function($) {
var module = this;

EasySocial.Controller('Field.Gender', {
    defaultOptions: {
        required: false,
        '{field}': '[data-field-gender]',
        '{selection}': '[data-field-gender-select]'
    }
}, function(self, opts, base) { return {

    "{self} onRender": function() {
        var data = self.field().htmlData();

        opts.error = data.error || {};
    },

    validateInput: function() {
        if(!self.options.required) {
            return true;
        }

        self.clearError();

        var value = self.selection(':checked').val();

        if($.isEmpty(value))
        {
            self.raiseError();
            return false;
        }

        return true;
    },

    raiseError: function() {
        self.trigger('error', [opts.error.required]);
    },

    clearError: function() {
        self.trigger('clear');
    },

    '{self} onSubmit': function(el, event, register) {
        register.push(self.validateInput());
    },

    '{selection} click': function() {
        self.validateInput();
    }
}});

module.resolve();
});
			EasySocial.module('apps/fields/user/joomla_email/content', function($) {

var module = this;

EasySocial.Controller('Field.Joomla_email', {
	defaultOptions: {
		required: true,
		id: null,
		userid: null,
		reconfirm: false,
		event: null,
		registration: null,

		'{field}': '[data-field-joomla_email]',
		'{input}': '[data-field-email-input]',
		'{confirm}': '[data-field-email-reconfirm-input]',
		'{confirmFrame}': '[data-field-email-reconfirm-frame]'
	}
}, function(self, opts, base) { return {
	init: function() {
		self.origEmail = self.input().val();

		// Check for input value
		value = self.input().val();

		// Registration form should always display reconfirm field
		if (opts.reconfirm && !opts.registration && value) {
			self.confirmFrame().hide();
		}
	},

	"{self} onRender": function() {
		var data = self.field().htmlData();

		opts.error = data.error || {};
	},

	'{input} blur': function(el, ev) {
		var value = self.input().val();

		if (opts.reconfirm && value !== self.origEmail) {
			self.confirmFrame().show();
		}

		if (opts.reconfirm && value === self.origEmail && (opts.event === 'onEdit' || opts.event === 'onAdminEdit')) {
			self.confirmFrame().hide();
		}

		self.validateInput();
	},

	'{confirm} blur': function(el, ev) {
		self.validateInput();
	},

	validateInput: function() {
		self.clearError();

		var value = self.input().val();

		if($.isEmpty(value)) {
			if(!self.options.required) {
				return true;
			}

			self.raiseError(opts.error.required);
			return false;
		}

		if(self.options.reconfirm)
		{
			var reconfirm = self.confirm().val();

			if(value !== self.origEmail && $.isEmpty(reconfirm))
			{
				self.raiseError(opts.error.reconfirmrequired);
				return false;
			}

			if(!$.isEmpty(reconfirm) && value !== reconfirm)
			{
				self.raiseError(opts.error.mismatch);
				return false;
			}
		}

		return self.checkInput()
			.done(function() {
				self.clearError();
			})
			.fail(function(msg) {
				self.raiseError(msg);
			});
	},

	checkInput: function() {
		return EasySocial.ajax('fields/user/joomla_email/isValid', {
			id: self.options.id,
			userid: self.options.userid,
			email: self.input().val()
		});
	},

	raiseError: function(msg) {
		self.trigger('error', [msg]);
	},

	clearError: function() {
		self.trigger('clear');
	},

	'{self} onSubmit': function(el, ev, register, mode) {
		if (mode === 'onRegisterMini') {
			return;
		}

		register.push(self.validateInput());
	}
}});

module.resolve();
});
			EasySocial.module('apps/fields/user/joomla_email/registermini_content', function($) {

var module = this;

EasySocial.Controller('Field.Joomla_email.Mini', {
    defaultOptions: {
        require: true,
        id: null,

        '{field}': '[data-field-joomla_email]',
        '{input}': '#email',
        '{confirm}' : '[data-field-email-reconfirm-input]'
    }
}, function(self, opts) { return {
    init: function() {
        self.origEmail = self.input().val();

        var data = self.field().htmlData();
        opts.error = data.error || {};
    },

    '{self} onRender': function() {
        var data = self.field().htmlData();

        opts.error = data.error || {};
    },

    '{input} keyup': function(el) {
        if(el.val().length > 0) {
            self.delayedCheck();
        }
    },

    '{confirm} blur': function(el, ev) {
        self.checkEmail();
    },

    state: false,

    delayedCheck: $.debounce(function() {
        self.checkEmail();
    }, 250),

    checkEmail: function() {

        self.clearError();

        var email = self.input().val();

        if(self.options.required && email.length == 0) {
            self.raiseError(opts.error.required);
            return false;
        }

        if(!$.isEmpty(email) && self.options.regex) {
            var regex = new RegExp(self.options.regexFormat, self.options.regexModifier);

            if(!regex.test(email)) {
                self.raiseError(opts.error.format);
                return false;
            }
        }


        if (opts.reconfirm) {
            var reconfirm = self.confirm().val();

            if (email !== self.origEmail && $.isEmpty(reconfirm)) {
                self.raiseError(opts.error.reconfirmrequired);
                return false;
            }

            if (!$.isEmpty(reconfirm) && email !== reconfirm) {
                self.raiseError(opts.error.mismatch);
                return false;
            }
        }


        if(email.length > 0) {
            var state = $.Deferred();

            self.input().addClass('is-loading');

            var email = self.input().val();

            EasySocial.ajax('fields/user/joomla_email/isValid', {
                id: self.options.id,
                userid: 0,
                email: email
            }).done(function(msg) {

                state.resolve();

            }).fail(function(msg) {
                self.raiseError(msg);

                state.reject();
            }).always(function() {
                self.input().removeClass('is-loading');
            })

            return state;
        }

        return true;
    },

    raiseError: function(msg) {
        self.trigger('error', [msg]);
    },

    clearError: function() {
        self.trigger('clear');
    },

    '{self} onSubmit': function(el, ev, register, mode) {
        if (mode !== 'onRegisterMini') {
            return;
        }

        if(self.options.required || self.input().val().length > 0) {
            register.push(self.checkEmail());
        }
    },

    setLoaded: function() {
        self.trigger('loaded');
    }
}});

module.resolve();
});
			EasySocial.module('apps/fields/user/joomla_email/sample_content', function($) {
    var module = this;

    EasySocial.Controller('Field.Joomla_email.Sample', {
        defaultOptions: {
            '{confirmEmail}'        : '[data-field-email-reconfirm-frame]'
        }
    }, function(self) {
        return {
            init: function() {

            },

            '{self} onConfigChange': function(el, event, name, value) {
                switch(name) {
                    case 'reconfirm_email':
                        self.confirmEmail().toggle(value);
                    break;
                }
            }
        }
    });

    module.resolve();
});
			EasySocial.module('apps/fields/user/joomla_fullname/content', function($) {

var module = this;

EasySocial.Controller('Field.Joomla_fullname', {
    defaultOptions: {
        "nameFormat": 1,
        "max": 0,
        "required": true,
        '{field}': '[data-field-joomla_fullname]',
        '{firstName}': '[data-field-jname-first]',
        '{middleName}': '[data-field-jname-middle]',
        '{lastName}': '[data-field-jname-last]',
        '{name}': '[data-field-jname-name]'
    }
}, function(self, opts, base) { return {

    init : function() {
        opts.nameFormat = self.field().data('name-format');
        opts.max = self.field().data('max');

        var data = self.field().htmlData();
        opts.error = data.error || {};
    },

    "{self} onRender": function() {

        var data = self.field().htmlData();
        opts.error = data.error || {};
    },

    validateInput : function() {

        self.clearError();

        if (!opts.required) {
            return true;
        }

        // Name format
        // 1 - first, middle, last
        // 2 - last, middle, first
        // 3 - single name
        // 4 - first, last
        // 5 - last, first

        if (opts.nameFormat == 3) {

            if($.isEmpty(self.name().val())) {
                self.raiseError(opts.error.empty);
                return false;
            }

            return true;
        }

        if ($.isEmpty(self.firstName().val())) {
            self.raiseError(opts.error.empty);
            return false;
        }

        return true;
    },

    raiseError: function(msg) {
        self.trigger('error', [msg]);
    },

    clearError: function() {
        self.trigger('clear');
    },

    "{firstName} blur" : function(el, event) {
        self.validateInput();
    },

    "{name} blur": function(el, event) {
        self.validateInput();
    },

    "{self} onError": function(el, event, type, field) {
        self.raiseError();
    },

    "{self} onSubmit" : function(el, event, register) {
        register.push(self.validateInput());

        return;
    }
}});

module.resolve();

});
			EasySocial.module('apps/fields/user/joomla_fullname/sample_content', function($) {
    var module = this;

    EasySocial.Controller('Field.Joomla_fullname.Sample', {
        defaultOptions: {
            '{fullnameFormat}'      : '[data-fullname-format]'
        }
    }, function(self) {
        return {
            init: function() {

            },

            '{self} onConfigChange': function(el, event, name, value) {
                switch(name) {
                    case 'format':
                        self.switchFormat(value);
                    break;
                }
            },

            switchFormat: function(value) {
                self.fullnameFormat().hide();

                self.fullnameFormat().eq(value - 1).show();
            }
        }
    });

    module.resolve();
});
			EasySocial.module('apps/fields/user/joomla_password/content', function($) {

var module = this;

EasySocial.require()
.library('passwordstrength')
.done(function(){

EasySocial.Controller('Field.Joomla_password', {
	defaultOptions: {
		event               : null,
		triggerError        : true,

		required            : false,
		passwordStrength    : false,
		reconfirmPassword   : false,
		requireOriginal     : false,

		min : 4,
		max : 0,

		minInteger: 0,
		minSymbol: 0,
		minUpperCase: 0,

		'{field}': '[data-field-joomla_password]',
		'{original}'    : '[data-field-password-orig]',
		'{input}'       : '[data-field-password-input]',
		'{reconfirm}'   : '[data-field-password-confirm]',
		'{pwResetSubmitButton}' : '[data-password-reset-submit]',
		
		'{warning}'    : '[data-field-password-warning]',
		'{reconfirmNotice}' : '[data-reconfirmPassword-failed]',

		// Password strength
		'{strength}': '[data-password-strength]'
	}
}, function(self, opts, base) { return {
	
	init: function() {
		if (opts.passwordStrength) {
			self.initPasswordStrength();
		}
	},

	"{self} onRender": function() {
		var data = self.field().htmlData();

		opts.error = data.error;
	},

	initPasswordStrength: function() {

		self.input().password_strength({
			container: self.strength.selector,
			minLength: opts.min,
			texts: {
				1: self.strength().data('message-1'),
				2: self.strength().data('message-2'),
				3: self.strength().data('message-3'),
				4: self.strength().data('message-4'),
				5: self.strength().data('message-5')
			},
			onCheck: function(level) {
				if(level <= 1) {
					self.strength()
						.removeClass('t-text--warning')
						.removeClass('t-text--success')
						.addClass('t-text--danger t-fs--sm');
				}

				if(level > 1 && level <= 3) {
					self.strength()
						.removeClass('t-text--danger')
						.removeClass('t-text--success')
						.addClass('t-text--warning t-fs--sm');
				}

				if(level >= 4) {
					self.strength()
						.removeClass('t-text--danger')
						.removeClass('t-text--warning')
						.addClass('t-text--success t-fs--sm');
				}
			}
		})
	},

	'{input} keyup': function() {
		self.validatePassword();
	},

	'{input} blur': function() {
		self.validatePassword();
	},

	'{reconfirm} keyup': function() {
		self.validatePassword();
	},

	'{reconfirm} blur': function() {
		self.validatePassword();
	},

	validatePassword: function() {
		self.clearError();

		var input = self.input().val();
		var reconfirm = self.reconfirm().val();

		if(self.options.event === 'onRegister' && !self.validatePasswordInput() ) {
			return false;
		}

		if(self.options.event === 'onEdit' && !self.validatePasswordEdit()) {
			return false;
		}

		if(self.options.reconfirmPassword && !self.validatePasswordConfirm()) {
			return false;
		}

		return true;
	},

	validatePasswordInput: function() {
		var input = self.input().val();

		if (!opts.error) {
			var data = self.field().htmlData();

			opts.error = data.error;
		}

		if($.isEmpty(input)) {
			self.raiseError(opts.error.empty);
			return false;
		}

		if(self.options.min > 0 && input.length < self.options.min) {
			self.raiseError(opts.error.min);
			return false;
		}

		if(self.options.max > 0 && input.length > self.options.max) {
			self.raiseError(opts.error.max);
			return false;
		}

		if(self.options.minInteger > 0) {
			var test = input.match(/[0-9]/g);
			if (!test || test.length < self.options.minInteger) {
				self.raiseError(opts.error.mininteger);
				return false;
			}
		}

		if(self.options.minSymbol > 0) {
			var test = input.match(/[\W]/g);
			if (!test || test.length < self.options.minSymbol) {
				self.raiseError(opts.error.minsymbols);
				return false;
			}
		}

		if(self.options.minUpperCase > 0) {
			var test = input.match(/[A-Z]/g);
			if (!test || test.length < self.options.minUpperCase) {
				self.raiseError(opts.error.minupper);
				return false;
			}
		}


		return true;
	},

	validatePasswordEdit: function() {
		var orig = self.original().val(),
			input = self.input().val();

		// If both original and input is empty, then we return true as it is not mandatory in edit
		if($.isEmpty(input) && $.isEmpty(orig)) {
			return true;
		}

		// Only original is empty
		if($.isEmpty(orig) && self.options.requireOriginal) {
			self.raiseError(opts.error.emptyoriginal);
			return false;
		}

		// Original is not empty, then we validate the new password
		return self.validatePasswordInput();
	},

	validatePasswordConfirm: function() {
		var input = self.input().val();
		var reconfirm = self.reconfirm().val();

		// Check if either input or reconfirm is not empty
		if (!$.isEmpty(input) || !$.isEmpty(reconfirm)) {
			
			if($.isEmpty(input)) {
				self.raiseError(opts.error.empty);
				return false;
			}

			if($.isEmpty(reconfirm)) {
				self.raiseError(opts.error.emptyconfirm);
				return false;
			}

			if(input !== reconfirm) {
				self.raiseError(opts.error.mismatch);
				return false;
			}
		}

		return true;
	},

	raiseError: function(msg) {
		if (self.options.triggerError) {
			self.trigger('error', [msg]);
		} else {
			self.warning().show();
			self.warning().text(msg);
		}
	},

	clearError: function() {
		if (self.options.triggerError) {
			self.trigger('clear');
		} else {
			self.warning().hide();
			self.warning().text('');
		}
	},

	"{pwResetSubmitButton} click": function() {
		return self.validatePassword();
	},

	"{self} onSubmit": function(el, event, register, mode) {

		if (mode === 'onRegisterMini') {
			return;
		}

		register.push(self.validatePassword());
	}
}});

module.resolve();
});
});
			EasySocial.module('apps/fields/user/joomla_password/registermini_content', function($) {
    var module = this;

EasySocial.Controller('Field.Joomla_password.Mini', {
    defaultOptions: {
        required: false,
        reconfirmPassword: false,
        min: 4,
        max: 0,

        '{field}': '[data-field-joomla_password]',
        '{input}': '[data-password]',
        '{reconfirm}'   : '[data-field-password-confirm]',
        '{reconfirmNotice}' : '[data-reconfirmPassword-failed]'
    }
}, function(self, opts, base) { return {

    init: function() {

        var data = self.field().htmlData();
        opts.error = data.error || {};
    },

    "{self} onRender": function() {
        var data = self.field().htmlData();

        opts.error = data.error;
    },

    '{input} keyup': function() {
        self.checkPassword();
    },

    '{reconfirm} keyup': function() {
        self.validatePassword();
    },

    '{reconfirm} blur': function() {
        self.validatePassword();
    },

    checkPassword: function() {
        self.clearError();

        var value = self.input().val();

        if(self.options.required && value.length == 0) {
            self.raiseError(opts.error.empty);
            return false;
        }

        if(self.options.min > 0 && value.length < self.options.min) {
            self.raiseError(opts.error.min);
            return false;
        }

        if(self.options.max > 0 && value.length > self.options.max) {
            self.raiseError(opts.error.long);
            return false;
        }

        if(self.options.minInteger > 0) {
            var test = value.match(/[0-9]/g);
            if (!test || test.length < self.options.minInteger) {
                self.raiseError(opts.error.min);
                return false;
            }
        }

        if(self.options.minSymbol > 0) {
            var test = value.match(/[\W]/g);
            if (!test || test.length < self.options.minSymbol) {
                self.raiseError(opts.error.minsymbols);
                return false;
            }
        }

        if(self.options.minUpperCase > 0) {
            var test = value.match(/[A-Z]/g);
            if (!test || test.length < self.options.minUpperCase) {
                self.raiseError(opts.error.minupper);
                return false;
            }
        }

        return true;
    },

    validatePassword: function() {
        self.clearError();

        var input = self.input().val();
        var reconfirm = self.reconfirm().val();

        if(self.options.reconfirmPassword && !self.validatePasswordConfirm()) {
            return false;
        }

        return true;
    },

    validatePasswordConfirm: function() {
        var input = self.input().val(),
            reconfirm = self.reconfirm().val();

        // Check if either input or reconfirm is not empty
        if(!$.isEmpty(input) || !$.isEmpty(reconfirm)) {
            if($.isEmpty(input)) {
                self.raiseError(opts.error.empty);
                return false;
            }

            if($.isEmpty(reconfirm)) {
                self.raiseError(opts.error.emptyconfirm);
                return false;
            }

            if(input !== reconfirm) {
                self.raiseError(opts.error.mismatch);
                return false;
            }
        }

        return true;
    },

    '{self} onSubmit': function(el, event, register, mode) {
        if (mode !== 'onRegisterMini') {
            return;
        }

        register.push(self.checkPassword());
    },

    clearError: function() {
        self.trigger('clear');
    },

    raiseError: function(msg) {
        self.trigger('error', [msg]);
    }
}});

module.resolve();
})
			EasySocial.module('apps/fields/user/joomla_password/sample_content', function($) {
    var module = this;

    EasySocial.Controller('Field.Joomla_password.Sample', {
        defaultOptions: {
            '{confirmPassword}'     : '[data-password-confirm]'
        }
    }, function(self) {
        return {
            init: function() {

            },

            '{self} onConfigChange': function(el, event, name, value) {
                switch(name) {
                    case 'reconfirm_password':
                        self.confirmPassword().toggle(value);
                    break;
                }
            }
        }
    });

    module.resolve();
});
			EasySocial.module('apps/fields/user/joomla_timezone/content', function($) {

var module = this;

EasySocial
.require()
.library('chosen')
.done(function($) {

EasySocial.Controller('Field.Joomla_timezone', {
	defaultOptions: {
		"required": false,
		'{field}': '[data-field-joomla_timezone]',
		'{input}': '[data-field-joomla_timezone-input]'
	}
}, function(self, opts, base) { return {

	init : function() {
		opts.message = self.element.find('[data-error]').data('error');

		self.input().chosen({
			// width: $('.o-control-input').eq(0).width() + 'px', // #3003
			width: '100%',
			allow_single_deselect: true,
			search_contains: true
		});
	},

	validateInput: function() {
		if(!self.options.required) {
			return true;
		}

		self.clearError();

		var value = self.input().val();

		if(value === 'null' || $.isEmpty(value)) {
			self.raiseError();
			return false;
		}

		return true;
	},

	raiseError: function() {
		self.trigger('error', opts.message);
	},

	clearError: function() {
		self.trigger('clear');
	},

	'{input} change': function() {
		self.validateInput();
	},

	"{self} onSubmit": function(el, event, register) {
		register.push(self.validateInput());
	}

}});

module.resolve();
});
});
			EasySocial.module('apps/fields/user/joomla_username/content', function($) {

var module = this;

EasySocial.Controller('Field.Joomla_username', {
	defaultOptions: {
		event: null,
		id: null,
		userid: null,

		'{button}': '[data-username-check]',
		'{input}': '[data-username-input]',
		'{available}': '[data-username-available]',
		"{error}": "[data-username-error]",
		"{errorMessage}": "[data-username-error] > [data-message]"
	}
}, function(self, opts, base) { return {
	state: false,

	init: function() {
	},

	'{button} click': function() {
		self.delayedCheck();
	},

	'{input} keyup': function() {
		self.delayedCheck();
	},

	delayedCheck: $.debounce(function() {
		self.checkUsername();
	}, 250),

	checkUsername: function() {
		self.clearError();

		var state = $.Deferred();
		var button = self.button();

		button.addClass('is-loading');

		var username = self.input().val();

		EasySocial.ajax('fields/user/joomla_username/isValid', {
			id: opts.id,
			userid: opts.userid,
			username: username,
			event: opts.event
		}).done(function(msg) {
			
			self.available().removeClass('t-hidden');
			self.error().addClass('t-hidden');
			state.resolve();

		}).fail(function(msg) {

			self.available().addClass('t-hidden');
			self.error().removeClass('t-hidden');
			self.errorMessage().html(msg);

			self.raiseError(msg);

			state.reject();

		}).always(function() {
			button.removeClass('is-loading');
		})

		return state;
	},

	raiseError: function(msg) {
		self.trigger('error', [msg]);
	},

	clearError: function() {
		self.trigger('clear');
	},

	'{self} onSubmit': function(el, ev, register, mode) {
		if (mode === 'onRegisterMini') {
			return;
		}

		register.push(self.checkUsername());
	}
}});

module.resolve();
});
			EasySocial.module('apps/fields/user/joomla_username/registermini_content', function($) {

var module = this;

EasySocial.Controller('Field.Joomla_username.Mini', {
    defaultOptions: {
        id: null,
        required: false,
        '{field}': '[data-field-joomla_username]',
        '{input}': '#joomla_username'
    }
}, function(self, opts, base) { return {

    init: function() {

        var data = self.field().htmlData();
        opts.error = data.error || {};
    },

    "{self} onRender": function() {
        var data = self.field().htmlData();

        opts.error = data.error || {};
    },

    '{input} keyup': function(el) {
        if(el.val().length > 0) {
            self.delayedCheck();
        }
    },

    state: false,

    delayedCheck: $.debounce(function() {
        self.checkUsername();
    }, 250),

    checkUsername: function() {

        var username = self.input().val();

        if(self.options.required && username.length == 0) {
            self.raiseError(opts.error.empty);
            return false;
        }

        if(username.length > 0) {
            var state = $.Deferred();

            self.clearError();

            self.input().addClass('is-loading');

            EasySocial.ajax('fields/user/joomla_username/isValid', {
                id: self.options.id,
                userid: 0,
                username: username
            }).done(function(msg) {
                self.setLoaded();

                state.resolve();

            }).fail(function(msg) {

                self.raiseError(msg);

                state.reject();

            }).always(function() {
                self.input().removeClass('is-loading');
            });

            return state;
        }

        return true;
    },

    raiseError: function(msg) {
        self.trigger('error', [msg]);
    },

    clearError: function() {
        self.trigger('clear');
    },

    '{self} onSubmit': function(el, ev, register, mode) {
        if (mode !== 'onRegisterMini') {
            return;
        }

        if(self.options.required || self.input().val().length > 0) {
            register.push(self.checkUsername());
        }
    },

    setLoading: function(msg) {
        self.trigger('loading', [msg]);
    },

    setLoaded: function() {
        self.trigger('loaded');
    }
}});

module.resolve();
});
			EasySocial.module('apps/fields/user/joomla_username/sample_content', function($) {
    var module = this;

    EasySocial.Controller('Field.Joomla_username.Sample', {
        defaultOptions: {
            '{checkUsername}'       : '[data-check-username]'
        }
    }, function(self) {
        return {
            init: function() {

            },

            '{self} onConfigChange': function(el, event, name, value) {
                switch(name) {
                    case 'check_username':
                        self.checkUsername().toggle(!!value);
                    break;
                }
            }
        }
    });

    module.resolve();
});
			EasySocial.module('apps/fields/user/keycaptcha/content', function($) {
var module = this;

EasySocial.Controller('Field.Keycaptcha', {
    defaultOptions: {
     required: true,
    '{input}': '[data-field-keycaptcha]',
   }
}, function(self, opts, base) { return {

    "{self} onRender": function() {
        var data = self.input().htmlData();

        opts.error = data.error || {};
    },

    validateInput: function() {
        self.clearError();
        var keycaptcha = self.input().val();

        if(keycaptcha.length > 100){
            return true;
        }

        self.raiseError();
        return false;
    },
    
    raiseError: function() {
        self.trigger('error', opts.error.required);
    },

    clearError: function() {
        self.trigger('clear');
    },
    
    '{self} onSubmit': function(el, event, register) {
        register.push(self.validateInput());
    }

}});

module.resolve();

});			EasySocial.module('apps/fields/user/keycaptcha/registermini_content', function($) {
    var module = this;

    EasySocial.require()
        EasySocial.Controller('Field.keycaptcha.Mini', {
            defaultOptions: {
                id: null,

                required: false,

                '{input}': '[data-field-keycaptcha]'
            }
        }, function(self) {
            return {
                init: function() {

                },
                validateInput: function() {

                   self.clearError();

                var state = $.Deferred();

                var keycaptcha = self.input().val();
                var a = keycaptcha.split('|');  

                    if(a[4] == 1){
                     state.resolve();
                      return true;
                    }
                     self.raiseError(msg);
                     state.reject();
                     return state;  
                },

                raiseError: function(msg) {
                    self.trigger('error', [msg]);
                },

                clearError: function() {
                    self.trigger('clear');
                },

                '{self} onSubmit': function(el, ev, register, mode) {
                    if (mode !== 'onRegisterMini') {
                        return;
                    }
                }
            }
        });

        module.resolve();
   
});
			EasySocial.module('apps/fields/user/multidropdown/content', function($) {

var module = this;

EasySocial
.require()
.library('ui/sortable')
.done(function() {

EasySocial.Controller('Field.Multidropdown', {
    defaultOptions: {
    required: false,

    id: null,

    inputName: '',

    max: 0,

    '{field}': '[data-field-multidropdown]',

    '{list}': '[data-field-multidropdown-list]',

    '{item}': '[data-field-multidropdown-item]',

    '{input}': '[data-field-multidropdown-input]',

    '{add}': '[data-field-multidropdown-add]',

    '{delete}': '[data-field-multidropdown-delete]',

    '{move}': '[data-field-multidropdown-move]'
    }
}, function(self, opts, base) { return {

    init: function() {

        opts.message = self.element.find('[data-error]').data('error');
        opts.max = self.field().data('max');

        self.initSortable();
    },

    initSortable: function() {
        self.list().sortable({
            items: self.item.selector,
            handle: self.move.selector
        });
    },

    '{add} click': function(el) {
        if (self.options.max < 1 || self.item().length < self.options.max)
        {
            var item = self.item().eq(0).clone();

            item.find(self.input.selector)
                .attr('value', '')
                .val('');

            self.list().append(item);
        }

        if(self.options.max > 0 && self.item().length >= self.options.max)
        {
            el.hide();
        }
    },

    '{delete} click': function(button, event) {
        var item = button.parents(self.item.selector);

        if (self.item().length > 1) {
            item.remove();
        } else {
            item.find(self.input.selector).val('');
        }

        if (opts.max > 0 && self.item().length < self.options.max) {
            self.add().show();
        }
    },

    '{self} onConfigChange': function(el, ev, name, value) {
        switch (name) {
            case 'add_button_text':
                self.add().text(value);
            break;
        }
    },

    raiseError: function() {
        self.trigger('error', [opts.message]);
    },

    '{self} onSubmit': function(el, ev, register) {
        if (!self.options.required) {
            register.push(true);
            return;
        }

        var state = false;

        $.each(self.input(), function(i, element) {
            if (!$.isEmpty($(element).val())) {
                state = true;

                return false;
            }
        });

        if (!state) {
            self.raiseError();
        }

        register.push(state);
    }
}});

module.resolve();

});
});
			EasySocial.module('apps/fields/user/multilist/content', function($) {

var module = this;

EasySocial.Controller('Field.Multilist', {
	defaultOptions: {
		required        : null,
		multiple        : null,

		"{field}"       : "[data-field-multilist]",

		"{item}"        : "[data-field-multilist-item]",

		"{option}"      : "[data-field-multilist-item] option"
	}
}, function(self, opts, base) { return {

	"{self} onRender": function() {
		var data = self.field().htmlData();

		opts.error = data.error || {};
	},

	validateInput : function() {
		self.clearError();

		if(self.options.multiple && self.item().children(':selected').length <= 0) {
			self.raiseError();
			return false;
		}

		// The only way to test for an empty value is when the value is empty and it's required.
		if(self.item().children(':selected' ).val() == '') {
			self.raiseError();
			return false;
		}

		return true;
	},

	raiseError: function() {
		self.trigger('error', [opts.error.empty]);
	},

	clearError: function() {
		self.trigger('clear');
	},

	"{self} onSubmit": function(el, event, register) {
		// If field is not required, skip the checks.

		if(!self.options.required)
		{
			register.push(true);
			return;
		}

		register.push(self.validateInput());

		return;
	},

	'{self} onChoiceAdded': function(el, event, index) {
		if(self.option().eq(index).length > 0) {
			self.option().eq(index).before($('<option></option>'));
		} else {
			self.item().append($('<option></option>'));
		}
	},

	'{self} onChoiceValueChanged': function(el, event, index, value) {
		self.option().eq(index).val(value);
	},

	'{self} onChoiceTitleChanged': function(el, event, index, value) {
		self.option().eq(index).text(value);
	},

	'{self} onChoiceRemoved': function(el, event, index) {
		self.option().eq(index).remove();
	},

	'{self} onChoiceToggleDefault': function(el, event, index, value) {
		if(value) {
			self.option().eq(index).attr('selected', 'selected');
		} else {
			self.option().eq(index).removeAttr('selected');
		}
	}
}});

module.resolve();
});			EasySocial.module('apps/fields/user/multitextbox/content', function($) {

var module = this;

EasySocial
.require()
.library('ui/sortable')
.done(function() {

EasySocial.Controller('Field.Multitextbox', {
    defaultOptions: {
        required: false,

        id: null,

        inputName: '',

        max: 0,

        '{field}': '[data-field-multitextbox]',

        '{list}': '[data-field-multitextbox-list]',

        '{item}': '[data-field-multitextbox-item]',

        '{input}': '[data-field-multitextbox-input]',

        '{add}': '[data-field-multitextbox-add]',

        '{delete}': '[data-field-multitextbox-delete]',

        '{move}': '[data-field-multitextbox-move]'
    }
}, function(self, opts, base) { return {
    
    init: function() {
        var data = self.field().htmlData();
        opts.error = data.error || {};

        opts.max = self.field().data('max');
        self.initSortable();
    },

    initSortable: function() {
        self.list().sortable({
            items: self.item.selector,
            handle: self.move.selector
        });
    },

    '{add} click': function(el) {
        
        if (self.options.max < 1 || self.item().length < self.options.max) {
            var item = self.item().eq(0).clone();

            item.find(self.input.selector)
                .attr('value', '')
                .val('');

            self.list().append(item);
        }

        if(self.options.max > 0 && self.item().length >= self.options.max)
        {
            el.hide();
        }
    },

    '{delete} click': function(el) {
        var item = el.parents(self.item.selector);

        if (self.item().length > 1) {
            item.remove();
        } else {
            item.find(self.input.selector).val('');
        }

        if (self.options.max > 0 && self.item().length < self.options.max) {
            self.add().show();
        }
    },

    '{self} onConfigChange': function(el, ev, name, value) {
        switch (name) {
            case 'add_button_text':
                self.add().text(value);
            break;
        }
    },

    raiseError: function() {
        self.trigger('error', [opts.error.required]);
    },

    '{self} onSubmit': function(el, ev, register) {
        if(!self.options.required) {
            register.push(true);
            return;
        }

        var state = false;

        $.each(self.input(), function(i, element) {
            if(!$.isEmpty($(element).val())) {
                state = true;

                return false;
            }
        });

        if (!state) {
            self.raiseError();
        }

        register.push(state);
    }
}
});

module.resolve();
});
});
			EasySocial.module('apps/fields/user/numeric/content', function($) {

var module = this;

EasySocial.Controller('Field.Numeric', {
	defaultOptions: {
		required: false,
		min: 0,
		max: 0,
		'{field}': '[data-field-numeric]',
		'{input}': '[data-field-numeric-input]',
		'{notice}': '[data-check-notice]'
	}
}, function(self, opts, base) { return {
	
	init: function() {
		opts.min = self.input().data('min');
		opts.max = self.input().data('max');
	},

	'{self} onRender': function() {
		var data = self.field().htmlData();
		opts.error = data.error || {};
	},

	'{input} mouseup': function() {
		self.validateInput();
	},

	'{input} keyup': function() {
		self.validateInput();
	},

	'{input} blur': function() {
		self.validateInput();
	},

	validateInput: function() {
		self.clearError();

		var value = self.input().val();

		if (opts.required && $.isEmpty(value)) {
			self.raiseError(opts.error.required);
			return false;
		}

		if (!$.isEmpty(value) && opts.min > 0 && value < opts.min) {
			self.raiseError(opts.error.short);
			return false;
		}

		if (opts.max > 0 && value > opts.max) {
			self.raiseError(opts.error.long);
			return false;
		}

		return true;
	},

	raiseError: function(msg) {
		self.trigger('error', [msg]);
	},

	clearError: function() {
		self.trigger('clear');
	},

	'{self} onError': function(el, ev, type) {
		if (type === 'required') {
			self.raiseError(opts.error.required);
		}

		if (type === 'validate') {
			self.raiseError(opts.error.invalid);
		}
	},

	'{self} onSubmit': function(el, ev, register) {
		register.push(self.validateInput());
	}
}});

module.resolve();
});			EasySocial.module('apps/fields/user/password/content', function($) {

var module = this;

EasySocial.Controller('Field.Password', {
    defaultOptions: {
        required: false,

        min: 0,
        max: 0,

        '{field}': '[data-field-password]',

        '{input}': '[data-field-password-input]',

        '{notice}': '[data-check-notice]'
    }
}, function(self, opts, base) { return {
    init: function() {
        var data = self.field().htmlData();

        opts.error = data.error || {};
        opts.min = self.field().data('min');
        opts.max = self.field().data('max');
    },

    '{input} keyup': function() {
        self.validateInput();
    },

    '{input} blur': function()
    {
        self.validateInput();
    },

    validateInput: function()
    {
        self.clearError();

        var value = self.input().val();

        if(self.options.required && $.isEmpty(value)) {
            self.raiseError(opts.error.required);
            return false;
        }

        if(!$.isEmpty(value) && self.options.min > 0 && value.length < self.options.min) {
            self.raiseError(opts.error.short);
            return false;
        }

        if(self.options.max > 0 && value.length > self.options.max) {
            self.raiseError(opts.error.long);
            return false;
        }

        return true;
    },

    raiseError: function(msg) {
        self.trigger('error', [msg]);
    },

    clearError: function() {
        self.trigger('clear');
    },

    '{self} onError': function(el, ev, type) {
        if(type === 'required') {
            self.raiseError(opts.error.required);
        }
    },

    '{self} onSubmit': function(el, ev, register) {
        register.push(self.validateInput());
    }
}});

module.resolve();
});
			EasySocial.module('apps/fields/user/password/sample_content', function($) {
    var module = this;

    EasySocial.Controller('Field.Password.Sample', {
        defaultOptions: {
            '{input}'           : '[data-input]',

            'min'                   : '',
            'max'                   : ''
        }
    }, function(self) {
        return {
            init: function() {

            },

            '{self} onConfigChange': function(el, event, name, value) {
                switch(name) {
                    case 'placeholder':
                        self.input().attr('placeholder', value);
                    break;

                    case 'default':
                        self.input().val(value);
                    break;

                    break;
                }
            }
        }
    });

    module.resolve();
});
			EasySocial.module('apps/fields/user/permalink/content', function($) {

var module = this;

EasySocial.Controller('Field.Permalink', {
    defaultOptions: {
        required: false,
        max     : 0,
        id      : null,
        userid  : null,
        '{field}': '[data-field-permalink]',
        '{checkButton}': '[data-permalink-check]',
        '{input}': '[data-permalink-input]',
        '{available}': '[data-permalink-available]'
    }
}, function(self, opts, base) { return {
    
    state: false,

    init: function() {
        opts.message = {
            length: base.find('[data-error-length]').data('error-length'),
            required: base.find('[data-error-required]').data('error-required')
        };

        opts.max = self.field().data('max');
    },

    "{checkButton} click" : function() {
        self.delayedCheck();
    },

    "{input} keyup" : function() {
        self.delayedCheck();
    },

    delayedCheck: $.debounce(function() {
        self.checkPermalink();
    }, 250),

    checkPermalink: function() {
        self.clearError();

        var permalink   = self.input().val();

        self.available().hide();

        if(self.options.max > 0 && permalink.length > self.options.max) {
            self.raiseError(opts.message.length);
            return false;
        }

        if(!$.isEmpty(permalink))
        {
            self.checkButton().addClass('is-loading');

            var state = $.Deferred();

            EasySocial.ajax('fields/user/permalink/isValid',
            {
                "id"        : self.options.id,
                "userid"    : self.options.userid,
                "permalink" : permalink
            })
            .done(function(msg)
            {
                self.checkButton().removeClass( 'is-loading' );

                self.available().show();

                state.resolve();
            })
            .fail(function(msg)
            {
                self.raiseError(msg);

                self.checkButton().removeClass('is-loading');

                self.available().hide();

                state.reject();
            });

            return state;
        }

        if(self.options.required && $.isEmpty(permalink))
        {
            self.available().hide();

            self.raiseError(opts.message.required);
            return false;
        }

        return true;
    },

    raiseError: function(msg)
    {
        self.trigger('error', [msg]);
    },

    clearError: function()
    {
        self.trigger('clear');
    },

    '{self} onSubmit': function(el, ev, register)
    {
        register.push(self.checkPermalink());
    }
}});

module.resolve();
});
			EasySocial.module('apps/fields/user/permalink/sample_content', function($) {
    var module = this;

    EasySocial.Controller('Field.Permalink.Sample', {
        defaultOptions: {
            '{checkPermalink}'      : '[data-check-permalink]'
        }
    }, function(self) {
        return {
            init: function() {

            },

            '{self} onConfigChange': function(el, event, name, value) {
                switch(name) {
                    case 'check_permalink':
                        self.checkPermalink().toggle(!!value);
                    break;
                }
            }
        }
    });

    module.resolve();
});
			EasySocial.module('apps/fields/user/relationship/content', function($) {

var module = this;

EasySocial
.require()
.script('site/friends/suggest')
.done(function($) {

EasySocial.Controller('Field.Relationship', {
	defaultOptions: {
		required: false,
		id: null,
		types: null,
		fieldname: null,
		actor: null,
		target: null,
		userid: null,

		'{type}': '[data-rs-type]',
		'{request}': '[data-rs-request]',

		'{field}': '[data-field-relationship]',
		'{pendingTitle}': '[data-rs-pending-title]',

		// Relations wrapper
		'{relations}': '[data-rs-relations]',

		// Delete a relation
		'{delete}': '[data-rs-delete]',

		// Request form
		'{rejectRequest}': '[data-rs-reject]',
		'{approveRequest}': '[data-rs-approve]'
	}
}, function(self, opts, base) { return {
	init: function() {

		EasySocial.module('field.relationship/' + opts.id).done(function(types) {
			self.options.types = types;
		});

		self.addPlugin('form');
	},

	getRequestId: function() {
		return self.request().data('id');
	},

	getRequestWrapper: function(id) {
		wrapper = $('[data-rs-request][data-id="' + id + '"]');
		return wrapper;
	},

	showTypeSelection: function() {
		// Show the form
		self.type().val(self.type().children(':first').val());
		self.type().removeClass('t-hidden').show();
		self.type().removeAttr('disabled');
	},

	'{self} relationshipDeleted': function() {
		self.showTypeSelection();
	},

	'{delete} click': function(button, event) {
		event.stopPropagation();
		event.preventDefault();

		button.addClass('is-loading');

		EasySocial.ajax('fields/user/relationship/delete', {
			"id": opts.id,
			"userid": opts.userid,
			"relid": self.getRequestId()
		}).done(function(output) {

			button.removeClass('is-loading');

			self.relations().remove();

			// Show the type selection again
			self.showTypeSelection();
		});
	},

	'{approveRequest} click': function(button, event) {
		var id = button.data('id');
		button.addClass('is-loading');

		EasySocial.ajax('fields/user/relationship/approve', {
			"id": opts.id,
			"relid": id,
			"inputName": opts.fieldname
		}).done(function(output) {

			// Remove hidden input
			$('[data-rs-request-hidden]').remove();

			wrapper = self.getRequestWrapper(id);

			button.removeClass('is-loading');
			self.request().not(wrapper).remove();


			wrapper.replaceWith(output);
		});
	},

	'{rejectRequest} click': function(button, event) {
		event.preventDefault();
		event.stopPropagation();

		var id = button.data('id');

		EasySocial.ajax('fields/user/relationship/reject', {
			"id": opts.id,
			"relid": id
		}).done(function() {
			// Hide the request item
			wrapper = self.getRequestWrapper(id);

			wrapper.remove();
			self.trigger('relationshipDeleted');
		});
	}
}});

EasySocial.Controller('Field.Relationship.Form', {
	defaultOptions: {

		'{field}': '[data-field-relationship]',
		'{type}': '[data-rs-type]',

		'{input}': '[data-rs-input]',
		'{target}': '[data-rs-target]',

		'{targetAvatar}': '[data-rs-target-avatar]',
		'{targetName}': '[data-rs-target-name]',
		'{targetDelete}': '[data-rs-form-delete]',
		'{textboxlistDelete}': '[data-textboxlist-itemRemoveButton]',

		target : false
	}
}, function(self, opts, base) { return {
	init: function() {
		self.input().addController(EasySocial.Controller.Friends.Suggest, {
			max: 1,
			name: self.parent.options.fieldname + '[target][]'
		});

        var data = self.field().htmlData();
        if (data && data.error) {
			opts.error = data.error;
        }

        // default this to true so that edit whitout changing the relationship will still pass. #492
		opts.target = true;

	},

    "{self} onRender": function() {
        var data = self.field().htmlData();
        opts.error = data.error;
    },

	'{type} change': function(dropdown, event) {

		var type = dropdown.val();
		var option = dropdown.find(':selected');
		var connection = option.data('connection') ? true : false;
		opts.target = false;

		// If this relationship does not have any connection, skip this
		if (!connection) {
			opts.target = true;

			self.clearError();
			self.input().hide();
			self.target().hide();
			return;
		}

		// Always remove the item when changing a type
		self.input().controller('Textboxlist').clearItems();
		self.target().hide();
		self.input().show();
		self.validateInput(opts.error.target);
	},

	'{input} addItem': function(el, ev, item) {

		// Since the item is html based, we need to extract the data
		var item = $('<div/>').html(item.html);
		var avatar = item.find('[data-suggest-avatar]').attr('src');
		var name = item.find('[data-suggest-title]').val();
		var id = item.find('[data-suggest-id]').val();

		if (avatar) {
			self.targetAvatar().attr('src', avatar);
		}

		if (name) {
			self.targetName().text(name);
		}

		if (id) {
			self.targetDelete().data('id', id);
		}

		self.input().hide();
		self.target().show();

		// Globally set the target is true
		opts.target = true;
		self.clearError();
	},

	'{input} blur' : function(el, ev) {
		self.validateInput(opts.error.target);
	},

	'{targetDelete} click': function(button, event) {
		var id = button.data('id');

		// Remove the selected item
		self.input().controller('Textboxlist').removeItem(id);

		self.type().removeAttr('disabled');
		self.input().show();
		self.target().hide();

		opts.target = false;
		self.validateInput(opts.error.target);
	},

	'{self} onSubmit': function(el, event, register) {

		register.push(self.validateInput(opts.error.target));
	},

	validateInput : function(msg) {

        var isRequired = self.parent.options.required;
        var type = self.type().val();

        var allowed = ['na', 'single', 'widowed', 'separated', 'divorced', 'relationshipnotarget', 'engagednotarget', 'marriednotarget', 'complicatednotarget'];

        if(isRequired && type == 'na') {
			self.raiseError(opts.error.required);
			return false;
        }

        if (!isRequired && ($.inArray(type, allowed) !== -1)) {
			self.clearError();
			return true;
        }

        if (($.inArray(type, allowed) === -1) && !opts.target) {
			self.raiseError(opts.error.target);
			return false;
        }

        // all pass.
		self.clearError();
		return true;
	},

	raiseError: function(msg) {
		if (!msg) {
			msg = opts.error.required;
		}

		self.trigger('error', [msg]);
	},

	clearError: function() {
		self.trigger('clear');
	}
}});

module.resolve();

});
});
			EasySocial.module('apps/fields/user/separator/sample', function($) {
    var module = this;

    EasySocial.Controller( 'Field.Separator.Sample',
    {
        defaultOptions:
        {
            "{items}"   : "[data-separator-type]"
        }
    },
    function( self )
    {
        return {
            "{self} onConfigChange" : function( el , event , name , value )
            {
                if( name == 'type' )
                {
                    var itemToShow  = $( '[data-separator-' + value + ']' );

                    // Hide all separators
                    self.items().hide();

                    // Only show the correct separator
                    itemToShow.show();
                }

            }
        }
    });

    module.resolve();
});
			EasySocial.module('apps/fields/user/terms/content', function($) {

var module = this;

EasySocial.Controller('Field.Terms', {
	defaultOptions: {
		event: null,
		required: false,

		'{textbox}': '[data-field-terms-textbox]',
		'{checkbox}': '[data-field-terms-checkbox]'
	}
}, function(self, opts, base) { return {

	"{self} onRender": function() {
		var data = self.element.htmlData();

		opts.error = data.error || {};
	},

	validateInput: function() {
		self.clearError();

		// We should not prevent admin from hitting errors
		if (opts.event == 'onAdminEdit') {
			return true;
		}

		if (opts.required && !self.checkbox().is(':checked')) {
			self.raiseError(opts.error.required);
			return false;
		}

		return true;
	},

	'{checkbox} change': function() {
		self.validateInput();
	},

	raiseError: function() {
		self.trigger('error', [opts.error.required]);
	},

	clearError: function() {
		self.trigger('clear');
	},

	'{self} onSubmit': function(el, event, register) {
		register.push(self.validateInput());
	}
}});

module.resolve();
});
			EasySocial.module('apps/fields/user/textarea/content', function($) {

var module = this;

EasySocial.Controller('Field.Textarea', {
	defaultOptions: {
		required: false,
		min: 0,
		max: 0,
		'{field}': '[data-field-textarea]',
		'{input}': '[data-field-textarea-input]'
	}
}, function(self, opts, base) { return {
	init : function() {
		opts.min = self.field().data('min');
		opts.max = self.field().data('max');
	},

	"{self} onRender": function() {
		var data = self.field().htmlData();

		opts.error = data.error || {};
	},

	validateInput : function() {
		self.clearError();

		var val = self.input().val();

		if (self.options.required && $.isEmpty(val)) {
			self.raiseError(opts.error.required);
			return false;
		}

		if (!$.isEmpty(val) && self.options.min > 0 && val.length < self.options.min) {
			self.raiseError(opts.error.short);
			return false;
		}

		if (self.options.max > 0 && val.length > self.options.max) {
			self.raiseError(opts.error.long);
			return false;
		}

		return true;
	},

	raiseError: function(msg) {
		self.trigger('error', [msg]);
	},

	clearError: function() {
		self.trigger('clear');
	},

	'{self} onSubmit': function(el, event, register) {
		register.push(self.validateInput());
	},

	'{self} onError': function(el, ev, type) {
		if (type === 'required') {
			self.raiseError(opts.error.required);
		}
	},

	'{input} keyup': function() {
		self.validateInput();
	},

	'{self} onConfigChange': function(el, event, name, value) {
		switch(name) {
			case 'default':
				self.input().val(value);
				break;

			case 'placeholder':
				self.input().attr('placeholder', value);
				break;

			case 'readonly':
				if (value) {
					self.input().attr('readonly', 'readonly');
				} else {
					self.input().removeAttr('readonly');
				}
				break;
		}
	}
}});

module.resolve();

});			EasySocial.module('apps/fields/user/textbox/content', function($) {

var module = this;

EasySocial.Controller('Field.Textbox', {
	defaultOptions: {
		required: false,
		min: 0,
		max: 0,
		'{field}': '[data-field-textbox]',
		'{input}': '[data-field-textbox-input]',
		'{notice}': '[data-check-notice]'
	}
}, function(self, opts, base) { return {
	
	init: function() {
		opts.min = self.field().data('min');
		opts.max = self.field().data('max');
	},

	'{self} onRender': function() {
		var data = self.field().htmlData();
		opts.error = data.error || {};
	},

	'{input} keyup': function() {
		self.validateInput();
	},

	'{input} blur': function() {
		self.validateInput();
	},

	validateInput: function() {
		self.clearError();

		var value = self.input().val();

		if (self.options.required && $.isEmpty(value)) {
			self.raiseError(opts.error.required);
			return false;
		}

		if (!$.isEmpty(value) && self.options.min > 0 && value.length < self.options.min) {
			self.raiseError(opts.error.short);
			return false;
		}

		if (self.options.max > 0 && value.length > self.options.max) {
			self.raiseError(opts.error.long);
			return false;
		}

		return true;
	},

	raiseError: function(msg) {
		self.trigger('error', [msg]);
	},

	clearError: function() {
		self.trigger('clear');
	},

	'{self} onError': function(el, ev, type) {
		if (type === 'required') {
			self.raiseError(opts.error.required);
		}

		if (type === 'validate') {
			self.raiseError(opts.error.invalid);
		}
	},

	'{self} onSubmit': function(el, ev, register) {
		register.push(self.validateInput());
	}
}});

module.resolve();
});			EasySocial.module('apps/fields/user/textbox/sample_content', function($) {
    var module = this;

    EasySocial.Controller('Field.Textbox.Sample', {
        defaultOptions: {
            '{input}'           : '[data-input]',

            'min'                   : '',
            'max'                   : '',
            'regex_validate'        : false,
            'regex_format'          : '',
            'regex_modifier'        : ''
        }
    }, function(self) {
        return {
            init: function() {

            },

            '{self} onConfigChange': function(el, event, name, value) {
                switch(name) {
                    case 'placeholder':
                        self.input().attr('placeholder', value);
                    break;

                    case 'default':
                        self.input().val(value);
                    break;

                    case 'readonly':
                        if(value) {
                            self.input().attr('disabled', 'disabled');
                        } else {
                            self.input().removeAttr('disabled');
                        }
                        break;
                    break;
                }
            }
        }
    });

    module.resolve();
});
			EasySocial.module('apps/fields/user/url/content', function($) {

var module = this;

EasySocial.Controller('Field.Url', {
	defaultOptions: {
		required: false,

		'{field}': '[data-field-url]',
		'{input}': '[data-field-url-input]'
	}
}, function(self, opts, base) { return {

	init: function() {
	},
	
	"{self} onRender": function() {
		var data = self.field().htmlData();

		opts.error = data.error || {};
	},

	'{input} blur': function() {
		self.validateInput();
	},

	'{input} keyup': function() {
		self.validateInput();
	},

	validateInput: function() {
		self.clearError();

		var value = self.input().val();

		if (self.options.required && $.isEmpty(value)) {
			self.raiseError(opts.error.empty);
			return false;
		}

		return true;
	},

	raiseError: function(msg) {
		self.trigger('error', [msg]);
	},

	clearError: function() {
		self.trigger('clear');
	},

	'{self} onError': function(el, event, type, field) {
		self.raiseError(opts.error.empty);
	},

	'{self} onSubmit': function(el, ev, register) {
		register.push(self.validateInput());
	}
}});

module.resolve();

});			EasySocial.module('shared/elements', function($){

var module = this;
var tooltipLoaded = false;

// Initialize yes/no buttons.
$(document).on('click.button.data-bs-api', '[data-bs-toggle-value]', function() {

	var button = $(this);
	var siblings = button.siblings("[data-bs-toggle-value]");
	var parent = button.parents('[data-bs-toggle="radio-buttons"]');

	if (parent.hasClass('disabled')) {
		return;
	}

	// This means that this toggle value belongs to a radio button
	if (parent.length > 0) {

		// Get the current button that's clicked.
		var value = $(this).data('bs-toggle-value');

		button.addClass("active");
		siblings.removeClass("active");

		// Set the value here.
		// Have to manually trigger the change event on the input
		parent.find('input[type=hidden]').val(value).trigger('change');
		return;
	}
});

$(document).on('change.form.toggler', '[data-toggler-checkbox]', function() {
	var checkbox = $(this);
	var checked = checkbox.is(':checked');
	var parent = checkbox.parents('[data-bs-toggler]');

	if (parent.length > 0) {

		var input = parent.find('input[type=hidden]');
		input.val(checked ? 1 : 0).trigger('change');
	}
});

EasySocial.isMobile = function() {
	try {
		document.createEvent('TouchEvent');
		return true;
	} catch(e) {
		return false;
	}
}

// String truncater
// Used when there is a read more of a truncated content.
var selector = '[data-es-truncater] > [data-readmore]';

$(document)
	.on('click.es.strings.truncater', selector, function() {

		var section = $(this).parent();
		var original = section.find('[data-original]');
		var text = section.find('[data-text]');

		// Hide the link
		$(this).addClass('t-hidden');

		// Show the full contents
		text.addClass('t-hidden');
		original.removeClass('t-hidden');
	});

// Tooltips
// detect if mouse is being used or not.
var mouseCount = 0;
window.onmousemove = function() {

	mouseCount++;

	addTooltip();
};

var addTooltip = $.debounce(function(){

    if (!tooltipLoaded && mouseCount > 10) {

		tooltipLoaded = true;
		mouseCount = 0;

		$(document).on('mouseover.tooltip.data-es-api', '[data-es-provide=tooltip]', function() {

			$(this)
				.tooltip({
					delay: {
						show: 200,
						hide: 100
					},
					animation: false,
					template: '<div id="es" class="tooltip tooltip-es"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
					container: 'body'
				})
				.tooltip("show");
		});
    } else {
    	mouseCount = 0;
    }
}, 500);


// TODO: Update to [data-es-provide=tooltip]
if (!EasySocial.isMobile()) {
	$(document).on('mouseover.tooltip.data-es-api', '[data-es-provide=tooltip]', function() {

		$(this)
			.tooltip({
				delay: {
					show: 200,
					hide: 100
				},
				animation: false,
				template: '<div id="es" class="tooltip tooltip-es"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
				container: 'body'
			})
			.tooltip("show");
	});
}

// Popovers
// TODO: Update to [data-es-provide=popover]
$(document).on('mouseover.popover.data-es-api', '[data-es-provide=popover]', function() {
	$(this)
		.popoverES({
			delay: {
				show: 200,
				hide: 100
			},
			animation: false,
			trigger: 'hover',
			container: 'body'
		})
		.popoverES("show");
});


var ly = function(yr) { return (yr%400)?((yr%100)?((yr%4)?false:true):false):true; };

$(document).on("keyup", "[data-date-form] [data-date-day]", function(){

	if (!$.trim($(this).val())) return;

	var year   = parseInt($(this).siblings("[data-date-year]").val()  || $(this).siblings("[data-date-year]").data("dateDefault")),

	    month  = parseInt($(this).siblings("[data-date-month]").val() || $(this).siblings("[data-date-month]").data("dateDefault")),

	    day    = parseInt($(this).val() || $(this).data("dateDefault")),

		maxDay = /1|3|5|7|8|10|12/.test(month) ? 31 : 30;

		if (month==2) maxDay = ly(year) ? 29 : 28;

		if (day < 1) day = 1;

		if (day > maxDay) day = maxDay;

		if ($.isNumeric(day)) {
			$(this).val(day);
		} else {
			$(this).val("");
		}
});

$(document).on("keyup", "[data-date-form] [data-date-year]", function(){

	if (!$.trim($(this).val())) return;

	var year = parseInt($(this).val());
	if (year < 1) year = 1;

	if ($.isNumeric(year)) {
		$(this).val(year);
	} else {
		$(this).val("");
	}
});

module.resolve();

});
			EasySocial.module('shared/fields/base', function($) {

var module = this;

EasySocial.Controller('Field.Base', {
	defaultOptions: {
		regPrefix : 'easysocial/',
		modPrefix : 'field.',
		ctrlPrefix : 'EasySocial.Controller.Field.',
		
		// Field attributes
		"id": null,
		"name": null,
		"element": null,
		"required": false,

		// Default mode
		"mode": 'edit',

		// Container items
		'{field}': '[data-field]',
		'{content}': '[data-content]',
		'{notice}': '[data-check-notice]'
	}
}, function(self, opts, base) { return {
	
	init: function() {

		// Initialize properties of the field
		opts.name = base.data('name');
		opts.element = opts.element || base.data('field-item');
		opts.id = base.data('id');
		opts.required = base.data('required') ? true : false;

		// Start triggering the field apps so that they can start doing their own initialization
		self.triggerFields();

		// Initialize error messages if there are any
		self.initializeErrorMessages();
	},

	initializeErrorMessages: function() {
		var notice = self.notice();
		var text = notice.text().trim();

		if (text.length <= 0) {
			return;
		}

		self.showError(text);
	},

	showError: function(message) {

		var content = self.content();
		
		content
			.find('[data-field-error]')
			.html(message);
	},

	// Trigger the necessary mode here for field to do necessary init
	triggerFields: function() {
		
		var field = self.field();
		var trigger = 'onEdit';

		if (opts.mode == 'registermini') {
			trigger = 'onRegisterMini';
		}

		if (opts.mode == 'register') {
			trigger = 'onRegister';
		}

		if (opts.mode == 'edit') {
			trigger = 'onEdit';
		}

		if (opts.mode == 'adminedit') {
			trigger = 'onAdminEdit';
		}

		if (opts.mode == 'sample') {
			trigger = 'onSample';
		}

		if (opts.mode == 'display') {
			trigger = 'onDisplay';
		}

		// Trigger the field
		field.trigger('onRender');
		field.trigger(trigger);
	},

	// Some base triggers/functions
	'{field} error': function(element, event, state, message) {
		var state = state !== undefined ? state : true;

		if ($.isString(state)) {
			message = state;
			state = true;
		}

		if ($.isBoolean(state)) {
			self.field().toggleClass('has-error', state);
		}

		if (message !== undefined) {
			self.showError(message);
		}
	},

	'{field} clear': function(el, ev) {
		self.field().removeClass('has-error');
		self.field().removeClass('is-loading');

		// Clear custom error
		var customError = self.field().find('[data-field-error]');

		if (customError.length > 0) {
			customError.html('');
		}

		self.content().popoverES('destroy');
	},

	'{self} show': function() {
		self.field().trigger('onShow');
	},

	'{field} loading': function(el, ev, msg) {
		self.field().addClass('is-loading');

		self.notice().html(msg);
	},

	'{field} loaded': function(el, ev) {
		self.field().removeClass('is-loading');
	}
}});

module.resolve();
});
			EasySocial.module('shared/fields/conditional', function($) {

var module = this;
var isController = $.isController('EasySocial.Controller.Field.Conditional');

if (isController) {
	return;
}

EasySocial.Controller('Field.Conditional', {
	defaultOptions: {
		id: null,
		fieldTargeted: [],
		operator: [],
		conditionValue: [],
		result: []
	}
}, function(self, opts, base) { return {

	init: function() {

		opts.id = base.data('id');
		var isConditional = base.data('isconditional');

		if (isConditional) {
			self.bindTargetedFields();
		}
	},

	bindTargetedFields: function() {
		var conditions = base.data('conditions');

		if (conditions) {
			$.each(conditions, function(key, value) {
				opts.fieldTargeted.push(value.fieldId);
				opts.operator.push(value.operator);
				opts.conditionValue.push(value.value);

				// Properly format the conditon value
				self.formatConditionsValue(key);

				// Bind listen event on targeted field
				self.bindFields(key);
			})
		}
	},

	bindFields: function(key) {

		var field = self.getTargetedField(key);

		if (self.isAutocomplete(key)) {
			self.bindAutocompleteFields(key);
		} else {

			// Listen on change event
			field.on('change', function() {
				self.fieldChanged(key);
			});

			// Listen on keyup event
			field.on('keyup', function() {
				self.fieldChanged(key);
			});

			// Re-check the current field value and determine if we should show or not the field
			field.on('onFieldShow', function() {
				self.fieldChanged(key);
			});

			// Directly trigger the checking during initial page load
			// only if the targeted field is not hidden
			if (!field.hasClass('t-hidden')) {
				self.fieldChanged(key);
			}
		}

		// Hide other field that are dependent on the field that are being hide
		field.on('onFieldHide', function() {
			self.hideSelf(key);
		});
	},

	bindAutocompleteFields: function(key) {

		var field = self.getTargetedField(key);
		var autocomplete = field.find('[data-field-suggest]');
		var accumulativeValue = [];

		// Get stored value
		var fieldName = field.data('name');
		var input = field.find(':input[name="' + fieldName + '[]"]');

		// Assign the stored value
		if (input.length > 0) {
			$.each(input, function(key, item) {
				var value = $(item).val();
				accumulativeValue.push(value);
			});
		}

		autocomplete.on('addItem', function(event, item) {
			accumulativeValue.push(item.value);
			self.fieldChanged(key, accumulativeValue);
		});

		autocomplete.on('removeItem', function(event, item) {
			accumulativeValue.splice($.inArray(item.value, accumulativeValue), 1);
			self.fieldChanged(key, accumulativeValue);
		});

		// Trigger initial page load
		if (!field.hasClass('t-hidden')) {
			self.fieldChanged(key, accumulativeValue);
		}

		// Re-check the current field value and determine if we should show or not the field
		field.on('onFieldShow', function() {
			self.fieldChanged(key, accumulativeValue);
		});
	},

	getRequiredChecking: function() {
		var data = $('[data-conditional-check]').val();

		if (data) {
			return JSON.parse(data);
		}

		return false;
	},

	fieldChanged: function(key, value) {

		// Get the latest value of the field
		if (!value) {
			var value = self.getTargetedFieldValue(key);
		}

		// Check conditions
		opts.result[key] = self.checkCondition(value, key);

		// Get the conditions logic
		var criteria = base.data('conditionsLogic');

		// Hide or show the field depending on the result
		if (opts.result) {
			var trueResult = true;

			$.each(opts.result, function(idx, result) {

				// OR criteria
				if (criteria == 'or') {

					// If there is one true, means everything is true
					if (result == true) {
						trueResult = true;
						return false;
					}
				}

				// AND criteria
				// All must be true in order to pass
				if (result == false) {
					trueResult = false;
				}
			});

			if (trueResult) {
				self.showSelf();
			} else {
				self.hideSelf();
			}
		}
	},

	checkCondition: function(value, key) {
		var condition = opts.conditionValue[key];
		var result = false;

		// format the value for special condition first
		value = self.formatValue(value, key);

		switch (opts.operator[key]) {
			case 'equal':

				if (self.isAutocomplete(key)) {
					$.each(value, function(idx, item) {
						if (item == condition) {
							result = true;
							return true;
						}
					});
				} else if (value == condition) {
					result = true;
				}
			break;

			case 'not equal':

				if (self.isAutocomplete(key)) {
					if (value.length > 0) {
						result = true;
						$.each(value, function(idx, item) {
							if (item == condition) {
								result = false;
								return true;
							}
						});
					}
				} else if (value != condition) {
					result = true;
				}
			break;

			case 'contain':
				if (self.isAutocomplete(key)) {
					$.each(value, function(idx, item) {
						result = new RegExp('\\b' + condition + '\\b', 'i').test(item);
					});
				} else {
					result = new RegExp( '\\b' + condition + '\\b', 'i').test(value);
				}
			break;
		}

		return result;
	},

	getTargetedFieldValue: function(key) {
		var field = self.getTargetedField(key);
		var fieldElement = self.getTargetedFieldElement(key);
		var inputs = field.find(':input');

		var value = [];
		var result = false;

		if (inputs.length > 0) {
			$.each(inputs, function() {
				var input = $(this);
				var type = input.attr('type');

				if (type != 'hidden') {
					switch (type) {
						case 'radio':
							radio = input.is(':checked') ? 1 : 0;

							// Only checked if the radio is selected, means that is the value
							if (radio) {
								value = input.val();
							}

						break;
						case 'checkbox':
							checkbox = input.is(':checked');

							if (checkbox) {
								value.push(input.val());
							}

						break;
						case 'button':
							// since button is not really an input, we need to check the hidden field instead
							var parent = input.parent();
							var inputButton = parent.find('input');

							if (inputButton.attr('type') == 'hidden') {
								value = inputButton.val();
							}
						break;
						default:
							if (input.val()) {
								value = input.val();
							}
						break;
					}
				}
			})
		}

		if ($.isArray(value)) {
			$.each(value, function(key, data) {
				result = result ? result + ' ' + data : data;
			})
		} else {
			result = value;
		}

		return result;
	},

	showSelf: function() {
		base.removeClass('t-hidden');
		base.trigger('onFieldShow');

		// Activate required field
		self.updateRequiredChecking(true);
	},

	hideSelf: function() {
		base.addClass('t-hidden');
		base.trigger('onFieldHide');

		// Disabled required field since the field is not visible on the form
		self.updateRequiredChecking(false);
	},

	updateRequiredChecking: function(operation) {
		// Get current required value
		var data = self.getRequiredChecking();

		if (data) {
			data[opts.id] = operation;
			data = JSON.stringify(data);

			$('[data-conditional-check]').val(data);
		}
	},

	isAutocomplete: function(key) {
		if (self.getTargetedFieldElement(key) == 'autocomplete') {
			return true;
		}

		return false;
	},

	getTargetedField: function(key) {
		var field = $('[data-field-item][data-id="' + opts.fieldTargeted[key] + '"]');

		return field;
	},

	getTargetedFieldElement: function(key) {
		var field = self.getTargetedField(key);
		return field.data('fieldItem');
	},

	formatValue: function(value, key) {

		var fieldElement = self.getTargetedFieldElement(key);

		var defaultGender = ["1", "2", "3"];

		// We check for gender male = 1 and female = 2 value
		if (fieldElement == 'gender' && value && $.inArray(value, defaultGender) >= 0) {
			value = value == "1" ? "male" : value == "3" ? "other" : "female";
		}

		return value;
	},

	formatConditionsValue: function(key) {
		var fieldElement = self.getTargetedFieldElement(key);

		// Properly check for gender value
		if (fieldElement == 'gender') {
			if (opts.conditionValue[key] == "1") {
				opts.conditionValue[key] = 'male';
			}

			if (opts.conditionValue[key] == "2") {
				opts.conditionValue[key] = 'female';
			}

			if (opts.conditionValue[key] == "3") {
				opts.conditionValue[key] = 'other';
			}
		}
	}
}});

module.resolve();
});
			EasySocial.module('shared/fields/validate', function ($) {

var module = this;
var isController = $.isController('EasySocial.Controller.Validator');

if (isController) {
	return;
}

EasySocial.Controller('Validator', {
	defaultOptions: {
		mode: null,
		checks: ['required', 'validate'],

		typeAttr: 'data-check-type',
		formatAttr: 'data-check-format',
		modifierAttr: 'data-check-modifier',
		errorTrigger: 'onError',
		submitTrigger: 'onSubmit',

		fieldSelector: '',

		'{container}': '[data-check]',
		'{notice}': '[data-check-notice]',
		'{required}': '[data-check-required]',
		'{validate}': '[data-check-validate]',
	}
}, function(self, opts) { return {
		// temporary variables
		vars: {},

		// Temporarily stored parents of containers
		parents: {},

		// register of elements returned by fields
		register: [],

		// deferreds return by elements
		deferreds: [],

		// errors return by elements
		errors: [],

		// state of validator
		state: $.Deferred(),

		init: function () {

		},

		reset: function() {
			self.vars = {};
			self.parents = {};

			self.register = [];
			self.deferreds = [];
			self.errors = [];

			self.state = $.Deferred();

			self.container().removeClass('error');
		},

		start: function() {
			self.reset();

			$.each(self.container(), function(i, container) {

				self.vars.container = container = $(container);
				self.parents.container = self.vars.container.parents(opts.fieldSelector);

				// Skip the checking for conditional field that are hidden from the form
				if (self.parents.container.data('isconditional') == "1" && self.parents.container.hasClass('t-hidden')) {
					return true;
				}

				container.trigger(self.options.submitTrigger, [self.register, self.options.mode]);

				$.each(self.getFields(), function(j, field) {
					self.vars.field = field = $(field);

					$.each(self.options.checks, function(i, check) {
						self.vars.check = check;

						self[check + 'Check']();
					});
				});
			});

			$.each(self.register, function(i, result) {
				if($.isDeferred(result)) {
					self.deferreds.push(result);
				} else if($.isPlainObject(result)) {
					$.each(result, function(key, value) {
						if(value === false) {
							self.errors.push(i);
							return true;
						}
					})
				} else {
					if(result === false) {
						self.errors.push(i);
						return true;
					}
				}
			});

			// If have static errors, then reject state
			if(self.errors.length > 0) {
				self.state.reject();
			} else {
				// If no static errors, then check if have deferreds
				if(self.deferreds.length > 0) {
					// This is because $.when accepts n amount of parameters instead of array, so we use .apply to pass in the array
					$.when.apply(null, self.deferreds)
						.done(function() {
							self.state.resolve();
						})
						.fail(function() {
							self.state.reject();
						});
				} else {
					// If no deferreds, then just resolve
					self.state.resolve();
				}
			}

			return self.state;
		},

		getFields: function() {
			return $.merge(self.vars.container.find(self.required.selector), self.vars.container.find(self.validate.selector));
		},

		requiredCheck: function() {
			if(self.vars.field.is(self.required.selector)) {
				var fieldType = self.vars.field.attr(self.options.typeAttr) || self.vars.field.attr('type') || 'text';

				if(fieldType === 'text' && $.trim(self.vars.field.val()) == '' ) {
					self.raiseError();
				}

				if(fieldType === 'checkbox' && self.vars.field.find('input[type="checkbox"]').filter(':checked').length < 1) {
					self.raiseError();
				}
			}
		},

		validateCheck: function() {
			if(self.vars.field.attr(self.options.formatAttr) !== undefined) {

				var value = self.vars.field.val();

				if($.isEmpty(value)) {
					return;
				}

				var format = self.vars.field.attr(self.options.formatAttr) || '';

				var modifier = self.vars.field.attr(self.options.modifierAttr) || '';

				var regex = new RegExp(format, modifier);

				if(!regex.test(value)) {
					self.raiseError();
				}
			}
		},

		raiseError: function () {
			self.vars.container.addClass('has-error');

			self.vars.container.trigger(self.options.errorTrigger, [self.vars.check, self.vars.field]);

			self.register.push(false);
		}
	};
});

// Apply $('xxx').validate
$.fn.validate = function(options) {
	var element = this;

	if (element.length > 0) {
		var controller = this.addController("EasySocial.Controller.Validator", options);

		return controller.start();
	}

	return false;
};

module.resolve();
});
			EasySocial.module('shared/popdown', function($){

var module = this;

$(document)
	.on('click.data.popdown', '[data-popdown-option]', function(event) {
		
		event.preventDefault();

		var option = $(this);
		var optionHtml = option.find('>a').html();
		var tmpl = $(optionHtml).clone();

		var popdown = option.parents('[data-popdown]');
		var value = option.data('popdown-option');
		var active = popdown.find('[data-popdown-active]');
		var input = popdown.find('input[type=hidden]');

		// Set the current option as active
		popdown.find('[data-popdown-option]').removeClass('active');
		option.addClass('active');

		active.html(tmpl);
		input.val(value);
	});



module.resolve();
});
			EasySocial.module("shared/privacy", function($){

var module	= this;

EasySocial.require()
.library("textboxlist")
.done(function($) {

	// Implement privacy button upon clicking on the button
	$(document).on('click.es.privacy',  '[data-es-privacy-form]', function() {

		var button = $(this);
		var controller = "EasySocial.Controller.Privacy.Form";

		// If controller is already implemented on the button, just skip implementation
		if (button.hasController(controller)) {
			return;
		}

		// Run the toggle.
		button.addController(controller).toggle();
	});

	EasySocial.Controller('Privacy.Form', {
		defaultOptions: {
			// The anchor button
			"{button}": "[data-privacy-toggle]",

			"{menu}": "[data-privacy-menu]",
			"{item}": "[data-privacy-menu] > [data-item]",

			// Display
			"{icon}": "[data-privacy-toggle] > [data-privacy-icon]",
			"{label}": "[data-privacy-toggle] > [data-label]",
			"{tooltip}": "[data-original-title]",
			"{key}": "[data-privacy-hidden]"
		}
	}, function(self, opts) { return {

		init: function() {

			// Get the save mode
			opts.mode = self.element.data('mode');

			self.instanceId = $.uid();
			self.addPlugin("custom");
			self.addPlugin("field");
		},

		getData: function(item) {
			var data = $._.pick(item.data(), "uid", "type", "value", "pid", "streamid", "pitemid", "userid");

			data.icon = item.data('privacy-icon');
			data.label = item.find('[data-label]').text();

			return data;
		},


		toggle: function() {

			var isActive = self.element.hasClass("active");
			self[(isActive) ? "deactivate" : "activate"]();
		},

		activate: function() {

			self.element.addClass("active");

			self.trigger("activate", [self]);
			$(window).trigger("activatePrivacy", [self]);

			var windowClick = "click.privacy." + self.instanceId;

			$(document).on(windowClick, function(event){

				var clickedTarget = $(event.target);

				// Don't do anything if we're clicking ourself
				if (clickedTarget.parents().andSelf().filter(self.element).length > 0
					|| clickedTarget.parents('[data-textboxlist-autocomplete]').length > 0
					|| clickedTarget.parents('[data-textboxlist-item]').length > 0 )
				{
					return;
				}

				$(document).off(windowClick);
				self.deactivate();
			});
		},

		deactivate: function() {
			// Remove active class
			self.element.removeClass("active");

			self.trigger("deactivateAllPrivacy", [self]);
			$(window).trigger("deactivatePrivacy", [self]);
		},

		save: function(data) {

			// Set privacy value
			self.key().val(data.value);

			// Update the display
			self.icon().attr("class", data.icon);
			self.label().html(data.label);

			// Trigger save event
			self.trigger("privacySave", [data]);

			// If saving is done via ajax, save now.
			if (opts.mode == "ajax") {
				EasySocial.ajax("site/controllers/privacy/update", {
					uid 	: data.uid,
					utype	: data.type,
					value 	: data.value,
					pid 	: data.pid,
					custom 	: data.custom,
					field	: data.field,
					streamid: data.streamid,
					userid	: data.userid,
					pitemid	: data.pitemid
				}).done(function(tooltips){
					// Update the tooltip for ajax mode
					if (tooltips) {
						self.element.attr('data-original-title', tooltips);
						self.element.tooltip();
					}
				});
			}
		},

		"{self} click" : function(el, event) {

			var target = $(event.target);
			var button = self.button();

			// If the area being clicked is within the toggle button, we should display the options
			if (target.parents().andSelf().filter(button).length > 0) {
				self.toggle();
			}
		},

		"{item} click" : function(item) {

			// Retrieve data from this privacy item
			var data = self.getData(item);

			// Trigger privacy changed event
			self.trigger("privacyChange", [data]);

			if (!data.preventSave) {

				self.save(data);
				self.deactivate();
			}
		},

		"{self} privacyChange": function(el, event, data) {

			// Deactivate other privacy item
			self.item().removeClass("active");
			self.item('[data-value=' + data.value + ']').addClass('active');
		},

		"{window} activatePrivacy": function(el, event, instance) {
			if (instance!==self) {
				self.deactivate();
			}
		}
	}});


	EasySocial.Controller("Privacy.Form.Custom", {
		defaultOptions: {
			"{textField}" : "[data-textfield]",
			"{saveButton}": "[data-save-button]",
			"{cancelButton}": "[data-cancel-button]",
			"{customItem}": "[data-item][data-value=custom]",
			"{customKey}": "[data-privacy-custom-hidden]",
			"{notice}": "[data-privacy-custom-notice]"
		}
	}, function(self) { return {

		init: function() {

			self.textField()
				.textboxlist({
					component: 'es',
					unique: true,
					plugin: {
						autocomplete: {
							exclusive: true,
							minLength: 1,
							cache: false,
							query: function(keyword) {
								var users = self.getIds();
								var ajax = EasySocial.ajax("site/views/privacy/getfriends", {
															"q": keyword,
															"exclude": users
											});

								return ajax;
							}
						}
					}
				});

			self.textboxlist = self.textField().controller("TextboxList");
		},

		getIds: function() {

			var items = self.textField().textboxlist("controller").getAddedItems();

			return $.map(items, function(item, idx) {
				return item.id;
			});
		},

		updateIds: function() {

			// lets update the notice message.
			if (!self.notice().hasClass('t-hidden')) {
				self.notice().addClass('t-hidden');
			}

			var ids = self.getIds();
			self.customKey().val(ids.join(","));
		},

		"{parent} privacyChange": function(el, event, data) {

			var isCustomPrivacy = (data.value=="custom");

			self.element.toggleClass("custom-privacy", isCustomPrivacy);

			// If user no longer selects custom privacy
			if (!isCustomPrivacy) {

				// Clear any existing custom privacy
				self.textField()
					.textboxlist("controller")
					.clearItems();
			} else {

				// Prevent privacy from saving
				data.preventSave = true;
			}
		},

		"{parent} privacySave": function(el, event, data) {
			// for now do nothing.
		},

		"{parent} deactivateAllPrivacy": function(el, event) {
			self.textboxlist.autocomplete.hide();
		},

		"{cancelButton} click" : function(){
			self.element.removeClass("custom-privacy");
			self.textboxlist.autocomplete.hide();
		},

		"{saveButton} click" : function(){

			var parent = self.parent;
			var customItem = self.customItem();
			var data = parent.getData(customItem);
			var value = self.customKey().val().trim();

			if (value == "") {
				self.notice().removeClass('t-hidden');
				return false;
			}

			data.custom = value;

			self.parent.save(data);
			self.parent.deactivate();
		},

		// event listener for adding new name
		"{textField} addItem": function() {
			self.updateIds();
		},

		// event listener for removing name
		"{textField} removeItem": function() {
			self.updateIds();
		}
	}});

	EasySocial.Controller("Privacy.Form.Field", {
		defaultOptions: {
			"{saveButton}": "[data-save-button]",
			"{cancelButton}": "[data-cancel-button]",
			"{fieldItem}": "[data-item][data-value=field]",
			"{fieldKey}": "[data-privacy-field-hidden]",
			"{inputs}": "[data-privacy-field-inputs]",
			"{notice}": "[data-privacy-field-notice]"
		}
	}, function(self) { return {

		init: function() {

		},

		updateIds: function() {

			var ids = self.getIds();
			self.customKey().val(ids.join(","));
		},

		"{parent} privacyChange": function(el, event, data) {

			var isFieldPrivacy = (data.value=="field");

			self.element.toggleClass("field-privacy", isFieldPrivacy);

			// If user no longer selects custom privacy
			if (isFieldPrivacy) {

				// Prevent privacy from saving
				data.preventSave = true;
			}
		},

		"{parent} privacySave": function(el, event, data) {
			// for now do nothing.
		},

		"{parent} deactivateAllPrivacy": function(el, event) {
			// for now do nothing.
		},

		"{cancelButton} click" : function(){

			self.notice().addClass('t-hidden');
			self.element.removeClass("field-privacy");
		},

		"{saveButton} click" : function(){

			var parent = self.parent;
			var fieldItem = self.fieldItem();
			var data = parent.getData(fieldItem);

			var hasValue = false;
			var tmp = [];

			self.inputs().each(function(idx, ele) {
				var select = $(ele);
				var key = select.attr('name');
				var values = select.val();

				if (values) {
					hasValue = true;
					key = key + '|' + values.join(',');
					tmp.push(key);
				}
			});

			if (! hasValue) {
				self.notice().removeClass('t-hidden');
				return false;
			}

			var value = tmp.join(';');
			data.field = value;

			self.parent.save(data);
			self.parent.deactivate();
		}
	}});

	module.resolve();
});

});
			EasySocial.module('shared/responsive', function($){

var module = this;

$(document)
	.on('click.es.sidebar.toggle', '[data-es-sidebar-toggle]', function() {
		// Locate the closest container
		var button = $(this);
		var container = button.siblings('[data-es-container]');

		if (container.length <= 0) {
			return;
		}

		container.toggleClass('sidebar-open');
	});

$(document).on("click.es.sidebar", "[data-sidebar-toggle]", function(){

	// Prefer sidebar from siblings
	var button = $(this);
	var selector = "[data-sidebar]";
	var sidebar = button.siblings(selector);

	// If not find closest sidebar
	if (sidebar.length < 1) {
		sidebar = button.closest(selector);
	}

	// If not find any sidebar
	if (sidebar.length < 1) {
		sidebar = $(selector);
	}

	sidebar
		.toggleClass("sidebar-open")
		.trigger("sidebarToggle");

});


// Simulate the responsive toggle button click.
$(document).on("onEasySocialFilterClick", function(){

	// lets check if this is viewing with mobile app or not. if yes, we
	// do not process further.
	var mobileWrappr = $("[data-es-mobile-wrapper]");
	if (mobileWrappr.length > 0) {
		return;
	}

	var container = $("[data-es-sidebar-toggle]").siblings('[data-es-container]');

	if (container.length <= 0) {
		return;
	}

	if (container.hasClass('sidebar-open')) {
		container.removeClass('sidebar-open');
	}
});



module.resolve();

});
			EasySocial.module('shared/sidebarmenu', function($) {

var module = this;
var isController = $.isController('EasySocial.Controller.Sidebarmenu');

if (isController) {
	return;
}

EasySocial.Controller('Sidebarmenu', {
	defaultOptions: {
		mainmenu: null,
		viewOpenClass: 'dl-subviewopen',
		subViewClass: 'dl-subview',
		animate: true,
		"{subMenuLink}" : "[data-submenu-link]",
		"{subMenuBack}" : "[data-submenu-back]"
	}
}, function(self, opts, base) { return {
	
	init: function() {
	},

	open: function(element) {
		var parent = element.parent('li');
		var submenu = parent.children('ul');

		self.animate('open', submenu).done(function() {

			// Change all of the dl-subviewopen to dl-subview first
			base.find('.dl-subviewopen').addClass(opts.subViewClass).removeClass(opts.viewOpenClass);

			parent.removeClass(opts.subViewClass).addClass(opts.viewOpenClass);
		});
	},

	close: function(submenu) {
		var parent = submenu.parent('li');
		parent.removeClass(opts.viewOpenClass);

		var main = parent.parent('ul');
		main.parent('li').removeClass(opts.subViewClass).addClass(opts.viewOpenClass);

		self.animate('close', submenu, main).done(function() {

			if (main.attr('data-sidebar-menu') !== undefined) {
				main.removeClass(opts.subViewClass);
			}
		});
	},

	animate: function(operation, submenu, main) {

		if (main !== undefined && main.attr('data-sidebar-menu') !== undefined) {
			base.removeClass(opts.subViewClass);
		}

		// Simulate the opposite effect
		if (opts.animate) {
			var dfd1 = $.Deferred(),
				dfd2 = $.Deferred();

			operation1 = operation == 'open' ? 'out' : 'in';
			operation2 = operation == 'open' ? 'in' : 'out';

			var subMenuClone = submenu.clone();

			subMenuClone.find('ul').remove();
			base.after(subMenuClone);
			base.addClass('dl-animate-' + operation1 + '-1');

			// Wait 0.3 second
			setTimeout(function() {
				base.addClass(opts.subViewClass).removeClass('dl-animate-' + operation1 + '-1');

				dfd1.resolve();
			}, 300);

			// Sub menu transition
			subMenuClone.addClass('dl-animate-' + operation2 + '-1');

			if (operation2 == 'in') {
				subMenuClone.css('opacity', '0');
			}

			// Wait 0.3 second
			setTimeout(function() {
				subMenuClone.removeClass('dl-animate-' + operation2 + '-1');
				subMenuClone.remove();

				dfd2.resolve();
			}, 300);

			// Return when the animation is finished
			return $.when(dfd1, dfd2).done(function() {
			}).promise();
		} else {
			var dfd = $.Deferred();

			base.addClass(opts.subViewClass);

			dfd.resolve();

			return dfd;
		}
	},

	"{subMenuLink} click": function(element, event) {
		event.preventDefault();
		event.stopPropagation();

		// Open submenu
		self.open(element);
	},

	"{subMenuBack} click": function(element, event) {
		event.preventDefault();
		event.stopPropagation();

		var parent = element.parent('ul');

		// Close submenu
		self.close(parent);
	},
}});

module.resolve();
});			EasySocial.module( 'uploader/item' , function($){

	var module 	= this;

	EasySocial.require()
	.view( 'site/uploader/preview' )
	.done( function($){

		EasySocial.Controller(
			'Uploader.Item',
			{
				defaults:
				{
					"{uploadItem}" : ".uploadItem",
					"{uploadItemPreview}" : ".uploadItem.preview a.itemLink",

					// Actions
					"{itemLink}"		: '.itemLink',
					"{itemDelete}"		: '.itemDelete',

					view: {

						preview : 'site/uploader/preview'

					}
				}
			},
			function( self ){ return {

				init: function(){

				},

				"{itemDelete} click": function( el ){

					var id 		= $( el ).data( 'id' );

					EasySocial.ajax( 'site:/controllers/uploader/delete' , {
						'id'	: id
					}, function(){

						// Remove the item from the list
						$( el ).parents( 'li.uploadItem' ).remove();
					})
				},

				"{uploadItemPreview} click" : function( el ){

					var uri 	= $( el ).data( 'uri' ),
						title 	= $( el ).data( 'title' );

					$.dialog({
						title: title,
						content: $.Image.get(uri)
					});





					// $.dialog({
					// 	'title'		: title,
					// 	'content'	: content,
					// 	afterShow	: function(){

					// 		$.dialog().update();

					// 	}
					// });
				}

			} }
		);
	});

	module.resolve();
});
			EasySocial.module('uploader/queue', function($){

var module = this;

EasySocial.require()
.done(function($){

	EasySocial.Controller('Uploader.Queue', {
		defaults: {
				"{item}": "[data-uploaderQueue-item]"
			}
		}, function(self) {

			return {
				init: function() {
					self.item().implement(EasySocial.Controller.Uploader.Queue.Item);
				}
			}
		}
	);

	EasySocial.Controller( 'Uploader.Queue.Item', {
		defaultOptions: {
			"{delete}"	: "[data-uploaderQueue-remove]",
			"{progress}": "[data-uploaderQueue-progress]",
			"{progressBar}" : "[data-uploaderQueue-progressBar]",
			"{status}"		: "[data-uploaderQueue-status]",
			"{id}"			: "[data-uploaderQueue-id]"
		}
	}, function(self, opts) { return {
		
		init : function() {

			// Store it as template and remove it
			if (self.uploader.options.temporaryUpload) {
				self.idTemplate = self.id().toHTML();
				self.id().remove();
			}
		},

		"{delete} click": function() {
			self.uploader.removeItem( self.element.attr( 'id' ) );
		},

		"{self} FileUploaded": function(el, event, file, response) {

			if (self.uploader.options.temporaryUpload) {
				// Create a hidden input containing the id
				$.buildHTML(self.idTemplate)
					.val(response.id)
					.appendTo(self.element);
			}

			if (file.status == 5) {
				self.element.removeClass("is-queue").addClass( 'is-done' );
			}
		},

		"{self} UploadProgress": function(el, event, progress) {

			self.status().html(progress.percent + '%');
			self.progressBar().css('width' , progress.percent + '%');
		},

		"{self} FileError": function() {
			self.element.removeClass("is-done is-queue").addClass("is-error");

			self.progress()
				.removeClass("progress-danger progress-success progress-info progress-warning")
				.addClass("progress-danger");

			self.status().html('Error');
		}
	}});

	module.resolve();
});

});
			EasySocial.module('uploader/uploader', function($){

var module = this;

EasySocial.require()
.library('plupload')
.script('uploader/queue')
.done(function() {

EasySocial.Controller('Uploader', {
	defaults: {

		url: $.indexUrl + '?option=com_easysocial&controller=uploader&task=uploadTemporary&format=json&tmpl=component&' + EasySocial.token() + '=1',
		uploaded: [],

		// Allows caller to define their custom query.
		query: "",

		plupload: '',
		dropArea: 'uploaderDragDrop',
		extensionsAllowed: 'jpg,jpeg,png,gif',

		// Determines if we should upload the file first or not
		temporaryUpload: false,

		// Contains a list of files in the queue so others can manipulate this.
		files: [],

		'{uploaderForm}': '[data-uploader-form]',
		'{uploadButton}': '[data-uploader-browse]',
		'{uploadArea}': '.uploadArea',

		// This contains the file list queue.
		'{queue}': '[data-uploaderQueue]',

		// The queue item.
		'{queueItem}': '[data-uploaderQueue-item]',

		// When the queue doesn't have any item, this is the container.
		'{emptyFiles}': '[data-uploader-empty]',

		// This is the file removal link.
		'{removeFile}': '[data-uploaderQueue-remove]',
		'{uploadCounter}': '.uploadCounter',
	}
}, function(self, opts, base) { return {

	init: function(){

		// Implement the uploader queue.
		self.queue().implement(EasySocial.Controller.Uploader.Queue);

		if (opts.temporaryUpload) {
			opts.url = $.indexUrl + '?option=com_easysocial&controller=uploader&task=uploadTemporary&format=json&tmpl=component&' + EasySocial.token() + '=1';
		}

		if (opts.query != '') {
			opts.url = opts.url + '&' + opts.query;
		}

		// Implement the plupload controller on the upload form
		self.uploaderForm().implement('plupload', {
			settings: {
				url: opts.url,
				drop_element: opts.dropArea,
				filters: [{
					title: 'Allowed File Type',
					extensions: opts.extensionsAllowed
				}]
			},
			'{uploader}': '[data-uploader-form]',
			'{uploadButton}': '[data-uploader-browse]'
		}, function() {
			// Get the plupload options
			opts.plupload = this.plupload;
		});
	},


	createFileItem: function(files) {

		$.each(files, function(index, file) {

			if (self.getItem(file)) {
				return;
			}

			// Get the file size.
			file.size = self.formatSize(file.size);

			var queueTemplate = $('[data-uploaderQueue-item-template]');
			var content = queueTemplate.clone();

			content.removeClass('t-hidden');

			content.removeAttr('data-uploaderQueue-item-template');
			content.attr('id', file.id);
			content.find('[data-filename]').text(file.name);
			content.find('[data-filesize]').text(file.size);

			// Implement the queue item controller.
			$(content).implement(EasySocial.Controller.Uploader.Queue.Item, {
				"{uploader}": self
			});

			// Keep a copy of the item in our registry
			self.items[file.id] = content;

			// Add this item into our own queue.
			opts.files.push(file);

			// Hide the "No files" value
			self.emptyFiles().hide();

			// Append the queue item into the queue
			self.queue().append(content);
		});
	},

	/**
	 * Formats the size in bytes into kilobytes.
	 */
	formatSize: function(bytes) {

		// @TODO: Currently this only converts bytes to kilobytes.
		var val = parseInt( bytes / 1024 );

		return val;
	},

	// Remove the item from the list.
	reset: function() {

		// self.queueItem().remove();
		$("[data-uploaderQueue-item].is-done").remove();
	},

	removeItem: function(id) {
		var element = $('#' + id);

		// When an item is removed, we need to send an ajax call to the server to delete this record
		var uploaderId = $(element).find('input[name=upload-id\\[\\]]').val();

		element.remove();

		if (!uploaderId) {
			self.options.plupload.removeFile(self.options.plupload.getFile(id));

			return;
		}

		EasySocial.ajax('site/controllers/uploader/delete' , { "id" : uploaderId })
		.done(function() {
			// Now remove the item from the plupload queue.
			self.options.plupload.removeFile( self.options.plupload.getFile( id ) );
		});

		delete self.items[id];
	},

	startUpload: function() {
		self.upload();
	},

	upload: function() {

		if (self.options.plupload.files.length > 0) {
			self.options.uploading 	= true;
			self.options.plupload.start();
		}
	},

	 hasFiles: function(){
		return self.options.files.length > 0;
	 },

	"{uploaderForm} FilesAdded": function(el, event, uploader, files ) {
		// Add a file to the queue when files are selected.
		self.createFileItem(files);

		// Begin the upload immediately if needed
		if (opts.temporaryUpload) {
			self.startUpload();
		}
	},

	items: {},

	getItem: function(file) {
		var id;

		// By id
		if ($.isString(file)) {
			id = file;
		}

		// By file object
		if (file && file.id) {
			id = file.id;
		}

		return self.items[id];
	},

	"{uploaderForm} UploadProgress" : function(el, event, uploader, file) {
		if (file) {
			self.queueItem('#' + file.id)
				.trigger('UploadProgress', file);
		}

	},

	'{uploaderForm} FileUploaded' : function( el , event, uploader, file , response ){
		self.queueItem('#' + file.id)
			.trigger('FileUploaded', [file , response]);
	},

	"{uploaderForm} UploadComplete" : function(el, event , uploader , files) {
		self.options.uploading 	= false;
	},

	'{uploaderForm} Error': function(el, event, uploader, error) {
		// Clear previous message
		self.clearMessage();

		var obj = { 'message' : error.message , 'type' : 'error' };

		self.setMessage( obj );
	},

	'{uploaderForm} FileError': function(el, event, uploader, file, response) {
		var obj = { 'message' : response.message , 'type' : 'error' };

		self.setMessage(obj);

		self.queueItem( '#' + file.id ).trigger('FileError', [file, response]);
	}
}});

module.resolve();

});


});
			EasySocial.module('site/activities/default', function($){

var module  = this;

EasySocial.Controller('Activities', {
	defaultOptions: {
		// Properties
		items : null,

		// Elements
		"{container}" : "[data-activities]",

		// Wrapper and content
		"{wrapper}": "[data-wrapper]",
		"{contents}": "[data-contents]",
		"{contentTitle}": "[data-activities-content-title]",

		"{sidebar}" : "[data-sidebar]",
		"{sidebarItem}" : "[data-sidebar-item]",

		// lists
		"{list}": "[data-activities-list]",

		// Single item
		"{item}": "[data-activity-item]",
		"{itemContent}" : "[data-activity-content]",
		"{toggle}" : "[data-toggle]",
		"{delete}" : "[data-delete]",

		// hidden apps
		"{appItem}": "[data-hidden-app-item]",
		"{appContent}" : "[data-hidden-app-content]",
		"{unhideApp}" : "[data-hidden-app-unhide]",

		// hidden actor
		"{actorItem}": "[data-hidden-actor-item]",
		"{actorContent}" : "[data-hidden-actor-content]",
		"{unhideActor}" : "[data-hidden-actor-unhide]",


		// pagination
		"{pagination}" : "[data-pagination]",

	}
}, function(self, opts){ return {

	clicked: false,

	"{sidebarItem} click": function(item, event) {

		// Prevent event from bubbling up
		event.preventDefault();
		event.stopPropagation();

		// Get the attributes of the item
		var type = item.data('type');
		var id = item.data('id');

		// Prevent clicking any items more than once
		if (self.clicked) {
			return;
		}

		self.clicked = true;

		// Route the anchor links embedded
		var anchor = item.find('> .o-tabs__link');

		anchor.route();

		// Notify the dashboard that it's starting to fetch the contents.
		self.updatingContents();

		// Set the active filter
		self.setActiveFilter(item);

		// Remove empty state
		self.wrapper().removeClass('is-empty');

		self.getItems(type, function() {
			self.clicked = false;
			item.removeClass('is-loading');
		});
	},

	getItems: function(type, callback) {
		EasySocial.ajax( 'site/controllers/activities/getActivities', {
			"type": type,
		}).done(function(contents, count) {

			if ($.isFunction(callback)) {
				callback.call(this, contents, count);
			}

			if (count == 0) {
				self.wrapper().addClass('is-empty');
			}

			// Update the contents of the dashboard area
			self.updateContents(contents);

		}).fail(function(message) {
			return message;
		});
	},

	setActiveFilter: function(item) {

		// Set active state
		self.sidebarItem().removeClass('active');
		item.addClass('active');

		// Add loading indicator
		item.addClass('is-loading');
	},

	updatingContents: function() {
		// When this method is invoked, clear the contents and add a loading indication
		self.contents().empty();
		self.wrapper().addClass('is-loading');
	},

	updateContents: function(contents) {
		self.wrapper().removeClass("is-loading");

		// Hide the content first.
		$.buildHTML(contents)
			.appendTo(self.contents());
	},


	// for single activity item
	getItem: function(element) {
		var item = element.closest(self.item.selector);
		return item;
	},


	"{toggle} click" : function(button, event) {
		var item = self.getItem(button);

		var id = item.data('id');
		var curState = item.data('current-state');

		EasySocial.ajax('site/controllers/activities/toggle', {
			"id" : id,
			"curState" : curState
		}).done(function(isHidden, message) {
			item.data('current-state', isHidden);

			var content = button.closest(self.itemContent.selector);
			// we need to hide the item when:
			//  from normal item to hidden,
			//  from hidden item to show.
			//  both scenario will have to hide the content.
			content.html(message);
		});
	},

	"{delete} click" : function(button, event) {

		var item = self.getItem(button);
		var id = item.data('id');

		EasySocial.dialog({
			content : EasySocial.ajax('site/views/activities/confirmDelete'),
			bindings :
			{
				"{deleteButton} click" : function() {
					EasySocial.ajax('site/controllers/activities/delete', {
						"id" : id,
					})
					.done(function(html) {
						item.fadeOut();

						// close dialog box.
						EasySocial.dialog().close();
					});
				}
			}
		});

	},

	"{pagination} click" : function() {
		self.loadMore();
	},

	loadMore: function() {

		var type = self.pagination().data('type');
		var startlimit = self.pagination().data('startlimit');

		if (startlimit == '') {
			self.pagination().remove();
			return;
		}

		self.loading = true;
		self.pagination().addClass('is-loading');

		EasySocial.ajax( 'site/controllers/activities/getActivities', {
			"limitstart" : startlimit,
			"loadmore" : '1',
			"type" : type
		}).done(function(contents, startlimit) {
			// update next start date
			self.pagination().data('startlimit', startlimit);

			var contents = $.buildHTML(contents);

			contents
				.appendTo(self.list());

			if (startlimit=="") {
				self.pagination().remove();
			}

		}).always(function(){
			self.pagination().removeClass('is-loading');
			self.loading = false;
		});
	},

	// for hidden apps
	"{unhideApp} click": function(button, event) {
		var item = button.closest(self.appItem.selector);

		EasySocial.ajax('site/controllers/activities/unhideapp', {
			"context" : item.data('context'),
			"id" : item.data('id')
		}).done(function(message) {
			var content = button.closest(self.appContent.selector);
			content.html(message);
		});
	},

	"{unhideActor} click": function(button, event) {
		var item = button.closest(self.actorItem.selector);

		EasySocial.ajax('site/controllers/activities/unhideactor', {
			"actor" : item.data('actor'),
			"id" : item.data('id')
		}).done(function(message) {
			var parent = button.parents(self.actorItem);
			var content = parent.find(self.actorContent.selector);

			content.html(message);

			button.remove();
		});
	}


}});

module.resolve();
});
			EasySocial.module('site/activities/filter', function($) {

var module = this;

EasySocial.require()
.script('site/activities/default')
.done(function($) {

EasySocial.Controller('Activities.Filter', {
	defaultOptions: {
		"{listController}": "[data-es-structure] [data-activities]",
		"{filter}": "[data-es-activities-filters] [data-sidebar-item]",
	}
}, function(self, opts) { return {

	getController: function() {
		var controller = self.listController().controller();

		return controller;
	},

	setActiveFilter: function(filter) {
		self.filter().removeClass('active');

		filter.addClass('active');

		// Update the URL on the browser
		filter.find('a').route();

		// Set loading on the correct filter
		filter.addClass('is-loading');
	},

	"{filter} click": function(filter, event) {

		var controller = self.getController();

		if (controller === undefined) {
			return;
		}

		event.preventDefault();
		event.stopPropagation();

		var filterType = filter.data('type');

		// Set active filter state
		self.setActiveFilter(filter);
		controller.setActiveFilter(filter);

		// Notify the dashboard that it's starting to fetch the contents.
		controller.updatingContents();

		// Fetch the items
		controller.getItems(filterType, function() {
			filter.removeClass('is-loading');
		});
	}
}});

module.resolve();

});

});
			EasySocial.module("site/albums/actions", function($){
var module = this;

// Load non essential dependencies
EasySocial.require()
.script("site/photos/item")
.done();

EasySocial.Controller("Albums.Actions", {
	hostname: "actions",

	defaultOptions: {
		"{photoItem}": "[data-photo-item]",
		"{imageLink}" : "[data-photo-image-link]",

		// Affix Header
		'{affix}': '[data-bs-spy=affix]',

		// Checkbox
		'{checkbox}': '[data-photo-item-checkbox]',
		'{checkAll}': '[data-photo-item-checkall]',

		// Actions button
		'{actionsWrapper}': '[data-photo-actions-wrapper]',
		'{actionsApply}': '[data-photo-actions-apply]',
		"{actionsTask}": '[data-photo-actions-task]'
	}
}, function(self, opts, base) { return {

	init: function() {
		self.albumId = base.data("album-id");

		// Calculate affix width
		self.updateHeader();

		$(window).resize(function() {
			self.updateHeader();
		});
	},

	updateHeader: function() {
		var width = self.element.width();
		var offset = self.affix().offset();

		self.affix()
			.css('width', width);

		// dynamically reset the top offset in affix
		self.affix().affix({
			offset: {
				top: offset.top - 20
			}
		});
	},

	getSelectedCheckbox: function() {
		var items = [];
		var selected = self.checkbox(':checked');

		selected.each(function(i, el) {
			items.push($(el).val());
		});

		return items;
	},

	"{self} afterLoadMore": function() {
		self.updateCheckboxSelection();
	},

	updateCheckboxSelection: function() {
		// Check if all checkbox is selected
		if (self.isAllCheckboxSelected()) {
			self.checkAll().prop('checked', true);
		} else {
			self.checkAll().prop('checked', false);
		}
	},

	isAllCheckboxSelected: function() {
		var totalSelected = self.getSelectedCheckbox().length;
		var totalCheckbox = self.checkbox().length;

		if (totalSelected == totalCheckbox) {
			return true;
		}

		return false;
	},

	clearSelectedCheckboxes: function() {
		self.checkAll().prop('checked', false);
		self.checkAll().trigger('change');
	},

	'{checkAll} change': function(input, event) {
		var checked = input.is(':checked');

		if (checked) {
			self.actionsWrapper().removeClass('t-hidden');
		} else {
			self.actionsWrapper().addClass('t-hidden');
		}

		self.checkbox().not(':disabled').prop('checked', checked);
		self.checkbox().not(':disabled').trigger('change');
	},

	"{checkbox} change" : function(input, event) {
		var selected = self.getSelectedCheckbox();
		var parent = input.parents(self.photoItem.selector);

		parent.removeClass('is-selected');

		// Check if all checkbox is selected
		self.updateCheckboxSelection();

		if (selected.length > 0) {
			self.actionsWrapper().removeClass('t-hidden');
			parent.addClass('is-selected');
			return;
		}

		self.actionsWrapper().addClass('t-hidden');
	},

	"{imageLink} click": function(image, event) {
		event.preventDefault();

		var parent = image.parents(self.photoItem.selector),
			checkbox = parent.find(self.checkbox.selector);

		checked = checkbox.is(':checked');

		checkbox.prop('checked', !checked);
		checkbox.trigger('change');
	},

	"{actionsApply} click": function(button, event) {
		var controllerTask = $.trim(self.actionsTask().val());

		if (controllerTask == '') {
			return false;
		}

		var confirmation = self.actionsTask().find(':selected').data('confirmation');

		// If there is no confirmation, just submit the form
		if (!confirmation) {
			self.taskInput().val(controllerTask);
			self.submitForm();

			return false;
		}

		// Get selected items
		var items = self.getSelectedCheckbox();

		EasySocial.dialog({
			"content": EasySocial.ajax(confirmation, {'ids': items, 'albumId': self.albumId, 'uid': opts.uid, 'type': opts.type}),
			"bindings": {
				"{submitButton} click": function(submitButton) {
					var dialog = this.parent;
					var submitButton = $(submitButton);
					var submitValue = '';

					// Get submitted value
					if (this.submitValue != undefined) {
						var submitValue = this.submitValue().val();
					}

					submitButton.disabled(true);

					var task = EasySocial.ajax(controllerTask, {
								"ids": items,
								"value": submitValue
							}).always(function() {
								dialog.close();
							});

					var trigger = self.actionsTask().find(':selected').data('trigger');

					if (trigger) {
						var total = items.length;

						$.each(items, function(idx, photoId) {

							// Get photo object
							var selector = $('[data-photo-item][data-photo-id=' + photoId + ']');
							var photo = selector.addController(EasySocial.Controller.Photos.Item);

							photo.trigger(trigger, [task, photo, true, submitValue]);

							// Trigger album pagination when all photos is deleted
							if (total - 1 === idx) {
								if (trigger == 'photoDelete' || trigger == 'photoMove') {
									photo.trigger('loadmore', [task, photo, total]);
								}
							}
						});
					}

					self.clearSelectedCheckboxes();
				}
			}
		});
	}
}});

module.resolve();

});
			EasySocial.module("site/albums/browser", function($){

var module = this;

EasySocial.Controller("Albums.Browser", {
	hostname: "browser",
	defaultOptions: {

		isMobile : false,

		itemRenderOptions: {},

		"{sidebar}" : "[data-album-browser-sidebar]",
		"{content}" : "[data-album-browser-content]",
		"{wrapper}" : "[data-wrapper]",

		"{createAlbumButton}" : "[data-album-create-button]",
		"{createAlbumButtonLink}" : "[data-album-create-button] > a",

		"{listItemGroup}" : "[data-album-list-item-group]",
		"{listItemRegularGroup}" : "[data-album-list-item-group=regular]",
		"{listItemCoreGroup}" : "[data-album-list-item-group=core]",

		// Sidebar items

		"{listItem}" : "[data-album-list-item]",
		"{listItemLink}" : "[data-album-list-item] > a",
		"{listItemTitle}" : "[data-album-list-item-title]",
		"{listItemCover}" : "[data-album-list-item-cover]",
		"{listItemCount}" : "[data-album-list-item-count]",

		"{albumItem}" : "[data-album-item]",

		"{photoBrowser}" : "[data-photo-browser]",
	}
},
function(self) { return {

	init: function() {
		// Attach existing album items as subscriber
		self.albumItem().each(function(){
			self.addSubscriber($(this).controller("EasySocial.Controller.Albums.Item"));
		});

		// Initialize back button
		toggleButton = $('.es-dialog-back-button');

		toggleButton.on('click.es.sidebar.toggle', function() {
			self.toggleSidebar();
		});
	},


	setLayout: function(layout) {

		// Don't switch layout on dialog.
		if (self.element.data("layout") == "dialog") return;

		self.element
			.data("layout", layout)
			.switchClass("layout-" + layout);
	},

	toggleSidebar: function() {

		// lets check if this is viewing with mobile app or not. if yes, we
		// do not process further.
		var mobileWrappr = $("[data-es-mobile-wrapper]");

		if (mobileWrappr.length > 0) {

			// Further check if the album is open via dialog browser
			if (self.element.data("layout") !== "dialog") {
				return;
			}
		}

		// Locate the closest container
		var container = $('[data-album-browser]');

		if (container.length <= 0) {
			return;
		}

		container
			.toggleClass('sidebar-open');

		// Toggle back button
		toggleButton.toggleClass('t-hidden');
	},

	open: function(view) {

		var args = $.makeArray(arguments);

		self.trigger("contentload", args);

		var method = "view" + $.String.capitalize(view);
		var loader = self[method].apply(self, args.slice(1));

		loader
			.done(self.displayContent(function(){
				// Open sidebar
				if (self.element.data("layout") == 'dialog') {
					self.toggleSidebar();
				}

				self.trigger("contentdisplay", args);
				return arguments;
			}))
			.fail(function(){
				self.trigger("contentfail", args);
			})
			.always(function(){
				self.trigger("contentcomplete", args);
			});

		return loader;
	},

	"{self} contentdisplay": function(el, event, view) {

		if (/album|albumform/gi.test(view)) {
			self.setLayout("album");
		}

		if (/photo/gi.test(view)) {
			self.setLayout("photo");
		}

		// remove the loading indicator
		self.wrapper().removeClass('is-loading');
	},

	displayContent: $.Enqueue(function(html){

		var scripts = [],
			content = $($.buildFragment([html], document, scripts));

		// Insert content
		self.content().html(content);

		// Remove scripts
		$(scripts).remove();
	}),

	viewAlbum: function(albumId) {

		// Remove loading indicator from any existing ones
		self.listItem().removeClass("active is-loading");

		var listItem = self.getListItem(albumId)
							.addClass("active is-loading");

		// Don't route if we're on dialog layout
		if (self.element.data("layout")!=="dialog") {
			listItem.find("> a").route();
		}

		var loader = EasySocial.ajax("site/views/albums/item", {
						"id": albumId,
						"renderOptions": self.options.itemRenderOptions
					})
					.always(function(){

						listItem.removeClass("is-loading");
					});

		return loader;
	},

	viewPhoto: function(photoId) {

		var loader =
			EasySocial.ajax("site/views/photos/item", {
					id: photoId,
					browser: 1
				})
				.fail(function(){
				})
				.always(function(){
				});

		return loader;
	},

	"{listItem} click": function(listItem, event) {

		event.preventDefault();
		event.stopPropagation();

		// Don't do anything on new album item
		if (listItem.hasClass("new")) {
			return;
		}

		var albumId = listItem.data("albumId");

		// Load album
		self.open("Album", albumId);

		// Trigger sidebar toggle for mobile apps view except dialog
		if (self.element.data("layout") !== "dialog") {
			$('body').trigger('afterUpdatingContents');
			self.toggleSidebar();
		}
	},

	"{listItemLink} click": function(listItemLink, event) {

		// Progressive enhancement, no longer refresh the page.
		event.preventDefault();

		// Prevent item from getting into :focus state
		listItemLink.blur();
	},

	"{createAlbumButton} click": function() {

		self.open("AlbumForm");

		// Don't route if we're on dialog layout
		if (self.element.data("layout")!=="dialog") {

			self.createAlbumButtonLink().route();
		}
	},

	"{createAlbumButtonLink} click": function(el, event) {

		event.preventDefault();
	},

	"{albumItem} init.albums.item": function(el, event, albumItem) {

		self.addSubscriber(albumItem);
	},

	getListItem: function(albumId, context) {

		var listItem =
			(!albumId) ?
				self.listItem(".new") :
				self.listItem().filterBy("albumId", albumId);

		if (!context) return listItem;

		return listItem.find(self["listItem" + $.String.capitalize(context)].selector);
	},

	updateListItemCount: function(albumId, val, append) {

		var stat = self.getListItem(albumId, "count");

		// If no stat element found, stop.
		if (stat.length < 0) return;

		// Get current stat count
		var statCount;

		if (append) {
			statCount = (parseInt(stat.text()) || 0) + (parseInt(val) || 0);
		} else {
			statCount = val;
		}

		// Always stays at 0 if less than that
		if (statCount < 0) statCount = 0;

		// Update stat count
		stat.text(statCount);
	},

	"{albumItem} albumSave": function(el, event, task) {
		task.done(function(album)
		{
			// For new albums
			// Remove item link's new state
			self.getListItem()
				.attr("data-album-id", album.id)
				.removeClass("new")

			// Update item link & route url
			self.getListItem(album.id)
				.find("> a")
				.attr({
					href : album.permalink,
					title: album.title
				})
				.route();

			// For existing albums
			self.getListItem(album.id, "title")
				.html(album.title);
		});
	},

	"{albumItem} titleChange": function(el, event, title, album) {

		self.getListItem(album.id, "title")
			.html($.trim(title) || "&nbsp;");
	},

	"{albumItem} coverChange": function(el, event, photo, album) {

		self.getListItem(album.id, "cover")
			.css("backgroundImage", $.cssUrl(photo.sizes.thumbnail.url));
	},

	"{albumItem} coverRemove": function(el, event, album) {

		self.getListItem(album.id, "cover")
			.css("backgroundImage", "");
	},

	"{albumItem} photoAdd": function(el, event, photoItem, photoData, album) {

		self.updateListItemCount(album.id, 1, true);
	},

	"{albumItem} photoMove": function(el, event, task, photo, batchAction, targetAlbumId) {

		task
			.done(function() {
				// Update current album count
				self.updateListItemCount(photo.album.id, -1, true);

				// Also update targetted album count
				self.updateListItemCount(targetAlbumId, 1, true);
			});
	},

	"{albumItem} photoDelete": function(el, event, task, photo) {

		task
			.done(function(){
				self.updateListItemCount(photo.album.id, -1, true);
			});
	},

	"{photoBrowser} init.photos.browser": function(el, event, photoBrowser) {

		// Attach browser to photo browser
		self.addSubscriber(photoBrowser);
	},

	"{self} contentload": function() {
		// Display the loading indication
		self.content().html('&nbsp;');
		self.wrapper().addClass('is-loading');

		// Remove any new item because there can only be one
		self.listItem(".new").remove();
	}

}});

module.resolve();

});
			EasySocial.module("site/albums/editor", function($){

var module = this;

// Constants
var photoEditorController = "EasySocial.Controller.Photos.Editor"

// Non-essential dependencies
EasySocial.require()
.script("site/albums/editor/uploader")
.done();

// Essential dependencies
var Controller =

EasySocial.Controller("Albums.Editor", {
	hostname: "editor",

	defaultOptions: {

		canReorder: false,
		canUpload: true,

		"{titleField}" : "[data-album-title-field]",
		"{passwordField}" : "[data-album-password-field]",
		"{captionField}" : "[data-album-caption-field]",
		"{descriptionField}" : "[data-album-description-field]",
		"{coverField}" : "[data-album-cover-field]",

		"{type}" : "[data-album-type]",
		"{uid}" : "[data-album-uid]",

		"{date}" : "[data-album-date]",
		"{dateCaption}" : "[data-album-date-caption]",
		"{addDateCaption}" : "[data-album-addDate-button]",
		"{privacy}" : "[data-album-privacy]",

		"{uploadButton}" : "[data-album-upload-button]",
		"{deleteButton}" : "[data-album-delete-button]",
		"{moreButton}" : "[data-album-more-button]",

		"{privacy}" : "[data-privacy-hidden]",
		"{privacycustom}" : "[data-privacy-custom-hidden]",

		"{uploadItem}" : "[data-photo-upload-item]",

		"{dateDay}" : "[data-date-day]",
		"{dateMonth}" : "[data-date-month]",
		"{dateYear}" : "[data-date-year]",

		"{editButton}" : "[data-album-edit-button]",
		"{doneButton}" : "[data-album-done-button]",
		"{cancelButton}" : "[data-album-cancel-button]",

		// Location
		"{location}" : "[data-album-location]",
		"{removeLocation}": "[data-album-location-remove]",
		"{locationCaption}" : "[data-album-location-caption]",
		"{addLocationButton}" : "[data-album-addLocation-button]",
		"{locationWidget}" : "[data-album-location-form] .es-locations",
		"{latitude}" : "[data-location-lat]",
		"{longitude}" : "[data-location-lng]"
	}
}, function(self, opts) { return {

	init: function() {

		self.id = self.element.data("album-id");

		// If we can upload photos, load & implement uploader.
		if (opts.canUpload) {
			EasySocial.module("site/albums/editor/uploader")
				.done(function(UploaderController){
					self.uploader = self.addPlugin("uploader", UploaderController);
				});
		}

		// If this is an existing album, there's no need to create album
		if (self.id) {
			self.createAlbum.task = $.Deferred().resolve();
			self.createStream = 0;
		} else {
			self.createStream = 1;
		}
	},

	data: function() {

		var title = self.titleField().val(),
			caption = self.captionField().val(),
			password = self.passwordField().val(),
			date = self.formatDate(),
			address = self.locationCaption().html(),
			latitude = self.latitude().val(),
			longitude = self.longitude().val(),
			privacy = self.privacy().val(),
			privacycustom = self.privacycustom().val();
			uid = self.element.data( 'album-uid' );
			type = self.element.data( 'album-type' );

		obj = {
			id : self.id,
			uid : uid,
			type : type,
			title : title,
			password : password,
			caption : caption,
			date : date,
			address : address,
			latitude : latitude,
			longitude : longitude,
			privacy : privacy,
			privacycustom : privacycustom,
			createStream : self.createStream
		};

		return obj;
	},

	createAlbum: function() {

		var task = self.createAlbum.task;

		if (!task) {

			task = self.createAlbum.task =

				self.save({
						createStream: 0
					})
					.done(function(album){
						self.deleteButton().disabled(false);
						self.element.attr("data-album-id", self.id = album.id);
					})
					.fail(function(message, type){
						self.setMessage(message, type);
					});
		}

		return task;
	},

	save: function(options) {

		self.trigger("beforeAlbumSave", [self]);

		// Build save data
		var data = $.extend(self.data(), options);

			data.photos =
				$.map(
					self.album.photoItem(),
					function(photoItem, i){
						var editor = $(photoItem).controller("EasySocial.Controller.Photos.Editor");
						return (editor) ? editor.data() : null;
					});

			// TODO: Get photo ordering
			// data.ordering = self.getPhotoOrdering();

		// Clear any messages
		self.clearMessage();

		// Save album
		var task = EasySocial.ajax( "site/controllers/albums/store" , data );

		// Trigger albumSave event
		self.trigger("albumSave", [task, self]);

		// Return task
		return task;
	},

	"{descriptionField} focus": function(el, event) {
		if (self.baseScrollHeight) {
			return;
		}

		var textarea = $(el);
		var savedValue = textarea.val();

		textarea.val('');

		self.baseScrollHeight = el[0].scrollHeight;

		textarea.val(savedValue);
	},

	"{descriptionField} input": function(el ,event) {
		var textarea = $(el);

		textarea.height(self.baseScrollHeight);
		textarea.height(textarea.prop('scrollHeight'));
	},

	"{self} photoAdd": function(el, event, photoItem, photoData) {

		// Set cover if this is the first photo
		if (self.album.photoItem().length <= 1) {
			self.changeCover(photoData);
		}
	},

	setCover: function(photoId) {

		var task =
			EasySocial.ajax(
				"site/controllers/albums/setCover",
				{
					albumId: self.id,
					coverId: photoId
				}
			)
			.done(function(photo){
				self.changeCover(photo);
			})
			.fail(function(){

			});

		return task;
	},

	removeCover: function() {

		self.trigger("coverRemove", [self.album]);
	},

	changeCover: function(photo) {

		self.trigger("coverChange", [photo, self]);
	},

	"{self} coverChange": function(el, event, photo) {

		self.coverField()
			.removeClass("no-cover")
			.css("backgroundImage", $.cssUrl(photo.sizes.thumbnail.url));
	},

	"{self} coverRemove": function() {

		self.coverField()
			.addClass("no-cover")
			.css("backgroundImage", "");
	},

	"{editButton} click": function(editButton, event) {
		event.preventDefault();
		event.stopPropagation();

		// Change viewer layout
		self.album.setLayout("form");

		// Route the button
		editButton.find('a').route();
	},

	"{editButtonLink} click": function(editButtonLink, event) {

		event.preventDefault();
	},

	"{cancelButton} click": function(cancelButton, event) {
		event.preventDefault();
		event.stopPropagation();

		// Change viewer layout
		self.album.setLayout("item");

		// Change address bar url
		cancelButton.route();
	},

	"{doneButton} click": function(doneButton, event) {
		event.preventDefault();
		event.stopPropagation();

		doneButton.addClass('is-loading');

		self.save({
			finalized : 1
		}).done(function(album, html){
			doneButton.removeClass('is-loading');

			// hide unfinalized message if there is any.
			$('[data-album-unfinalized-label]').hide();

			$.buildHTML(html).replaceAll(self.element);
		}).progress(function(message, type){
			self.setMessage(message, type);
		});
	},


	"{deleteButton} click": function(deleteButton) {

		if (deleteButton.disabled()) return;

		EasySocial.dialog({
			content: EasySocial.ajax("site/views/albums/confirmDelete", {id: self.id})
		});
	},

	formatDate: function() {
		var day = self.dateDay().val() || self.dateDay().data('date-default'),
			month = self.dateMonth().val() || self.dateMonth().data('date-default'),
			year = self.dateYear().val() || self.dateYear().data('date-default');

		return year + '-' + month + '-' + day;
		},

	updateDate: function() {

		self.date().addClass("has-data");
		var dateCaption = self.dateDay().val() + ' ' + $.trim(self.dateMonth().find(":selected").html()) + ' ' + self.dateYear().val();
		self.dateCaption().html(dateCaption);
	},

	"{dateDay} keyup": function() {
		self.updateDate();
	},

	"{dateMonth} change": function() {
		self.updateDate();
	},

	"{dateYear} keyup": function() {
		self.updateDate();
	},

	"{titleField} keyup": function(titleField) {

		self.trigger("titleChange", [titleField.val(), self]);
	},

	"{passwordField} keyup": function(passwordField) {

		self.trigger("passwordChange", [passwordField.val(), self]);
	},

	"{removeLocation} click": function(link, event) {
		event.preventDefault();
		event.stopPropagation();

		// Reset the location
		self.location().removeClass('has-data');
		self.locationCaption().empty();
		self.latitude().val('');
		self.longitude().val('');
	},

	"{locationWidget} locationChange": function(element, event, location) {
		var address = location.fulladdress || location.address || location.formatted_address || location.name;
		var controller = self.locationWidget().controller();

		// Set the address in the caption
		self.locationCaption().html(address);
		self.location().addClass("has-data");

		// We should now hide the location suggestion popup
		self.addLocationButton().click();
	}

}});

module.resolve(Controller);

});
			EasySocial.module("site/albums/editor/uploader", function($){

var module = this;

EasySocial.require()
.script("site/albums/uploader")
.done(function() {

var Controller =

EasySocial.Controller("Albums.Editor.Uploader", {
	defaultOptions: {
	}
}, function(self, opts) { return {

	init: function() {

		// Shortcuts
		self.album = self.editor.album;

		// Get upload settings
		var settings = self.album.options.uploader;

		// Implement uploader
		self.uploader = self.addPlugin("uploader", EasySocial.Controller.Albums.Uploader, {
								settings: settings,
								direction: settings.direction,
								"{uploadButton}"   : self.editor.uploadButton.selector,
								"{uploadItemGroup}": self.album.photoItemGroup.selector,
								"{uploadDropsite}" : self.album.content.selector
						});
	},

	setLayout: function() {
		self.album.setLayout_();
	},

	"{self} beforeAlbumSave": function() {
		// Stop existing upload process.
		self.uploader.stop();
	},

	"{self} albumSave": function(el, event, task) {

		task.done(function(album){

			var url = $.uri(self.uploader.settings("url"))
						.replaceQueryParam("albumId", album.id)
						.toString();

			self.uploader.settings("url", url);
		});
	},

	"{self} layoutChange": function(el, event, layoutName) {

		// Stop any running upload process
		// and clear upload items.
		self.uploader.stop();
		self.uploader.clear();

		var url =
			$.uri(self.uploader.settings("url"))
				.replaceQueryParam("createStream", layoutName=="form" ? 0 : 1)
				.replaceQueryParam("layout", layoutName)
				.toString();

		self.uploader.settings("url", url);
	},

	"{self} QueueCreated": function(el, event, uploadItem) {

		// Give upload item a layout when we're under editor
		if (self.album.currentLayout()=="form") {
			uploadItem.element.addClass("layout-form");
		}

		self.setLayout();
	},

	startUpload: $.Enqueue(),

	"{uploader} FilesAdded": function(el, event, uploader, files) {

		// If this is a new album
		if (!self.id) {

			// Create the album first
			self.editor.createAlbum()
				.done(
					// Before we start uploading
					self.startUpload(function(){
						self.uploader.start();
					})
				);

		// Else start uploading straightaway
		} else {
			self.uploader.start();
		}

		self.setLayout();
	},

	"{uploader} FilesRemoved": function() {

		self.setLayout();
	},

	"{uploader} FileUploaded": function(el, event, uploader, file, response) {

		var uploadItem = self.uploader.getItem(file);
		var photoItem = $.buildHTML(response.html);
		var photoData = response.data;

		// Initialize photo item
		photoItem
			.addClass("new-item")
			.insertAfter(uploadItem.element);

		setTimeout(function(){
			photoItem.removeClass("new-item");
		}, 1);

		self.uploader.removeItem(file.id);

		self.trigger("photoAdd", [photoItem, photoData, self.album]);

		self.setLayout();
	}

}});

module.resolve(Controller);

});

});
			EasySocial.module('site/albums/filter', function($) {

var module = this;

EasySocial.require()
.script('site/albums/browser')
.done(function($) {

EasySocial.Controller('Albums.Filter', {
	defaultOptions: {
		"{sidebarWrapper}": "[data-es-album-filters]",
		"{filter}": "[data-es-album-filters] [data-album-list-item]",
		"{filterLink}" : "[data-album-list-item] > a",

		"{filterTitle}" : "[data-album-list-item-title]",
		"{filterCover}" : "[data-album-list-item-cover]",
		"{filterCount}" : "[data-album-list-item-count]"
	}
}, function(self, opts) { return {

	init: function() {

		// Bind known event
		self.bindEvent();
	},

	bindEvent: function() {
		var controller = self.getController();

		controller.albumItem().on('titleChange', function(event, title, album) {
			self.getFilterItem(album.id, "title").html($.trim(title) || "&nbsp;");
		});

		controller.albumItem().on('photoAdd', function(event, photoItem, photoData, album) {
			self.updateListItemCount(album.id, 1, true);
		});

		controller.albumItem().on('photoMove', function(event, task, photo, batchAction, targetAlbumId) {
			task
			.done(function() {
				// Update current album count
				self.updateListItemCount(photo.album.id, -1, true);

				// Also update targetted album count
				self.updateListItemCount(targetAlbumId, 1, true);
			});
		});

		controller.albumItem().on('photoDelete', function(event, task, photo) {
			task
			.done(function(){
				self.updateListItemCount(photo.album.id, -1, true);
			});
		});
	},

	getController: function() {
		var albumLists = self.element.find('[data-album-browser=' + self.getUuid() + ']');
		var controller = albumLists.controller();

		return controller;
	},

	getUuid: function() {
		return self.sidebarWrapper().data('album-uuid');
	},

	setActiveFilter: function(filter) {
		self.filter().removeClass('active');

		filter.addClass('active');

		// Update the URL on the browser
		filter.find('a').route();

		// Set loading on the correct filter
		filter.addClass('is-loading');
	},

	getFilterItem: function(albumId, context) {

		var filter =
			(!albumId) ?
				self.filter(".new") :
				self.filter().filterBy("albumId", albumId);

		if (!context) return filter;

		return filter.find(self["filter" + $.String.capitalize(context)].selector);
	},

	updateListItemCount: function(albumId, val, append) {

		var stat = self.getFilterItem(albumId, "count");

		// If no stat element found, stop.
		if (stat.length < 0) return;

		// Get current stat count
		var statCount;

		if (append) {
			statCount = (parseInt(stat.text()) || 0) + (parseInt(val) || 0);
		} else {
			statCount = val;
		}

		// Always stays at 0 if less than that
		if (statCount < 0) statCount = 0;

		// Update stat count
		stat.text(statCount);
	},

	"{filterLink} click": function(filterItemLink, event) {

		// Progressive enhancement, no longer refresh the page.
		event.preventDefault();

		// Prevent item from getting into :focus state
		filterItemLink.blur();
	},

	"{filter} click": function(filter, event) {
		var controller = self.getController();

		if (controller === undefined) {
			return;
		}

		event.preventDefault();
		event.stopPropagation();

		// Don't do anything on new album item
		if (filter.hasClass("new")) {
			return;
		}

		// Set active filter state
		self.setActiveFilter(filter);

		var albumId = filter.data("albumId");

		// Load album
		var loader = controller.open("Album", albumId);
		loader.done(function() {
			filter.removeClass('is-loading');
		});
	}

}});

module.resolve();

});

});
			EasySocial.module("site/albums/item", function($){

var module = this;

// Non-essential dependencies
EasySocial.require()
.script("site/albums/editor")
.done();

// Essential dependencies
EasySocial.require()
.script("site/vendors/masonry", "site/albums/actions")
.done(function() {

EasySocial.Controller("Albums.Item", {
	hostname: "album",

	defaultOptions: {

		tilesPerRow: 4,
		editable: false,
		multipleSelection: false,

		"{header}": "[data-album-header]",
		"{content}": "[data-album-content]",
		"{footer}": "[data-album-footer]",

		"{info}": "[data-album-info]",

		"{title}": "[data-album-title]",
		"{caption}": "[data-album-caption]",
		"{location}": "[data-album-location]",
		"{date}": "[data-album-date]",
		"{cover}": "[data-album-cover]",
		"{favouriteButton}": "[data-album-favourite-button]",

		"{photoItemGroup}": "[data-photo-item-group]",
		"{photoItem}": "[data-photo-item]",
		"{photoImage}": "[data-photo-image]",
		"{photoImageCss}" : "[data-photo-image-css]",
		"{featuredItem}"  : "[data-photo-item].featured",
		"{featuredImage}" : "[data-photo-item].featured [data-photo-image]",
		"{featuredImageCss}" : "[data-photo-item].featured [data-photo-image-css]",
		"{uploadItem}"    : "[data-photo-upload-item]",

		"{moreButton}": "[data-album-more-button]",
		"{viewButton}": "[data-album-view-button]",

		"{share}": "[data-repost-action]",
		"{likes}": "[data-likes-action]",
		"{likeContent}": "[data-likes-content]",
		"{repostContent}": "[data-repost-content]",
		"{counterBar}": "[data-stream-counter]",
		"{imageLink}" : "[data-photo-image-link]",

		// Affix Header
		'{affix}': '[data-bs-spy=affix]',

		// Checkbox
		'{checkbox}': '[data-photo-item-checkbox]',
		'{checkAll}': '[data-photo-item-checkall]',

		// Actions button
		'{actionsWrapper}': '[data-photo-actions-wrapper]',
		'{actionsApply}': '[data-photo-actions-apply]'
	}
}, function(self, opts, base) { return {

	init: function() {
		self.id = base.data("album-id");

		self.nextStart = base.data("album-nextstart") || -1;

		// If this viewer is editable, load & implement editor.
		if (opts.editable) {
			EasySocial.module("site/albums/editor")
				.done(function(EditorController) {
					self.editor = self.addPlugin("editor", EditorController);
				});
		}

		// Set layout when window is resized
		self.setLayout();

		// Show load more button
		// Quick monkey fix for load more button showing
		// on the right corner before layout is set.
		self.moreButton().show();

		// Attach existing photo items as subscribers
		var controllers = self.photoItem().controllers("EasySocial.Controller.Photos.Item");
		self.addSubscriber(controllers);

		// Apply actions controller
		self.element.addController("EasySocial.Controller.Albums.Actions", opts);
	},

	"{window} resize": $.debounce(function(){
		self.setLayout();
	}, 250),

	currentLayout: function() {
		return base.data("albumLayout");
	},

	setLayout_: $.debounce(function(){
		self.setLayout();
	}, 100),

	setLayout: function(layoutName) {

		var photoItemGroup = self.photoItemGroup();
		var currentLayout = self.currentLayout();
		var layoutName = layoutName || currentLayout;
		var seed = self.setLayout.seed;
		var intact = (seed == photoItemGroup.width() && currentLayout==layoutName);
		var hasPhotoItem  = self.photoItem().length > 0;
		var hasUploadItem = self.uploadItem().length > 0;
		var hasItem = hasPhotoItem || hasUploadItem;
		var masonry = $.data(photoItemGroup[0], "masonry");

		// Put them in an object
		var layout = {
				currentLayout: currentLayout,
				seed         : seed,
				intact       : intact,
				hasPhotoItem : hasPhotoItem,
				hasUploadItem: hasUploadItem,
				hasItem      : hasItem,
				masonry      : masonry
			};

		// Determine if we need to switch layout
		if (!intact) {

			// Switch layout
			base
				.data("albumLayout", layoutName)
				.switchClass("layout-" + layoutName);

			// Switch all photo item's layout
			self.photoItem()
				.switchClass("layout-" + layoutName);

			// Reset viewport width to force layout redraw
			self.setLayout.seed = layout.seed = null;

			// Only trigger layout change when layout has really changed.
			if (currentLayout !== layoutName) {
				// Trigger layout change event
				self.trigger("layoutChange", [layoutName, layout]);
			}
		}

		// Show upload hint when content is empty
		base.toggleClass("has-photos", hasItem);

		// If there's no item from the list
		if (!hasItem) {

			// If this is coming from deleting the last item
			// from the list, we need to keep the container
			// on zero height.
			photoItemGroup.css("opacity", 1);
		}

		// Execute layout handler
		var layoutHandler = "set" + $.String.capitalize(layoutName) + "Layout";
		self[layoutHandler](layout);

		// Save current layout
		self.setLayout.seed = photoItemGroup.width();
	},

	setItemLayout: function(layout) {

		self.photoItem().attr("data-es-photo-disabled", 0);

		// Get photoItemGroup
		var tilesPerRow = 4;
		var photoItemGroup = self.photoItemGroup();
		var viewportWidth  = base.width();
		var containerWidth = Math.floor(viewportWidth / tilesPerRow) * tilesPerRow;

		self.photoItemGroup().width(containerWidth);

		if (layout.masonry) {
			photoItemGroup.masonry("reloadItems").masonry("layout");
		} else {

			photoItemGroup
				.masonry({
					columnWidth: ".es-photo-item.grid-sizer",
					itemSelector: self.photoItem.selector + ", " + self.uploadItem.selector,
					isOriginLeft: !self.options.rtl
				});
		}
	},

	setFormLayout: function(layout) {

		self.photoItem().attr("data-es-photo-disabled", 1);

		// Destroy masonry if we are on form layout
		layout.masonry && layout.masonry.destroy();

		// Reset layout
		self.clearLayout();
	},

	setDialogLayout: function(layout) {

		self.photoItem().attr("data-es-photo-disabled", 1);

		// Destroy masonry if we are on form layout
		layout.masonry && layout.masonry.destroy();

		// Reset layout
		self.clearLayout();
	},

	setThumbnailLayout: function() {

	},

	setRowLayout: function() {

		self.photoItem().attr("data-es-photo-disabled", 0);

		self.clearLayout();
	},

	clearLayout: function() {

		self.photoItemGroup()
			.addClass("no-transition");

		self.photoItem
			.css().remove();

		self.photoImage
			.css().remove();

		self.photoImageCss
			.css().remove();

		self.featuredItem
			.css().remove();

		self.featuredImage
			.css().remove();

		self.featuredImageCss
			.css().remove();

		self.uploadItem
			.css().remove();

		self.setLayout.seed = null;
	},

	getSelectedItems: function() {

		var selectedPhotos = self.photoItem(".selected");

		var data = [];

		selectedPhotos.each(function(i, photo){
			data.push($(photo).controller("EasySocial.Controller.Photos.Item").data());
		});

		return data;
	},

	"{photoItem} init.photos.item": function(el, event, photoItem) {
		self.addSubscriber(photoItem);
	},

	"{photoItem} destroyed": function() {

		self.setLayout();
	},

	"{photoItem} activate": function(photoItem, event, photo) {

		// Activate is a non-standard IE event,
		// if photo is undefined then it is coming
		// from the browser not photo item controller.
		if (!photo) return;

		var currentLayout = self.currentLayout();

		switch (currentLayout) {

			case "item":
			case "row":

				// Show loading indicator
				photoItem.addClass("is-loading");

				// If browser is available, ask browser
				// to load photo view via ajax.
				if (self.browser) {

					// View photo
					self.browser
						.open("photo", photo.id)
						.always(function(){

							// Remove loading indicator
							photoItem.removeClass("is-loading");
						});

					// Change address bar url
					photo.imageLink().route();

				// If browser is not available,
				// just load the photo view normally.
				} else {
					window.location = photo.imageLink().attr("href");
				}
				break;

			case "form":
				// photo.editor && photo.editor.enable();
				break;

			case "dialog":

				var selectedPhotos = self.photoItem(".selected");

				if (!self.options.multipleSelection) {

					var selected = photoItem.hasClass("selected");

					// In case it came from multiple selection
					selectedPhotos.removeClass("selected");

					photoItem.toggleClass("selected", !selected);

				} else {

					photoItem.toggleClass("selected");
				}
				break;
		}
	},

	"{photoItem} photoFeature": function(el, event, task, photo, featured) {

		// Set layout to accomodate double size photo item
		self.setLayout();

		// When a photo fail to be featured, it shrinks
		task
			.fail(function(){

				// So we're resetting layout again
				self.setLayout();
			});
	},

	"{photoItem} photoMove": function(el, event, task, photo, batchAction) {

		self.clearMessage();

		task
			.done(function() {

				// Trigger pagination first
				if (!batchAction) {
					photo.trigger('loadmore', [task, photo, 1]);
				}

				// Remove photo
				photo.element.remove();

				// Set layout
				self.setLayout();

				// If there are no more photos, remove cover
				if (self.photoItem().length < 1) {
					self.trigger("coverRemove", [self]);
				}
			})
			.fail(function(message, type){
				self.setMessage(message, type);
			});
	},

	"{photoItem} photoDelete": function(el, event, task, photo, batchAction) {

		self.clearMessage();

		task
			.done(function() {

				// Trigger pagination first
				if (!batchAction) {
					photo.trigger('loadmore', [task, photo, 1]);
				}

				// Remove photo
				photo.element.remove();

				// Set layout
				self.setLayout();

				// If there are no more photos, remove cover
				if (self.photoItem().length < 1) {
					self.trigger("coverRemove", [self]);
				}
			})
			.fail(function(message, type){
				self.setMessage(message, type);
			});
	},

	"{photoItem} loadmore": function(el, event, task, photo, total) {
		task.done(function() {

			if (self.nextStart == -1) {
				return;
			}

			var nextStart = base.data("album-nextstart") || -1;
			var currentPhoto = self.nextStart;
			var photoLeft = currentPhoto - total;

			self.nextStart = photoLeft;

			if (photoLeft < nextStart) {
				var limit = nextStart - photoLeft;
				self.loadmore(self.moreButton(), limit);
			}
		});
	},

	loadmore: function(moreButton, limit) {
		// If nextStart is -1, means no more photos
		if (self.nextStart == -1) {
			return;
		}

		if (moreButton.disabled()) {
			return;
		}

		if (!limit) {
			limit = 0;
		}

		// Disable this button
		moreButton.toggleClass('is-loading');
		moreButton.disabled(true);

		// Set the button into loading state
		// moreButton.addClass('loading');

		// Get the new photos content
		EasySocial.ajax("site/controllers/albums/loadMore", {
			albumId: self.id,
			start: self.nextStart,
			layout: self.currentLayout(),
			limit: limit
		})
		.done(function(htmls, nextStart) {

			self.nextStart = nextStart;

			var photoItemGroup = self.photoItemGroup();

			$.each(htmls, function(i, html){
				$.buildHTML(html).appendTo(photoItemGroup);
			});

			moreButton.toggleClass('is-loading');

			// If there is no more photos to load, hide the button
			if (nextStart < 0) {
				moreButton.hide();
			}

			self.setLayout();

			self.trigger('afterLoadMore');
		})
		.always(function(){

			moreButton.disabled(false);
		});
	},

	// These are coming from album editor
	"{self} albumSave": function(el, event, task) {

		task.done(function(album){
			self.id = album.id;
		});
	},

	"{self} coverChange": function(el, event, photo, album) {

		self.cover()
			.css("backgroundImage", $.cssUrl(photo.sizes.thumbnail.url));
	},

	"{self} coverRemove": function() {

		self.cover()
			.css("backgroundImage", "");
	},

	"{viewButton} click": function(viewButton, event) {
		if (self.browser)
		{
			event.preventDefault();
			base.addClass("is-loading");
			self.browser.open("Album", self.id);
		}
	},

	"{moreButton} click": function(moreButton) {
		self.loadmore(moreButton);
	},

	"{share} create": function(el, event, itemHTML) {
		self.counterBar().removeClass('hide');
	},

	"{likes} onLiked": function(el, event, data) {

		//need to make the data-stream-counter visible
		self.counterBar().removeClass( 'hide' );
	},

	"{likes} onUnliked": function(el, event, data) {

		var isLikeHide 		= self.likeContent().hasClass('hide');
		var isRepostHide 	= self.repostContent().hasClass('hide');

		if( isLikeHide && isRepostHide )
		{
			self.counterBar().addClass( 'hide' );
		}
	},

	"{favouriteButton} click": function() {

		EasySocial.ajax("site/controllers/albums/favourite", {
			"id": self.id
		})
		.done(function() {
			self.favouriteButton().toggleClass('is-fav active');
		});
	}

}});

module.resolve();

});


});
			EasySocial.module("site/albums/uploader.item", function($) {

var module = this;

EasySocial.Controller("Albums.Uploader.Item", {
	defaultOptions: {
		"{status}"       : ".upload-status",
		"{filename}"     : ".upload-filename",
		"{progressBar}"  : ".upload-progress-bar",
		"{percentage}"   : ".upload-percentage",
		"{filesizeTotal}": ".upload-filesize-total",
		"{filesizeLeft}" : ".upload-filesize-left",
		"{details}"      : ".upload-details",
		"{detailsButton}": "[data-upload-failed-link]",
		"{removeButton}" : ".upload-remove-button",
		"{message}"      : ".upload-message"
	}
}, function(self, opts) { return {

	init: function() {

		self.id = self.element.attr("id");

		var file = self.file();

		// Set filename
		self.filename().text(file.name);

		// Set state
		self.setState("pending");

		// Set progress & filesize
		self.setProgress();

		var html4 = self.uploader.plupload.runtime=="html4";

		if ($.IE < 10 || html4) {
			// So upload item will display with indefinite progressbar
			self.element.addClass("indefinite-progress");
		}

		if (html4) {
			self.element.addClass("no-filesize");
		}
	},

	file: function() {

		var file = self.uploader.plupload.getFile(self.id) || self.options.file;

		if (file) {
			var noFilesize = (file.size===undefined || file.size=="N/A");
			file.percentage = file.percent + "%";
			file.filesize   = (noFilesize) ? "" : $.plupload.formatSize(file.size);
			file.remaining  = (noFilesize) ? "" : $.plupload.formatSize(file.size - (file.loaded || 0));
		}

		return file;
	},

	setProgress: function() {

		var file = self.file(),
			percentage = file.percentage;

		// Never use 100% because users might think
		// the photo is completely uploaded when it might
		// still be working.
		// - Thanks Alex Heil.
		if (percentage=="100%") percentage = "99%";
		if (percentage=="0%") percentage = "1%";

		// Progress bar width
		self.progressBar()
			.width(percentage);

		// Progress bar percentage
		self.percentage()
			.html(percentage);

		// Total filesize
		self.filesizeTotal()
			.html(file.filesize);

		// Remaining filesize
		self.filesizeLeft()
			.html(file.remaining);
	},

	setState: function(state) {

		self.element
			.removeClass("pending preparing uploading failed done")
			.addClass(state);

		self.state = state;
	},

	setMessage: function(message) {
		opts.errorMessage = message;
	},

	"{detailsButton} click": function() {
		if (!opts.errorMessage) {
			return;
		}

		EasySocial.dialog({
			"content": opts.errorMessage
		});
	},

	"{removeButton} click": function(el, event) {

		self.uploader.removeItem(self.id);
	}

}});

module.resolve();

});
			EasySocial.module("site/albums/uploader", function($) {

var module = this;

// require: start
EasySocial.require()
.library("plupload")
.script("site/albums/uploader.item")
.done(function(){

// controller: start
EasySocial.Controller("Albums.Uploader", {
	defaultOptions: {

		direction: 'prepend',
		"{uploadButton}"   : "[data-upload-button]",
		"{uploadItemGroup}": "[data-upload-item-group]",
		"{uploadItem}"     : "[data-upload-item]",
		"{uploadDropsite}" : "[data-upload-dropsite]"
	}
}, function(self, opts, base) { return {

	init: function() {

		// Try to get the uploader template
		self.getUploadItemTemplate();

		var uploader = self.element;

		// Plupload controller
		self.pluploadController = self.element.addController("plupload", $.extend({
										"{uploadButton}" : self.uploadButton.selector,
										"{uploadDropsite}": self.uploadDropsite.selector
									}, opts.settings));

		// Plupload
		self.plupload = self.pluploadController.plupload;

		// Indicate uploader supports drag & drop
		if (!$.IE && self.plupload.runtime=="html5") {
			uploader.addClass("can-drop-file");
		}

		// Indicate uploader is ready
		uploader.addClass("can-upload");
	},

	getUploadItemTemplate: function() {
		var template = self.element.find('[data-uploader-template]');

		opts.uploadTemplate = $(template.html()).clone();
	},

	setLayout: function() {
		self.uploadItemGroup().toggleClass("no-upload-items", self.uploadItem().length < 1);
	},

	items: {},

	getItem: function(file) {
		var id;

		// By id
		if ($.isString(file)) {
			id = file;
		}

		// By file object
		if (file && file.id) {
			id = file.id;
		}

		return self.items[id];
	},

	createItem: function(file) {

		// Create item controller
		var itemTemplate = opts.uploadTemplate.clone();

		// Set the properties on the template
		itemTemplate.attr('data-photo-upload-item', '1');
		itemTemplate.attr('id', file.id);
		itemTemplate.removeClass('t-hidden');

		var item = itemTemplate.switchClass("layout-" + (base.data("albumLayout") || "form"))
					.addController("EasySocial.Controller.Albums.Uploader.Item", {
							"{uploader}": self,
							file: file
						}
					);

		// Add to item group
		item.element[opts.direction=='append' ? 'appendTo' : 'prependTo'](self.uploadItemGroup());

		// Keep a copy of the item in our registry
		self.items[file.id] = item;

		self.setLayout();

		self.trigger("QueueCreated", [item]);

		return item;
	},

	settings: function(key, val) {

		var settings = self.plupload.settings;

		// Setter
		if (val!==undefined) {
			settings[key] = val;
		}

		// Getter
		return (key) ? settings[key] : settings;
	},

	start: function() {

		return self.plupload.start();
	},

	stop: function() {

		return self.plupload.stop();
	},

	"{self} FilesAdded": function(el, event, uploader, files) {

		// Wrap the entire body in a try...catch scope to prevent
		// browser from trying to redirect and load the file if anything goes wrong here.
		try {

			// Reverse upload ordering as we are prepending.
			files.reverse();

			$.each(files, function(i, file) {

				// The item may have been created before, e.g.
				// when plupload error event gets triggered first.
				if (self.getItem(file)) {
					return;
				}

				self.createItem(file);
			});

		} catch (e) {

			console.error(e);
		};
	},

	"{self} BeforeUpload": function(el, event, uploader, file) {

		var item = self.getItem(file);

		if (!item) {
			return;
		}

		item.setState("preparing");
	},

	"{self} UploadFile": function(el, event, uploader, file) {

		var item = self.getItem(file);
		if (!item) return;

		item.setState("uploading");
	},

	"{self} UploadProgress": function(el, event, uploader, file) {

		var item = self.getItem(file);

		if (!item) {
			return;
		}

		item.setState("uploading");
		item.setProgress();
	},

	"{self} FileUploaded": function(el, event, uploader, file, response) {

		var item = self.getItem(file);
		if (!item) return;

		// If the response is not a valid object
		if (!$.isPlainObject(response)) {

			// Set upload item state to failed.
			item.setState("failed");
			return;
		}

		item.setState("done");
	},

	"{self} FileError": function(el, event, uploader, file, response) {

		var item = self.getItem(file);

		// If the item hasn't been created, create first.
		if (!item) {
			item = self.createItem(file);
		}

		item.setState("failed");
		item.setMessage(response.message);
	},

	"{self} Error": function(el, event, uploader, error) {

		// If the returned error object also returns a file object
		if (error.file) {

			// Check if the upload item has been created
			var file = error.file,
				item = self.getItem(file);

			// If the upload item doesn't exist
			if (!item) {
				item = self.createItem(file);
			}

			item.setState("failed");
			item.setMessage(error.message);
		}
	},

	removeItem: function(id) {

		var item = self.getItem(id);
		if (!item) return;

		// Remove item
		self.plupload.removeFile(item.file());
		item.element.remove();
		delete self.items[id];

		self.setLayout();
	},

	clear: function(id) {

		$.each(self.items, function(id, item){

			// Remove item
			self.plupload.removeFile(item.file());
			item.element.remove();
			delete self.items[id];
		});

		self.items = {};
	}

}});

module.resolve();

});

});
			EasySocial.module('site/api/admin', function($){

var module = this;

// Admin tools - Unban user
$(document)
	.on('click.es.user.unban', '[data-es-user-unban]', function() {
		var element = $(this);
		var uid = element.data('id');

		EasySocial.dialog({
			content: EasySocial.ajax('site/views/profile/confirmUnban', {id: uid}),
			bindings: {
				"{unbanButton} click": function() {
					var button =  $('[data-unban-button]');
					var loadButton = $('[data-unban-button-loader]');

					loadButton.addClass('is-active');

					// Prevent users to click more than one time
					button.attr("disabled", true);

					EasySocial.ajax('site/controllers/profile/unbanUser', {
						"id": uid
					}).done(function(html) {
						EasySocial.dialog({
							content: html
						});
					});

				},

				"{closeButton} click": function() {
					EasySocial.dialog().close();
				}
			}
		});

	});


// Admin tools - Delete user
$(document)
	.on('click.es.user.delete', '[data-es-user-delete]', function() {

		var element = $(this);
		var uid = element.data('id');

		EasySocial.dialog({
			content: EasySocial.ajax('site/views/profile/confirmDeleteUser', {id: uid}),
			bindings: {
				"{deleteButton} click": function() {
					EasySocial.ajax('site/controllers/profile/deleteUser', {
						"id": uid
					}).done(function(html) {
						EasySocial.dialog({
							content: html
						});
					});
				},

				"{closeButton} click": function() {
					EasySocial.dialog().close();
				}
			}
		});
	});

// Admin tools - Ban user
$(document)
	.on('click.es.user.ban', '[data-es-user-ban]', function() {
		var element = $(this);
		var uid = element.data('id');

		EasySocial.dialog({
			content: EasySocial.ajax('site/views/profile/confirmBanUser', {id: uid}),
			bindings: {

				"{banButton} click": function() {
					var textarea = $('[data-ban-reason]');
					var reason = textarea.val();
					var period = $('[data-ban-period]').val();
					var notice = $('[data-composer-notice]');
					var errorMsg = textarea.data('required-error');
					var button =  $('[data-ban-button]');
					var loadButton = $('[data-ban-button-loader]');

					loadButton.addClass('is-active');

					// Prevent users to click more than one time
					button.attr("disabled", true);

					if (reason.length < 1) {
						notice.html(errorMsg)
							.toggleClass('t-hidden', reason.length > 1);

						loadButton.removeClass('is-active');
						button.removeAttr("disabled");
						return;
					}

					EasySocial.ajax('site/controllers/profile/banUser', {
						"id": uid,
						"period": period,
						"reason": reason
					}).done(function(html) {
						EasySocial.dialog({
							content: html
						});

					});
				},

				"{closeButton} click": function() {
					EasySocial.dialog().close();
				}
			}
		})


	});


module.resolve();

});
			EasySocial.module('site/api/data', function($){

var module = this;

EasySocial.require()
.script('site/friends/suggest', 'site/api/events', 'site/api/groups', 'site/api/pages', 'site/api/friends')
.done(function(){

	// Reports
	$(document).on("click.es.reports.link", "[data-reports-link]", function(){

		var button = $(this);
		var props = "url,extension,uid,type,object,title,description".split(",");
		var data = {};

		$.each(props, function(i, prop){
			data[prop] = button.data(prop);
		});

		EasySocial.dialog({

			content: EasySocial.ajax("site/views/reports/confirmReport", {
					title: data.title,
					description: data.description
			}),
			selectors: {
				"{message}": "[data-reports-message]",
				"{reportButton}": "[data-report-button]",
				"{cancelButton}": "[data-cancel-button]"
			},
			bindings: {

				"{reportButton} click": function() {

					var message	= this.message().val();

					EasySocial.dialog({
						content: EasySocial.ajax("site/controllers/reports/store", {
								url      : data.url,
								extension: data.extension,
								uid      : data.uid,
								type     : data.type,
								title    : data.object,
								message  : message
							})
					});
				},

				"{cancelButton} click": function() {
					EasySocial.dialog().close();
				}
			}
		});
	});

	var esConversationCompose = false;

	// Data API
	$(document)
		.on('click.es.conversations.compose', '[data-es-conversations-compose]', function(){

			var element = $(this);
			var userId = element.data('id') || element.data('es-conversations-id');
			var listId = element.data('list-id') || element.data('es-conversations-listid');

			EasySocial.dialog({
				"content": EasySocial.ajax('site/views/conversations/composer', {"id" : userId, "listId" : listId}),
				"bindings": {

					"{sendButton} click" : function(el) {

						// Ensure that the button is only clicked once to avoid duplication
						if (esConversationCompose) {
							return;
						}

						el.addClass('is-loading');
						esConversationCompose = true;

						var recipients = $('input[name=recipient\\[\\]]');
						var message = $('[data-composer-message]').val();
						var notice = $('[data-composer-notice]')
						var uids = new Array;
						var dialog = this.parent;

						if (!notice.hasClass('t-hidden')) {
							// remove the notice message.
							notice.addClass('t-hidden');
						}

						$(recipients).each(function(){
							uids.push($(this).val());
						});

						EasySocial.ajax('site/controllers/conversations/store', {
							"uid": uids,
							"message": message
						}).done(function(link) {

							if (userId) {

								EasySocial.dialog({
									"content": EasySocial.ajax('site/views/conversations/sent', {"id" : userId}),
									"bindings": {
										"{viewButton} click" : function() {
											document.location = link;
										}
									}
								});
							}

							if (listId) {
								EasySocial.dialog({
									"content": EasySocial.ajax('site/views/conversations/sentList', {"id" : listId}),
									"bindings": {
										"{viewButton} click" : function() {
											document.location = link;
										}
									}
								});
							}
						}).fail(function(err) {
							notice.text(err.message);
							notice.removeClass('t-hidden');
						}).always(function() {
							el.removeClass('is-loading');
							esConversationCompose = false;
						});
					}
				}
			});
		});

	var esCancelLegacy = false;

	// Legacy api
	$(document)
		.on('click.es.friends.cancelLegacy', '[data-es-friends-cancel]', function() {
			var element = $(this);
			var friendId = element.data('es-friends-id');

			// Show confirmation dialog
			EasySocial.dialog({
				content: EasySocial.ajax('site/views/friends/confirmCancel'),
				bindings: {

					"{confirmButton} click": function() {
						if (esCancelLegacy) {
							return;
						}

						esCancelLegacy = true;

						EasySocial.ajax('site/controllers/friends/cancelRequest', {
							"id": friendId
						}).done(function() {
							EasySocial.dialog().close();
							esCancelLegacy = false;
						});
					}
				}
			});
		});

	var esSubscription = [];

	// Apply actions upon clicking the follow / unfollow button
	$(document)
		.on('click.es.user.subscription', '[data-es-subscription]', function() {

			var button = $(this);
			var task = $(this).data('task');
			var id = $(this).data('id');

			if (esSubscription[task]) {
				return;
			}

			esSubscription[task] = true;

			// Add loading indicator on the button
			button.addClass('is-loading');

			// Let's do an ajax call to follow the user.
			EasySocial.ajax('site/controllers/subscriptions/' + task, {
				"id": id,
				"type": "user"
			}).done(function(html) {
				button.replaceWith(html);
				button.removeClass('is-loading');
				esSubscription[task] = false;
			});
		});


	// Block a target user
	$(document).on("click.es.blocks.link", "[data-blocks-link]", function(){

		var target = $(this).data('target');

		EasySocial.dialog({

			content: EasySocial.ajax(
				"site/views/blocks/confirmBlock",
				{
					"target": target
				}),

				selectors: {
					"{reason}": "[data-block-reason]",
					"{blockButton}": "[data-block-button]",
					"{cancelButton}": "[data-cancel-button]"
				},

				bindings: {

					"{blockButton} click": function() {

						var reason = this.reason().val();

						EasySocial.dialog({
							content: EasySocial.ajax("site/controllers/blocks/store", {"target": target, "reason": reason})
						});
					},

					"{cancelButton} click": function() {
						EasySocial.dialog().close();
					}
				}
		});
	});

	// Unblock a target user
	$(document).on("click.es.unblock.link", "[data-unblock-link]", function(){

		var target = $(this).data('target');

		EasySocial.dialog({

			content: EasySocial.ajax(
				"site/views/blocks/confirmUnblock",
				{
					"target": target
				}),

				selectors: {
					"{unblockButton}": "[data-unblock-button]",
					"{cancelButton}": "[data-cancel-button]"
				},

				bindings: {

					"{unblockButton} click": function() {

						EasySocial.dialog({
							content: EasySocial.ajax(
								"site/controllers/blocks/unblock",
								{
									"target": target
								})
								.done(function() {

									// remove the user from the listing page.
									$('[data-blocked-user-' + target + ']').remove();

								}),

							selectors: {
								"{cancelButton}": "[data-cancel-button]"
							},

							bindings: {
								"{cancelButton} click": function() {
									EasySocial.dialog().close();
								}
							}
						});
					},

					"{cancelButton} click": function() {
						EasySocial.dialog().close();
					}
				}
		});
	});

	// Logout buttons
	$(document)
		.on('click', '[data-es-logout-button]', function() {
			var parent = $(this).closest('[data-es-logout]')
			var form = parent.find('[data-es-logout-form]');

			form.submit();
		});

	// Video embeds on stream
	$(document).on("click", "[data-es-links-embed-item]", function() {

		var button = $(this);
		var player = $('<div>').html(button.data('es-stream-embed-player'));
		var embed = '<div class="video-container">' + player.html() + '</div>';

		button.replaceWith(embed);
	});

	// Processes stream items containing videojs embed codes
	$(document).on('click', '[data-es-video-embed]', function() {
		var button = $(this);
		var embed = button.siblings('[data-es-video-embed-player]');

		button.replaceWith(embed);
		embed.removeClass('hide');
	});


	// Api for EasySocial.login
	EasySocial.login = function() {

		EasySocial.dialog({
			"content": EasySocial.ajax('site/views/login/form')
		});
	};

	module.resolve();
});

});
			EasySocial.module('site/api/events', function($){

var module = this;

// Events invite friends
$(document).on('click.es.events.invite', '[data-es-events-invite]', function() {

	var element = $(this);
	var id = element.data('id');
	var returnUrl = element.data('return');

	EasySocial.dialog({
		content: EasySocial.ajax('site/views/events/invite', {"id" : id, "return" : returnUrl}),
		position: {
			my: "center top",
			at: "center top",
			of: window
		}
	});
});

var eventRsvp = false;

// Changing the action state for an event
$(document).on('click.es.events.rsvp', '[data-es-events-rsvp] [data-state]', function() {

	if (eventRsvp) {
		return;
	}

	eventRsvp = true;

	var item = $(this);
	var task = item.data('state');

	// Get the other dom objects
	var wrapper = item.closest('[data-es-events-rsvp]');
	var eventId = wrapper.data('id');
	var button = wrapper.find('[data-button]');

	// Text for rsvp button
	var text = wrapper.find('[data-text]');

	// Update counter for my event
	var filter = $('[data-type="mine"]');
	var counterWrapper = filter.find('[data-counter]');

	// Add loading indicator
	button.addClass('is-loading');

	// Remove all states active class
	item.siblings().removeClass('active');
	item.addClass('active');

	// Perform a query to the server
	EasySocial.ajax('site/controllers/events/rsvp', {
		"task": task,
		"id": eventId
	}).done(function(newButton, newText, counter) {

		counterWrapper.html(counter);

		// Remove loading
		button.removeClass('is-loading');

		// Update the current text of the button
		text.html(newText);

		// Trigger the button
		button.trigger('es.events.rsvp', [task, newButton, newText]);

		// Force page reload
		var reload = wrapper.data('page-reload');

		if (reload) {
			location.reload(true);
		}
	}).fail(function(dialog){

		button.removeClass('is-loading');

		EasySocial.dialog({
			"content": dialog
		});
	}).always(function() {
		eventRsvp = false;
	});
});

var eventRequest = false;

// Request join request
$(document).on('click.es.events.request', '[data-es-events-request]', function() {

	if (eventRequest) {
		return;
	}

	eventRequest = true;

	var button = $(this);
	var eventId = button.data('id');

	button.addClass('is-loading');

	// Perform a query to the server
	EasySocial.ajax('site/controllers/events/rsvp', {
		"task": "request",
		"id": eventId
	}).done(function(newButton, newText) {

		// Remove loading
		button.replaceWith(newButton);

		// Trigger the button
		button.trigger('es.events.rsvp', ["request", newButton, newText]);
	}).always(function() {
		eventRequest = false;
	});
});

// Withdraw join request
$(document).on('click.es.events.withdraw', '[data-es-events-withdraw]', function() {
	var button = $(this);
	var eventId = button.data('id');

	button.addClass('is-loading');

	EasySocial.ajax('site/controllers/events/rsvp', {
		"task": "withdraw",
		"id": eventId
	}).done(function(newButton, newText) {

		button.replaceWith(newButton);

		button.trigger('es.events.rsvp', ['withdraw'], newButton, newText);
	});
});

// Featuring events
$(document).on('click.es.events.admin.feature', '[data-es-events-feature]', function() {
	var element = $(this);
	var id = element.data('id');
	var returnUrl = element.data('return');

	EasySocial.dialog({
		content: EasySocial.ajax('site/views/events/confirmFeature', {"id" : id, "return": returnUrl})
	});
});

// Unfeature events
$(document).on('click.es.events.admin.feature', '[data-es-events-unfeature]', function() {
	var element = $(this);
	var id = element.data('id');
	var returnUrl = element.data('return');

	EasySocial.dialog({
		content: EasySocial.ajax('site/views/events/confirmUnfeature', {"id" : id, "return": returnUrl})
	});
});


// Group admin tools - Unpublish group
$(document).on('click.es.events.admin.unpublish', '[data-es-events-unpublish]', function() {
	var element = $(this);
	var id = element.data('id');

	EasySocial.dialog({
		content: EasySocial.ajax('site/views/events/confirmUnpublish', {"id" : id})
	});
});

// Group admin tools - Delete group
$(document).on('click.es.events.admin.delete', '[data-es-events-delete]', function() {
	var element = $(this);
	var id = element.data('id');

	EasySocial.dialog({
		content: EasySocial.ajax('site/views/events/confirmDelete', {"id" : id})
	});
});

module.resolve();

});
			EasySocial.module('site/api/floatlabels', function($) {

	var module = this;

	var inputGroups = '.o-form-group';
	var inputSelectors = '.o-form-control.o-float-label__input:not(.is-static)';

	$(document).on('change.floatlabel', inputSelectors, function() {
		var self = $(this);
		var label = self.closest(inputGroups);

		label.addClass('is-focused');
	});

	$(document).on('focus.floatlabel', inputSelectors, function() {
		var self = $(this);
		var label = self.closest(inputGroups);

		label.addClass('is-focused');
	});


	$(document).on('blur.floatlabel', inputSelectors, function() {
		var self = $(this);
		var label = self.closest(inputGroups);
		var value = self.val();

		// When there is a value, we should inject is-filled.
		if ($.trim(value) !== '') {
			label.addClass('is-filled');
			label.removeClass('is-focused');
			return;
		}

		label.removeClass('is-filled');
		label.removeClass('is-focused');
	});


	$(inputSelectors).trigger('blur.floatlabel');

	module.resolve();
});			EasySocial.module('site/api/friends', function($){

var module = this;

var actions = [];

// Data API
$(document)
	.on('click.es.friends.addLegacy', '[data-es-friends-add]', function() {

		if (actions['addLegacy']) {
			return;
		}

		actions['addLegacy'] = true;

		var element = $(this);
		var userId = element.data( 'es-friends-id');
		var popboxContent = $.Deferred();
		var popboxOptions = {
			"content": popboxContent,
			"id" : "es",
			"component": "",
			"type": "api-friends",
			"toggle": "click"
		};

		// Display the popbox
		element.popbox('destroy');

		// Generate a new popbox instance
		element.popbox(popboxOptions);

		// Display the popbox
		element.popbox('show');

		// Run an ajax call now to perform the add friend request.
		EasySocial.ajax( 'site/controllers/friends/request' , {
			"viewCallback": "popboxRequest",
			"id": userId
		}).done(function(content) {
			popboxContent.resolve(content);
		}).always(function() {
			actions['addLegacy'] = false;
		});
	});

// New api to add friends
$(document)
	.on('click.es.friends.add', '[data-es-friends] [data-task="add"]', function() {

		if (actions['add']) {
			return;
		}

		actions['add'] = true;

		var button = $(this);
		var wrapper = button.closest('[data-es-friends]');
		var targetId = wrapper.data('id');
		
		button.addClass('is-loading');

		EasySocial.ajax('site/controllers/friends/request', {
			"id": targetId
		}).done(function(newButton) {

			button.trigger('es.friends.add', [newButton]);
			wrapper.replaceWith(newButton);
		}).fail(function(message) {
			EasySocial.dialog({
				"content": message.message
			});
		})
		.always(function() {
			button.removeClass('is-loading');
			actions['add'] = false;
		})
	});

// New api to unfriend a person
$(document)
	.on('click.es.friends.unfriend', '[data-es-friends] [data-task="unfriend"]', function() {

		if (actions['unfriend']) {
			return;
		}

		actions['unfriend'] = true;

		var anchor = $(this);
		var wrapper = anchor.closest('[data-es-friends]');
		var targetId = wrapper.data('id');
		var button = wrapper.find('[data-es-friends-button]');

		// Add loading indicator			
		button.addClass('is-loading');

		EasySocial.ajax('site/controllers/friends/unfriend', {
			"id": targetId
		}).done(function(newButton) {
			anchor.trigger('es.friends.unfriend', [newButton]);
			wrapper.replaceWith(newButton);
		}).always(function() {
			actions['unfriend'] = false;
		});
	});

// New api to cancel friend requests
$(document)
	.on('click.es.friends.cancel', '[data-es-friends] [data-task="cancel"]', function() {

		if (actions['cancel']) {
			return;
		}

		actions['cancel'] = true;

		var anchor = $(this);
		var wrapper = anchor.closest('[data-es-friends]');
		var targetId = wrapper.data('id');
		var button = wrapper.find('[data-es-friends-button]');

		// Add loading indicator
		button.addClass('is-loading');

		EasySocial.ajax('site/controllers/friends/cancelRequest', {
			"id": targetId
		}).done(function(newButton) {
			anchor.trigger('es.friends.cancel', [newButton]);
			wrapper.replaceWith(newButton);
		}).always(function() {
			actions['cancel'] = false;
		});
	});

// API to reject a friend request
$(document)
	.on('click.es.friends.reject', '[data-es-friends] [data-task="reject"]', function() {

		if (actions['reject']) {
			return;
		}

		actions['reject'] = true;
		
		var anchor = $(this);
		var wrapper = anchor.closest('[data-es-friends]');
		var friendId = wrapper.data('id');

		EasySocial.ajax('site/controllers/friends/reject', {
			"id": friendId
		}).done(function(newButton) {			
			anchor.trigger('es.friends.reject', [newButton]);
			wrapper.replaceWith(newButton);
		}).always(function() {
			actions['reject'] = false;
		});

	});

// Api to approve a friend request
$(document)
	.on('click.es.friends.accept', '[data-es-friends] [data-task="accept"]', function() {

		if (actions['accept']) {
			return;
		}

		actions['accept'] = true;

		var anchor = $(this);
		var wrapper = anchor.closest('[data-es-friends]');
		var friendId = wrapper.data('id');

		EasySocial.ajax('site/controllers/friends/approve', {
			"id": friendId
		}).done(function(newButton) {
			anchor.trigger('es.friends.accept', [newButton]);
			wrapper.replaceWith(newButton);
		}).always(function() {
			actions['accept'] = false;
		});
	});

module.resolve();

});
			EasySocial.module('site/api/groups', function($){

var module = this;

var groupJoin = false;

// Groups API
$(document).on('click.es.groups.join', '[data-es-groups-join]', function() {
	if (groupJoin) {
		return;
	}

	groupJoin = true;

	var button = $(this);
	var groupId = button.data('id');
	var join = "[data-group-join-count-"+groupId+"]";

	// Add loading indicator
	button.addClass('is-loading');

	EasySocial.ajax('site/controllers/groups/join', {
		"api": 1, 
		"id": groupId
	}).done(function(dialog, newButton, newJoinCount) {
			
		// Once the request is completed, we just replace the button
		if (newButton) {
			button.replaceWith(newButton);
			$(join).html(newJoinCount);
		} else {
			button.removeClass('is-loading');
		}

		if (dialog) {
			EasySocial.dialog({
				"content": dialog
			});
		}

		// Force page reload
		var reload = button.data('page-reload');

		if (reload) {
			location.reload(true);
		}
	}).fail(function(dialog) {
		EasySocial.dialog({
			"content": dialog
		});

		button.removeClass('is-loading');
	}).always(function() {
		groupJoin = false;
	});
});

var groupLeave = false;

// Groups API - Leave group
$(document).on('click.es.groups.join', '[data-es-groups-leave]', function() {
	var button = $(this);
	var groupId = button.data('id');

	// Add loading indicator
	button.addClass('is-loading');

	EasySocial.dialog({
		"content": EasySocial.ajax('site/views/groups/confirmLeaveGroup', {
					"api": 1, 
					"id": groupId
					}).done(function(){
						button.removeClass('is-loading');
					}),
		"bindings": {
			"{leaveButton} click": function() {
				if (groupLeave) {
					return;
				}

				groupLeave = true;
				this.leaveForm().submit();
			}
		}
	});
});

// Groups API - Withdraw request
$(document).on('click.es.groups.withdraw', '[data-es-groups-withdraw]', function() {
	var link = $(this);
	var id = link.data('id');
	var parent = link.closest('[data-request-sent]');

	EasySocial.ajax('site/controllers/groups/withdraw', {
		"id": id
	}).done(function(newButton) {
		parent.replaceWith(newButton);
	});
});

// Groups API - Respond to invitation request
$(document).on('click.es.groups.respond.invitation', '[data-es-groups-respond-invitation]', function() {
	var button = $(this);
	var groupId = button.data('id');

	button.addClass('is-loading');

	EasySocial.dialog({
		"content": EasySocial.ajax('site/views/groups/confirmRespondInvitation', {
			"id": groupId
		}),
		"bindings": {
			"{rejectButton} click" : function() {
				this.responseValue().val('reject');
				this.respondForm().submit();
			},
			"{acceptButton} click" : function() {
				this.responseValue().val('accept');
				this.respondForm().submit();
			}
		}
	});
});

// Group invite friends
$(document).on('click.es.groups.invite', '[data-es-groups-invite]', function() {

	var element = $(this);
	var id = element.data('id');

	EasySocial.dialog({
		content: EasySocial.ajax('site/views/groups/invite', { "id" : id }),
		position: {
			my: "center top",
			at: "center top",
			of: window
		}
	});
});

// Group admin tools - Feature group
$(document).on('click.es.groups.admin.feature', '[data-es-groups-feature]', function() {
	var element = $(this);
	var id = element.data('id');
	var returnUrl = element.data('return');

	EasySocial.dialog({
		content: EasySocial.ajax('site/views/groups/confirmFeature', {"id" : id, "return": returnUrl})
	});
});

// Group admin tools - Unfeature group
$(document).on('click.es.groups.admin.feature', '[data-es-groups-unfeature]', function() {
	var element = $(this);
	var id = element.data('id');
	var returnUrl = element.data('return');

	EasySocial.dialog({
		content: EasySocial.ajax('site/views/groups/confirmUnfeature', {"id" : id, "return": returnUrl})
	});
});

// Group admin tools - Unpublish group
$(document).on('click.es.groups.admin.unpublish', '[data-es-groups-unpublish]', function() {
	var element = $(this);
	var id = element.data('id');

	EasySocial.dialog({
		content: EasySocial.ajax('site/views/groups/confirmUnpublishGroup', {"id" : id})
	});
});

// Group admin tools - Delete group
$(document).on('click.es.groups.admin.delete', '[data-es-groups-delete]', function() {
	var element = $(this);
	var id = element.data('id');

	EasySocial.dialog({
		content: EasySocial.ajax('site/views/groups/confirmDelete', {"id" : id})
	});
});

module.resolve();

});
			EasySocial.module('site/api/likes', function($){

var module = this;
var deepPress = false;
var reactionEvent = false;

if (window.es.mobile || window.es.tablet) {
	window.es.initReactions = function() {
		EasySocial.require()
		.library('pressure', 'mobile-events')
		.done(function($) {

			// Since pressure library only applicable for ios, we just apply to ios devices
			if (navigator.userAgent.match(/iPhone|iPad|iPod/i)) {

				Pressure.set('[data-button-main]', {
					start: function() {
					},
					end: function() {
					},
					change: function(force) {

						if (force > 0.15) {

							if (!reactionEvent) {
								$(this).addClass('is-hover');

								reactionEvent = true;
								deepPress = true;

								var button = $(this);
								deactivateClickableImage(button);

								// Activate event to hide reaction buttons popup
								setTimeout(function() {
									initReactionHide(button);
								}, 500);
							}
						}
					}
				});

			} else {


				$(document)
					.on('taphold', '[data-es-likes]', function(e) {

						if (!reactionEvent) {
							$(this).addClass('is-hover');

							deepPress = true;

							var button = $(this);
							deactivateClickableImage(button);

							// Activate event to hide reaction buttons popup
							setTimeout(function() {
								initReactionHide(button);
							}, 500);

						}
					});

				$(document)
					.on('contextmenu', '[data-es-likes]', function(e) {
						e.preventDefault();
						e.stopPropagation();

						return false;
					});
			}
		});
	};

	window.es.initReactions();
}

function initReactionHide(button) {

	// Activate click event
	bindReactionHideEvent();

	$(document).on('click.es.likes.reaction.hide', function(event) {
		var container = $('[data-reaction-list]');

		// if the target of the click isn't the container nor a descendant of the container
		if (reactionEvent && !container.is(event.target) && container.has(event.target).length === 0) {

			$('[data-button-main]').removeClass('is-hover');

			deepPress = false;

			// unbind event
			unbindReactionHideEvent();
		}

		activateClickableImage(button);

	});
}

// Bind hide event
function bindReactionHideEvent() {
	$(document).bind('click.es.likes.reaction.hide');
	reactionEvent = true;
}

// Unbind hide event
function unbindReactionHideEvent() {
	$(document).unbind('click.es.likes.reaction.hide');
	reactionEvent = false;
}

// determine whether that is photo stream item or not (only check for mobile device)
function deactivateClickableImage(element) {

	var streamItemWrapper = element.parents('[data-context="photos"]');
	var isPhotoStream = streamItemWrapper.hasClass('es-context-photos');

	// Only check this for photo stream item
	if (isPhotoStream) {

		var previewElement = streamItemWrapper.find('[data-preview]');

		// do not allow user to click preview image section within this stream item #3651
		previewElement.addClass('t-pointer-events--none');
	}
}

function activateClickableImage(element) {

	var streamItemWrapper = element.parents('[data-context="photos"]');
	var isPhotoStream = streamItemWrapper.hasClass('es-context-photos');

	// Only check this for photo stream item
	if (isPhotoStream) {

		var previewElement = streamItemWrapper.find('[data-preview]');

		// release it if do not have reaction pop up within this stream item #3651
		previewElement.removeClass('t-pointer-events--none');
	}
}

// Reaction statistics
$(document)
	.on('click.es.likes.stats', '[data-es-reaction-stats] [data-bs-toggle]', function(event) {
		var tab = $(this);
		var siblings = tab.siblings();

		siblings.removeClass('is-active');
		tab.addClass('is-active');
	});

$(document)
	.on("click.es.likes.action", "[data-es-likes]", function(event) {

		// Button
		var button = $(this);
		var reaction = button.data('es-likes');
		var isMainButton = button.data('button-main') !== undefined;

		if (deepPress && isMainButton && reactionEvent) {

			// unbind event
			unbindReactionHideEvent();
			return;
		}

		// Containers
		var container = button.parents('[data-es-likes-container]');
		var reactionList = container.find('[data-reactions-list]');
		var currentReaction = container.data('current');

		// Main button
		var mainButton = container.find('[data-button-main]');
		var mainButtonIcon = mainButton.find('[data-button-main-icon]');
		var mainButtonText = mainButton.find('[data-button-text]');
		var defaultText = container.data('default-text');
		var defaultReaction = container.data('default');

		// Ensure that remove the backslash before populate the word during like process
		// Because there got some possibility translator will translate the like word which got contain the single quote
		defaultText = defaultText.replace(/\\/g, "");

		// Once a reaction is tapped, hide the hover
		mainButton.removeClass('is-hover');
		deepPress = false;

		var postAsHidden = $('[data-postas-base] [data-postas-hidden]');
		var postActor = postAsHidden.length > 0 ? postAsHidden.val() : 'user';

		// Data to be sent to the server
		var data = {
				"id": container.data("id"),
				"type": container.data("likes-type"),
				"group": container.data("group"),
				"verb": container.data("verb"),
				"streamid": container.data("streamid"),
				"clusterid": container.data("clusterid"),
				"reaction": reaction,
				"uri": container.data('uri'),
				"reactas": postActor
		};

		// Find the actions row
		var key = data.type + "-" + data.group + "-" + data.id;
		var actions = button.closest('[data-stream-actions]');
		var content = actions.find('[data-likes-content=' + key + ']');

		// Find all the counters
		var counter = content.find('[data-reaction-counter=' + reaction + ']');

		// Determines if we are adding a new reaction
		var addingReaction = false;

		// If the user previously reacted, and the new reaction isn't the same, we need to update
		// the reaction with the one they chose
		if (currentReaction != reaction) {

			var count = parseInt(counter.text());
			count = count + 1;

			container.data('current', reaction);

			// Update the main button with the appropriate reaction
			mainButton
				.data('es-likes', reaction)
				.addClass('is-active');

			if (mainButtonIcon.length) {
				mainButtonIcon
					.removeClass('es-icon-reaction--' + defaultReaction)
					.removeClass('es-icon-reaction--' + currentReaction)
					.addClass('es-icon-reaction--' + reaction);
			}

			// Update the counter
			counter.text(count.toString());

			// Update the active button text
			var active = reactionList.find('[data-es-likes=' + reaction + ']');
			var activeText = active.data('text');
			var activeReactionItem = content.find('[data-reaction-item=' + reaction + ']');

			activeReactionItem.removeClass('t-hidden');
			mainButtonText.text(activeText);

			// Get the previous reaction and reduce the count
			if (currentReaction) {
				var previousReactionItem = content.find('[data-reaction-item=' + currentReaction + ']');
				var previousReactionCounter = content.find('[data-reaction-counter=' + currentReaction + ']');
				var previousReactionCount = parseInt(previousReactionCounter.text()) - 1;
				previousReactionCounter.text(previousReactionCount.toString());

				if (previousReactionCount <= 0) {
					previousReactionItem.addClass('t-hidden');
				}
			}

			addingReaction = true;
		}

		// User already provided a reaction earlier and they are probably withdrawing
		// their previous reaction by clicking on the same button again
		if (currentReaction == reaction) {

			// Reset the current reaction
			container.data('current', '');

			// Get the previous reaction and reduce the count
			var previousReactionItem = content.find('[data-reaction-item=' + currentReaction + ']');
			var previousReactionCounter = content.find('[data-reaction-counter=' + currentReaction + ']');
			var previousReactionCount = parseInt(previousReactionCounter.text()) - 1;

			previousReactionCounter.text(previousReactionCount.toString());

			if (previousReactionCount <= 0) {
				previousReactionItem.addClass('t-hidden');
			}

			// Update the main button text
			mainButton
				.data('es-likes', defaultReaction)
				.removeClass('is-active');

			// Reset the main button icon
			mainButtonIcon.removeClass('es-icon-reaction--' + currentReaction)
				.addClass('es-icon-reaction--' + defaultReaction);

			mainButtonText.text(defaultText);
		}

		// The result isn't shown yet. We should show it
		if (!currentReaction && content.hasClass('t-hidden')) {
			content.removeClass('t-hidden');
		}

		var label = content.find('[data-reaction-label]');

		EasySocial.ajax('site/controllers/likes/react', data)
			.done(function(labelText, hideResult, action, count) {
				// Update the label on the result

				label.html(labelText);

				// Get the stream id from the button
				var id = button.data("streamid");

				// Furnish data with like count
				data.uid = data.id;
				data.count = count;

				// Hide the result row if there is nothing left
				if (data.count <= 0) {
					content.addClass('t-hidden');
				}

				// verb = like/unlike
				var trigger = addingReaction ? "onLiked" : "onUnliked";
				button.trigger(trigger, [data]);

				if (addingReaction && id != "") {
					var exclusion = $('[data-es-streams]').data('excludeids');
					var newIds = '';

					if (exclusion != '' && exclusion != undefined) {
						newIds = exclusion + ',' + id;
					} else {
						newIds = id;
					}

					$('[data-es-streams]').data('excludeids', newIds);
				}
			});
	});

	module.resolve();
});
			EasySocial.module('site/api/mobile', function($) {

var module = this;

if (window.es.mobile) {

	// Only process this when all DOM is laoded. #2789
	$('document').ready(function() {

		// Fix scrolling issue when mobile actions are rendered
		$('body').on('shown.bs.dropdown', function(event) {
			$('body').addClass('t-body-overflow-hidden');

			var target = $(event.target);
			var header = target.parents().hasClass('es-profile-header');

			if (header) {
				$('body').addClass('dropdown-mobile-from-header');
				return;
			}

			$('body').addClass('dropdown-mobile-from-container');
		});

		// Fix scrolling issue when mobile actions are rendered
		$('body').on('hide.bs.dropdown hidden.bs.dropdown', function() {
			$('body').removeClass('t-body-overflow-hidden dropdown-mobile-from-header dropdown-mobile-from-container');
		});

		// Prevent clicking on ul to close
		var dropdownButton = $('[data-bs-toggle=dropdown]');
		var dropdown = dropdownButton.siblings('.dropdown-menu');

		dropdown.on('click touchstart', function(event) {
			var target = $(event.target);

			if (target.is(dropdown)) {
				event.preventDefault();
				event.stopPropagation();
			}

			// User tapped on a link on the actions section
			if (target.is('a')) {

				if (target.attr('href') == 'javascript:void(0);') {
					return;
				}

				event.stopPropagation();

				var listItem = target.parent();
				listItem.addClass('is-loading');

				return;
			}
		});
	})
}

module.resolve();
});
			EasySocial.module('site/api/oauth', function($) {

var module = this;

$(document).on('click', '[data-oauth-login-button]', function() {
	
	var button = $(this);

	// Implement the controller on the parent
	var parent = button.closest("[data-oauth-login]");
	var controller = "EasySocial.Controller.OAuth.Login";

	if (parent.length < 1) {
		return;
	}
	
	if (parent.hasController(controller)) {
		return;
	}

	parent.addController(controller)
		.openDialog();
});


EasySocial.Controller('OAuth.Login', {
	defaultOptions: {
		"popup": {
			"width": 500,
			"height": 520
		},
		"{button}": "[data-oauth-login-button]"
	}
}, function(self, opts, base) { return {

	init: function() {
		opts.url = base.data('url');
	},

	openDialog : function() {
		var width = opts.popup.width;
		var height = opts.popup.height;
		var url = opts.url || self.button().data('url');
		var left = (screen.width/2) - (width / 2);
		var top = (screen.height/2) - (height / 2);

		window.open(url , "" , 'scrollbars=no,resizable=no,width=' + width + ',height=' + height + ',left=' + left + ',top=' + top);
	},

	"{button} click": function(button, event) {
		self.openDialog();
	}
}});


module.resolve();
});
			EasySocial.module('site/api/pages', function($) {

var module = this;
var pageLike = false;

// Page API
// Like Page
$(document).on('click.es.pages.like', '[data-es-pages-like]', function() {

	if (pageLike) {
		return;
	}

	pageLike = true;

	var button = $(this);
	var pageId = button.data('id');

	var like = "[data-page-like-count-"+pageId+"]";

	//Add loading indicator
	button.addClass('is-loading');

	EasySocial.ajax('site/controllers/pages/like', {
		"api": 1, 
		"id": pageId
	}).done(function(dialog, newButton, newLikeCount) {
			
		// Once the request is completed, we just replace the button
		if (newButton) {
			button.replaceWith(newButton);
			$(like).html(newLikeCount);
		} else {
			button.removeClass('is-loading');
		}

		if (dialog) {
			EasySocial.dialog({
				"content": dialog
			});
		}

		// Force page reload
		var reload = button.data('page-reload');

		if (reload) {
			location.reload(true);
		}
	}).always(function() {
		pageLike = false;
	});
});

var pageUnlike = false;

// Unlike page
$(document).on('click.es.pages.unlike', '[data-es-pages-unlike]', function() {
	var button = $(this);
	var pageId = button.data('id');
	var returnUrl = button.data('return');

	EasySocial.dialog({
		"content": EasySocial.ajax('site/views/pages/confirmUnlike', {
					"api": 1, 
					"id": pageId,
					"return": returnUrl
		}),
		"bindings": {
			"{unlikeButton} click": function() {
				if (pageUnlike) {
					return;
				}

				pageUnlike = true;
				this.unlikeForm().submit();
			}
		}
	});
});

// Withdraw request
$(document).on('click.es.pages.withdraw', '[data-es-pages-withdraw]', function() {
	var link = $(this);
	var id = link.data('id');
	var parent = link.closest('[data-request-sent]');

	EasySocial.ajax('site/controllers/pages/withdraw', {
		"id": id
	}).done(function(newButton) {
		parent.replaceWith(newButton);
	});
});

// Pages API - Respond to invitation request
$(document).on('click.es.pages.respond.invitation', '[data-es-pages-respond-invitation]', function() {
	var button = $(this);
	var pageId = button.data('id');

	button.addClass('is-loading');

	EasySocial.dialog({
		"content": EasySocial.ajax('site/views/pages/confirmRespondInvitation', {
			"id": pageId
		}),
		"bindings": {
			"{rejectButton} click" : function() {
				this.responseValue().val('reject');
				this.respondForm().submit();
			},
			"{acceptButton} click" : function() {
				this.responseValue().val('accept');
				this.respondForm().submit();
			}
		}
	});
});

// Page invite friends
$(document).on('click.es.page.invite', '[data-es-pages-invite]', function() {
	var element = $(this);
	var id = element.data('id');

	EasySocial.dialog({
		content: EasySocial.ajax('site/views/pages/invite', {"id" : id}),
		position: {
			my: "center top",
			at: "center top",
			of: window
		}
	})
})

// Page admin tools - Feature page
$(document).on('click.es.pages.admin.feature', '[data-es-pages-feature]', function() {
	var element = $(this);
	var id = element.data('id');
	var returnUrl = element.data('return');

	EasySocial.dialog({
		content: EasySocial.ajax('site/views/pages/confirmFeature', {"id" : id, "return": returnUrl})
	});
});

// Page admin tools - Unfeature page
$(document).on('click.es.pages.admin.feature', '[data-es-pages-unfeature]', function() {
	var element = $(this);
	var id = element.data('id');
	var returnUrl = element.data('return');

	EasySocial.dialog({
		content: EasySocial.ajax('site/views/pages/confirmUnfeature', {"id" : id, "return": returnUrl})
	});
});

// Page admin tools - Unpublish page
$(document)
	.on('click.es.pages.admin.unpublish', '[data-es-pages-unpublish]', function() {
		var element = $(this);
		var id = element.data('id');

		EasySocial.dialog({
			content: EasySocial.ajax('site/views/pages/confirmUnpublishPage', {"id" : id})
		});
	});

// Page admin tools - Delete page
$(document).on('click.es.pages.admin.delete', '[data-es-pages-delete]', function() {
	var element = $(this);
	var id = element.data('id');

	EasySocial.dialog({
		content: EasySocial.ajax('site/views/pages/confirmDelete', {"id" : id})
	});
});

module.resolve();
});
			EasySocial.module("site/api/photos", function($){

var module = this;

// Non-essential dependencies
EasySocial.require()
.script("site/photos/popup")
.done();

var DialogController = EasySocial.Controller("Photos.Dialog", { 
}, function(self) { return {

	init: function() {
		EasySocial.photos.selectPhoto = self.show;
	},

	show: function(options) {
		var task = $.Deferred();
		var dialog = EasySocial.ajax( "site/views/albums/dialog" , { "uid" : options.uid , "type" : options.type });
		var browser = EasySocial.require().script("site/albums/browser").done();

		// Show a loading indicator first
		EasySocial.dialog(
			$.extend({
			    content: task
			}, options)
		);

		$.when(browser, dialog)
			.done(function(){
				dialog.done(function(html){
					task.resolve(html);
				});
			});
	}

}});

EasySocial.Controller("Photos", {
}, function(self) { return {

	init: function() {

		// Extend EasySocial object
		EasySocial.photos = self;

		// Popup plugin
		EasySocial.module("site/photos/popup")
			.done(function(PopupController){
				self.popup = self.addPlugin("popup", PopupController);
			});

		// Dialog plugin
		// EasySocial.module("site/photos/dialog")
			// .done(function(DialogController){
		self.dialog = self.addPlugin("dialog", DialogController);
			// });
	},

	crop: function(id, options) {

		if (id == undefined) {
			return;
		}

		if (!options) {
			options = {};
		}

		var avatarOptions = { "id" : id };

		if (options.uid) {
			avatarOptions.uid = options.uid;
			delete options.uid;
		}

		if (options.type) {
			avatarOptions.type 	= options.type;
			delete options.type;
		}

		if (options.redirect) {

			// Legacy
			avatarOptions.redirect = options.redirect;

			// New way of passing redirect url
			avatarOptions.return = options.redirect;

			delete options.redirect;
		}


		EasySocial.dialog($.extend({
			"content": EasySocial.ajax('site/views/avatar/crop', avatarOptions)
		}, options));
	}

}});

// Add this controller to the html body;
$(function(){
	$("body").addController("EasySocial.Controller.Photos");
});

module.resolve();

});			EasySocial.module('site/api/popbox', function($) {

var module = this;

EasySocial.require()
.library("popbox")
.done(function($) {

	// System Notifications
	EasySocial.module("notifications/popbox", function($){

		this.resolve(function(popbox) {

			var autoread = popbox.button.data('autoread');

			return {

				content: EasySocial.ajax("site/controllers/notifications/getNotifications", {
					layout: "popbox.notifications"
				}).done(function(){

					if (autoread) {
						$('[data-notificationSystem-counter]').parents('li').removeClass('has-notice');
						$('[data-notificationSystem-counter]').html(0);
					}
				}),
				id: "es",

				// type: "notifications",
				cache: false
			};
		});
	});

	EasySocial.module("conversations/popbox", function($) {
		this.resolve(function(popbox) {
			var view = popbox.button.data('popbox-view');

			if (view == undefined) {
				view = '';
			}

			return {
				content: EasySocial.ajax("site/controllers/conversations/getNotificationItems", {
					"paginate": "1",
					"view": view,
					"layout": "popbox.conversations"
				}),
				id: "es",

				cache: false
			};
		});
	});

	// Friends notifications dropdown
	EasySocial.module("friends/popbox", function($){

		this.resolve(function(popbox) {

			return {
				content: EasySocial.ajax("site/controllers/friends/getRequests", {
								layout: "popbox.friends"
				}),
				id: "es",

				cache: false
			};
		});
	});

	// Reaction stats popbox
	EasySocial.module("likes/popbox", function($){

		this.resolve(function(popbox) {
			var wrapper = popbox.button.parents('[data-likes-content]');

			var options = {
				"uid": wrapper.data('id'),
				"type": wrapper.data('likes-type'),
				"group": wrapper.data('group'),
				"verb": wrapper.data('verb'),
				"streamid": false,
				"filter": popbox.button.data('reaction-item')
			};

			return {
				content: EasySocial.ajax("site/views/likes/popbox", options),
				hideDelay: 300,
				cache: false
			};
		});
	});

	// We should check if popbox should be initialized or not.
	var initPopbox = (EasySocial.options.lockdown && !EasySocial.options.guest) || !EasySocial.options.lockdown;

	if (initPopbox) {
		EasySocial.module("profile/popbox", function($) {

			this.resolve(function(popbox){

				var id = popbox.button.data("userId");
				var position = popbox.button.attr('data-popbox-position') || 'top-left';

				return {
					content: EasySocial.ajax("site/views/profile/popbox", {id: id}),
					id: "es",
					component: "",
					type: "profile",
					position: position,
					exclusive: true,
					hideDelay: 300
				}
			})
		});
	}
});

module.resolve();
});
			EasySocial.module("site/api/repost", function($){

var module 	= this;

EasySocial.require()
.library('mentions')
.done(function() {

	$(document)
		.on("click.es.repost.action", "[data-repost-action]", function(){
			var postAsHidden = $('[data-postas-base] [data-postas-hidden]');
			var shareAs = postAsHidden.length > 0 ? postAsHidden.val() : 'user';

			var button = $(this),
				data = {
					id: button.data('id'),
					element: button.data('element'),
					group: button.data('group'),
					clusterId: button.data('clusterid'),
					clusterType: button.data('clustertype'),
					shareAs: shareAs,
					streamId: button.data('streamid'),
				},
				key = data.element + '-' + data.group + '-' + data.id;


			EasySocial.dialog({
				content	: EasySocial.ajax('site/views/repost/form', data),
				selectors : {
					"{wrapper}" : "[data-repost-wrapper]"
				},
				bindings: {
					init: function() {

						// There could be instances where this dialog doesn't contain a form.
						if (!this.textbox) {
							return;
						}

						// Get available hints for friend suggestions and hashtags
						this.hints = {
								"friends": this.form().find('[data-hints-friends]'),
								"hashtags": this.form().find('[data-hints-hashtags]')
						};

						this.setMentionsLayout();
					},

					setMentionsLayout: function() {
						var textbox = this.textbox();
						var mentions = textbox.controller("mentions");

						if (mentions) {
							mentions.cloneLayout();
							return;
						}

						var header = this.header();

						textbox
							.mentions({
								triggers: {
									"@": {
										type: "entity",
										wrap: false,
										stop: "",
										allowSpace: true,
										finalize: true,
										query: {
											loadingHint: true,
											"searchHint": this.hints.friends.find('[data-search]').html(),
											"emptyHint": this.hints.friends.find('[data-empty]').html(),
											data: function(keyword) {

												var task = $.Deferred();

												EasySocial.ajax("site/controllers/friends/suggest", {search: keyword})
													.done(function(items){

														if (!$.isArray(items)) {
															task.reject();
														}

														var items = $.map(items, function(item){

															var html = $('<div/>').html(item);
															var title = html.find('[data-suggest-title]').val();
															var id = html.find('[data-suggest-id]').val();

															return {
																"id": id,
																"title": title,
																"type": "user",
																"menuHtml": item
															};
														});

														task.resolve(items);
													})
													.fail(task.reject);

												return task;
											},
											use: function(item) {
												return item.type + ":" + item.id;
											}
										}
									},
									"#": {
										type: "hashtag",
										wrap: true,
										stop: " #",
										allowSpace: false,
										query: {
											loadingHint: true,
											emptyHint: this.hints.hashtags.find('[data-empty]').html(),
											searchHint: this.hints.hashtags.find('[data-search]').html(),
											data: function(keyword) {

												var task = $.Deferred();

												EasySocial.ajax("site/controllers/hashtags/suggest", {search: keyword})
													.done(function(items){

														if (!$.isArray(items)) task.reject();

														var items = $.map(items, function(item){
															return {
																"title": "#" + $.trim(item),
																"type": "hashtag",
																"menuHtml": item
															};
														});

														task.resolve(items);
													})
													.fail(task.reject);

												return task;
											}
										}
									}
								},
								plugin: {
									autocomplete: {
										id: "es",
										component: "",
										modifier: "es-story-mentions-autocomplete",
										sticky: true,
										shadow: true,
										position: {
											my: 'left top',
											at: 'left bottom',
											of: header,
											collision: 'none'
										},
										size: {
											width: function() {
												return header.outerWidth(true);
											}
										}
									}
								}
							});
					},

					"{sendButton} click": function(sendButton) {
						var self = this;
						var dialog = this.parent;
						var content = $.trim(this.repostContent().val());
						var shareAs = sendButton.attr('data-share-as');

						// Add data content
						data.content = content;
						data.shareAs = shareAs;

						var mentions = this.textbox().mentions("controller").toArray();

						data.mentions = $.map(mentions, function(mention){
							if (mention.type==="hashtag" && $.isPlainObject(mention.value)) {
								mention.value = mention.value.title.slice(1);
							}
							return JSON.stringify(mention);
						});

						this.element.addClass('is-loading');

						EasySocial.ajax("site/controllers/repost/share", data)
							.done(function(content, isHidden, count, streamHTML) {
								var content = $.buildHTML(content);

								actionContent =
									$('[data-repost-' + key + ']')
										.toggleClass("hide", isHidden)
										.toggle(!isHidden);

								actionContent.find("span.repost-counter")
									.html(content);

								button.trigger("create", [streamHTML]);
							})
							.fail(function(message) {
								dialog.clearMessage();
								dialog.setMessage(message);
							})
							.always(function() {
								self.element.removeClass('is-loading');

								EasySocial.dialog().close();
							});

						this.disableAudio();
					},

					"{closeButton} click": function() {
						this.disableAudio();
						EasySocial.dialog().close();

					},

					"{cancelButton} click": function() {
						this.disableAudio();
						EasySocial.dialog().close();
					},

					disableAudio: function() {
						var audio = this.wrapper().find('[data-audio-player]');

						// If there is an audio player in preview, destroy it.
						if (audio.length > 0) {
							var audioController = audio.controller();

							audioController.player.destroy();
						}
					}
				}
			});
		});

	EasySocial.module("repost/authors", function() {
		this.resolve(function(popbox) {

			var id = popbox.button.data('id');
			var element = popbox.button.data('element');

			var options = {
				"id": id,
				"element": element
			};

			if (EasySocial.isMobile()) {
				popbox.button
					.off('popboxActivate')
					.on('popboxActivate', function() {
						$('body').addClass('has-es-popbox');
					});

				popbox.button
					.off('popboxDeactivate')
					.on('popboxDeactivate', function() {
						$('body').removeClass('has-es-popbox');
					});
			}

			return {
				content: EasySocial.ajax('site/controllers/repost/getRepostAuthors', options),
				id: "es",
				component: "",
				type: "repost",
				position: "bottom-right"
			}
		});
	});

	module.resolve();
});

});
			EasySocial.module("site/api/share", function($){

$(document)
	.on("click.es.share.button", "[data-es-share-button]", function(){

		var button = $(this);
		var self = this;

		EasySocial.dialog({
			"content":
				EasySocial.ajax("site/views/sharing/dialog", {
					"url": button.data("url"),
					"title": button.data("title")
				}),
			"bindings": {
				init: function() {
		            EasySocial
		            .require()
		            .script('site/utilities/sharing').done(function($) {
		                self.controller = $("[data-sharing]").addController("EasySocial.Controller.Sharing");
		            });
				},

				"{shareButton} click": function() {

					var controller = self.controller.getPlugin('email');

					controller.send();
				}
			}
		});
	});

	this.resolve();
});
			EasySocial.module('site/api/stream', function($) {

var module = this;

/*========================================================================
 * Capture events from the story form and trigger it on the stream.
 * This allows us to inject stuffs on the stream on trigger level
 *======================================================================== */
$(document)
	.on('create', '[data-story]', function(event, html, ids) {

		// Get the stream controller
		var stream = $('[data-es-streams]');

		if (stream.length <= 0) {
			return;
		}

		var stream = $('[data-es-streams]');
		var controller = stream.controller();

		if (ids != '') {
			controller.updateExcludeIds(ids);
		}

		controller.insertItem(html);
	});

$(document)
	.on('update', '[data-story]', function(event, html, id, preview, backgroundId, locationPreview, privacyHtml) {

		// Get the stream item
		var streamItem = $('[data-stream-list], [data-stream-sticky-list]').find('[data-id='+ id +']');
		var contents = streamItem.find('[data-contents]');
		var editor = streamItem.find('[data-editor]');

		contents.html(html);

		streamItem.removeClass('is-editing');

		if (backgroundId) {
			contents.switchClass('es-story--bg-' + backgroundId, 'es-story--bg-');
		} else {
			contents.switchClass('es-story--bg-0',  'es-story--bg-');
		}

		// Remove the editor form
		editor.empty();

		// Show the contents
		contents.removeClass('t-hidden');

		// update preview if there is any
		if (preview != undefined && preview.length > 0) {
			var previewEle = streamItem.find('[data-preview]');
			if (previewEle.length > 0) {

				if (previewEle.hasClass('t-hidden')) {
					previewEle.removeClass('t-hidden')
				}

				previewEle.html(preview);
			}
		}

		if (locationPreview != undefined && locationPreview.length > 0) {
			var previewEle = streamItem.find('[data-location-preview]');

			if (previewEle.length > 0) {
				previewEle.html(locationPreview);
			}
		}

		if (privacyHtml != undefined && privacyHtml.length > 0) {
			var privacyForm = streamItem.find('[data-es-privacy-form]');

			if (privacyForm.length > 0) {
				$(privacyForm).replaceWith($(privacyHtml));
			}
		}

	});


module.resolve();

});
			EasySocial.module('site/apps/apps', function($) {

var module = this;

EasySocial.require()
.library('history')
.done(function($) {

EasySocial.Controller('Apps', {
	defaultOptions : {
		"tnc": true,

		// Content area
		"{wrapper}": "[data-wrapper]",
		"{contents}": "[data-contents]",
		"{item}": "[data-item]",

		// Filters
		"{filterItem}": "[data-filter-item]",
		"{filterText}": "[data-filter-item-text]",
		"{activeText}": "[data-active-filter-text]",
		"{activeButton}": "[data-active-filter-button]",

		// Item actions
		"{install}": "[data-install]",
		"{uninstall}": "[data-uninstall]",
		"{settings}": "[data-settings]"
	}
}, function(self, opts) { return {
	init: function() {
		self.initDefaultFilter();
	},

	initDefaultFilter: function() {
		var activeFilter = self.filterItem('.active');

		self.setActiveFilter(activeFilter);
	},

	setActiveFilter: function(filterItem) {
		var text = filterItem.find(self.filterText.selector).clone();

		self.activeText().html(text);
		self.activeButton().removeClass('is-loading');

		// Remove all active classes
		self.filterItem().removeClass('active');

		// Add active class on itself
		filterItem.addClass('active');
	},

	setContents: function(contents) {
		self.wrapper().removeClass('is-loading');

		// Append the output back.
		self.contents().html(contents);
	},

	getAppId: function(element) {
		var item = self.getAppSelector(element);

		return item.data('id');
	},

	getAppSelector: function(element) {
		var item = $(element).closest(self.item.selector);

		return item;
	},

	installApp: function(id, selector) {

		var installing = EasySocial.ajax('site/controllers/apps/installApp', {
			"id": id
		}).done(function() {
			var uninstallButton = selector.find('[data-uninstall]');
			var settingsButton = selector.find('[data-settings]');

			uninstallButton.show();
			settingsButton.removeClass('t-hidden');
		});

		EasySocial.dialog({
			"content": installing,
			"bindings": {
				"{closeButton} click" : function(){
					EasySocial.dialog().close();
				}
			}
		});
	},

	"{filterItem} click": function(filterItem, event) {
		event.preventDefault();
		// event.stopPropagation();

		// Find the anchor
		var anchor = filterItem.find('a');
		anchor.route();

		// Remove the content.
		self.contents().empty();

		self.wrapper().addClass('is-loading');

		// Add active class to the current filter item.
		self.setActiveFilter(filterItem);

		// Get the filter type
		var type = filterItem.data("filter-item");

		EasySocial.ajax('site/views/apps/filter', {
			"filter": type
		}).done(function(output) {

			// Append the output into the content
			self.setContents(output);
		}).always(function(){

			self.wrapper().removeClass('is-loading');
			filterItem.removeClass("is-loading");
		});
	},

	"{install} click" : function(button, event) {
		var selector = self.getAppSelector(button);
		var id = self.getAppId(button);

		if (!opts.tnc) {
			// Hide the install button since it is already clicked
			button.hide();

			self.installApp(id, selector);

			return;
		}

		EasySocial.dialog({
			"content": EasySocial.ajax('site/views/apps/getTnc'),
			"bindings": {
				'{cancelButton} click': function() {
					EasySocial.dialog().close();
				},

				'{installButton} click': function(el) {
					var agreed = this.agreeCheckbox().is(':checked');

					if (!agreed) {
						this.termsError().show();
						return;
					}

					// Hide the install button since it is already clicked
					button.hide();

					self.installApp(id, selector);
				}
			}
		});
	},

	"{settings} click" : function(button, event) {
		var id = self.getAppId(button);

		EasySocial.dialog({
			"content": EasySocial.ajax("site/views/apps/settings", {"id" : id}),
			"bindings": {
				"{cancelButton} click": function() {
					this.parent.close();
				},

				"{saveButton} click" : function() {
					var data = this.form().serializeJSON();

					EasySocial.ajax('site/controllers/apps/saveSettings', {
						"data" : data,
						"id" : id
					}).done(function() {
						EasySocial.dialog({
							content : EasySocial.ajax('site/views/apps/saveSuccess')
						});
					});
				}
			}
		})
	},

	'{uninstall} click': function(button, event) {
		var selector = self.getAppSelector(button);
		var id = self.getAppId(button);

		if (!button.enabled()) {
			return;
		}

		EasySocial.dialog({
			"content": EasySocial.ajax('site/controllers/apps/uninstall', {"id": id})
				.done(function(){
					var installButton = selector.find('[data-install]');
					var settingsButton = selector.find('[data-settings]');
					installButton.show();
					button.hide();
					settingsButton.addClass('t-hidden');
				})
		});
	}
}});


module.resolve();
});

});
			EasySocial.module('site/apps/discussions/discussions', function($) {

var module = this;

EasySocial.Controller('Apps.Discussion.Item', {
	defaultOptions: {

		// Replies listing
		"{list}": "[data-reply-list]",
		"{replies}": "[data-reply-item]",
		"{repliesWrap}": "[data-replies-wrapper]",
		"{replyCounter}": "[data-reply-count]",

		// Main Discussion actions
		"{lock}": "[data-lock]",
		"{unlock}": "[data-unlock]",
		"{delete}": "[data-delete]",

		// Reply item actions
		"{itemWrapper}": "[data-discussion-item-wrapper]",
		"{item}": "[data-reply-item]",
		"{itemAcceptAnswer}": "[data-reply-accept-answer]",
		"{itemRejectAnswer}": "[data-reply-reject-answer]",
		"{itemDelete}": "[data-reply-delete]",
		"{itemEdit}": "[data-reply-edit]",
		"{itemCancelEdit}": "[data-reply-edit-cancel]",
		"{itemUpdate}": "[data-reply-edit-update]",
		"{itemEditor}": "[data-reply-editor]",
		"{itemPreview}": "[data-reply-preview]",
		"{itemAlert}": "div.alert-error",

		// Reply form
		"{replyForm}": "[data-reply-form]",
		"{submitReply}" : "[data-reply-submit]",
		"{textarea}": "[data-reply-editor][data-reply-editor-new]"
	}
}, function(self, opts) { return {

	init: function() {
		opts.id = self.element.data('id');
		opts.uid = self.element.data('uid');
		opts.type = self.element.data('type');
	},

	insertReply: function(html) {
		// Since we know that we need to append the reply item, we need to remove is-unanswered
		self.element.removeClass('is-unanswered');

		// Since an item is added, we want to remove the empty class.
		self.repliesWrap().removeClass('is-empty');

		// Append the new item
		var sorting = self.element.data('sorting') || 'asc';

		if (sorting == 'desc') {
			self.list().prepend(html);
			return;
		}

		self.list().append(html);
	},

	getReplyItem: function(element) {
		var item = element.closest(self.item.selector);

		return item;
	},

	updateReplyCounter: function(total) {

		if (total == 0) {
			self.repliesWrap().addClass( 'is-empty' );
		}

		self.replyCounter().html( total );
	},

	setResolved: function() {
		self.element.addClass('is-resolved');
	},

	setUnresolved: function() {
		self.element.removeClass('is-resolved');
	},

	"{textarea} keydown": function(textarea, event) {

		// Bind cmd + enter key to submit
		// If pressing enter submits form
		// And enter key was pressed
		// Without any meta keys involved
		if ((event.metaKey && event.keyCode == 13)|| (opts.enterToSubmit && event.keyCode==13 && !(event.shiftKey || event.altKey || event.ctrlKey || event.metaKey))) {
			self.submitReply().click();
			event.preventDefault();
		}
	},

	"{lock} click" : function(link, event) {

		EasySocial.ajax('site/controllers/discussions/lock', {
			"id": opts.id
		}).done(function() {
			self.itemWrapper().addClass('is-locked');
		});
	},

	"{unlock} click" : function(el , event) {

		EasySocial.ajax('site/controllers/discussions/unlock', {
			"id": opts.id
		}).done(function() {
			self.itemWrapper().removeClass('is-locked');
		});
	},

	"{delete} click" : function(el, event) {
		EasySocial.dialog({
			"content": EasySocial.ajax('site/views/discussions/confirmDelete', { "id" : opts.id})
		});
	},

	isReplying: false,

	disableForm: function() {
		self.textarea().attr('disabled', true);
		self.submitReply().disabled(true);

		self.isReplying = true;
	},

	enableForm: function() {
		self.textarea().removeAttr('disabled');
		self.submitReply().enabled(true);

		self.isReplying = false;
	},

	"{submitReply} click" : function(button, event) {
		var content = self.textarea().val();

		// If content is empty, throw some errors
		if (content == '') {
			self.replyForm().addClass('is-empty');
			return false;
		}

		if (self.isReplying) {
			return false;
		}

		// Disabled the form
		self.disableForm();

		EasySocial.ajax('site/controllers/discussions/reply', {
			"id": opts.id,
			"uid": opts.uid,
			"type": opts.type,
			"content": content
		}).done(function(html) {

			self.insertReply(html);

			// Reset the textarea
			self.textarea().val('');
		}).always(function() {
			self.enableForm();
		});

	},

	"{itemAcceptAnswer} click" : function(link, event) {
		var item = self.getReplyItem(link);
		var id = item.data('id');

		EasySocial.ajax('site/controllers/discussions/accept', {
			"id": id
		}).done(function() {
			self.setResolved();

			// Show all of the button first
			$(self.itemAcceptAnswer()).removeClass('t-hidden');
			$(self.itemRejectAnswer()).addClass('t-hidden');

			// Hide accept answer button
			$(link).addClass('t-hidden');

			// Show reject button
			item.find(self.itemRejectAnswer()).removeClass('t-hidden');

			item.siblings().removeClass('is-answer-item');
			item.addClass('is-answer-item');
		});
	},

	"{itemRejectAnswer} click" : function(link, event) {
		var item = self.getReplyItem(link);
		var id = item.data('id');

		EasySocial.ajax('site/controllers/discussions/reject', {
			"id" : id
		}).done(function() {
			self.setUnresolved();

			$(self.itemAcceptAnswer()).removeClass('t-hidden');
			$(self.itemRejectAnswer()).addClass('t-hidden');

			item.removeClass('is-answer-item');
		});
	},

	"{itemCancelEdit} click" : function(link, event) {
		var item = self.getReplyItem(link);
		var editForm = item.find(self.replyForm.selector);

		item.removeClass('is-editing');
		editForm.addClass('t-hidden');
	},

	"{itemEdit} click" : function(link, event) {
		var item = self.getReplyItem(link);
		var editForm = item.find(self.replyForm.selector);

		editForm.removeClass('t-hidden');

		item.addClass('is-editing');
	},

	"{itemUpdate} click" : function(button, event) {
		var item = self.getReplyItem(button);
		var id = item.data('id');
		var preview = item.find(self.itemPreview.selector);

		var editForm = button.closest(self.replyForm.selector);
		var content = editForm.find(self.itemEditor.selector).val();

		// If content is empty, throw some errors
		if (content == '') {
			editForm.addClass('is-empty');
			editForm.find(self.itemAlert.selector).show();
			return false;
		}

		EasySocial.ajax('site/controllers/discussions/update', {
			"id": id,
			"content": content
		}).done(function(content) {
			preview.html(content);

			editForm.addClass('t-hidden');
			editForm.removeClass('is-empty');
			editForm.find(self.itemAlert.selector).hide();
		});
	},

	"{itemDelete} click" : function(link, event) {
		var item = self.getReplyItem(link);
		var id = item.data('id');

		EasySocial.dialog({
			"content": EasySocial.ajax('site/views/discussions/confirmDeleteReply', {"id": id}),
			"bindings": {
				"{deleteButton} click" : function() {
					EasySocial.ajax('site/controllers/discussions/deleteReply', {
						"id": id
					}).done(function(totalReplies) {
						// Update the counter
						self.updateReplyCounter(totalReplies);

						// Hide the dialog
						EasySocial.dialog().close();

						// Remove the element
						item.remove();
					});
				}
			}
		});
	}
}});

module.resolve();
});

			EasySocial.module('site/apps/feeds/feeds', function($) {

var module = this;

EasySocial.Controller('Apps.Feeds', {
	defaultOptions: {
		"{browser}": "[data-feeds-browser]",
		"{sources}": "[data-feeds-lists]",
		"{item}": "[data-feed-item]",

		// Actions
		"{create}" : "[data-feeds-create]",
		"{remove}": "[data-feeds-remove]"
	}
}, function(self, opts, base) { return {

	init: function() {
		opts.id = base.data('uid');
		opts.appId = base.data('app');
	},

	"{create} click": function() {
		EasySocial.dialog({
			"content": EasySocial.ajax('site/views/feeds/create', {"id" : opts.id}),
			caller: self
		});
	},


	"{remove} click": function(link, event) {
		var item = link.parents(self.item.selector);
		var id = item.data('id');

		EasySocial.dialog({
			"content": EasySocial.ajax('site/views/feeds/confirmDelete', {"uid": opts.id, "id": id}),
			caller: self
		});
	}
}});

module.resolve();
});

			EasySocial.module('site/apps/news/news', function($) {

var module = this;

EasySocial.Controller('Apps.News.Item', {
    defaultOptions: {
        "{delete}": "[data-delete]",
        "{likes}": "[data-likes-action]",
        "{counter}": "[data-news-counter]",
        "{likeContent}": "[data-likes-content]",
    }
}, function(self, opts) { return {

    init : function() {
        opts.id = self.element.data('id');
    },

    //need to make the data-stream-counter visible
    "{likes} onLiked": function(el, event, data) {
        self.counter().removeClass('hide');
    },

    "{likes} onUnliked": function(el, event, data) {
        var hideCounter     = self.likeContent().hasClass( 'hide' );

        if (hideCounter) {
            self.counter().addClass( 'hide' );
        }
    },

    "{delete} click" : function(button, event) {
        EasySocial.dialog({
            "content": EasySocial.ajax('site/views/news/confirmDelete' , { "id" : opts.id})
        });
    }

}});

module.resolve();

});

			EasySocial.module('site/apps/reviews/filter', function($){

var module = this;

EasySocial.require()
.script('site/apps/reviews/reviews')
.done(function($) {

EasySocial.Controller('Apps.Reviews.Filter', {
	defaultOptions: {
		"{filterWrapper}": "[data-es-reviews-filter]",
		"{filter}": "[data-es-reviews-filter] [data-review-filter]",
		"{filterController}": "[data-es-structure] [data-es-reviews]"
	}
}, function(self,opts,base) { return {

	init : function() {
		self.controller = self.getController();
	},

	getController: function() {
		var controller = self.filterController().controller();
		return controller;
	},

	setActiveFilter: function(filter) {

		var activeClass = (window.es.mobile || window.es.tablet || window.es.ios) ? 'is-active' : 'active';

		self.filter().removeClass(activeClass);

		filter.addClass(activeClass);
	},

	"{filter} click": function(filter, event) {

		if (self.controller === undefined) {
			return;
		}

		event.preventDefault();
		event.stopPropagation();

		var type = filter.data('review-filter');

		self.setActiveFilter(filter);

		self.controller.getItems(type, self.clusterId, function(contents, empty) {
			filter.removeClass('is-loading');
		});
	}
}});

module.resolve();

});
});
			EasySocial.module('site/apps/reviews/reviews', function($) {

var module = this;


EasySocial.Controller('Apps.Review', {
	defaultOptions: {
		"{wrapper}": "[data-reviews-wrapper]",
		"{contents}": "[data-reviews-contents]",
		"{delete}": "[data-delete]",
		"{approve}": "[data-approve]",
		"{reject}": "[data-reject]",
		"{withdraw}": "[data-withdraw]",
		"{mobileFilter}": "[data-es-mobile-filters] [data-review-filter]",
		"{item}": "[data-review-item]"
	}
}, function(self, opts) { return {

	init: function() {
		opts.id = self.element.data('id');
		opts.uid = self.element.data('uid');
		opts.type = self.element.data('type');
	},

	"{delete} click" : function(el, event) {

		var item = el.parents(self.item().selector);
		var id = item.data('id');

		EasySocial.dialog({
			"content": EasySocial.ajax('site/views/reviews/confirmDelete', { "id" : id})
		});
	},

	"{approve} click" : function(el, ev) {

		var item = el.parents(self.item().selector);
		var id = item.data('id');

		EasySocial.dialog({
			"content": EasySocial.ajax('site/views/reviews/confirmApprove', { "id" : id})
		});
	},

	"{reject} click" : function(el, ev) {

		var item = el.parents(self.item().selector);
		var id = item.data('id');

		EasySocial.dialog({
			"content": EasySocial.ajax('site/views/reviews/confirmReject', { "id" : id})
		});
	},

	"{withdraw} click" : function(el, ev) {

		var item = el.parents(self.item().selector);
		var id = item.data('id');

		EasySocial.dialog({
			"content": EasySocial.ajax('site/views/reviews/confirmWithdraw', { "id" : id})
		});
	},

	setActiveFilter: function(filter) {
		self.mobileFilter().removeClass('active');
		filter.addClass('active');
	},

	updatingContents: function() {
		self.contents().html('&nbsp;');
		self.wrapper().removeClass('is-empty').addClass('is-loading');
	},

	updateContents: function(html, empty) {
		self.wrapper().removeClass('is-loading');
		self.contents().html(html);

		if (empty) {
			self.wrapper().addClass('is-empty');
		} else {
			self.wrapper().removeClass('is-empty');
		}
	},

	"{mobileFilter} click" : function(el, ev) {
		var type = el.data('review-filter');

		self.setActiveFilter(el);

		self.getItems(type);
	},

	getItems: function(type, callback) {

		self.updatingContents();

		EasySocial.ajax('site/controllers/reviews/getReviews', {
			"id": opts.id,
			"type": opts.type,
			"filter": type
		}).done(function(contents, empty) {
			if ($.isFunction(callback)) {
				callback.call(this, contents, empty);
			}

			self.updateContents(contents, empty);
		});
	}
}});

module.resolve();
});

			EasySocial.module('site/apps/tasks/filter', function($){

var module = this;

EasySocial.Controller('Apps.Tasks', {
	defaultOptions: {

		// New task button
		"{create}": "[data-create]",
		"{form}": "[data-form]",

		// New task form
		"{title}": "[data-form-title]",
		"{cancel}": "[data-form-cancel]",
		"{save}": "[data-form-save]",

		// Contents
		"{content}": "[data-app-contents]",
		"{lists}": "[data-lists]",

		// Item
		"{item}": "[data-item]",
		"{checkbox}": "[data-item-checkbox]",
		"{delete}": "[data-item-delete]",

		// Filters
		"{filter}": "[data-tasks-filter]",
		"{filterLinks}" : "[data-tasks-filter] > a"
	}
}, function(self, opts) { return {

	removeItem: function(item) {

		item.remove();

		// Determines if there's any else left on the page
		if (self.item().length == 0) {
			self.content().addClass('is-empty');
		}
	},

	insertItem: function(item) {
		item.prependTo(self.lists());
	},

	"{create} click" : function() {

		// If this is on mobile, we need to toggle the filter
		if (window.es.mobile) {
			var filter = $('[data-es-mobile-filters]');

			if (filter.length > 0) {
				filter.click();
			}
		}

		self.content().removeClass('is-empty');
		self.form().removeClass('t-hidden');
	},


	"{save} click" : function() {
		var val = self.title().val();

		if (val == "") {
			return;
		}

		EasySocial.ajax('apps/user/tasks/controllers/tasks/save', {
			"title"	: self.title().val()
		}).done(function(item) {
			self.insertItem($(item));
			self.title().val('');
		});
	},

	"{title} keyup" : function(input, event) {

		// Enter key
		if (event.keyCode == 13) {
			self.save().click();
		}

		// Escape key
		if (event.keyCode == 27) {
			self.cancel().click();
		}
	},

	"{cancel} click" : function() {
		self.title().val('');
		self.form().addClass('t-hidden');
	},

	"{filter} click" : function(filter, event) {
		var type = filter.data('tasks-filter');

		// Set active filter
		self.filter().removeClass('active');
		filter.addClass('active');

		// Show all
		if (type == 'all') {
			var total = self.item().show();

			if (!total.length) {
				self.content().addClass('is-empty');
				return;
			}

			self.content().removeClass('is-empty');

			return;
		}

		// Remove empty state
		self.content().removeClass('is-empty');

		// Hide all items
		self.item().hide();

		// Show only specific types.
		var total = self.item('.' + type).show();

		// If there is no content, add the empty state
		if (!total.length) {
			self.content().addClass('is-empty');
		}
	},

	"{checkbox} change" : function(checkbox, event) {
		var checked = checkbox.is(":checked");
		var task = checked ? 'resolve' : 'unresolve';
		var item = checkbox.closest(self.item.selector);
		var id = item.data('id');

		if (task == 'resolve') {
			item.removeClass('is-unresolved').addClass('is-resolved');
		}

		if (task == 'unresolve') {
			item.removeClass('is-resolved').addClass('is-unresolved');
		}

		EasySocial.ajax('apps/user/tasks/controllers/tasks/' + task, {
			"id": id
		}).done(function() {
		});
	},

	"{delete} click" : function(link, event) {
		var item = link.closest(self.item.selector);
		var id = item.data('id');

		EasySocial.ajax( 'apps/user/tasks/controllers/tasks/remove' , {
			"id": id
		}).done(function() {
			self.removeItem(item);
		});
	}

}});

module.resolve();

});
			EasySocial.module('site/apps/tasks/tasks', function($) {

var module = this;

EasySocial.require()
.script('site/members/suggest')
.done(function($){

	$(document)
	.on('change.tasks.app', '[data-task-checkbox]', function() {
		var checkbox = $(this);
		var id = checkbox.data('id');
		var checked = checkbox.is(':checked');

		if (checked) {
			EasySocial.ajax('site/controllers/tasks/resolveTask', {
				"id": id
			}).done(function() {

			});
		} else {

			EasySocial.ajax('site/controllers/tasks/unresolveTask', {
				"id": id
			}).done(function() {

			});
		}
	});


	EasySocial.Controller('Apps.Tasks.Milestones.Form', {
		defaultOptions: {
			// Wrapper for suggest to work.
			"{memberSuggest}": "[data-members-suggest]",
			"exclusion": []
		}
	}, function(self, opts) { return {

		init: function() {

			opts.id = self.element.data('id');

			// console.log(opts.id);
			opts.uid = self.element.data('uid');

			// bind member suggest controller
			self.memberSuggest().addController(EasySocial.Controller.Members.Suggest, {"uid": opts.uid, "max": 1, "exclusion": opts.exclusion});
		}
	}});



	EasySocial.Controller('Apps.Tasks.Milestones.Browse', {
		defaultOptions: {
			eventId: null,
			"{milestone}": "[data-tasks-milestone-item]"
		}
	}, function(self, opts) { return {

		init: function() {
			opts.id = self.element.data('id');
			opts.type = self.element.data('type');

			self.milestone().addController(EasySocial.Controller.Apps.Tasks.Milestones.Item, {
				"{parent}": self,
				"return": opts.return
			});
		}
	}});

	EasySocial.Controller('Apps.Tasks.Milestones.Item', {
		defaultOptions: {
			"{task}": "[data-milestone-task]",
			"{delete}": "[data-milestone-delete]",
			"{milestone}": "[data-event-tasks-milestone-item]"
		}
	}, function(self, opts) { return {

		init: function() {
			opts.id = self.element.data('id');
		},

		"{task} click" : function(link, event) {
			var task = link.data('milestone-task');

			EasySocial.ajax('site/controllers/tasks/' + task, {
				"id": opts.id
			}).done(function() {

				if (task == 'resolve') {
					self.element
						.removeClass('is-due')
						.addClass('is-completed');
				}

				if (task == 'unresolve') {
					self.element
						.removeClass('is-completed')
						.addClass('is-due');
				}
			});
		},

		"{delete} click" : function() {


			EasySocial.dialog( {
				content : EasySocial.ajax('site/views/tasks/confirmDeleteMilestone', {
					"id": opts.id,
					"return": opts.return
				})
			});
		}
	}});

EasySocial.Controller('Apps.Tasks', {
	defaultOptions: {

		// Creating task items form
		"{create}": "[data-create]",
		"{input}": "[data-form-input]",
		"{assignee}": "[data-suggest-id]",
		"{edit}": "[data-task-edit]",
		"{cancelEdit}": "[data-cancel-edit]",
		"{saveEdit}": "[data-save-edit]",

		"{due}": "[data-form-due]",
		"{error}": "[data-form-error]",
		"{form}": "[data-form]",
		'{formWrapper}': '[data-tasks-form-wrapper]',
		'{taskList}': '[data-tasks-list]',

		// Tasks item
		"{item}": "[data-item]",
		'{checkbox}': '[data-item-checkbox]',
		'{deleteItem}': '[data-remove]',

		// Wrapper for suggest to work.
		"{memberSuggest}": "[data-members-suggest]",

		"{viewOpenTasks}": "[data-view-open-tasks]",

		// Completed list
		'{completedList}': '[data-tasks-completed]',

		// Counters
		'{openCounter}': '[data-tasks-open-counter]',
		'{closedCounter}': '[data-tasks-closed-counter]',

		"{completeMilestone}": "[data-milestone-mark-complete]",
		"{uncompleteMilestone}": "[data-milestone-mark-incomplete]",
		"{deleteMilestone}": "[data-milestone-delete]",
		"{wrapper}": "[data-tasks-wrapper]"
	}
}, function(self, opts) { return {

	init: function() {
		opts.id = self.element.data('id');

		// console.log(opts.id);
		opts.uid = self.element.data('uid');

		// bind member suggest controller
		self.memberSuggest().addController(EasySocial.Controller.Members.Suggest, {"uid": opts.uid, "max": 1});

	},

	updateOpenCounter: function(total) {
		self.openCounter().html(total);
	},

	updateClosedCounter: function(total) {
		self.closedCounter().html(total);
	},

	insertCompleted: function(task) {
		task.appendTo(self.completedList());
	},

	insertTask: function(task) {
		self.taskList().prepend(task);
	},

	resetForm: function() {
		var form = self.form();

		form[0].reset();
	},

	updateCounter: function(resolved) {
		var totalOpen = parseInt(self.openCounter().html());
		var totalClosed = parseInt(self.closedCounter().html());

		if (resolved) {
			self.updateOpenCounter(totalOpen - 1);
			self.updateClosedCounter(totalClosed + 1);
		} else {
			self.updateOpenCounter(totalOpen + 1);
			self.updateClosedCounter(totalClosed - 1);
		}
	},

	"{input} keyup" : function(el, event) {

		if(event.keyCode == 13) {
			self.create().click();
		}
	},

	"{saveEdit} click" : function(button) {

		button.addClass('is-loading');

		var taskId = button.data('save-edit-task-id');

		// Get the updated title
		var title = $('[data-edit-title-value]').val();

		if (title == '') {
			self.error().removeClass('t-hidden');
			return false;
		}

		// Hide the error message if there is title
		self.error().addClass('t-hidden');

		// Get the updated due date and assignee
		var due = $('[data-edit-due-value]').val();
		var user = self.assignee();
		var assignee = '';

		if (user !== undefined) {
			assignee = user.val();
		}

		EasySocial.ajax('site/controllers/tasks/saveEditedTask', {
			"title": title,
			"assignee": assignee,
			"due": due,
			"taskId": taskId
		}).done(function(task) {

			button.removeClass('is-loading');

			self.viewOpenTasksList();
		});
	},

	"{create} click" : function(button, event) {
		var title = self.input().val();

		if (title == '') {
			self.error().removeClass('t-hidden');
			return false;
		}

		// Hide the error message
		self.error().addClass('t-hidden');

		// Get the other properties
		var user = self.assignee();
		var assignee = '';

		if (user !== undefined) {
			assignee = user.val();
		}

		var due = self.due().val();

		EasySocial.ajax('site/controllers/tasks/saveTask', {
			"title": title,
			"assignee": assignee,
			"due": due,
			"milestoneId": opts.id
		}).done(function(task) {

			// Reset the form
			self.resetForm();

			// Increment the counter
			var total = parseInt(self.openCounter().html());
			self.updateOpenCounter(total + 1);

			// self.insertTask(task);

			// after create a new task, it will always show in the correct order
			self.viewOpenTasksList();
		});
	},

	"{uncompleteMilestone} click" : function() {
		EasySocial.ajax('site/controllers/tasks/unresolve', {
			id: opts.id
		}).done(function() {
			self.wrapper().removeClass('is-due').removeClass('is-completed');
		});
	},

	"{completeMilestone} click" : function() {
		EasySocial.ajax('site/controllers/tasks/resolve', {
			id: opts.id
		})
		.done(function() {
			self.wrapper().removeClass('is-due').addClass('is-completed');
		});
	},

	"{deleteMilestone} click" : function() {
		EasySocial.dialog({
			content : EasySocial.ajax('site/views/tasks/confirmDeleteMilestone', {
				"id": opts.id,
				"return": opts.return
			})
		});
	},


	'{deleteItem} click' : function(link, event) {
		var item = link.closest(self.item.selector);
		var id = item.data('id');
		var checked = item.find(self.checkbox.selector).is(':checked');

		EasySocial.ajax('site/controllers/tasks/deleteTask', {
			"id": id
		}).done(function() {

			if (checked) {
				var total = parseInt(self.closedCounter().html());
				self.updateClosedCounter(total - 1);
			}

			if (!checked) {
				var total = parseInt(self.openCounter().html());
				self.updateOpenCounter(total - 1);
			}

			item.remove();
		});
	},

	'{viewOpenTasks} click': function() {
		self.viewOpenTasksList();
	},

	'{edit} click': function(el) {

		var task_id = el.data('task-id');

		EasySocial.ajax('site/views/tasks/editTask', {
			"task_id": task_id
		}).done(function(output, taskId){
			var itemToEdit = "[data-id=" + taskId + "]";
			var taskList = $('[data-tasks-list]');
			var item = taskList.find(itemToEdit);

			// Hide the selected task item and show its edit form
			item.addClass('t-hidden');

			$('[data-tasks-list]').find("[data-edit-task-id=" + taskId + "]").removeClass('t-hidden');
			$('[data-tasks-list]').find("[data-edit-task-id=" + taskId + "]").html(output);
		});
	},

	"{cancelEdit} click": function(el) {
		var task_id = el.data('cancel-task-id');
     	var itemToEdit = "[data-id=" + task_id + "]";
		var taskList = $('[data-tasks-list]');
		var item = taskList.find(itemToEdit);

		item.removeClass('t-hidden');
		$('[data-tasks-list]').find("[data-edit-task-id=" + task_id + "]").addClass('t-hidden');
    },

	viewOpenTasksList: function() {

		var cluster_id = self.element.data('uid');
		var milestoneId = self.element.data('id');
		var type = self.element.data('task-cluster-type');

		EasySocial.ajax('site/views/tasks/viewOpenTasks', {
			"milestone_id": milestoneId,
			"cluster_id": cluster_id,
			"cluster_type": type
		}).done(function(output){
			$('[data-task-select-open]').html(output);
		});
	},

	'{checkbox} change': function(checkbox, event) {

		var checked = checkbox.is(':checked');
		var task = checked ? 'resolveTask' : 'unresolveTask';
		var item = checkbox.closest(self.item.selector);
		var id = item.data('id');


		EasySocial.ajax('site/controllers/tasks/' + task, {
			"id": id
		}).done(function() {

			self.updateCounter(checked);

			if (task == 'resolveTask') {
				self.insertCompleted(item);
			} else {
				self.insertTask(item);
			}
		});

	}
}});


module.resolve();
});

});

			EasySocial.module('site/articles/suggest', function($){

var module = this;

EasySocial.require()
.library('textboxlist')
.done(function($) {

EasySocial.Controller('Articles.Suggest', {
	defaultOptions: {
		max: null,
		exclusive: true,
		exclusion: [],
		minLength: 1,
		highlight: true,
		uid: "",
		name: "article_id",
		type: "",

		// Namespace to query for suggestions
		"query": {
			"articles": "admin/controllers/articles/suggest"
		}
	}
}, function(self, opts, base) { return {

	init: function() {

		// Implement the textbox list on the implemented element.
		self.element
			.textboxlist({
				"component": 'es',
				"name": opts.name,
				"max": opts.max,
				"plugin": {
					"autocomplete": {
						"exclusive": opts.exclusive,
						"minLength": opts.minLength,
						"highlight": opts.highlight,
						"showLoadingHint": true,
						"showEmptyHint": true,

						query: function(keyword) {

							var options = {
											"search": keyword,
											"inputName": opts.name
										};

							return EasySocial.ajax(opts.query.articles, options);
						}
					}
				}
			})

			self.element.textboxlist('enable');

			// Search for saved value
			var savedValue = self.element.find('[data-textboxlist-item]').data('title');

			if (savedValue) {
				self.element.find('[data-textboxlist-textField]').addClass('t-hidden');
				self.element.textboxlist('disable');
			}
	},

	"{self} filterItem": function(el, event, item) {

		var html = $('<div/>').html(item.html);
		var wrapper = html.find('[data-suggest]');

		var title = wrapper.data('suggest-title');
		var id = wrapper.data('suggest-id');

		item.id = id;
		item.title = title;
		item.menuHtml = item.html;
	},

	"{self} addItem": function(el, event, item) {
		var input = self.element.find('[data-fields-config-param]');

		input.val(item.id);
		input.trigger('change');

		self.element.textboxlist("disable");
	},

	"{self} removeItem": function(el, event, item) {
		var input = self.element.find('[data-fields-config-param]');

		input.val('');
		input.trigger('change');

		self.element.find('[data-textboxlist-textField]').removeClass('t-hidden');
		self.element.textboxlist("enable");		
	}
}});

module.resolve();
});

});

			EasySocial.module('site/audios/browser', function($) {

var module = this;

EasySocial.Controller('Audios.Browser', {
	defaultOptions: {
		"{sorting}": "input[name='sorting']",
		"{sortItem}": "[data-sorting]",
		"{counters}": "[data-counter]",

		// content wrapper
		"{wrapper}": "[data-wrapper]",

		// Audios result
		"{result}": "[data-audios-result]",
		"{list}": "[data-result-list]",

		// Audio actions
		"{item}": "[data-audio-item]",
		"{deleteButton}": "[data-audio-delete]",
		"{featureButton}": "[data-audio-feature]",
		"{unfeatureButton}": "[data-audio-unfeature]",
		"{playlistItem}": "[data-playlist-item]"
	}
}, function(self, opts, base) { return {

	clicked: false,
	currentFilter: "",
	currentSorting: "",
	genreId: null,
	isSort: false,

	getPlaylist: function(playlistId, callback) {

		self.wrapper().addClass('is-loading');
		self.result().empty();

		EasySocial.ajax('site/views/audios/loadPlaylist', {
			id: playlistId
		}).done(function(output) {

			if (typeof(callback) == 'function') {
				callback.apply(output);
			}

			self.activeFilter.parent().removeClass('is-loading');

			self.result().html(output);
			self.wrapper().removeClass('is-loading');

			$('body').trigger('afterUpdatingContents', [output]);
		});
	},

	getAudios: function(callback) {

		if (!self.currentSorting) {
			// Set the current sorting
			self.currentSorting = self.sorting().val();
		}

		if (!self.currentFilter) {
			// Set the current sorting
			self.currentFilter = self.activeFilter.data('type');
		}

		// if still empty the filter, just set to all.
		if (!self.currentFilter) {
			self.currentFilter = "all";
		}

		var isSortReq = self.isSort ? "1" : "0";

		EasySocial.ajax('site/controllers/audios/getAudios',{
			"filter": self.currentFilter,
			"genreId": self.genreId,
			"sort": self.currentSorting,
			"uid": opts.uid,
			"type": opts.type,
			"hashtags": opts.hashtag,
			"hashtagFilterId": self.hashtagId,
			"isSort": isSortReq
		}).done(function(output) {

			if (typeof(callback) == 'function') {
				callback.apply(output);
			}

			if (self.isSort) {
				self.result().removeClass('is-loading');
				self.list().html(output);
			} else {
				self.wrapper().removeClass('is-loading');
				self.result().html(output);
			}

			$('body').trigger('afterUpdatingContents', [output]);
		});
	},

	"{sortItem} click" : function(sortItem, event) {

		// Get the sort type
		var type = sortItem.data('type');
		self.currentSorting = type;

		if (!self.hashtagId) {
			self.hashtagId = sortItem.data('tag-id');
		}

		var sortFilter = sortItem.data('filter');

		if (sortFilter == 'genre') {
			self.genreId = sortItem.data('id');
		}

		self.isSort = true;

		// Route the item so that we can update the url
		sortItem.route();

		self.result().addClass('is-loading');
		self.list().empty();

		self.getAudios();
	},

	"{deleteButton} click": function(deleteButton, event) {

		var item = deleteButton.parents(self.item.selector);
		var id = item.data('id');
		var returnUrl = deleteButton.data('return');

		var options = {
			"id": id
		};

		if (returnUrl) {
			options["return"] = returnUrl;
		}

		EasySocial.dialog({
			content: EasySocial.ajax('site/views/audios/confirmDelete', options)
		});
	},

	"{unfeatureButton} click": function(unfeatureButton, event) {
		var item = unfeatureButton.parents(self.item.selector);
		var id = item.data('id');
		var returnUrl = unfeatureButton.data('return');

		var options = {
			"id": id
		};

		if (returnUrl.length > 0) {
			options["return"] = returnUrl;
		}

		EasySocial.dialog({
			content: EasySocial.ajax('site/views/audios/confirmUnfeature', options)
		});
	},

	"{featureButton} click": function(featureButton, event) {
		var item = featureButton.parents(self.item.selector);
		var id = item.data('id');
		var returnUrl = featureButton.data('return');

		var options = {
			"id": id
		};

		if (returnUrl) {
			options["return"] = returnUrl;
		}

		EasySocial.dialog({
			content: EasySocial.ajax('site/views/audios/confirmFeature', options)
		});
	},

	"{playlistItem} click": function(playlistItem, event) {
		var item = playlistItem.parents(self.item.selector);
		var audioId = item.data('id');
		var playlistId = playlistItem.data('id');
		var previouslyAdded = playlistItem.find('i').length > 0;
		var overlayNotice = item.find('[data-overlay-notice]');

		EasySocial.ajax('site/controllers/audios/addToPlaylist',{
			"playlistId": playlistId,
			"audioId": audioId
		}).done(function(message) {
			self.trigger('updateListCounters');

			if (previouslyAdded === false) {
				playlistItem.append('<i class="fa fa-check pull-right"></i>');
			}

			overlayNotice.fadeIn('fast');

			setTimeout(function(){
				overlayNotice.fadeOut('slow');
			}, 2000);
		});
	}
}});

module.resolve();


});
			EasySocial.module('site/audios/filter', function($) {

var module = this;

EasySocial.require()
.script('site/audios/browser')
.done(function($) {

EasySocial.Controller('Audios.Filter', {
	defaultOptions: {
		"{filter}": "[data-es-audio-filters] [data-filter-item]",
		"{createFilter}": "[data-audio-create-filter]",
		"{browserController}": "[data-audios-listing]"
	}
}, function(self, opts, base) { return {

	controller: null,

	getController: function() {
		var controller = self.browserController().controller();

		return controller;
	},

	init: function() {
		self.controller = self.getController();

		if (self.controller) {
			self.controller.activeFilter = self.filter('[data-type=' + opts.active + ']');
		}
	},

	setActiveFilter: function(filter) {
		self.filter().removeClass('active');

		filter.addClass('active');

		// Update the URL on the browser
		filter.find('a').route();

		// Set loading on the correct filter
		filter.addClass('is-loading');
	},

	"{filter} click": function(filter, event) {

		// Since controller doesn't exist, we should just redirect to the view
		if (!self.controller) {
			return;
		}

		// Prevent bubbling up
		event.preventDefault();
		event.stopPropagation();

		var type = filter.data('type');

		// Route the inner filter links
		if (filter.is('a')) {
			filter.route();
		} else {
			filter.find('a').route();
		}

		// Add an active state to the parent
		self.setActiveFilter(filter);

		// If this is list filter, we generate the playlist player
		if (type == 'list') {
			playlistId = filter.data('id');

			self.controller.getPlaylist(playlistId, function() {
				filter.removeClass('is-loading');
				filter.parent().removeClass('is-loading');
			});
			return;
		}

		// Filter by genre
		var genreId = null;

		if (type == 'genre') {
			type = 'all';
			genreId = filter.data('id');
		}

		var hashtagId = null;

		if (type == 'hashtag') {
			hashtagId = filter.data('tagId');
		}

		// Set the current filter
		self.controller.currentFilter = type;
		self.controller.genreId = genreId;
		self.controller.isSort = false;
		self.controller.hashtagId = hashtagId;

		self.controller.result().empty();
		self.controller.wrapper().addClass('is-loading');

		self.controller.getAudios(function() {

			filter.removeClass('is-loading');
			filter.parent().removeClass('is-loading');
			self.filter().parent().removeClass('active');
		});

		self.controller.trigger('onEasySocialFilterClick');
	},

	"{self} updateListCounters": function() {

		EasySocial.ajax('site/controllers/audios/getListCounts')
		.done(function(lists) {

			$(lists).each(function(i, list){
				self.filter('[data-type="list"][data-id="' + list.id + '"]')
					.siblings(self.counters.selector)
					.html(list.count);
			});
		});
	},

	"{createFilter} click": function(filter, event) {

		// Prevent default
		event.preventDefault();
		event.stopPropagation();

		EasySocial.dialog({
			"content": EasySocial.ajax('site/views/audios/getFilterFormDialog', {
				"id": filter.data('id'),
				"cid": filter.data('uid'),
				"clusterType": filter.data('clusterType')
			})
		});
	}
}});

module.resolve();
});


});
			EasySocial.module('site/audios/form', function($) {

var module = this;

EasySocial.require()
.script('site/friends/suggest', 'site/albums/uploader')
.library('mentions')
.done(function($) {

EasySocial.Controller('Audios.Form', {
	defaultOptions: {
		defaultAlbumart: null,
		importMetadata: false,

		"{audioSource}": "[data-audio-source]",
		"{albumartSource}": "[data-albumart-source]",
		"{form}": "[data-audios-form]",
		"{albumartForm}": "[data-form-albumart]",
		"{albumartFrame}": "[data-albumart-frame]",
		"{removeButton}": "[data-albumart-remove-button]",

		// Forms for audio source
		"{forms}": "[data-form-source]",
		"{linkForm}": "[data-form-link]",
		"{uploadForm}": "[data-form-upload]",
		"{file}": "[data-audio-file]",
		"{linkSource}": "[data-audio-link]",
		"{albumArt}": "[data-audio-albumart]",
		"{albumartData}": "[data-audio-albumart-data]",
		"{browseButton}": "[data-browse-button]",

		// Mentions
		"{mentions}": "[data-mentions]",
		"{hashtags}": "[data-hashtags]",
		"{header}": "[data-hashtags-header]",

		// Fields
		"{title}": "[data-audio-title]",
		"{desc}": "[data-audio-desc]",
		"{artist}": "[data-audio-artist]",
		"{album}": "[data-audio-album]",
		"{filename}": "[data-audio-filename]",
		"{albumartFilename}": "[data-audio-albumart-filename]",

		"{saveButton}": "[data-save-button]"
	}
}, function(self, opts, base) { return {

	init: function() {
		self.initMentions();

		// Get available hints for friend suggestions and hashtags
		opts.hints = {
			"friends": self.element.find('[data-hints-friends]'),
			"hashtags": self.element.find('[data-hints-hashtags]')
		};

		// Apply the mentions on the comment form
		self.setMentionsLayout();
	},

	'{file} change' : function(el , event) {

		if($.isEmpty(el.val())) {
			return;
		}

		var label = el.val().replace(/\\/g, '/').replace(/.*\//, '');

		el.parents('.o-input-group').find(':text').val(label);

		if (self.options.importMetadata === '0') {
			return;
		}

		self.browseButton().addClass('is-loading');

		EasySocial.ajax('site/controllers/audios/importMetadata' , {
			files: el
		}, {
			type: 'iframe'
		}).done(function(result){

			// Once get the metadata, we fill in the field
			if (result['title']) {
				self.title().val(result['title'])
			}

			if (result['description']) {
				self.desc().val(result['description'])
			}

			if (result['artist']) {
				self.artist().val(result['artist'])
			}

			if (result['album']) {
				self.album().val(result['album'])
			}

			self.browseButton().removeClass('is-loading');

		}).fail(function(msg) {

		});
	},

	'{linkSource} focusout' : function(el, ev) {

		var url = el.val();

		if (url.length == 0) {
			return;
		}

		self.linkForm().addClass('is-loading');

		self.clearError(self.linkForm());

		EasySocial.ajax('site/controllers/audios/processLink', {
			"link": url
		}).done(function(result) {

			if (result['title']) {
				self.title().val(result['title'])
			}

			if (result['description']) {
				self.desc().val(result['description'])
			}

			if (result['artist']) {
				self.artist().val(result['artist'])
			}

			if (result['album']) {
				self.album().val(result['album'])
			}

			self.linkForm().removeClass('is-loading');

		}).fail(function(message){
			self.linkForm().removeClass('is-loading');

			self.showError(self.linkForm(), message);
		});
	},

	showError: function (field, message) {
		field.addClass('has-error');
		field.find('[data-link-notice]').html(message);
	},

	clearError: function (field) {
		field.removeClass('has-error');
		field.find('[data-link-notice]').html('');
	},

	'{albumArt} change' : function(el , event) {
		if($.isEmpty(el.val())) {
			return;
		}

		var label = el.val().replace(/\\/g, '/').replace(/.*\//, '');

		el.parents('.o-input-group').find(':text').val(label);

		self.albumartFrame().addClass('is-loading');

		EasySocial.ajax('site/controllers/audios/uploadAlbumArt' , {
			files: el
		}, {
			type: 'iframe'
		}).done(function(result){

			self.albumartFrame().removeClass('is-loading');

			var resultString = JSON.stringify(result);

			// Set the result in a string format
			self.albumartData().val(resultString);

			self.setAlbumArt(result.thumbnail.uri);

			self.removeButton().show();

		}).fail(function(msg) {

			self.albumartFrame().removeClass('is-loading');
		});
	},

	setAlbumArt: function(url, position) {

		self.albumartFrame()
			.css({
				backgroundImage: $.cssUrl(url)
			});
	},

	"{removeButton} click": function(el) {
		self.albumartData().val();

		self.setAlbumArt(self.options.defaultAlbumart);

		el.parents('.input-group').find(':text').val('');
		self.albumartFilename().val('');

		self.albumartData().val('delete');

		el.hide();
	},

	initMentions: function() {

		var options = {
				"showNonFriend": false,
				"includeSelf": true,
				"name": "tags[]",
				"exclusion": opts.tagsExclusion
			}

		if (opts.isPrivateCluster) {
			var options = $.extend(options, {
				clusterId: opts.uid,
				clusterType: opts.type
			});
		}

		self.mentions()
			.addController("EasySocial.Controller.Friends.Suggest", options);
	},

	"{audioSource} change": function(audioSource, event) {

		var source = $(audioSource).val();

		var form = self[source + "Form"]();

		// Hide all source forms
		self.forms().addClass('t-hidden');

		// Remove hidden class for the active form
		form.removeClass('t-hidden');
	},

	"{albumartSource} change": function(albumartSource, event) {
		var checked = albumartSource.is(':checked');
		$('[data-albumart-input]').attr('disabled', checked);
		$('[data-audio-albumart]').attr('disabled', checked);

		if (checked) {
			$('[data-audio-albumart-source]').val('audio');
		} else {
			$('[data-audio-albumart-source]').val('upload');
		}

	},

	setMentionsLayout: function() {
		var hashtags = self.hashtags();
		var mentions = hashtags.controller("mentions");

		if (mentions) {
			mentions.cloneLayout();
			return;
		}

		var header = self.header();

		hashtags.mentions({

			triggers: {
				"#": {
					"type": "hashtag",
					"wrap": true,
					"stop": " #",
					"allowSpace": false,
					"query": {
						"loadingHint": false,
						"searchHint": opts.hints.hashtags.find('[data-search]'),
						"emptyHint": opts.hints.hashtags.find('[data-empty]'),
						data: function(keyword) {

							var task = $.Deferred();

							EasySocial.ajax("site/controllers/hashtags/suggest", {search: keyword, type: "audio"})
								.done(function(items) {

									if (!$.isArray(items)) {
										task.reject();
									}

									var items = $.map(items, function(item) {

										return {
											"title": "#" + $.trim(item),
											"type": "hashtag",
											"menuHtml": item
										};
									});

									task.resolve(items);
								})
								.fail(task.reject);

							return task;
						}
					}
				}
			},
			"plugin": {
					"autocomplete": {
						"id": "es",
						"component": "",
						"position": {
							my: 'left top',
							at: 'left bottom',
							of: header.parent(),
							collision: 'none'
						},
						"size": {
							width: function() {
								return header.parent().outerWidth();
							}
						}
					}
				}

		});
	},

	"{saveButton} click": function(ele, event) {

		var title = self.title().val();
		var wrapper = self.title().closest('div.o-control-input');
		title = title.trim();

		// clear the error 1st
		wrapper.removeClass('has-error');

		if (title == '') {
			wrapper.addClass('has-error');
			self.title().focus();
			return false;
		}

		return true;
	}
}});

module.resolve();

});
});
			EasySocial.module('site/audios/item', function($) {

var module = this;

EasySocial.Controller('Audios.Item', {
	defaultOptions: {

		tagAdding : null,
		"{wrapper}": "[data-audio-item]",

		"{tagPeople}": "[data-audio-tag]",
		"{tagsWrapper}": "[data-audio-tag-wrapper]",
		"{deleteButton}": "[data-audio-delete]",

		"{removeTag}": "[data-remove-tag]",
		"{tagItem}": "[data-tags-item]",

		"{featureButton}": "[data-audio-feature]",
		"{unfeatureButton}": "[data-audio-unfeature]",
		"{playlistItem}": "[data-playlist-item]"
	}
}, function(self, opts, base) { return {

	init: function() {
		opts.id = self.element.data('id');
	},

	"{unfeatureButton} click": function(unfeatureButton, event) {
		EasySocial.dialog({
			content: EasySocial.ajax("site/views/audios/confirmUnfeature", {
				"id": opts.id,
				"return": opts.callbackUrl
			})
		})
	},

	"{featureButton} click": function(featureButton, event) {

		EasySocial.dialog({
			content: EasySocial.ajax("site/views/audios/confirmFeature", {
				"id": opts.id,
				"return": opts.callbackUrl
			})
		});
	},

	"{deleteButton} click": function(deleteButton, event) {
		EasySocial.dialog({
			content: EasySocial.ajax("site/views/audios/confirmDelete", {
				"id": opts.id
			}),
			bindings: {

			}
		})
	},

	"{removeTag} click": function(removeTag, event) {

		var parent = removeTag.parents(self.tagItem.selector);
		var id = parent.data('id');

		var userId = parent.find('[data-user-id]').data('user-id');
		var userId = userId.toString();

		parent.remove();

		// If the length is only 1, we know that it's empty
		if (self.tagsWrapper().children().length == 0) {
			self.tagsWrapper().parent().addClass('is-empty');
		}

		EasySocial.ajax('site/controllers/audios/removeTag', {
			"id": id
		}).done(function() {
			opts.tagsExclusion.splice($.inArray(userId, opts.tagsExclusion), 1);
		});
	},

	"{tagPeople} click": function(tagPeople, event) {

		self.tagAdding = false;

		EasySocial.dialog({
			content: EasySocial.ajax('site/views/audios/tagPeople', {
							"id": opts.id,
							"exclusion": opts.tagsExclusion,
							"clusterId": opts.clusterId,
							"clusterType": opts.clusterType
						}),
			bindings: {
				"{submit} click": function(submitButton, event) {

					if (self.tagAdding) {
						return;
					}

					// now we set the state
					self.tagAdding = true;

					var suggest = this.suggest().textboxlist("controller");
					var items = suggest.getAddedItems();

					if (items.length <= 0) {
						return;
					}

					var ids = $.pluck(items, "id");

					// Make an ajax call to the server to tag people in this audio
					EasySocial.ajax('site/controllers/audios/tag', {
						"ids": ids,
						"id": opts.id
					}).done(function(tags) {

						if (! opts.tagsExclusion) {
							opts.tagsExclusion = [];
						}

						$.each(ids, function(i, id) {
							opts.tagsExclusion.push(id);
						});

						// Remove hidden class
						self.tagsWrapper().removeClass('t-hidden');

						// Just try to remove the is-empty on the wrapper.
						self.tagsWrapper().parent().removeClass('is-empty');

						// Append the tags to the wrapper
						self.tagsWrapper().append(tags);

						//clear items in dialog to avoid user click insert multiple time
						suggest.clearItems();

						// Hide the dialog
						EasySocial.dialog().close();

						// unset the state
						self.tagAdding = false;
					});
				}
			}
		})
	},
	"{playlistItem} click": function(playlistItem, event) {
		var item = playlistItem.parents(self.wrapper.selector);
		var audioId = item.data('id');
		var playlistId = playlistItem.data('id');
		var previouslyAdded = playlistItem.find('i').length > 0;

		var player = item.find('[data-audio-player][data-id="' + audioId + '"]')
		var overlayNotice = player.find('[data-overlay-notice]');

		EasySocial.ajax('site/controllers/audios/addToPlaylist',{
			"playlistId": playlistId,
			"audioId": audioId
		}).done(function(message) {
			if (previouslyAdded === false) {
				playlistItem.append('<i class="fa fa-check pull-right"></i>');
			}

			overlayNotice.fadeIn('fast');

			setTimeout(function(){
				overlayNotice.fadeOut('slow');
			}, 2000);
		});
	}
}});

module.resolve();


});
			EasySocial.module('site/audios/player', function($) {

var module = this;

EasySocial.require()
.library('wavesurfer')
.done(function($) {

EasySocial.Controller('Audios.Player', {
	defaultOptions: {
		"{playButton}": "[data-play-button]",
		"{pauseButton}": "[data-pause-button]",
		"{audioContainer}": "[data-audio-container]",
		"{duration}": "[data-playing-duration]"

	}
}, function(self, opts, base) { return {

	id: "",
	container: "",
	file: "",
	player: "",
	loaded: false,

	init: function() {
		self.container = base.find('[data-audio-wave]').attr('id');
		self.file = base.data('file');

		var ctx = document.createElement('canvas').getContext('2d');
		var linGrad = ctx.createLinearGradient(0, 64, 0, 200);
		linGrad.addColorStop(0.5, 'rgba(255, 255, 255, 1.000)');
		linGrad.addColorStop(0.5, 'rgba(183, 183, 183, 1.000)');

		self.player = WaveSurfer.create({
			container: '#' + self.container,
			interact: true,
			waveColor: linGrad,
			progressColor: 'hsla(200, 100%, 30%, 0.5)',
			cursorColor: '#fff',
			barWidth: 2,
			backend: 'MediaElement'
		});

		var playButtons = document.querySelectorAll('[data-play-button-mini], [data-play-button]');
		var playButtons = Array.prototype.slice.call(playButtons,0);

		// If user click on any other play button, we trigger pause for others player
		playButtons.forEach(function(playButton){
			playButton.addEventListener('click', function (e) {
				self.pauseButton().click();
			});
		});

		var filters = document.querySelectorAll('[data-audios-filter]');
		filters = Array.prototype.slice.call(filters,0);

		// If user click on any other filter on the sidebar, we destroy the player
		filters.forEach(function(filter){
			filter.addEventListener('click', function (e) {
				self.player.destroy();
			});
		});

		self.player.on('audioprocess', function () {
			self.duration().html(self.formatTime(self.player.getCurrentTime()));
		});
	},

	formatTime: function(time) {
		return [
			Math.floor((time % 3600) / 60), // minutes
			('00' + Math.floor(time % 60)).slice(-2) // seconds
		].join(':');
	},

	"{pauseButton} click": function(el) {

		self.player.pause();

		self.togglePlayPause(false);

		// el.addClass('t-hidden');
		// self.playButton().removeClass('t-hidden');
		// self.audioContainer().removeClass('is-playing');
	},

	"{playButton} click": function(el) {
		// Add loading state
		el.addClass('is-loading');

		if (self.loaded == false) {
			this.loadPlayer(el);

			// update hit for audio
			EasySocial.ajax('site/controllers/audios/hit',{
				"id": base.data('id')
			});
		} else {
			el.removeClass('is-loading');
			self.player.play();

			self.togglePlayPause(true);
			self.pauseButton().css('opacity', '0.5');
		}

		self.audioContainer().addClass('is-playing');
	},

	togglePlayPause: function(isPlaying) {

		self.playButton().toggleClass('t-hidden', isPlaying);
		self.audioContainer().toggleClass('is-playing', isPlaying);
		self.pauseButton().toggleClass('t-hidden', !isPlaying);
	},

	"{audioContainer} mouseover": function(el, ev) {
		if (self.audioContainer().hasClass('is-playing')) {
			this.changeOpacity(ev);
		}
	},

	"{audioContainer} mouseout": function(el, ev) {
		if (self.audioContainer().hasClass('is-playing')) {
			this.changeOpacity(ev);
		}
	},

	changeOpacity: function(ev) {
		var value = ev.type == 'mouseout' ? '0.5' : '';
		self.pauseButton().css('opacity', value);
	},

	loadPlayer: function(button) {
		self.player.load(self.file);

		self.player.on('ready', function () {
			button.removeClass('is-loading');
			button.addClass('t-hidden');
			self.pauseButton().removeClass('t-hidden');
			self.pauseButton().css('opacity', '0.5');

			self.player.playPause();

			self.loaded = true;
		});
	}

}});

module.resolve();

});
});
			EasySocial.module('site/audios/player.mini', function($) {

var module = this;

EasySocial.require()
.library('wavesurfer')
.done(function($) {

EasySocial.Controller('Audios.PlayerMini', {
	defaultOptions: {
		"{playButton}": "[data-play-button-mini]",
		"{pauseButton}": "[data-pause-button-mini]",
		"{audioContainer}": "[data-audio-container]",
		"{duration}": "[data-playing-duration]",
		"{bar}": "[data-player-bar]",
		"{barProgress}": "[data-bar-progress]",
		"{marqueeTitle}": "[data-marquee-title]"
	}
}, function(self, opts, base) { return {

	id: "",
	container: "",
	file: "",
	player: "",
	loaded: false,
	interval: false,

	init: function() {
		self.container = base.find('[data-audio-wave]').attr('id');
		self.file = base.data('file');

		var ctx = document.createElement('canvas').getContext('2d');
		var linGrad = ctx.createLinearGradient(0, 64, 0, 200);
		linGrad.addColorStop(0.5, 'rgba(255, 255, 255, 1.000)');
		linGrad.addColorStop(0.5, 'rgba(183, 183, 183, 1.000)');

		self.player = WaveSurfer.create({
			container: '#' + self.container,
			interact: true,
			waveColor: linGrad,
			progressColor: 'hsla(200, 100%, 30%, 0.5)',
			cursorColor: '#fff',
			barWidth: 2,
			backend: 'MediaElement'
		});

		var playButtons = document.querySelectorAll('[data-play-button-mini], [data-play-button]');
		var playButtons = Array.prototype.slice.call(playButtons,0);

		// If user click on any other play button, we trigger pause for others player
		playButtons.forEach(function(playButton){
			playButton.addEventListener('click', function (e) {
				self.pauseButton().click();
			});
		});

		self.player.on('audioprocess', function (result) {
			var duration = self.player.getDuration();
			var current = result;

			var percent = Math.floor((current / duration) * 100) + '%';
			self.barProgress().css('width', percent);

			if (percent == '100%') {
				self.player.stop();
				self.togglePlayPause(false);
			}
		});

		self.bar().click(function(e) {
			var bar = $(this);

			// to get part of width of progress bar clicked
			var widthclicked = e.pageX - bar.offset().left;
			var totalWidth = bar.width();

			// do calculation of the seconds clicked
			var calc = (widthclicked / totalWidth );
			self.player.seekTo(calc);
		});

		self.player.on('seek', function (result) {
			var duration = self.player.getDuration();
			var current = result;

			var percent = Math.floor((current / duration) * 100) + '%';
			self.barProgress().css('width',percent);
		});
	},

	formatTime: function(time) {
		return [
			Math.floor((time % 3600) / 60), // minutes
			('00' + Math.floor(time % 60)).slice(-2) // seconds
		].join(':');
	},

	"{pauseButton} click": function(el) {

		self.player.pause();

		self.togglePlayPause(false);

		clearInterval(self.interval);
		self.marqueeTitle().css('text-indent', 0);
	},

	"{playButton} click": function(el) {
		// Add loading state
		el.addClass('is-loading');

		if (self.loaded == false) {

			this.loadPlayer(el);

			// update hit for audio
			EasySocial.ajax('site/controllers/audios/hit',{
				"id": base.data('id')
			});
		} else {
			el.removeClass('is-loading');
			self.player.play();

			self.togglePlayPause(true);
			self.pauseButton().css('opacity', '0.5');
		}

		var mar = self.marqueeTitle();

		if (mar.get(0).scrollWidth > mar.outerWidth()) {

			var indent = mar.width();

			mar.marquee = function() {
				indent--;
				mar.css('text-indent', indent);
				if (indent < -1 * mar.width()) {
					indent = mar.width();
				}
			};

			self.interval = setInterval(mar.marquee, 1000/60);
		}

		self.audioContainer().addClass('is-playing');
	},

	togglePlayPause: function(isPlaying) {

		self.playButton().toggleClass('t-hidden', isPlaying);
		self.audioContainer().toggleClass('is-playing', isPlaying);
		self.pauseButton().toggleClass('t-hidden', !isPlaying);
	},

	"{audioContainer} mouseover": function(el, ev) {
		if (self.audioContainer().hasClass('is-playing')) {
			this.changeOpacity(ev);
		}
	},

	"{audioContainer} mouseout": function(el, ev) {
		if (self.audioContainer().hasClass('is-playing')) {
			this.changeOpacity(ev);
		}
	},

	changeOpacity: function(ev) {
		var value = ev.type == 'mouseout' ? '0.5' : '';
		self.pauseButton().css('opacity', value);
	},

	loadPlayer: function(button) {
		self.player.load(self.file);

		self.player.on('ready', function () {
			button.removeClass('is-loading');
			button.addClass('t-hidden');
			self.pauseButton().removeClass('t-hidden');
			self.pauseButton().css('opacity', '0.5');

			self.player.playPause();

			self.loaded = true;
		});
	}

}});

module.resolve();

});
});
			EasySocial.module('site/audios/playlist', function($) {

var module = this;

EasySocial.require()
.script('site/audios/suggest')
.library('wavesurfer', 'ui/slider')
.done(function($) {

EasySocial.Controller('Audios.Playlist', {
	defaultOptions: {
		nowPlaying: "",
		playlistId: "",
		"{wrapper}": "[data-audio-playlist]",
		"{playlistPlayer}": "[data-audio-playlist-player]",
		"{playingInfo}": "[data-playing-info]",
		"{playingTitle}": "[data-playing-title]",
		"{playingDuration}": "[data-playing-duration]",
		"{playingAlbumart}": "[data-playing-albumart]",

		// Buttons
		"{playpauseButton}": "[data-playpause-button]",
		"{nextButton}": "[data-next-button]",
		"{prevButton}": "[data-prev-button]",
		"{volumeButton}": "[data-volume-button]",
		"{removeTrack}": "[data-remove-track]",
		"{volumeSlider}": "[data-volume-slider]",

		"{playlist}": "[data-playlist]",
		"{track}": "[data-playlist-track]",

		// Manage Playlist
		"{listActions}": "[data-list-actions]",
		"{deletePlaylist}": "[data-list-actions] [data-delete]",
		"{addToPlaylist}": "[data-add]"
	}
}, function(self, opts, base) { return {

	currentTrack: 0,
	id: "",
	tracks: "",
	player: "",
	initialized: false,
	currentVolume: 0.2,
	init: function() {

		self.id = base.data('id');
		self.tracks = document.querySelectorAll('[data-playlist] [data-playlist-track]');

		// If there is no track, just return.
		if (self.tracks.length < 1) {
			return;
		}

		// Initialize player
		self.initPlayer();

		// Initialize volume slider
		self.initSlider();

		tracks = Array.prototype.slice.call(self.tracks,0);

		// Load the track on click
		tracks.forEach(function(track, index){
			track.addEventListener('click', function (e) {

				// We don't want to trigger this when click on the trash
				if ($(e.target).hasClass('fa-trash')) {
					return;
				}

				self.setCurrentSong(index);
			});
		});

		var filters = document.querySelectorAll('[data-audios-filter]');
		filters = Array.prototype.slice.call(filters,0);

		// If user click on any other filter on the sidebar, we destroy the player
		filters.forEach(function(filter){
			filter.addEventListener('click', function (e) {
				self.player.destroy();
			});
		});

		// Play on audio load only if the player is on playing state
		self.player.on('ready', function () {
			self.playlistPlayer().removeClass('is-loading');
			if (self.playpauseButton().hasClass('is-playing')) {
				self.player.play();
			}
		});

		// Go to the next track on finish
		self.player.on('finish', function () {
			self.setCurrentSong((self.currentTrack + 1) % self.tracks.length);
		});

		self.player.on('audioprocess', function () {
			self.playingDuration().html(self.formatTime(self.player.getCurrentTime()));
		});

		// Load the first track
		self.setCurrentSong(self.currentTrack);
	},

	formatTime: function(time) {
		return [
			Math.floor((time % 3600) / 60), // minutes
			('00' + Math.floor(time % 60)).slice(-2) // seconds
		].join(':');
	},

	initPlayer: function() {
		var ctx = document.createElement('canvas').getContext('2d');
		var linGrad = ctx.createLinearGradient(0, 64, 0, 200);

		linGrad.addColorStop(0.5, '#ffffff');
		linGrad.addColorStop(0.5, '#b7b7b7');

		// Initiallize the player
		self.player = WaveSurfer.create({
			container: '#es-waveform-playlist',
			interact: true,
			waveColor: '#C7C6D5',
			progressColor: '#9595B1',
			progressColor: '#9595B1',
			cursorColor: '#fff',
			barWidth: 2,
			cursorWidth: 0,
			height: 80
		});

		self.initialized = true;
	},

	initSlider: function() {
		self.volumeSlider().slider({
			range: "max",
			min: 0,
			max: 20,
			value: 4,
			slide: function(event, ui) {
				var volume = ui.value / 20;

				// Change the player volume when it slide
				self.player.setVolume(volume);
				self.currentVolume = volume;
		}
		});

		// self.player.setVolume(self.volumeSlider().slider("value"));
	},

	initTracksListener: function() {
		self.tracks = document.querySelectorAll('[data-playlist] [data-playlist-track]');
		tracks = Array.prototype.slice.call(self.tracks,0);

		// Load the track on click
		tracks.forEach(function(track, index){
			track.addEventListener('click', function (e) {

				// We don't want to trigger this when click on the trash
				if ($(e.target).hasClass('fa-trash')) {
					return;
				}

				self.setCurrentSong(index);
			});
		});
	},

	setCurrentSong: function(index) {

		// Remove 'is-active' class from all the item
		self.tracks[self.currentTrack].classList.remove('is-active');

		self.currentTrack = index;

		self.tracks[self.currentTrack].classList.add('is-active');

		// Update the Now Playing info
		self.updateNowPlaying(self.tracks[self.currentTrack]);

		self.playlistPlayer().addClass('is-loading');

		var file = $(self.tracks[self.currentTrack]).data('file');
		var audioId = $(self.tracks[self.currentTrack]).data('audio-id');

		self.player.load(file);

		self.player.setVolume(self.currentVolume);

		self.updateHit(audioId);
	},

	updateHit:function(audioId) {
		// update hit for audio
		EasySocial.ajax('site/controllers/audios/hit',{
			"id": audioId
		});
	},

	updateNowPlaying: function(currentPlaying){
		var title = $(currentPlaying).find('[data-title]').html();
		var duration = $(currentPlaying).find('[data-duration]').html();
		var albumArt = $(currentPlaying).data('albumart');

		self.playingTitle().html(title);
		self.playingDuration().html(duration);
		self.playingAlbumart().css('background-image', 'url('+ albumArt +')');
	},

	"{playpauseButton} click": function(el) {
		self.player.playPause();
		el.toggleClass('is-playing');
	},

	"{nextButton} click": function (el) {
		self.setCurrentSong((self.currentTrack + 1) % self.tracks.length);
	},

	"{prevButton} click": function (el) {
		var prevIndex = self.currentTrack - 1;
		self.setCurrentSong((prevIndex < 0 ? 0 : prevIndex) % self.tracks.length);
	},

	"{volumeButton} click": function (el) {
		el.toggleClass('is-muted');
		self.player.setMute(el.hasClass('is-muted'));
	},

	"{removeTrack} click": function (el) {
		var listMapId = el.parents(self.track.selector).data('listmap-id');

		EasySocial.ajax('site/controllers/audios/removeFromPlaylist', {
			"playlistId": opts.playlistId,
			"listMapId": listMapId
		}).done(function() {

			// Remove the item from the list.
			self.removeItem(listMapId, 'list');
		});
	},

	"{deletePlaylist} click" : function(track) {
		var actions = track.parents(self.listActions.selector);
		var id = actions.data('id');

		EasySocial.dialog({
			content: EasySocial.ajax("site/views/audios/confirmDeletePlaylist", {"id": id}),
			bindings: {
				"{deleteButton} click" : function() {
					$('[data-playlist-delete-form]').submit();
				}
			}
		});
	},

	"{addToPlaylist} click": function(track) {

		EasySocial.dialog({
			content: EasySocial.ajax('site/views/audios/assignList', {"id" : self.id}),
			bindings: {

				"{insertButton} click" : function() {
					var items = this.suggest().textboxlist("controller").getAddedItems();

					EasySocial.ajax('site/controllers/audios/assignItem', {
						"uid": $.pluck(items, "id"),
						"listId": self.id
					}).done(function(contents) {

						// Hide any notice messages.
						$('[data-assignAudios-notice]').hide();

						$(contents).each(function(i, item) {

							// Pass the item to the parent so it gets inserted into the playlist.
							self.insertItem(item);

							// Assign back the event listener to the new list of tracks
							self.initTracksListener();

							// If the playlist is previously not initialized, we should initialize it.
							if (self.initialized === false) {
								self.init();
								self.playingInfo().html(opts.nowPlaying);
							}

							// Close the dialog
							EasySocial.dialog().close();
						});

					}).fail(function(message) {
						$('[data-assignAudios-notice]').addClass('alert alert-error')
							.html(message.message);
					});
				}
			}
		});
	},

	insertItem: function(item) {

		// Hide any empty notices.
		self.playlist().removeClass('is-empty');

		// Prepend the result back to the list
		$(item).appendTo(self.playlist());

		// Update the counter for the list items.
		self.trigger('updateListCounters');
	},

	removeItem: function(id, source) {
		// Remove item from the list.
		var item = self.track('[data-listmap-id="' + id + '"]');

		item.remove();

		// Update the counter for the list items.
		self.trigger('updateListCounters');
	}

}});

module.resolve();

});
});
			EasySocial.module('site/audios/process', function($) {

var module = this;

EasySocial.Controller('Audios.Process', {
	defaultOptions: {
		"{progressBar}": "[data-audio-progress-bar]",
		"{progressResult}": "[data-audio-progress-result]"
	}
}, function(self, opts, base) { return {

	init: function() {

		// Set the global options
		opts.id = base.data('id');

		self.processAudio();
	},

	processAudio: function() {

		// Initialize the audio processing here
		EasySocial.ajax('site/controllers/audios/process', {
			"id": opts.id
		}).done(function() {

			// Run check status
			self.status(opts.id);
		});
	},

	status: function(audioId) {
		// Initialize the audio processing here
		EasySocial.ajax('site/controllers/audios/status', {
			"id": audioId
		}).done(function(permalink, progress) {

			if (progress == 'done') {
				self.progressBar().css('width', '100%');
				self.progressResult().html('100%');

				// Redirect the user upon completion
				window.location = permalink;

				return;
			}

			// There is a possibility that the progress is throwing errors on the line so we should skip this
			if (progress == 'ignore') {
				self.status(audioId);
				return;
			}

			var percentage = progress + '%';

			// Reiterate the same method again until it's completed.
			self.progressBar().css('width', percentage);
			self.progressResult().html(percentage);

			self.status(audioId);

			return;
		});
	}

}});

module.resolve();
});
			EasySocial.module('site/audios/suggest', function($){

var module = this;

EasySocial.require()
.library('textboxlist')
.done(function($) {

EasySocial.Controller('Audios.Suggest', {
	defaultOptions: {
		max: null,
		exclusive: true,
		exclusion: [],
		minLength: 1,
		highlight: true,
		name: "uid[]",
		type: "",

		// Namespace to query for suggestions
		"query": {
			"audios": "site/controllers/audios/suggest"
		}
	}
}, function(self, opts, base) { return {

	init: function() {

		// Implement the textbox list on the implemented element.
		self.element
			.textboxlist({
				"component": 'es',
				"name": opts.name,
				"max": opts.max,
				"plugin": {
					"autocomplete": {
						"exclusive": opts.exclusive,
						"minLength": opts.minLength,
						"highlight": opts.highlight,
						"showLoadingHint": true,
						"showEmptyHint": true,

						query: function(keyword) {

							var options = {
									"search": keyword,
									"type": opts.type,
									"inputName": opts.name
								};

							return EasySocial.ajax(opts.query.audios, options);
						}
					}
				}
			})
			.textboxlist("enable");
	},

	"{self} filterItem": function(el, event, item) {

		var html = $('<div/>').html(item.html);
		var title = html.find('[data-suggest-title]').text();
		var id = html.find('[data-suggest-id]').val();

		item.id = id;
		item.title = title;
		item.menuHtml = item.html;
	},

	"{self} filterMenu": function(el, event, menu, menuItems, autocomplete, textboxlist) {
		// Get list of excluded audios
		var items = textboxlist.getAddedItems();
		var audios = $.pluck(items, "id");
		var audios = audios.concat(self.options.exclusion);

		menuItems.each(function(){

			var menuItem = $(this);
			var item = menuItem.data("item");

			// If this user is excluded, hide the menu item
			menuItem.toggleClass("hidden", $.inArray(item.id.toString(), audios) > -1);
		});
	}

}});

module.resolve();
});

});

			EasySocial.module('site/avatar/avatar', function($){

var module = this;

EasySocial.require()
.script('site/utilities/webcam')
.done(function($) {

	EasySocial.Controller('Avatar', {
		defaultOptions: {
			uid: null,
			type: null,
			redirectUrl: null,
			"{menu}": "[data-avatar-menu]",

			"{takePictureButton}": "[data-avatar-webcam]",
			"{uploadButton}": "[data-avatar-upload-button]",
			"{selectButton}": "[data-avatar-select-button]",
			"{removeButton}": "[data-avatar-remove-button]"
		}
	}, function(self, opts) { return {

			init: function() {

				// Implement the webcam js on the take picture button
				opts.hasFlash = self.hasFlash();
			},

			"{uploadButton} click": function() {
				EasySocial.dialog({
					content: EasySocial.ajax('site/views/avatar/upload', {
						'uid': opts.uid,
						'type': opts.type,
						'return': opts.redirectUrl
					})
				});
			},

			getViewType: function () {
				var type = self.options.type;

				if (type == 'user') {
					type = 'profile';
				} else {
					type = type + 's';
				}

				return type;
			},

			hasFlash: function() {

				// method to check if web browser installed with flash plugin or not.
				var hasFlash = false;

				try {
				  var fo = new ActiveXObject('ShockwaveFlash.ShockwaveFlash');
				  if (fo) {
				    hasFlash = true;
				  }
				} catch (e) {
				  if (navigator.mimeTypes
				        && navigator.mimeTypes['application/x-shockwave-flash'] != undefined
				        && navigator.mimeTypes['application/x-shockwave-flash'].enabledPlugin) {
				    hasFlash = true;
				  }
				}

				return hasFlash;
			},

			hideWebcamCanvas: function() {
				// Instead of hiding the canvas, we reposition the webcam canvas
				$('[data-canvas-webcam]')
					.css('position', 'absolute')
					.css('left', '-9999px');
			},

			showWebcamCanvas: function() {
				// Instead of hiding the canvas, we reposition the webcam canvas
				$('[data-canvas-webcam]')
					.css('position', 'relative')
					.css('left', '0');
			},

			webcamStarted : false,
			"{takePictureButton} click": function() {

				var viewType = self.getViewType();

				var pos = 0, ctx = null, saveCB, image = [];

				var canvas = document.createElement("canvas");
				canvas.setAttribute('width', 320);
				canvas.setAttribute('height', 240);

				ctx = canvas.getContext("2d");

				image = ctx.getImageData(0, 0, 320, 240);

				saveCB = function(data) {

					var col = data.split(";");
					var img = image;

					for(var i = 0; i < 320; i++) {
						var tmp = parseInt(col[i]);
						img.data[pos + 0] = (tmp >> 16) & 0xff;
						img.data[pos + 1] = (tmp >> 8) & 0xff;
						img.data[pos + 2] = tmp & 0xff;
						img.data[pos + 3] = 0xff;
						pos+= 4;
					}

					if (pos >= 4 * 320 * 240) {
						ctx.putImageData(img, 0, 0);

						EasySocial.ajax('site/views/' + viewType + '/saveCamPicture', {
							type: "data",
							image: canvas.toDataURL('image/png')
						}).done(function(result){
							var source = result.url;
							var image = new Image();

							preview = $('[data-photo-camera-preview]');

							preview.removeClass('t-hidden');

							$(image).attr('src', source)
								.appendTo(preview);

							$('[data-save-button]').removeClass('t-hidden');

							// Instead of hiding the canvas, we reposition the webcam canvas
							self.hideWebcamCanvas();

							// Hide the capture picture button now
							$('[data-capture-button]').addClass('t-hidden');
							$('[data-recapture-button]').removeClass('t-hidden');

							$('[data-photo-filename]').val(result.file);
						});

						pos = 0;
					}
				};


				if (!self.webcamStarted) {

					var viewType = self.getViewType();

					EasySocial.dialog({
						content: EasySocial.ajax('site/views/' + viewType + '/takePicture', {
							"uid" : self.options.uid
						}),

						bindings: {
							init: function() {

								$('[data-canvas-webcam]').webcam({
									onSave: saveCB,
									onCapture: function () {
										webcam.save();
									},
									debug: function(type, message) {

										// User denied access to the camera
										if (type == 'notify' && message == 'Camera stopped') {
											self.webcamStarted = false;
											EasySocial.dialog().close();
											return;
										}
									}
								});
							},

							"{captureButton} click": function() {
								webcam.capture();
							},

							"{recaptureButton} click": function(el, event) {
								$('[data-capture-button]').removeClass('t-hidden');
								$('[data-recapture-button]').addClass('t-hidden');
								$('[data-save-button]').addClass('t-hidden');

								// Display the webcam canvas again.
								self.showWebcamCanvas();

								preview.find('img').remove();
								preview.addClass('t-hidden');
							},

							"{saveButton} click": function(el, event) {
								file = $('[data-photo-filename]').val();
								uid = $('[data-photo-uid]').val();

								EasySocial.ajax('site/controllers/photos/createAvatarFromWebcam', {
									uid : uid,
									type : self.options.type,
									file : file
								}).done(function(result){
									EasySocial.dialog().close();
									location.reload();
								});

							}
						}
					})
				}
			},

			"{selectButton} click": function() {

				EasySocial.photos.selectPhoto({
					uid : self.options.uid,
					type : self.options.type,
					bindings: {
						"{self} photoSelected": function(el, event, photos) {

							// Photo selection dialog returns an array,
							// so just pick the first one.
							var photo = photos[0];

							// If no photo selected, stop.
							if (!photo) {
								return;
							}

							EasySocial.photos.crop(photo.id , { "uid" : self.options.uid , "type" : self.options.type , "redirectUrl" : self.options.redirectUrl } );
						},

						"{cancelButton} click": function() {
							this.parent.close();
						}
					}
				});
			},

            "{menu} shown.bs.dropdown": function() {
                 self.element.addClass("show-all");
            },

            "{menu} hidden.bs.dropdown": function() {
                 self.element.removeClass("show-all");
            },

			"{removeButton} click": function() {

				var viewType = self.getViewType();

				EasySocial.dialog({
					"content": EasySocial.ajax('site/views/' + viewType + '/confirmRemoveAvatar', {
						id : self.options.uid
					})
				});
			}
		}
	});

	module.resolve();
});


});
			EasySocial.module('site/badges/badge', function($) {
	var module = this;

	EasySocial.Controller('Badges.Badge', {
		defaultOptions: {
			id					: 0,
			total				: 0,

			'{achieversList}'	: '[data-badge-achievers-list]',

			'{achiever}'		: '[data-badge-achievers-achiever]',

			'{loadButton}'		: '[data-badge-achievers-load]',
		}
	}, function(self) {
		return {
			init: function() {
				self.options.id = self.element.data('id');
				self.options.total = self.element.data('total-achievers');
			},

			'{loadButton} click': function(el) {
				var current = el.data('nextlimit');

				if (el.enabled()) {
					el.disabled(true);

					el.hide();

					EasySocial.ajax('site/controllers/badges/loadAchievers', {
						id: self.options.id,
						start: current
					}).done(function(html, nextlimit) {

						self.achieversList().append(html);

						el.enabled(true);

						if(nextlimit > 0) {
							el.data('nextlimit', nextlimit)
							el.show();
						}

					}).fail(function(msg) {

					});
				}
			}
		}
	});

	module.resolve();
});
			EasySocial.module('site/clusters/create', function ($) {
    var module = this;

    EasySocial.require()
        .script('shared/fields/validate', 'shared/fields/base', 'shared/fields/conditional')
        .done(function ($) {
            EasySocial.Controller('Clusters.Create', {
                defaultOptions: {
                    'previousLink': null,
                    'clusterType': null,
                    '{field}': '[data-field-item]',
                    "{form}": "[data-form]",
                    "{previous}": "[data-previous]",
                    "{next}": "[data-next]",

                    // Category select page
                    "{toggleSub}": "[data-toggle-subcategories]",
                    "{categoryItem}": "[data-category-item]",
                    "{itemsContainer}": "[data-es-items-container]",
                    "{backButton}": "[data-select-category-back]"
                }
            }, function (self, opts, base) {
                return {

                    init: function () {
                        self.field().addController('EasySocial.Controller.Field.Base');

                        // Implement conditional field controller
                        self.field().addController('EasySocial.Controller.Field.Conditional');

                    },

                    "{previous} click": function () {
                        window.location = opts.previousLink;
                    },

                    "{next} click": function (button, event) {

                        if (!button.enabled()) {
                            return false;
                        }

                        // Set it to disabled
                        button.disabled(true);
                        button.addClass('is-loading');

                        self.element
                            .validate({
                                fieldSelector: self.field.selector
                            })
                            .done(function () {
                                button.removeClass('is-loading');
                                button.enabled(true);

                                self.form().submit();
                            }).fail(function () {
                                button.removeClass('is-loading');
                                button.enabled(true);

                                EasySocial.dialog({
                                    "content": EasySocial.ajax('site/views/profile/showFormError')
                                });
                            });
                    },

                    hideChild: function (id) {
                        var items = document.querySelectorAll(self.categoryItem.selector + '[data-parent-id="' + id + '"]');

                        items = Array.prototype.slice.call(items, 0);

                        items.forEach(function (item) {
                            var childId = $(item).data('id');
                            self.hideChild(childId);
                        });

                        $(items).remove();
                    },

                    "{backButton} click": function (el) {
                        // We need to get the first item's parent id
                        var parentId = self.itemsContainer().find(self.categoryItem.selector).data('back-id');

                        EasySocial.ajax('site/controllers/' + opts.clusterType + '/getSubcategories', {
                                "parentId": parentId
                            })
                            .done(function (html) {
                                self.itemsContainer().html(html);
                                self.backButton().toggleClass('t-hidden', parentId == 0);
                            });
                    },

                    "{toggleSub} click": function (el) {

                        var itemWrapper = el.parent(self.categoryItem.selector);
                        var parentId = itemWrapper.data('id');
                        var backId = itemWrapper.data('parent-id');

                        var groupId = base.data('group-id') ? base.data('group-id') : 0;
                        var pageId = base.data('page-id') ? base.data('page-id') : 0;

                        EasySocial.ajax('site/controllers/' + opts.clusterType + '/getSubcategories', {
                                "parentId": parentId,
                                "groupId": groupId,
                                "pageId": pageId,
                                "backId": backId
                            })
                            .done(function (html) {
                                self.itemsContainer().html(html);
                                self.backButton().removeClass('t-hidden');
                            });
                    }
                }
            });

            module.resolve();
        });
});			EasySocial.module('site/comments/control', function($) {

var module = this;

/**
 *	Comments update controller
 *	Should only exist once on the page
 *	Act as a data handler between server and client for comments update (add/delete/edit etc)
 *	Global functions should be here as well
 */

EasySocial.Controller('CommentsControl', {
	defaultOptions: {
		interval: 30
	}
}, function(self, opts) { return {

	init: function() {
		// self.startUpdate();


		// listening to notifier.updates trigger
        $(window).on('notifier.updates', function(event, data) {

            if (data.comment == undefined) {
                return;
            }

            var result = data.comment.data;

			// Push updates to each comment block
			$.each(result, function(element, block) {
				$.each(block, function(uid, comments) {

					var comment = self.$Blocks[element][uid];

					if (comment._destroyed) {
						return;
					}

					comment.updateComment(comments);
				});
			});
        });

		// listening to notifier.collection trigger
        $(window).on('notifier.collection', function(event, data) {
            comments = self.populate();
            data.comment = comments;
        });

	},

	// Comments block registry
	$Blocks: {},

	startUpdate: function() {
		opts.monitoring = true;
		self.updateBlocks();
	},

	stopUpdate: function() {
		opts.monitoring = false;
	},

	updateBlocks: function(){

		(self.updateBlocks = $._.debounce(function() {

			var data = self.populate();

			if (!opts.monitoring) {
				return false;
			}

			EasySocial.ajax('site/controllers/comments/getUpdates', {
				data: data
			}).done(function(result) {

				// Push updates to each comment block
				$.each(result, function(element, block) {
					$.each(block, function(uid, comments) {

						var comment = self.$Blocks[element][uid];

						if (comment._destroyed) {
							return;
						}

						comment.updateComment(comments);
					});
				});

			}).always(function() {

				self.updateBlocks();
			});
		}, opts.interval * 1000))();
	},

	register: function(instance) {
		var group = instance.options.group;
		var element = instance.options.element;
		var streamid = instance.options.streamid;
		var uid = instance.options.uid;
		var verb = instance.options.verb;
		var timestamp = instance.options.timestamp;

		if (streamid == '') {
			streamid = '0';
		}

		var key = element + '.' + group + '.' + verb;

		if(self.$Blocks[key] === undefined) {
			self.$Blocks[key] = {};
		}

		// we need to use the stream id + uid so that for those aggregated items,
		// we can still get the comments correctly for each individual items. E.g. upload mulitple photos will create same stream id for each photo items.
		var blockkey = streamid + '.' + uid;

		self.$Blocks[key][blockkey] = instance;

		instance.trigger('commentBlockRegistered');
	},

	populate: function() {
		var data = {};

		$.each(self.$Blocks, function(key, block) {
			data[key] = {};

			$.each(block, function(blockkey, comments) {
				data[key][blockkey] = comments._export();
			});
		});

		return data;
	}
}});


EasySocial.ready(function(){

	// Implement this controller on to es-wrap
	EasySocial.Comments = $('body').addController('EasySocial.Controller.CommentsControl');

	module.resolve();
});


});
			EasySocial.module('site/comments/form', function($) {

var module = this;

EasySocial.Controller('Comments.Form', {
	defaultOptions: {
		'{editor}': '[data-comments-editor]',
		'{input}': '[data-comments-form-input]',
		'{submit}': '[data-comments-form-submit]',

		// Smileys
		"{smileyLink}": "[data-comment-smileys]",
		"{smileyItem}": "[data-comment-smiley-item]",

		// Giphy
		'{giphyButton}': '[data-giphy-button]',
		'{giphyPlaceholder}': '[data-giphy-placeholder]',
		'{giphyPreview}': '[data-giphy-preview]',
		'{giphyRemove}': '[data-giphy-remove]',
		'{giphyContainer}': '[data-giphy-container]',

		// Attachments
		"{attachmentQueue}": "[data-comment-attachment-queue]",
		"{attachmentProgress}": "[data-comment-attachment-progress-bar]",
		"{attachmentBackground}": "[data-comment-attachment-background]",
		"{attachmentRemove}": "[data-comment-attachment-remove]",
		"{attachmentItem}": "[data-comment-attachment-item]",
		"{attachmentButton}": "[data-uploader-browse]",
		"{attachmentDelete}": "[data-comment-attachment-delete]",

		"{uploaderForm}": "[data-uploader-form]",
		"{itemTemplate}": "[data-comment-attachment-template]",

		"{dismissError}": "[data-comment-error-dismiss]",
		"{errorMessage}": "[data-comment-error]",
		"{errorCommentMessage}": "[data-comment-error-message]",

		"{uploadItem}": "[data-comment-photo-upload-item]",

		attachmentIds:[],
		emoticons: []
	}
}, function(self, opts, base, parent) { return {

	init: function() {

		// Assign the parent
		parent = self.parent;

		// Get available hints for friend suggestions and hashtags
		opts.hints = {
				"friends": $('[data-hints-friends]'),
				"hashtags": $('[data-hints-hashtags]'),
				"emoticons": $('[data-hints-emoticons]')
		};

		// Apply the mentions on the comment form
		self.setMentionsLayout();

		// Implement attachments on the comment form.
		if (parent.options.attachments) {
			self.implementAttachments();
		}
	},

	attachmentTemplate: null,
	giphyURL: null,

	getAttachmentTemplate: function() {

		if (!self.attachmentTemplate) {
			self.attachmentTemplate = self.itemTemplate().detach();
		}

		var tpl = $(self.attachmentTemplate).clone().html();

		return $(tpl);
	},

	implementAttachments: function() {

		// Implement uploader controller
		self.editor().implement(EasySocial.Controller.Uploader, {
			'temporaryUpload': true,
			'query': 'type=comments',
			'type': 'comments',
			extensionsAllowed: 'jpg,jpeg,png,gif'
		});

	},

	// determine whether uploading image complete or not
	hasUploadItems: function() {

		var	hasUploadItem = self.uploadItem().length > 0;

		return hasUploadItem;
	},

	"{smileyItem} click": function(smileyItem, event) {

		var value = smileyItem.data('comment-smiley-value');
		var editor = self.editor();

		// Add additional space to allow multiple smiley to be click at once. #3122
		value = value + ' ';

		// Get the input
		var isEditing = smileyItem.parents('[data-comment-editor]').length > 0 ? true : false;

		if (isEditing) {
			editor = smileyItem.parents('[data-comment-editor]');
		}

		var controller = editor.mentions("controller");
		var textarea = controller.textarea();

		previousCursor = controller.previousCursorPosition;

		var currentValue = textarea.val();
		var beforeValue = currentValue.substring(0, previousCursor) + value;
		var newValue = beforeValue + currentValue.substring(previousCursor);

		// We need to trigger the mention
		controller.isPasting = true;
		controller.smileyLength = value.length;

		textarea.val(newValue);
		textarea.trigger('input');

		controller.moveCursor(beforeValue.length);
	},

	"{smileyLink} click": function(smileyLink, event) {

		if (smileyLink.hasClass('active')) {
			smileyLink.removeClass('active');
			return;
		}

		smileyLink.addClass('active');
	},

	"{attachmentDelete} click": function(deleteLink, event) {

		var attachmentId = deleteLink.data('id');

		EasySocial.dialog({
			content: EasySocial.ajax('site/views/comments/confirmDeleteCommentAttachment', {
							"id": attachmentId
						}),
			bindings: {
				"{deleteButton} click": function() {

					// Perform an ajax call to the server
					EasySocial.ajax('site/controllers/comments/deleteAttachment', {
						"id": attachmentId
					})
					.done(function() {
						// Remove the dom from the page
						var item = deleteLink.parents(self.attachmentItem.selector);

						item.remove();

						EasySocial.dialog().close();
					});
				}
			}
		});

	},

	"{attachmentRemove} click": function(removeLink, event) {

		var item = removeLink.parents(self.attachmentItem.selector);

		// Remove the item from the attachment ids
		opts.attachmentIds = $.without(opts.attachmentIds, item.data('id'));

		// Remove the item
		item.remove();

		// find the attachment item from the comment form
		var attachmentItems = self.attachmentQueue().find(self.attachmentItem());

		if (attachmentItems.length < 1) {
			self.attachmentQueue().removeClass('has-attachments');

			// Show giphy button
			self.giphyButton().removeClass('t-hidden');
		}
	},

	insertGiphy: function(item) {
		var imageUrl = item.data('original');

		// Ensure that the old giphy item has been removed
		self.removeGiphy();

		self.giphyPlaceholder().css('width', '100%');
		self.giphyPlaceholder().removeClass('t-hidden');
		self.giphyPreview().attr('src', imageUrl);
		self.giphyRemove().addClass('t-hidden');
		self.giphyContainer().addClass('is-loading');

		self.giphyPreview()
			.off('load')
				.on('load', function() {
				self.giphyContainer().removeClass('is-loading');
				self.giphyRemove().removeClass('t-hidden');

				var parent = $(this).parent();

				// Display the placeholder and set the width given the width of the image
				setTimeout(function() {
					var computedWidth = parent.css('width');

					self.giphyPlaceholder().css('width', computedWidth);
				}, 10);
		});

		// Hide attachment button since the user shouldn't be able to insert attachment alongside giphy
		self.attachmentButton().addClass('t-hidden');

		self.giphyURL = imageUrl;
	},

	removeGiphy: function() {
		// Show attachment button since giphy is removed
		self.attachmentButton().removeClass('t-hidden');

		// Hide preview
		self.giphyPlaceholder().addClass('t-hidden');

		// Remove background
		self.giphyPreview().attr('src', '');
	},

	bindClickGiphyItem: function(popbox) {
		popbox.tooltip
			.find('[data-giphy-item]')
			.off('click.giphy.comment.form')
			.on('click.giphy.comment.form', function() {
				var item = $(this);

				self.insertGiphy(item);

				// Hide the popbox once an item is selected
				popbox.hide();
			});
	},

	"{giphyButton} popboxActivate": function(element, event, popbox) {
		event.stopPropagation();

		popbox.tooltip
			.find('[data-popbox-content]')
			.off('giphyAfterSearch')
			.on('giphyAfterSearch', function(event, query) {
				self.bindClickGiphyItem(popbox);
			});

		self.bindClickGiphyItem(popbox);
	},

	"{giphyRemove} click": function(element, event) {
		self.removeGiphy();
	},

	"{self} editCommentTrigger": function() {
		// Reset the attachments
		opts.attachmentIds = [];
	},

	// When a new item is added, we want to display
	"{uploaderForm} FilesAdded": function(el, event, uploader, files) {
		self.giphyButton().addClass('t-hidden');

		var attachmentQueue = $(el).find(self.attachmentQueue().selector);

		$.each(files, function(index, file) {

			// Get the attachment template
			var item = self.getAttachmentTemplate();

			// Set the queue to use has-attachments class
			attachmentQueue
				.addClass('has-attachments');

			// Insert the item into the queue
			item.attr('id', file.id)
				.addClass('is-uploading')
				.attr('data-comment-photo-upload-item', '1')
				.prependTo(attachmentQueue);
		});
	},

	// When the file is uploaded, we need to remove the uploading state
	"{uploaderForm} FileUploaded": function(el, event, uploader, file, response) {

		var item = self.attachmentQueue().find('#' + file.id);

		// Add preview
		self.attachmentBackground.inside(item)
			.css('background-image', 'url("' + response.preview + '")');

		// Remove the is-uploading state on the upload item
		item.removeClass('is-uploading');

		// Push the id
		item.data('id', response.id);

		opts.attachmentIds.push(response.id);

		// prevent user click submit button quickly caused show broken image in comment
		setTimeout(function() {

			// Determine whether this is the last image uploading
			// If yes, then activate the submit button here
			if (self.uploadItem().length < 2) {
				self.submit().removeAttr('disabled');
			}

			// Remove this data attribute once finish uploaded
			item.removeAttr('data-comment-photo-upload-item');

		}, 1);

	},

	// When item is being uploaded
	"{uploaderForm} UploadProgress" : function(el, event, uploader, file) {

		// Deactivate comment submit button to prevent users submitting the comment
		self.submit().attr('disabled', 'disabled');

		var item = $('#' + file.id);
		var progress = self.attachmentProgress.inside(item);

		progress.css('width', file.percent + '%');
	},

	'{input} keydown': function(el, event) {
		// Only allow control + shift or cmd + enter to submit comments
		if ((event.metaKey || event.ctrlKey) && event.keyCode == 13 && !self.hasUploadItems()) {
			self.submitComment();
		}
	},

	'{submit} click': function(el, event) {

		// prevent user proceed this if the image still under uploading process
		if (self.hasUploadItems()) {
			return;
		}

		if (el.enabled()) {
			self.submitComment();
		}
	},

	'{dismissError} click': function(el, event) {
		self.errorMessage().addClass('t-hidden');
	},

	setMentionsLayout: function() {
		var loader = $.Deferred();
		var editor = self.editor();
		var mentions = editor.controller('mentions');

		if (mentions) {
			mentions.cloneLayout();
			return;
		}

		// Get the immediate parent
		var header = self.editor().parent();

		editor.mentions({
			triggers: {

				"@": {
					type: "entity",
					wrap: false,
					stop: "",
					allowSpace: true,
					finalize: true,
					query: {
						loadingHint: true,
						emptyHint: opts.hints.friends.find('[data-empty]').html(),
						searchHint: opts.hints.friends.find('[data-search]').html(),

						data: function(keyword) {

							var task = $.Deferred();

							EasySocial.ajax("site/controllers/friends/suggest" , {
									search: keyword,
									clusterId: self.parent.options.clusterid
							}).done(function(items) {

								if (!$.isArray(items)) {
									task.reject();
								}

								var items = $.map(items, function(item){

									var html = $('<div/>').html(item);
									var title = html.find('[data-suggest-title]').val();
									var id = html.find('[data-suggest-id]').val();

									return {
										"id": id,
										"title": title,
										"type": "user",
										"menuHtml": item
									};
								});

								task.resolve(items);
							}).fail(task.reject);

							return task;
						},
						use: function(item) {
							return item.type + ":" + item.id;
						}
					}
				},
				"#": {
					"type": "hashtag",
					"wrap": true,
					"stop": " #",
					"allowSpace": false,
					"query": {
						loadingHint: true,
						emptyHint: opts.hints.hashtags.find('[data-empty]').html(),
						searchHint: opts.hints.hashtags.find('[data-search]').html(),
						data: function(keyword) {

							var task = $.Deferred();

							EasySocial.ajax("site/controllers/hashtags/suggest", {search: keyword})
								.done(function(items) {

									if (!$.isArray(items)) {
										task.reject();
									}

									var items = $.map(items, function(item) {

										return {
											"title": "#" + $.trim(item),
											"type": "hashtag",
											"menuHtml": item
										};
									});

									task.resolve(items);
								})
								.fail(task.reject);

							return task;
						}
					}
				},
				":": {
					type: "emoticon",
					wrap: true,
					stop: "",
					allowSpace: false,
					query: {
						loadingHint: true,
						searchHint: opts.hints.emoticons.find('[data-search]').html(),
						emptyHint: opts.hints.emoticons.find('[data-empty]').html(),
						data: $.parseJSON(parent.options.emoticons),
						renderAll: true
					}
				}
			},
			plugin: {
				autocomplete: {
					id: "es",
					component: "",
					sticky: true,
					position: {
						my: 'left top',
						at: 'left bottom',
						of: header,
						collision: 'none'
					},
					size: {
						width: function() {
							return header.outerWidth();
						}
					}
				}
			}
		});
	},

	isCommenting: false,

	submitComment: function() {
		var comment = self.input().val();

		self.errorMessage().addClass('t-hidden');

		self.removeGiphy();

		// If comment value is empty, then don't proceed
		// If comment value is empty but there is giphy we can continue to save the comment
		if ($.trim(comment) == '' && !self.giphyURL) {

			// Display appropriate message to user
			self.errorMessage().removeClass('t-hidden');
			self.errorCommentMessage().html(parent.options.errorMessage);

			return false;
		}

		if (self.isCommenting) {
			return false;
		}

		self.isCommenting = true;

		// Add loading indicator below the textarea
		// And disable the submit button during processing
		self.submit()
			.addClass('is-loading')
			.attr('disabled');

		// Disable comment form
		self.disableForm();

		// Execute save
		self.save()
			.done(function(comment) {
				// Rather than using commentItem ejs, let PHP return a full block of HTML codes
				// This is to unify 1 single theme file to use loading via static or ajax

				// Trigger parent's commentSaved event
				self.parent.trigger('newCommentSaved', [comment]);

				// Enable the submit button
				self.submit().enabled(true);

				var editor = self.editor();
				var mentions = editor.controller("mentions");

				// Reset the mentions upon saving.
				mentions && mentions.reset();

				// Update the stream exclude id if applicable
				if (self.parent.options.streamid != '') {
					self.updateStreamExcludeIds(self.parent.options.streamid);
				}

			})
			.fail(function(message) {
				self.errorMessage().removeClass('t-hidden');
				self.errorCommentMessage().html(message);

				// Enable the submit button
				self.submit().enabled(true);

				self.submit()
					.removeClass('is-loading')
					.removeAttr('disabled');

				self.enableForm();
			}).always(function() {
				self.isCommenting = false;

				self.removeGiphy();

				self.attachmentButton().removeClass('t-hidden');

				self.giphyButton().removeClass('t-hidden');

				// Initialize reactions
				if (window.es.mobile || window.es.tablet) {
					window.es.initReactions();
				}

			});
	},

	save: function() {
		var mentions = self.editor().controller("mentions");
		var giphy = self.giphyURL;

		var data = {
			url: self.parent.options.url,
			mentions: mentions ? mentions.toArray() : [],
			giphy: giphy
		};

		data.mentions = $.map(data.mentions, function(mention){

			if ((mention.type==="hashtag" || mention.type==="emoticon") && $.isPlainObject(mention.value)) {
				mention.value = mention.value.title.slice(1);
			}
			return JSON.stringify(mention);
		});

		return EasySocial.ajax('site/controllers/comments/save', {
			uid: self.parent.options.uid,
			element: self.parent.options.element,
			group: self.parent.options.group,
			verb: self.parent.options.verb,
			streamid: self.parent.options.streamid,
			input: self.input().val(),
			attachmentIds: opts.attachmentIds,
			data: data,

			clusterid: self.parent.options.clusterid,
			postActor: self.getPostActor()
		});
	},

	getPostActor: function() {
		var postAsHidden = $('[data-postas-base] [data-postas-hidden]');

		postActor = postAsHidden.length > 0 ? postAsHidden.val() : 'user';

		return postActor;
	},

	updateStreamExcludeIds: function(id) {
		// ids = self.element.data('excludeids' );
		ids = $('[data-streams-wrapper]').data( 'excludeids' );

		newIds = '';

		if (ids != '' && ids != undefined) {
			newIds = ids + ',' + id;
		} else {
			newIds = id;
		}

		$('[data-streams-wrapper]').data('excludeids', newIds);
	},

	disableForm: function() {
		// Disable input
		self.input().attr('disabled', true);
		self.submit().attr('disabled', true);

		// Disable submit button
		self.submit().disabled(true);
	},

	enableForm: function() {
		// Enable and reset input
		self.input().removeAttr('disabled');
		self.submit().removeAttr('disabled');

		// Enable submit button
		self.submit().enabled(true);
	},

	'{parent} newCommentSaved': function() {
		self.submit()
			.removeClass('is-loading');

		// Enable comment form
		self.enableForm();

		// Reset the attachments
		opts.attachmentIds = [];

		// Reset the giphy
		self.giphyURL = null;

		// Get all the attachment items in the queue
		var attachmentItems = self.attachmentItem.inside(self.attachmentQueue.selector);

		attachmentItems.remove();

		self.attachmentQueue().removeClass('has-attachments');

		// Reset comment input
		self.input().val('');
	}
}});

module.resolve();

});
			EasySocial.module('site/comments/frame', function($) {

var module = this;

EasySocial
.require()
.library('mentions')
.script('site/comments/item', 'uploader/uploader', 'site/comments/form')
.done(function() {

EasySocial.Controller('Comments', {
	defaultOptions: {

		'group': 'user',
		'element': 'stream',
		'verb': 'null',
		'uid': 0,
		'enterkey': 'newline',
		'url': '',
		'streamid': '',
		'clusterid': '',

		// Comment link
		'{actionLink}': '[data-stream-actions] [data-action] [data-type=comments]',
		'{actionContent}': '[data-action-contents-comments]',

		'{stat}': '[data-comments-stat]',
		'{load}': '[data-comments-load]',
		'{list}': '[data-comments-list]',
		'{item}': '[data-comments-item]',
		'{form}': '[data-comments-form]'
	}
}, function(self, opts, base) { return {

	init: function() {

		opts.uid = base.data('uid') || opts.uid;
		opts.element = base.data('element') || opts.element;
		opts.group = base.data('group') || opts.group;
		opts.verb = base.data('verb') || opts.verb;
		opts.url = base.data('url') || opts.url;
		opts.streamid = base.data('streamid') || opts.streamid;
		opts.timestamp = base.data('timestamp') || opts.timestamp;
		opts.clusterid = base.data('clusterid') || opts.clusterid;

		self.$Stat = self.addPlugin('stat');
		self.$Load = self.addPlugin('load');
		self.$List = self.addPlugin('list');
		self.$Form = self.addPlugin('form');

		// Comment Control needs to be required once when there is a frame on the page
		EasySocial.require().script('site/comments/control').done(function() {

			// This block needs to be registered
			EasySocial.Comments.register(self);
		});

		// Trigger commentInit on self
		self.trigger('commentInit', [self]);
	},

	// Create a registry of items
	$Comments: {},

	registerComment: function(instance) {
		var id = instance.options.id;

		self.$Comments[id] = instance;
	},

	'{actionLink} click' : function() {
		self.actionContent().toggle();
	},

	_export: function() {
		var data = {
			// "total": self.$Stat.total(),
			// "count": self.$Stat.count(),
			"timestamp": opts.timestamp,
			"ids": $._.keys(self.$Comments)
		};

		return data;
	},

	updateComment: function(comments) {

		var newComments = [];

		$.each(comments['ids'], function(commentid, state) {

			if (state !== true) {

				if (state === false) {
					// Trigger commentDeleted event on self (as parent)
					self.trigger('commentDeleted', [commentid]);
				} else {

					// Always ensure that the comments is enabled and append the comment to the list
					self.showComments();
					self.$List.addToList(state, 'append', false);

					// Add this comment into the list of new comments
					newComments.push(state);
				}
			}
		});

		// Update the new total count
		self.$Stat.total(comments['total']);

		// Trigger oldCommentsLoaded event
		self.trigger('oldCommentsLoaded', [newComments]);
	},

	showComments: function() {
		self.element.removeClass('t-hidden');
	},

	// Triggered on the wrapper level
	'{self} show': function() {
		self.showComments();

		// Focus on the input
		self.$Form.input().focus();
	}
}});

EasySocial.Controller('Comments.List', {
	defaultOptions: {
		'{list}': '[data-comments-list]',
		'{item}': '[data-comment-item]'
	}
}, function(self) { return {
	init: function() {

		// Multiple instances of items
		self.initItemController(self.item(), false);
	},

	initItemController: function(item, isNew) {
		item.addController('EasySocial.Controller.Comments.Item', {
			controller: {
				parent: self.parent
			},
			isNew: isNew
		});

		return item;
	},

	'{parent} newCommentSaved': function(el, event, comment) {
		// Add the comment to the list
		self.addToList(comment);
	},

	addToList: function(comment, type, isNew) {
		// Set type to append by default
		type = type === undefined ? 'append' : type;

		// Set isNew to true by default
		isNew = isNew === undefined ? true : isNew;

		// Wrap comment in jQuery
		comment = $(comment);

		// Implement item controller on comment
		self.initItemController(comment, isNew);

		// Check if type is append/prepend
		if(type == 'append' || type == 'prepend') {

			// Prepare function values based on type (append/prepend)
			var filter = type == 'append' ? ':last' : ':first',
				action = type == 'append' ? 'after' : 'before';

			// Add the comment item into list
			if(self.item().length === 0) {
				// If no comments yet then add the html into the list
				self.list().html(comment);
			} else {
				// If there are existing comments, then append/prepend comment into the list
				self.item(filter)[action](comment);
			}
		} else {

			// If type is neither append or prepend, then type could be the comment id
			var item = self.parent.$Comments[type];

			// Check if type is a valid comment, if it is then by this means prepend on top
			if(item !== undefined) {
				item.element.before(comment);
			}
		}

		// Show the whole comment block because the block could be hidden
		self.parent.actionContent().show();
	},

	'{parent} commentDeleted': function(el, event, id) {
		// Remove this comment from comment registry
		if (self.parent.$Comments[id] !== undefined) {

			// Remove the element
			self.parent.$Comments[id].element.remove();

			// Remove the controller reference in the registry
			delete self.parent.$Comments[id];
		}
	},

	'{parent} commentUpdated': function(el, event, id, comment) {

		// Remove this comment from comment registry
		if (self.parent.$Comments[id] !== undefined) {

			// Wrap comment in jQuery
			comment = $(comment);

			// Implement item controller on comment
			self.initItemController(comment, false);

			var commentItemWrapper = $('[data-comment-item][data-id=' + id + ']');

			commentItemWrapper.replaceWith(comment);
		}
	}

}});

EasySocial.Controller('Comments.Stat', {
	defaultOptions: {
		'{stats}': '[data-comments-stats]',
		"count": 0,
		"total": 0,
		"limit": 10
	}
}, function(self, opts, base) { return {

	init: function() {
		opts.count = self.element.data('count');
		opts.total = self.element.data('total');
	},

	// Get / set total comments
	total: function(count) {

		if (count !== undefined) {
			opts.total = parseInt(count);

			var visible = self.stats().find('[data-visible]');
			visible.text(self.count());

			var total = self.stats().find('[data-total]');
			total.text(self.total());
		}

		return opts.total;
	},

	// Get / set current comments
	count: function(count) {

		if (count !== undefined) {
			opts.count = parseInt(count);

			var visible = self.stats().find('[data-visible]');
			visible.text(self.count());

			var total = self.stats().find('[data-total]');
			total.text(self.total());
		}

		return opts.count;
	},

	getNextCycle: function() {
		var start = Math.max(self.total() - self.count() - opts.limit, 0);
		var limit = self.total() - self.count() - start;

		return {
			"start": start,
			"limit": limit
		};
	},

	'{parent} oldCommentsLoaded': function(el, event, comments) {
		var count = comments.length;

		self.count(self.count() + count);
	},

	'{parent} newCommentSaved': function(element, event, html, stats) {

		self.total(self.total() + 1);
		self.count(self.count() + 1);
	},

	'{parent} commentDeleted': function() {
		self.total(self.total() - 1);

		self.count(self.count() - 1);
	}
} });

EasySocial.Controller('Comments.Load', {
	defaultOptions: {
		'{load}'		: '[data-comments-load]',
		'{loadMore}'	: '[data-comments-load-loadMore]'
	}
}, function(self) { return {

	'{loadMore} click': function(el, event) {
		if(el.enabled()) {

			// Disable the button
			el.disabled(true);

			// Get boundary details
			var cycle = self.parent.$Stat.getNextCycle();

			// If limit is 0, means no comment to load
			if (cycle.limit == 0) {
				return false;
			}

			// Send load comments command to the server
			self.loadComments(cycle.start, cycle.limit)
				.done(function(comments) {
					// Comments come in with chronological order array
					// Hence need to reverse comment and prepend from bottom

					// Create a copy of reverse comments to not affect the original array
					// Slice is to create a non reference copy of the array
					var reversedComments = comments.slice().reverse();

					$.each(reversedComments, function(index, comment) {
						self.parent.$List.addToList(comment, 'prepend', false);
					});

					// Trigger oldCommentsLoaded event
					self.parent.trigger('oldCommentsLoaded', [comments]);

					// Enable the button
					el.enabled(true);

					// If start is 0, means this is the last round of comments to load
					cycle.start == 0 && self.load().hide();

					// re-init reaction when in mobile
					if (window.es.mobile || window.es.tablet) {
						window.es.initReactions();
					}

				})
				.fail(function(msg) {

					// Trigger oldCommentsLoadError event
					self.parent.trigger('oldCommentsLoadError', [msg]);
				});
		}
	},

	loadComments: function(start, limit) {

		limit = limit || 10;

		return EasySocial.ajax('site/controllers/comments/load', {
			uid: self.parent.options.uid,
			element: self.parent.options.element,
			group: self.parent.options.group,
			verb: self.parent.options.verb,
			start: start,
			length: limit
		});
	}
}});




module.resolve();
});


});
			EasySocial.module('site/comments/item', function($) {
var module = this;

EasySocial.require()
.library('mentions')
.script('site/comments/form', 'uploader/uploader')
.done(function() {

EasySocial.Controller('Comments.Item', {
	defaultOptions: {
		'id': 0,
		'child': 0,
		'loadedChild': 0,
		'limit': 10,
		'isNew': false,

		// Comment item wrapper
		'{wrapper}': '[data-comment-wrapper]',

		// Content of the comment
		'{content}': '[data-comment-content]',

		// Editing
		'{editor}': '[data-comment-editor]',
		'{edit}': '[data-comment-actions] [data-edit]',
		'{input}'	: '[data-comment-input]',
		'{cancel}': "[data-comment-editor] [data-cancel]",
		'{save}': "[data-comment-editor] [data-save]",

		// Giphy
		'{giphyButton}': '[data-giphy-button]',
		'{giphyPlaceholder}': '[data-giphy-placeholder]',
		'{giphyPreview}': '[data-giphy-preview]',
		'{giphyRemove}': '[data-giphy-remove]',
		'{giphyContainer}': '[data-giphy-container]',

		'{giphyItemPreviewPlaceholder}': '[data-giphy-item-preview-placeholder]',
		'{giphyItemPreview}': '[data-giphy-item-preview]',
		'{giphyPermalink}': '[data-giphy-permalink]',

		// Actions
		'{delete}': '[data-comment-actions] [data-delete]',
		'{loadReplies}': '[data-comments-item-loadReplies]',
		'{readMore}': '[data-es-comment-readmore]',
		'{fullContent}': '[data-es-comment-full]',

		// Attachments
		"{attachmentQueue}": "[data-comment-attachment-queue]",
		"{attachmentProgress}": "[data-comment-attachment-progress-bar]",
		"{attachmentBackground}": "[data-comment-attachment-background]",
		"{attachmentRemove}": "[data-comment-attachment-remove]",
		"{attachmentItem}": "[data-comment-attachment-item]",
		"{attachmentButton}": "[data-uploader-browse]",
		"{attachmentDelete}": "[data-comment-attachment-delete]",

		"{uploaderForm}": "[data-uploader-form]",
		"{itemTemplate}": "[data-comment-attachment-template]",

		"{dismissError}": "[data-comment-error-dismiss]",
		"{errorMessage}": "[data-comment-error]",
		"{errorCommentMessage}": "[data-comment-error-message]",

		"{uploadItem}": "[data-comment-photo-upload-item]",

		attachmentIds:[],
		emoticons: []
	}
}, function(self, opts) { return {
	init: function() {

		// Get available hints for friend suggestions and hashtags
		opts.hints = {
				"friends": $('[data-hints-friends]'),
				"hashtags": $('[data-hints-hashtags]'),
				"emoticons": $('[data-hints-emoticons]')
		};

		// Initialise comment id
		opts.id = self.element.data('id');

		// Initialise child count
		opts.child = self.element.data('child');

		// Register self into the registry of comments
		self.parent.registerComment(self);
	},

	giphyURL: null,
	currentGiphyURL: null,
	attachmentTemplate: null,

	removeGiphy: function() {
		self.giphyPreview().attr('src', '');

		// Hide preview in comment form
		self.giphyPlaceholder().addClass('t-hidden');

		self.giphyURL = null;
		self.currentGiphyURL = null;
	},

	showGiphy: function(url) {
		self.giphyItemPreviewPlaceholder().removeClass('t-hidden');
		self.giphyItemPreview().prop('src', url);
		self.giphyPermalink().prop('href', url);
	},

	updateGiphy: function(item) {
		var imageUrl = item.data('original');

		// Ensure that the old giphy item has been removed
		self.removeGiphy();

		self.giphyPlaceholder().removeClass('t-hidden');
		self.giphyPreview().prop('src', imageUrl);

		// Set the width given the width of the image
		self.setGiphyImageWidth();

		self.giphyURL = imageUrl;
	},

	setGiphyImageWidth: function() {
		self.giphyPlaceholder().css('width', '100%');
		self.giphyRemove().addClass('t-hidden');
		self.giphyContainer().addClass('is-loading');

		self.giphyPreview().off('load').on('load', function() {
			self.giphyContainer().removeClass('is-loading');

			var parent = $(this).parent();

			// Display the placeholder and set the width given the width of the image
			setTimeout(function() {
				var computedWidth = parent.css('width');

				self.giphyPlaceholder().css('width', computedWidth);
			}, 10);

			self.giphyRemove().removeClass('t-hidden');
		});
	},

	bindClickGiphyItem: function(popbox) {
		popbox.tooltip
			.find('[data-giphy-item]')
			.off('click.giphy.comment.edit')
			.on('click.giphy.comment.edit', function() {
				var item = $(this);

				self.updateGiphy(item);

				// Hide the popbox once an item is selected
				popbox.hide();
			});
	},

	"{giphyButton} popboxActivate": function(element, event, popbox) {
		// Ensure event is exclusive to edit comment only
		event.stopPropagation();

		popbox.tooltip
			.find('[data-popbox-content]')
			.off('giphyAfterSearch')
			.on('giphyAfterSearch', function(event, query) {
				self.bindClickGiphyItem(popbox);
			});

		self.bindClickGiphyItem(popbox);
	},

	"{giphyRemove} click": function() {
		self.removeGiphy();
	},

	getAttachmentTemplate: function() {

		if (!self.attachmentTemplate) {
			self.attachmentTemplate = self.itemTemplate().detach();
		}

		var tpl = $(self.attachmentTemplate).clone().html();

		return $(tpl);
	},

	populateAttachmentOnEdit: function(curEditor, attachmentFiles) {

		// find the attachment queue data attribute
		var attachmentQueue = curEditor.find(self.attachmentQueue().selector);

		$.each(attachmentFiles, function(index, attachmentFile) {

			// Get the attachment template
			var item = self.getAttachmentTemplate();

			// Set the queue to use has-attachments class
			attachmentQueue
				.addClass('has-attachments');

			// Insert the item into the queue
			item.attr('id', attachmentFile.id)
				// .prependTo(attachmentQueue);
				.appendTo(attachmentQueue);

			// show the attachment during editing operation
			var item = self.attachmentQueue().find('#' + attachmentFile.id);

			// Add preview image here
			self.attachmentBackground.inside(item)
				.css('background-image', 'url("' + attachmentFile.permalink + '")');

			// find the delete icon for each attachment item
			var deleteButton = item.find(self.attachmentRemove);

			// insert attachment data id for those attachment already stored in database
			$(deleteButton).attr('data-id', attachmentFile.id);
			$(deleteButton).attr('data-edit-comment-attachment', '');

			// the behavior is if the user delete those attachment which already stored in database
			// we need to show the delete dialog pop up
			$(deleteButton).removeAttr('data-comment-attachment-remove');
			$(deleteButton).attr('data-comment-attachment-delete', '');

		});
	},

	'{edit} click': function(link, event) {

		if (!link.enabled()) {
			return;
		}

		// Get the editor
		var editor = self.editor();
		var mentions = editor.controller('mentions');

		// Manually clear out the html and destroy the mentions controller to prevent conflict of loading the editFrame again.
		editor.empty();

		if (mentions) {
			mentions.destroy();
		}

		// Disable the edit link
		link.disabled(true);

		// Trigger commentEditLoading event
		// self.trigger('commentEditLoading', [self.options.id]);

		EasySocial.ajax('site/controllers/comments/edit', {
			id: self.options.id
		}).done(function(contents, attachmentFiles) {

			// Hide the current contents and show the editor
			self.wrapper().hide();

			self.editor().show();

			// Append the form to the edit frame
			self.editor().html(contents).show();

			// Implement uploader controller during edit comment
			var curEditor = self.editor().find('[data-comments-editor]')
				.implement(EasySocial.Controller.Uploader, {
					'temporaryUpload': true,
					'query': 'type=comments',
					'type': 'comments',
					extensionsAllowed: 'jpg,jpeg,png,gif'
				});

			self.uploader = curEditor.controller('uploader');
			self.addPlugin("uploader", self.uploader);

			self.setMentionsLayout();

			self.input().focus();

			// Get the current giphy url
			self.giphyURL = self.editor().find('[data-giphy-preview]').attr('src');

			// hide attachment button if there got giphyURL
			if (self.giphyURL) {
				self.attachmentButton().addClass('t-hidden');
			}

			// Set the width given the width of the image
			self.setGiphyImageWidth();

			// Just in case the giphy URL is invalid, we just use show back the current giphy
			self.currentGiphyURL = self.giphyURL;

			// Process this if this comment has attachment
			if (attachmentFiles) {

				// Hide giphy button
				self.giphyButton().addClass('t-hidden');

				self.populateAttachmentOnEdit(curEditor, attachmentFiles);
			}
		});
	},

	setMentionsLayout: function() {
		var editor = self.editor();
		var mentions = editor.controller("mentions");

		if (mentions) {
			mentions.cloneLayout();
			return;
		}

		editor.mentions({
			triggers: {
				"@": {
					type: "entity",
					wrap: false,
					stop: "",
					allowSpace: true,
					finalize: true,
					query: {
						loadingHint	: true,
						searchHint: opts.hints.friends.find('[data-search]').html(),
						emptyHint: opts.hints.friends.find('[data-empty]').html(),
						data: function (keyword) {

							var task = $.Deferred();

							EasySocial.ajax( "site/controllers/friends/suggest" , {
								"search": keyword,
								clusterId: self.parent.options.clusterid
							}).done(function(items) {

								if (!$.isArray(items)) {
									task.reject();
								}

								var items = $.map(items, function(item){

									var html = $('<div/>').html(item);
									var title = html.find('[data-suggest-title]').val();
									var id = html.find('[data-suggest-id]').val();

									return {
										"id": id,
										"title": title,
										"type": "user",
										"menuHtml": item
									};
								});

								task.resolve(items);
							})
							.fail(task.reject);

							return task;
						},
						use: function(item) {
							return item.type + ":" + item.id;
						}
					}
				},
				"#": {
					type: "hashtag",
					wrap: true,
					stop: " #",
					allowSpace: false,
					query: {
						loadingHint	: true,
						searchHint: opts.hints.hashtags.find('[data-search]').html(),
						emptyHint: opts.hints.hashtags.find('[data-empty]').html(),

						data: function(keyword) {

							var task = $.Deferred();

							EasySocial.ajax("site/controllers/hashtags/suggest", {
								search: keyword
							}).done(function(items) {
								if (!$.isArray(items)) {
									task.reject();
								}

								var items = $.map(items, function(item) {

									return {
										"title": "#" + $.trim(item),
										"type": "hashtag",
										"menuHtml": item
									};
								});

								task.resolve(items);
							}).fail(task.reject);

							return task;
						}
					}
				},
				":": {
						type: "emoticon",
						wrap: true,
						stop: "",
						allowSpace: false,
						query: {
							loadingHint: true,
							searchHint: opts.hints.emoticons.find('[data-search]').html(),
							emptyHint: opts.hints.emoticons.find('[data-empty]').html(),
							data: $.parseJSON(self.parent.options.emoticons),
							renderAll: true
						}
					}
			},
			plugin: {
				autocomplete: {
					id: "es",
					component: "es",
					position: {
						my: 'left top',
						at: 'left bottom',
						of: editor,
						collision: 'none'
					},
					size: {
						width: function() {
							return editor.width();
						}
					}
				}
			}
		});
	},

	"{input} keyup": function(element, event) {
		// Prevent cursor keys from moving between photos
		event.preventDefault();
		event.stopPropagation();
	},

	'{cancel} click': function() {

		// Destroy the editor
		self.editor().empty();
		self.wrapper().show();

		self.edit().enabled(true);

		// Trigger editCommentTrigger event
		self.trigger('editCommentTrigger');

		// clear the attachment queue
		self.clearAttachmentForm();
	},

	// When the file is uploaded, we need to remove the uploading state
	"{uploader} FileUploaded": function(el, event, uploader, file, response) {

		// keep track local attachment id here.
		opts.attachmentIds.push(response.id);
	},

	"{attachmentRemove} click": function(removeLink, event) {

		var item = removeLink.parents(self.attachmentItem.selector);

		// Remove the item from the attachment ids
		opts.attachmentIds = $.without(opts.attachmentIds, item.data('id'));
	},

	'{save} click': function(el) {

		// Get and trim the edit value
		var input = self.input().val();

		// Do not proceed if value is emptycommentDeletedcommentDeleted
		if (input == '' && (!self.giphyURL || self.giphyURL == undefined)) {
			return false;
		}

		// Trigger commentEditSaving event
		// self.trigger('commentEditSaving', [self.options.id, input]);

		var mentions = self.editor().mentions("controller");

		EasySocial.ajax('site/controllers/comments/update', {
			"id": self.options.id,
			"input": self.input().val(),
			"giphy": self.giphyURL ? self.giphyURL : self.currentGiphyURL,
			"attachmentIds": opts.attachmentIds,
			"mentions": mentions ? mentions.toArray() : []
		}).done(function(comment, giphyInValid) {

			// Update the comment content
			// self.content().html(comment);

			// Trigger editCommentTrigger event
			// Need to trigger this before commentUpdated event
			self.trigger('editCommentTrigger');

			// comment id
			var commentId = self.options.id;

			// trigger the comment update event for implment the controller
			// Because need to render the comment item again after comment update
			self.parent.trigger('commentUpdated', [commentId, comment]);

			if (giphyInValid) {
				self.giphyURL = self.currentGiphyURL;
			}

			// If there is any giphy url, it should be updated on screen
			if (self.giphyURL) {
				self.showGiphy(self.giphyURL);
			}

			// There is a possibility that user removed their giphy
            if (!self.giphyURL) {
            	// Hide preview in comments listing
            	self.giphyItemPreviewPlaceholder().addClass('t-hidden');
                self.removeGiphy();
            }

			// Hide the editor
			self.editor().empty().hide();
			self.wrapper().show();

			self.edit().enabled(true);

			// clear the attachment queue
			self.clearAttachmentForm();
		});
	},

	'{delete} click': function(el) {

		EasySocial.dialog({
			content: EasySocial.ajax('site/views/comments/confirmDelete', {
				id: self.options.id
			}),
			bindings: {
				"{deleteButton} click": function() {

					// Close the dialog
					EasySocial.dialog().close();

					EasySocial.ajax('site/controllers/comments/delete', {
						id: self.options.id
					}).done(function() {

						// Trigger commentDeleted event on parent, since this element will be remove, no point triggering on self
						self.parent.trigger('commentDeleted', [self.options.id]);

					});
				}
			}
		});
	},

	'{loadReplies} click': function(el) {
		// Hide the loadReplies button
		el.hide();

		// Add a loader after this comment first

		// Calculate the start
		var start = Math.max(self.options.child - self.options.loadedChild - self.options.limit, 0);

		// Get the child comments
		EasySocial.ajax()
			.done(function(comments) {

				// Append the comments below the current comment item
				$.each(comments, function(index, comment) {
					self.parent.$List.addToList(comment, 'child', false);
				});

				// Trigger oldCommentsLoaded event
				self.parent.trigger('oldCommentsLoaded', [comments]);

				// Check if we need to show the load more replies button in the current item
				start > 0 && self.loadMoreReplies().show();
			});
	},

	'{readMore} click': function(el, ev) {
		self.content().html(self.fullContent().html());
	},

	clearAttachmentForm: function() {

		// Reset the attachments
		opts.attachmentIds = [];

		// Get all the attachment items in the queue
		var attachmentItems = self.attachmentItem.inside(self.attachmentQueue.selector);

		attachmentItems.remove();

		self.attachmentQueue().removeClass('has-attachments');
	}
}});

module.resolve();

});

});
			EasySocial.module( 'site/conversations/composer' , function($){

var module 	= this;

EasySocial.require()
.library('mentions')
.script('site/friends/suggest', 'uploader/uploader')
.done(function($){

EasySocial.Controller('Conversations.Composer', {
	defaultOptions: {

		draftMessage: {},
		emoticons: [],

		// Determines if these features should be enabled.
		"attachments": true,
		"location": true,
		"showNonFriend": false,
		"isNewPage": false,

		// Uploader properties.
		"extensionsAllowed": "",

		// File uploads
		"{uploader}": "[data-composer-attachment]",
		"{uploaderQueueItem}": "[data-uploaderQueue-item]",

		// Mass Conversation.
		"{massConversation}": "[data-mass-conversation-checkbox]",

		// Location service.
		"{location}": "[data-composer-location]",

		// The text editor.
		"{editorHeader}": "[data-composer-editor-header]",
		"{editorArea}": "[data-composer-editor-area]",
		"{editor}": "[data-composer-editor]",

		// Wrapper for suggest to work.
		"{friendSuggest}": "[data-friends-suggest]",

		"{recipients}": "input[name=uid\\[\\]],input[name=list_id\\[\\]]",

		"{recipientRow}": "[data-composer-recipients]",
		"{messageRow}": "[data-composer-message]",

		// submit button
		"{submit}" : "[data-composer-submit]",
	}
}, function(self, opts) { return {

	init: function() {

		// Initialize the participants textbox.
		self.initSuggest();

		// Initialize uploader
		if (opts.attachments) {
			self.initUploader();
		}

		// Since the page just initialized, we just update it with not typing
		if (!opts.isNewPage) {
			self.setTyping(0);
		}

		self.setMentionsLayout();

		if (!opts.isNewPage) {
			window.onbeforeunload = function() {
				self.setTyping(0);
			};
		}

		if (self.parent !== undefined) {
			self.options.emoticons = self.parent.options.emoticons
		}
	},

	initUploader: function() {
		// Implement uploader controller.
		self.uploader().implement(EasySocial.Controller.Uploader, {
			"temporaryUpload": true,
			"query": "type=conversations",
			"type": 'conversations',
			"extensionsAllowed": opts.extensionsAllowed
		});
	},

	initSuggest: function() {
		self.friendSuggest()
			.addController(EasySocial.Controller.Friends.Suggest, {
					friendList: true,
					friendListName: "list_id[]",
					showNonFriend: opts.showNonFriend,
					privacyRule: 'profiles.post.message',
					type: 'conversations'
				});
	},

	initEditor: function() {
		self.editor().expandingTextarea();
	},

	setTyping: function(typing) {
		var state = typing === true ? 1 : 0;

		$.ajax({
			"url": window.es.rootUrl + '/components/com_easysocial/polling.php',
			"method": "post",
			"data": {
				"method": "typing",
				"userId": self.parent.options.userId,
				"typing": state,
				"key": self.parent.options.userKey,
				"conversationId": self.parent.options.conversationId
			}
		});
	},

	resetForm: function() {
		self.editor().val('');
	},

	typingTimer: null,

	"{submit} click": function(el) {
		var tagsArray = self.editorArea().mentions('controller').toArray();
		var tags = $.map(tagsArray, function(mention){
			if (mention.type==="emoticon" && $.isPlainObject(mention.value)) {
				mention.value = mention.value.title.slice(1);
			}
			return mention;
		});

		if (tags) {
			$.each(tags, function(idx, tag) {
				$.each(tag, function(key, element) {
					$('<input>').attr({
						type: 'hidden',
						name: 'tags[' + idx + '][' + key + ']',
						value: element
					}).appendTo('[data-composer-form]');
				});
			})
		}
	},

	"{massConversation} change": function(el) {
		if (el.is(':checked')) {
			self.recipientRow().hide();
			return;
		}

		self.recipientRow().show();
	},

	// Capture ctrl + enter / cmd + enter submission
	"{editor} keydown": function(editor, event) {

		if (opts.isNewPage) {
			return;
		}

		if ((event.metaKey || event.ctrlKey || self.parent.options.enterToSubmit) && event.keyCode == 13) {
			self.trigger('save');
			event.preventDefault();

			return;
		}

		if (!self.parent.options.typingState || opts.isNewPage) {
			return;
		}

		self.setTyping(true);

		// Update the typing state
		clearTimeout(self.typingTimer);

		self.typingTimer = setTimeout(self.setTyping, 1000);
	},

	// When a new item is added, we want to disable reply button and reenable it when the upload finished
	"{uploader} FilesAdded": function(el, event, uploader, files) {
		self.parent.toggleReplyButton(true);
	},

	"{uploader} FileUploaded": function(el, event, uploader, files) {

		// If there is no more file in queue, we re-enable the reply button
		if ($('[data-uploaderqueue]').children('.is-queue').length == 0) {
			self.parent.toggleReplyButton(false);
		}

	},

	// Uploader
	"{uploaderQueueItem} FileUploaded": function(element, event, file, response) {

		var state = element.find('[data-upload-state]');

		// Once it is uploaded, removed the uploading state
		state.remove();
	},

	"{uploaderQueueItem} FileError": function(element, event, file, response) {
		var state = element.find('[data-upload-state]');
		var message = state.data('error');

		state.html(message)
			.removeClass('t-text--success')
			.addClass('t-text--danger');
	},

	saveDraftMessage: function() {
		// Get current conversation id
		var id = self.parent.replyForm().data('id');

		opts.draftMessage[id] = self.editor().val();
	},

	setDraftMessage: function(id) {
		var message = opts.draftMessage[id];

		self.editor().val(message);
	},

	setMentionsLayout: function() {

		var editor = self.editorArea();
		var mentions = editor.controller("mentions");

		if (mentions) {
			mentions.cloneLayout();
			return;
		}

		var header = self.editorHeader();

		editor
			.mentions({

				triggers: {

					"@": {
						type : "entity",
						wrap : false,
						stop : "",
						allowSpace : true,
						finalize : true,
						query:
						{
							loadingHint	: true,
							searchHint	: $('[data-hints-friends]').find('[data-search]').html(),
							emptyHint	: $('[data-hints-friends]').find('[data-empty]').html(),

							data: function(keyword) {

								var task = $.Deferred();

								EasySocial.ajax("site/controllers/friends/suggest" , { search: keyword })
								.done(function(items) {
									if (!$.isArray(items)) task.reject();

									var items = $.map(items, function(item)
									{
										var html = $('<div/>').html(item);
										var title = html.find('[data-suggest-title]').val();
										var id = html.find('[data-suggest-id]').val();

										return {
											"id": id,
											"title": title,
											"type": "user",
											"menuHtml": item
										};
									});

									task.resolve(items);
								})
								.fail(task.reject);

								return task;
							},
							use: function(item) {
								return item.type + ":" + item.id;
							}
						}
					},
					"#":
					{
						type : "hashtag",
						wrap : true,
						stop : " #",
						allowSpace : false,
						query:
						{
							loadingHint : false,
							searchHint : $('[data-hints-friends]').find('[data-search]').html(),
							emptyHint : $('[data-hints-friends]').find('[data-empty]').html(),
							data: function(keyword)
							{
								var task = $.Deferred();

								EasySocial.ajax("site/controllers/hashtags/suggest", {search: keyword})
									.done(function(items)
									{
										if (!$.isArray(items)) task.reject();

										var items = $.map(items, function(item){

											var html = $('<div/>').html(item);
											var title = html.find('[data-suggest-title]').val();
											var id = html.find('[data-suggest-id]').val();

											return {
												"id": id,
												"title": "#" + title,
												"type": "hashtag",
												"menuHtml": item
											};
										});

										task.resolve(items);
									})
									.fail(task.reject);

								return task;
							}
						}
					},
					":": {
						type: "emoticon",
						wrap: true,
						stop: "",
						allowSpace: false,
						query: {
							loadingHint: true,
							searchHint: $('[data-hints-emoticons]').find('[data-search]').html(),
							emptyHint: $('[data-hints-emoticons]').find('[data-empty]').html(),
							data: $.parseJSON(self.options.emoticons),
							renderAll: true
						}
					}
				},
				plugin:
				{
					autocomplete:
					{
						id : "es",
						component : "",
						sticky: true,
						shadow: true,
						position:
						{
							my: 'left top',
							at: 'left bottom',
							of: header,
							collision: 'none'
						},
						size:
						{
							width: function()
							{
								return header.width();
							}
						}
					}
				}
			});
	}
}});

module.resolve();
});

});

			EasySocial.module('site/conversations/conversations', function($){

var module  = this;

EasySocial.require()
.library("scrollTo")
.script('site/conversations/composer','site/conversations/item')
.done(function($){

EasySocial.Controller('Conversations', {

	defaultOptions: {

		// Determines if these features should be enabled.
		attachments : true,
		location : true,
		maxSize : "3mb",
		extensionsAllowed : "",
		isMobile : false,
		enterToSubmit: false,

		attachmentController : null,
		locationController : null,
		composerController   : null,

		"{tabs}" : "[data-es-tab]",
		"{contents}": "[data-contents]",
		"{conversationHeader}" : "[data-es-conversation-header]",

		"{listWrapper}" : "[data-es-list]",
		"{contentsWrapper}" : "[data-es-contents-wrapper]",

		"{lists}" : "[data-es-list-items]",
		"{listItem}" : "[data-es-item]",

		"{emptyListSidebar}" : "[data-es-list-empty]",
		"{emptyContents}" : "[data-es-content-empty]",
		"{emptyActionBtn}" : "[data-es-action-btn-empty]",

		"{scroller}" : "[data-es-scroller]",
		"{latestWrapper}" : "[data-es-latest]",
		"{messageContent}" : "[data-es-messages]",
		"{messageItems}" : "[data-es-message]",
		"{toolDropDown}" : "[data-item-tools]",

		"{unreadButton}" : "[data-es-unread]",
		"{archiveButton}" : "[data-es-archive]",
		"{unarchiveButton}" : "[data-es-unarchive]",
		"{leaveButton}" : "[data-es-leave]",
		"{deleteButton}" : "[data-es-delete]",
		"{addParticipant}" : "[data-es-addparticipant]",
		"{viewParticipants}" : "[data-es-viewparticipants]",
		"{editTitle}" : "[data-es-rename]",

		"{composer}" : "[data-es-composer]",

		"{attachments}" : "[data-uploaderQueue-id]",
		"{replyForm}" : "[data-es-reply-form]",

		"{replyButton}" : "[data-es-reply-button]",
		"{attachmentForm}" : "[data-es-attachment-form]",
		"{attachmentToggle}" : "[data-es-attachment-toggle]",
		"{emoticonsToggle}" : "[data-comment-smileys]",
		"{attachmentCloseBtn}" : "[data-es-attachment-close]",

		"{locationForm}" : "[data-es-location-form]",
		"{locationToggle}" : "[data-es-location-toggle]",

		"{conversationTitle}" : "[data-es-title]",
		"{conversationActions}" : "[data-es-actions]",
		"{titleContainer}" : "[data-es-title-container]",
		"{titleInputBox}" : "[data-es-title-textbox]",
		"{titleSaveButton}" : "[data-title-save]",
		"{titleCancelButton}" : "[data-title-cancel]",

		// Giphy
		'{giphyButton}': '[data-giphy-button]',
		'{giphyPlaceholder}': '[data-giphy-item-preview-placeholder]',
		'{giphyPreview}': '[data-giphy-item-preview]',

		// Item
		"{item}": "[data-item]",
		"{itemMenuDropdown}": "[data-menu-dropdown]",
		"{itemMenu}": "[data-item-menu]",
		"{listTitleInput}": "[data-es-title-textbox-list]",
		"{listTitleSaveButton}": "[data-title-save-list]",
		"{listRenameTitleButton}": "[data-es-rename-list]",

		"{typing}": "[data-typing]",

		// search
		"{search}": "[data-es-search]",

		// conversation back button. used in responsive mode.
		"{backBtn}": "[data-back-button]",

		"{pagination}": "[data-es-conversation-pagination]",
		"{paginationWrapper}" : "[data-es-conversation-pagination-wrapper]",
		"{smileyItem}": "[data-comment-smiley-item]"
	}
}, function(self, opts, base) { return {
	init: function() {

		// Implement composer controller.
		self.composer().implement(EasySocial.Controller.Conversations.Composer, {
			"{parent}"  : self,
			"{uploader}" : "[data-es-attachment-form]",
			"{location}" : "[data-es-location]",
			maxSize : self.options.maxSize,
			extensionsAllowed : self.options.extensionsAllowed,
			emoticons: self.options.emoticons
		});

		self.options.composerController = self.composer().controller();

		// Get the uploader controller.
		if (opts.attachments) {
			self.options.attachmentController = self.options.composerController.uploader().controller();
		}

		if (self.options.location){
			self.options.locationController = self.options.composerController.location().controller();
		}

		self.messageContent().implement(EasySocial.Controller.Conversations.Message, {
			"{parent}"  : self
		});

		self.lists().implement(EasySocial.Controller.Conversations.Item, {
			"{parent}"  : self
		});

		self.goToLatest();
	},

	setActiveTab: function(tab) {
		self.tabs().removeClass('active');
		tab.addClass('active');

		self.wrapperEmpty(false);
		self.loading(true);
		self.conversationTitle().empty();
	},

	getConversationItem: function(element) {
		var item = element.closest(self.item.selector);

		return item;
	},

	filter: $.debounce(function(keyword) {

		var totalList = self.listItem().length;
		if (totalList <= 0) {
			// nothing to find. just return false.
			return;
		}
		self.listWrapper().removeClass("is-empty");

		if (!keyword || !(keyword=$.trim(keyword)) || keyword.length <= 2) {
			// self.listItem().removeClass('hidden');
			self.listItem().show();
			return;
		}

		// show all 1st
		self.listItem().show();

		var list = self.listItem().filter(function() {
			// if not match, then return this item so that we can 'hide' it.
			if ($(this).data('title').indexOf(keyword.toLowerCase()) <= -1) {
				return this;
			}
		});

		if (list.length == totalList) {
			// this mean no item found. show empty list message.
			self.listWrapper().addClass("is-empty");
		}

		list.hide();


	}, 250),

	"{composer} save": function() {
		self.replyButton().click();
	},

	"{search} keyup": function() {
		var keyword = self.search().val();
		self.filter(keyword);
	},

	"{itemMenuDropdown} click": function(dropdown, event) {
		event.preventDefault();
		event.stopPropagation();

		// is-dropdown is injected to all conversation item. It should be removed.
		var wrapper = dropdown.parents('[data-es-list-items]');
		wrapper.find('[data-item]').removeClass('is-dropdown');

		// inject is-dropdown class when conversation is click.
		dropdown.closest('[data-item]').addClass('is-dropdown');

		var button = dropdown.find('[data-bs-toggle]');
		button.trigger('click.bs.dropdown');
	},

	"{itemMenu} click" : function(menu, event) {

		var item = self.getConversationItem(menu);
		var id = item.data('id');
		var task = menu.data('item-menu');

		if (task == 'unread') {
			self.setUnread(id);
			return;
		}

		self.showDialog(task, id);
	},

	"{listItem} click": function() {

		// need to clear off the title edit form.
		if (self.conversationHeader().hasClass('is-editing')) {
			self.toggleTitleEditForm();
		}
	},

	loadMore: function() {

		//conversation id
		var type = self.pagination().data('type');

		// Get the pagination attributes
		var limitstart = self.pagination().data('limitstart');

		if (limitstart < 0) {
			return;
		}

		// Set the current loading state
		self.moreLoading = true;

		// Add loading indicator
		self.pagination().addClass('is-loading');

		EasySocial.ajax('site/views/conversations/getConversations',{
			"type" : type,
			"limitstart" : limitstart,
			'loadmore' : 1
		}).done(function(conversations, emptyList, emptyContents, nextlimit) {

			// we need to remove the pagination becuase the new html already included the pagination div.
			self.pagination().data('limitstart', nextlimit);

			// append the conversations into the list
			self.lists().append(conversations);

			if (nextlimit < 0) {
				self.paginationWrapper().addClass('t-hidden');
			}

			// add support to kunena [tex] replacement.
			try { MathJax && MathJax.Hub.Queue(["Typeset",MathJax.Hub]); } catch(err) {};

		}).always(function(){
			self.pagination().removeClass('is-loading');
			self.moreLoading = false;
		});

	},

	"{pagination} click" : function(el, event) {
		self.loadMore();
	},

	"{tabs} click" : function(tab, event) {
		event.stopPropagation();
		event.preventDefault();

		var anchor = tab.find('> a');
		anchor.route();

		self.setActiveTab(tab);

		var type = tab.data('es-tab');

		EasySocial.ajax('site/views/conversations/getConversations',{
			"type": type
		}).done(function(conversations, emptyList, emptyContents, nextlimit){

			self.contents().removeClass('has-active');

			if (conversations.length < 1) {
				self.pagination().data('limitstart', '0');
				self.wrapperEmpty(true, type, emptyList, emptyContents);
				self.replyForm().addClass('t-hidden');
				self.paginationWrapper().addClass('t-hidden');
			} else {

				self.pagination().data('limitstart', nextlimit);
				self.contents().addClass('has-active');
				self.replyForm().removeClass('t-hidden');

				if (nextlimit < 0) {
					self.paginationWrapper().addClass('t-hidden');
				} else {
					self.paginationWrapper().removeClass('t-hidden');
				}

			}

			// re-assign the contents to th conversation listing.
			self.lists().html(conversations);

			if (!self.options.isMobile) {
				// Find the first list item
				var item = self.lists().children(':first').find('[data-es-conversation]');
				item.trigger('click');
			}

			self.loading(false);
		});

	},

	"{backBtn} click": function() {
		// triggering conversation toggle for responsive view
		self.trigger('togglees.conversation');
	},

	// mark unread
	"{deleteButton} click": function() {
		var conversationId = self.replyForm().data('id');
		self.showDialog('Delete', conversationId);
	},

	"{archiveButton} click": function() {
		var conversationId = self.replyForm().data('id');
		self.showDialog('Archive', conversationId);
	},

	"{unarchiveButton} click": function() {
		var conversationId = self.replyForm().data('id');
		self.showDialog('Unarchive', conversationId);
	},

	"{leaveButton} click": function() {
		var conversationId = self.replyForm().data('id');
		self.showDialog('Leave', conversationId);
	},


	"{unreadButton} click": function() {
		var conversationId = self.replyForm().data('id');
		self.setUnread(conversationId);
	},

	"{addParticipant} click": function() {
		var conversationId = self.replyForm().data('id');
		self.showInviteForm(conversationId);
	},

	"{viewParticipants} click": function() {
		var conversationId = self.replyForm().data('id');
		self.showParticipants(conversationId);
	},

	"{attachmentToggle} click" : function(el, event) {
		// Stop bubbling up.
		event.preventDefault();
		self.attachmentForm().toggleClass('t-hidden');
	},

	"{emoticonsToggle} click" : function(el, event) {
		// Stop bubbling up.
		event.preventDefault();

		if (el.hasClass('active')) {
			el.removeClass('active');
			return;
		}

		el.addClass('active');
	},

	"{attachmentCloseBtn} click" : function(el, event) {
		self.attachmentForm().toggleClass('t-hidden');
	},

	"{locationToggle} click" : function(el, event) {
		// Stop bubbling up.
		event.preventDefault();
		self.locationForm().toggleClass('t-hidden');
	},

	"{editTitle} click": function(el, event) {
		self.toggleTitleEditForm();

		// now assign the title into the textbox
		var title = self.conversationTitle().text();

		title = title.trim();

		self.titleInputBox().val(title);
		self.titleInputBox().focus();
	},

	"{titleInputBox} keydown": function(el, event) {
		var wrapper = el.parents('[data-es-title-container]');
		var saveButton = wrapper.find('[data-title-save]');

		if (event.keyCode == 13) {
			saveButton.trigger('click');
			event.preventDefault();
		}

		if (event.keyCode == 27) {
			self.toggleTitleEditForm();
		}
	},

	"{listTitleInput} keydown": function(el, event) {

		var wrapper = el.parents('[data-es-item]');
		var saveButton = wrapper.find('[data-title-save-list]');

		// Capture enter key
		if (event.keyCode == 13) {
			saveButton.trigger('click');
			event.preventDefault();
		}

		// Capture esc button to cancel the edit
		if (event.keyCode == 27) {
			self.toggleItemTitle(wrapper);
		}
	},

	"{listRenameTitleButton} click": function(el, event) {
		var wrapper = el.parents('[data-es-item]');

		// Toggle item title button
		self.toggleItemTitle(wrapper);

		// now assign the title into the textbox
		var title = wrapper.find('[data-item-title]').text().trim();
		var inputBox = wrapper.find('[data-es-title-textbox-list]');

		inputBox.val(title);
		inputBox.focus();
	},

	toggleItemTitle: function(wrapper) {
		var itemTitleBox = wrapper.find('[data-item-title-textbox]');
		var itemTitle = wrapper.find('[data-item-title]');

		// Reset the classes first
		$(itemTitle).removeClass('t-hidden');
		wrapper.removeClass('is-editing-title');

		var isNotActive = $(itemTitleBox).toggleClass('t-hidden').hasClass('t-hidden');

		if (!isNotActive) {
			$(itemTitle).addClass('t-hidden');
			wrapper.addClass('is-editing-title');
		}
	},

	toggleTitleEditForm: function() {
		self.conversationHeader().toggleClass('is-editing');

		// clear the input box
		self.titleInputBox().val('');
	},

	"{titleCancelButton} click": function(el, event) {
		self.toggleTitleEditForm();
	},

	"{titleSaveButton} click": function(el, event) {

		//disable button
		self.titleSaveButton().attr('disabled', true);

		var id = self.replyForm().data('id');
		var title = self.titleInputBox().val();

		if (title.trim() == '') {
			self.titleSaveButton().attr('disabled', false);
			return;
		}

		var options = {
			"id" : id,
			"title" : title
		};

		// Do an ajax call to submit the reply.
		EasySocial.ajax('site/controllers/conversations/updateTitle', options)
		.done(function(title) {
			self.conversationTitle().text(title);
			self.updateListTitle(id, title);
			self.toggleTitleEditForm();

		})
		.fail(function(error) {

			EasySocial.dialog({
				content: error.message
			});
		})
		.always(function(){
			self.titleSaveButton().attr('disabled', false);
		});
	},

	"{listTitleSaveButton} click": function(el, event) {
		$(el).attr('disabled', true);

		var wrapper = el.parents('[data-es-item]');
		var id = wrapper.data('id');
		var title = wrapper.find('[data-es-title-textbox-list]').val();

		var options = {
			"id" : id,
			"title" : title
		};

		// Do an ajax call to submit the reply.
		EasySocial.ajax('site/controllers/conversations/updateTitle', options)
		.done(function(title) {

			parentId = self.replyForm().data('id');

			// If current conversation is being display, let's update the title on the fly.
			if (parentId == id) {
				self.conversationTitle().text(title);
			}

			self.updateListTitle(id, title);
			self.toggleItemTitle(wrapper);

		})
		.fail(function(error) {

			EasySocial.dialog({
				content: error.message
			});
		})
		.always(function(){
			$(el).attr('disabled', false);
		});
	},

	updateListTitle: function(id, title) {
		// need to update the conversation title at left panel
		var curConversation = $('[data-es-item][data-id="' + id + '"]');

		if (curConversation.length > 0) {
			curConversation.data('title', title);
			curConversation.find("[data-link]").attr('title', title);
			curConversation.find("[data-item-title]").text(title);
		}
	},

	isReplying: false,

	toggleReplyButton: function(action) {
		self.replyForm().toggleClass('is-uploading', action);
		self.replyButton().toggleClass('disabled', action);
	},

	"{replyButton} click" : function( el , event ) {

		if (self.replyForm().hasClass('is-uploading')) {
			return false;
		}

		// Stop bubbling up.
		event.preventDefault();

		var conversationId = self.replyForm().data('id');

		var content = opts.composerController.editor().val();
		var files = new Array;

		if (opts.attachments) {
			// Get through each attachments.
			self.attachments().each(function(i, attachment){
				var fid = $( attachment ).val();
				if (fid) {
					files.push( $( attachment ).val() );
				}
			});
		}

		if (content.length <= 0 && files.length <= 0) {
			return false;
		}

		if (self.isReplying) {
			return false;
		}

		self.isReplying = true;

		var options = {
			"id" : conversationId,
			"message" : content
		};

		if (self.options.attachments) {
			options['upload-id'] = files;
		}

		if (self.options.location) {
			var locationController = self.composer().controller().location().controller();
			options.address     = locationController.textField().val();
			options.latitude    = locationController.latitude().val();
			options.longitude   = locationController.longitude().val();
		}

		options['tags'] = self.composer().controller().editorArea().mentions('controller').toArray();

		options['tags'] = $.map(options['tags'], function(mention){

			if (mention.type==="emoticon" && $.isPlainObject(mention.value)) {
				mention.value = mention.value.title.slice(1);
			}
			return JSON.stringify(mention);
		});

		// Disable submit button.
		self.replyButton().attr('disabled', true);

		// Do an ajax call to submit the reply.
		self.submitReply(options);

		return false;
	},

	insertGiphy: function(item) {
		var imageUrl = item.data('original');
		var conversationId = self.replyForm().data('id');
		var options = {
			"id" : conversationId,
			"message" : imageUrl,
			"giphy" : true
		};

		self.submitReply(options);
	},

	bindClickGiphyItem: function(popbox) {
		popbox.tooltip
			.find('[data-giphy-item]')
			.off('click.giphy.conversation.form')
			.on('click.giphy.conversation.form', function() {
				var item = $(this);

				self.insertGiphy(item);

				// Hide the popbox once an item is selected
				popbox.hide();
			});
	},

	"{giphyButton} popboxActivate": function(element, event, popbox) {
		event.stopPropagation();

		popbox.tooltip
			.find('[data-popbox-content]')
			.off('giphyAfterSearch')
			.on('giphyAfterSearch', function(event, query) {
				self.bindClickGiphyItem(popbox);
			});

		self.bindClickGiphyItem(popbox);
	},

	submitReply: function(options) {
		EasySocial.ajax('site/controllers/conversations/reply', options)
		.done(function(message, html, lastupdate) {

			// update the lastupdate timestamp
			$('[data-es-item][data-id="' + options['id'] + '"]').data('lastupdate', lastupdate);

			// Apply controller on the appended item.
			var item = $(html);

			// Append the data back to the list.
			self.messageContent().append(item);

			// If is sent by giphy, we do not need to reset the form #3669
			if (!options['giphy']) {
				// Reset the composer form.
				self.resetForm();
			}
			
			// Go to the latest reply
			self.goToLatest();

			// Add loader to the giphy image to tell the users that the image hasn't finish load
			item.find('[data-giphy-item-preview-placeholder]').addClass('is-loading');

			item.find('[data-giphy-item-preview]')
				.off('load')
					.on('load', function() {
						item.find('[data-giphy-item-preview-placeholder]').removeClass('is-loading');										
					});
		})
		.fail(function(error) {
			EasySocial.dialog({
				content: error.message
			});
		})
		.always(function(){
			self.replyButton().attr('disabled', false);
			self.isReplying = false;
		});
	},



	getLanguageString: function(string) {
		return $('[data-id="' + string + '"]').text();
	},

	resetForm: function() {
		// Reset the editor form.
		self.options.composerController.resetForm();

		var mentions = self.composer().controller().editorArea().mentions('controller');
		mentions.reset();

		if (self.options.location) {
			// Reset the location.
			// self.options.locationController.unset();
			var locationController = self.composer().controller().location().controller();
			locationController.unset();

			// hide the location form.
			self.locationForm().addClass('t-hidden');

		}

		if (self.options.attachments) {
			// Reset the uploader.
			self.options.attachmentController.reset();

			// hide the attatchment form.
			self.attachmentForm().addClass('t-hidden');
		}
	},


	loading: function(loading) {

		if (loading) {
			self.listWrapper().addClass('is-loading');
			self.contentsWrapper().addClass('is-loading');
		} else {
			self.listWrapper().removeClass('is-loading');
			self.contentsWrapper().removeClass('is-loading');
		}
	},

	wrapperEmpty: function(isEmpty, type, emptyList, emptyContent) {
		if (isEmpty) {

			// update the empty content message.
			self.emptyListSidebar().find('div.o-empty__text').html(emptyList);
			self.emptyContents().find('div.o-empty__text').html(emptyContent);

			if (type == 'archives') {
				self.emptyActionBtn().addClass('t-hidden');
				self.toolDropDown().addClass('t-hidden');
			} else {
				self.emptyActionBtn().removeClass('t-hidden');
				self.toolDropDown().removeClass('t-hidden');
			}

			self.editTitle().addClass('t-hidden');
			self.listWrapper().addClass('is-empty');
			self.contentsWrapper().addClass('is-empty');
		} else {
			self.listWrapper().removeClass('is-empty');
			self.contentsWrapper().removeClass('is-empty');
			self.toolDropDown().removeClass('t-hidden');
			self.editTitle().removeClass('t-hidden');
		}
	},

	// Set an active conversation item
	setActiveConversation: function(item) {
		// Update the conversation area
		self.listItem().removeClass('is-active');

		// Addd active class on the element
		item.addClass('is-active');

		item.removeClass('is-unread');

		self.toolDropDown().removeClass('hidden');

		// Go to the latest content
		self.goToLatest();
	},

	// Scroll to the latest
	goToLatest: function() {
		self.scroller().scrollTo(self.latestWrapper(), 250, {offset: {top: -100}});
	},

	showDialog: function(type, id) {
		var methodName = type.charAt(0).toUpperCase() + type.slice(1);

		EasySocial.dialog({
			"content": EasySocial.ajax('site/views/conversations/confirm' + methodName, {
				"id" : id
			})
		});
	},

	showInviteForm: function(id) {
		EasySocial.dialog(
		{
			content : EasySocial.ajax( 'site/views/conversations/addParticipantsForm', {
				"id" : id
			})
		});
	},

	showParticipants: function(id) {
		EasySocial.dialog(
		{
			content : EasySocial.ajax( 'site/views/conversations/viewParticipants', {
				"id" : id
			})
		});
	},

	setUnread: function(id) {

		EasySocial.ajax( 'site/controllers/conversations/markUnread',{
			"id"   : id
		}).done(function(){
			var item = $('[data-es-item][data-id="' + id + '"]');
			if (item.length > 0) {
				item.removeClass('is-active');
				item.addClass('is-unread');
			}
		})
		.fail(function( message ){
			EasySocial.dialog({
				content: message
			});
		})
	},

	"{smileyItem} click": function(smileyItem, event) {

		var editor = self.composer().controller().editorArea();
		var value = smileyItem.data('comment-smiley-value');

		// Add additional space to allow multiple smiley to be click at once. #3122
		value = value + ' ';

		var controller = editor.mentions("controller");

		var textarea = controller.textarea();

		previousCursor = controller.previousCursorPosition;

		var currentValue = textarea.val();
		var beforeValue = currentValue.substring(0, previousCursor) + value;
		var newValue = beforeValue + currentValue.substring(previousCursor);

		// We need to trigger the mention
		controller.isPasting = true;
		controller.smileyLength = value.length;

		textarea.val(newValue);
		textarea.trigger('input');

		controller.moveCursor(beforeValue.length);
	}


}});

module.resolve();

});

});

			EasySocial.module( 'site/conversations/filter' , function($){

	var module 	= this;


	EasySocial.require()
	.done( function($){

		EasySocial.Controller(
			'Conversations.Filter',
			{
				defaultOptions:
				{
				}
			},
			function( self ){

				return {

					init: function()
					{
					},

					"{self} click" : function()
					{
						var type 		= self.element.data( 'filter' ),
							selector	= '.' + type,
							total 		= self.parent.item( selector ).length;

						if( $("[data-mailboxitem]").filter(".active").length == 1 )
						{
							var curActiveMenu = $("[data-mailboxitem]").filter(".active");

							var url 	= curActiveMenu.data( 'url' ),
								title 	= curActiveMenu.data( 'title' ),
								mailbox	= curActiveMenu.data( 'mailbox' );


							History.pushState( {state:1} , title , url );

							// Get contents via ajax.
							EasySocial.ajax( 'site/views/conversations/getItems' ,
							{
								"mailbox"	: mailbox,
								"filter" 	: type,
								"limitstart": 0
							},
							{
								beforeSend: function()
								{
									// Add loading indicator.
									self.parent.toggleLoading();
								}
							})
							.done(function( content , empty ){


								// Remove loading class on the content.
								self.parent.toggleLoading();

								if( content.length <= 0 )
								{
									// Empty the contents too to maintain the integrity of the checkbox
									self.parent.updateContent( '' );
									return self.parent.showEmpty();
								}

								// Hide empty class if it has items.
								self.parent.hideEmpty();

								// Now we'd need to update the content.
								self.parent.updateContent( content , mailbox );

							});



						}

						// if( type == 'all' )
						// {
						// 	if( self.parent.item().length == 0 )
						// 	{
						// 		self.parent.showEmpty();
						// 	}
						// 	else
						// 	{
						// 		self.parent.hideEmpty();
						// 	}

						// 	self.parent.item().show();
						// }
						// else
						// {

						// 	// Hide all conversations initially.
						// 	self.parent.item().hide();


						// 	if( total == 0 )
						// 	{
						// 		// Show empty.
						// 		self.parent.showEmpty();
						// 	}
						// 	else
						// 	{
						// 		// Always hide empty when there are items.
						// 		self.parent.hideEmpty();
						// 	}

						// 	// Only show the necessary item.
						// 	self.parent.item( "." + type ).show();
						// }
					}
				}
			}
		);

		module.resolve();
	});

});

			EasySocial.module( 'site/conversations/item' , function($){

var module  = this;

EasySocial.require()
.script('site/conversations/message')
.library('scrollTo')
.done(function($){

EasySocial.Controller('Conversations.Item', {
	defaultOptions: {
		"keepAliveInterval": 3,
		"typingInterval": 2,
		'activeItem' : '',
		"{item}": "[data-es-conversation]"
	}
}, function(self, opts){ return {

	init: function() {
		var activeItem = $('[data-es-item].is-active');

		if (activeItem.length > 0) {
			opts.activeItem = activeItem;
			self.keepAlive();

			if (self.parent.options.typingState) {
				self.checkTypingState();
			}
		}
	},

	checkTypingState: function() {
		var interval = opts.typingInterval * 1000;

		setTimeout(function(){
			$.ajax({
				"url": window.es.rootUrl + '/components/com_easysocial/polling.php',
				"method": "post",
				"data": {
					"method": "typingState",
					"userId": self.parent.options.userId,
					"key": self.parent.options.userKey,
					"conversationId": self.parent.options.conversationId
				}
			}).done(function(data) {
				var typing = self.parent.typing();

				if (data.users == null) {
					typing.addClass('t-hidden');
					self.checkTypingState();
					return;
				}

				var message = self.parent.options.typingMessage;
				message = message.replace('%s', data.users.name);

				$('[data-typing]')
					.html(message)
					.removeClass('t-hidden')

				self.checkTypingState();
			});

		}, interval);
	},

	"{item} click" : function(el, event) {

		var item = el.closest('[data-es-item]');

		// Do not trigger anything
		if (item.hasClass('is-editing-title')) {
			return;
		}

		opts.activeItem = item;

		// Find the anchor link so we can route it
		var anchor = item.find('[data-link]');
		anchor.route();

		// Save any current message in the form as draft
		self.parent.options.composerController.saveDraftMessage();

		// Get the object property
		var id = item.data('id');

		// We need to update the reply form id.
		self.parent.replyForm().data('id', id);
		self.parent.options.composerController.setDraftMessage(id);

		// Add loader and clear up contents
		self.parent.contentsWrapper().addClass('is-loading');
		self.parent.messageContent().empty();

		// triggering conversation toggle for responsive view
		self.trigger('togglees.conversation');

		EasySocial.ajax( 'site/views/conversations/getConversation',{
			"id"   : id,
			"isloadmore" : 0
		}).done(function(title, messages, lastupdate, actions, lastCreatorUserEmail, lastCreatorExist, canEditTitle) {

			var arguments = [title, messages, lastupdate, actions, lastCreatorUserEmail, lastCreatorExist, canEditTitle];
			self.trigger('es.getConversation', arguments);

			// Update the parent's conversation id
			self.parent.options.conversationId = id;

			// update the timestamp on lastupdate
			item.data('lastupdate', lastupdate);

			// Update the title
			self.parent.conversationTitle().html(title);

			self.parent.editTitle().toggleClass('t-hidden', !canEditTitle);

			// Update the contents
			self.parent.messageContent().html(messages);

			self.parent.messageContent().implement(EasySocial.Controller.Conversations.Message , {
				"{parent}": self
			});

			// append the actions into dropdown.
			if (actions != undefined && actions.length > 0) {
				self.parent.toolDropDown().html(actions);
			}

			// Set active conversation
			setTimeout(function() {
				self.parent.setActiveConversation(item);
			}, 1);

			// check for new messages.
			self.keepAlive();
		})
		.fail(function( message ){
			self.parent.messageContent().html(message);
		})
		.always(function() {
			self.parent.contentsWrapper().removeClass('is-loading');
		});

	},

	"keepAlive": function() {
		// When checking, ensure that all previous queues are stopped
		self.stop();

		// now start new checking
		self.start();
	},

	getInterval: function() {
		var interval = opts.keepAliveInterval * 1000;

		return interval;
	},

	start: function() {
		self.options.state = setTimeout(self.check, self.getInterval());
	},

	stop: function() {
		clearTimeout(self.options.state);
	},

	check: function() {
		// When checking, ensure that all previous queues are stopped
		self.stop();

		setTimeout(function(){

			var lastUpdate = opts.activeItem.data('lastupdate');

			$.ajax({
				"url": window.es.rootUrl + '/components/com_easysocial/polling.php',
				"method": "post",
				"data": {
					"method": "checkNewMessages",
					"userId": self.parent.options.userId,
					"key": self.parent.options.userKey,
					"conversationId": self.parent.options.conversationId,
					"lastUpdate": lastUpdate
				}
			}).done(function(data) {

				// Update the last updated timestamp
				opts.activeItem.data('lastupdate', data.timestamp);

				if (data.hasNew) {

					// Make an ajax call to retrieve the HTML
					EasySocial.ajax('site/views/conversations/getNewMessages', {
						"id": self.parent.options.conversationId,
						"lastUpdate": lastUpdate,
						"isActive": 1
					}).done(function(messages) {
						self.parent.messageContent().append(messages);

						self.parent.messageItems().implement(EasySocial.Controller.Conversations.Message, {
							"{parent}": self
						});

						self.parent.goToLatest();
					});
				}

				// Restart the loop
				self.start();
			});

		}, self.getInterval());
	}
}});

module.resolve();

});

});

			EasySocial.module( 'site/conversations/message' , function($){

var module  = this;

EasySocial.Controller('Conversations.Message', {
	defaultOptions: {
		"{attachmentDelete}" : "[data-es-attachment-delete]",
		"{pagination}": "[data-es-message-pagination]",
		"{paginationWrapper}" : "[data-es-message-pagination-wrapper]"
	}
}, function(self, opts){ return {

	loadMore: function() {
		//conversation id
		var id = self.pagination().data('id');

		// Get the pagination attributes
		var limitstart = self.pagination().data('limitstart');

		if (id == '') {
			return;
		}

		if (limitstart < 0) {
			return;
		}

		// Set the current loading state
		self.loading = true;

		// Add loading indicator
		self.pagination().addClass('is-loading');

		EasySocial.ajax('site/views/conversations/getConversation',{
			"id" : id,
			"limitstart" : limitstart,
			"isloadmore" : 1
		}).done(function(title, messages) {

			// we need to remove the pagination becuase the new html already included the pagination div.
			self.paginationWrapper().remove();

			// prepend the messages into the list
			self.parent.messageContent().prepend(messages);

			// add support to kunena [tex] replacement.
			try { MathJax && MathJax.Hub.Queue(["Typeset",MathJax.Hub]); } catch(err) {};

		}).always(function(){
			self.pagination().removeClass('is-loading');
			self.loading = false;
		});

	},

	"{pagination} click" : function(el, event) {
		self.loadMore();
	},


	"{attachmentDelete} click" : function(el, event) {

		var attachmentId = $(el).data('id');

		EasySocial.dialog({
			content : EasySocial.ajax( 'site/views/conversations/confirmDeleteAttachment', { "id" : attachmentId } ),
			bindings :
			{
				"{deleteButton} click" : function() {
					EasySocial.ajax( 'site/controllers/conversations/deleteAttachment', {
						id  : attachmentId
					})
					.done(function(message) {
						// Remove the attachment element.
						$(el).parents('[data-es-attachment]').remove();

						EasySocial.dialog({
							content : message
						});
					})
					.fail(function(message) {
						self.setMessage(message);
					})
				}
			}
		});

	}

}});

module.resolve();

});

			EasySocial.module('site/cover/cover', function($) {

var module = this;

EasySocial.require()
.library("image")
.done(function() {

EasySocial.Controller('Cover', {
	defaultOptions: {
		"uid": null,
		"type": null,
		"{image}" : "[data-cover-image]",
		"{editButton}" : "[data-cover-edit-button]",
		"{doneButton}": "[data-cover-done-button]",
		"{cancelButton}": "[data-cover-cancel-button]",
		"{uploadButton}": "[data-cover-upload-button]",
		"{selectButton}": "[data-cover-select-button]",
		"{removeButton}": "[data-cover-remove-button]",
		"{menu}": "[data-cover-menu]",

		// Hack to disable click that causes photo popup on the flyout
		"{flyout}": ".es-flyout-content"
	}
}, function(self, opts, base) { return {

	init: function() {

		// Automatically enable cover editing if not manually disabled
		// if (!self.options.disabled) { self.start("url"); }

		self.setLayout();

		if (self.element.hasClass("editing")) {
			self.enable();
		}
	},

	"{editButton} click": function() {
		self.enable();

		// After enabling, manually get the position from self.element and apply it
		self.image().css('backgroundPosition', self.element.css('backgroundPosition'));
	},

	"{cancelButton} click": function(el, ev) {
		self.disable();
	},

	uploadNew: false,

	ready: false,

	disabled: true,

	uploading : false,

	toggle: function() {
		self[(self.disabled) ? "enable" : "disable"]();
	},

	enable: function() {
		self.setLayout();
		self.disabled = false;
		self.element.addClass("editing");

		// self.element
		// 	.removeClass('no-cover')
		// 	.addClass('has-cover');

		base.attr("data-es-photo-disabled", 1);
	},

	disable: function() {
		self.disabled = true;
		self.element.removeClass("editing");

		// Allow some time before enabling photo popup
		setTimeout(function(){
			base.attr("data-es-photo-disabled", 0);
		}, 1);

		var profileUrl =
			$.uri(window.location.href)
				.deleteQueryParam("cover_id")
				.toString();

		History.pushState({state: 0}, window.title, profileUrl);
	},

	imageLoaders: {},

	setLayout: function() {

		var cover = self.image(),
			image = self.setLayout.image;

		if (!image) {

			// Extract image url from cover
			var url = $.uri(cover.css("backgroundImage")).extract(0);

			// If no url given, stop.
			if (!url) return;

			// Load image
			var imageLoaders = self.imageLoaders,
				imageLoader =
					(imageLoaders[url] || (imageLoaders[url] = $.Image.get(url)))
						.done(function(image) {

							// Set it as current image
							self.setLayout.image = image;

							// Then set layout again
							self.setLayout();
						});

				return;
		}

		// Get measurements
		var imageWidth  = image.data("width"),
			imageHeight = image.data("height"),
			coverWidth  = cover.width(),
			coverHeight = cover.height(),
			size = $.Image.resizeProportionate(
				imageWidth, imageHeight,
				coverWidth, coverHeight,
				"outer"
			);

		self.availableWidth  = coverWidth  - size.width;
		self.availableHeight = coverHeight - size.height;
	},

	setCover: function(id, url) {

		// Show loading indicator
		self.element.addClass("is-loading");

		// Make sure the image has been properly loading
		$.Image.get(url)
			.done(function(){

				self.image()
					.data("photoId", id)
					.css({
						backgroundImage: $.cssUrl(url),
						backgroundPosition: "50% 50%"
					});

				// Reset position
				self.x = 0.5;
				self.y = 0.5;

				self.enable();
			})
			.fail(function(){
				self.disable();
			})
			.always(function(){
				self.element
					.removeClass('no-cover')
					.addClass('has-cover');

				self.element.removeClass("is-loading");
			});
	},

	drawing: false,

	moveCover: function(dx, dy, image) {

		// Optimization: Pass in reference to image
		// so we don't have to query all the time.
		if (!image) { image = self.image(); }

		var w = self.availableWidth,
			h = self.availableHeight,
			x = (w==0) ? 0 : self.x + ((dx / w) || 0),
			y = (h==0) ? 0 : self.y + ((dy / h) || 0);

		// Always stay within 0 to 1.
		if (x < 0) x = 0; if (x > 1) x = 1;
		if (y < 0) y = 0; if (y > 1) y = 1;

		// Set position on cover
		image.css("backgroundPosition",
			((self.x = x) * 100) + "% " +
			((self.y = y) * 100) + "% "
		);
	},

	x: 0.5,

	y: 0.5,

	"{image} click": function(el, event) {
		if (!self.disabled) {
			event.stopPropagation();
		}
	},

	"{image} mousedown": function(selection, event) {

		if (self.disabled || self.drawing) return;

		if (event.target === self.image()[0]) {
			event.preventDefault();
		}

		self.drawing = true;
		base.addClass("active");

		// Initial cover position
		var image = self.image(),
			position = self.image().css("backgroundPosition").split(" ");
			self.x = parseInt(position[0]) / 100;
			self.y = parseInt(position[1]) / 100;

		// Initial cursor position
		var x = event.pageX,
			y = event.pageY;

		$(document)
			.on("mousemove.movingCover mouseup.movingCover", function(event) {

				if (!self.drawing) return;

				self.moveCover(
					(x - (x = event.pageX)) * -1,
					(y - (y = event.pageY)) * -1,
					image
				);
			})
			.on("mouseup.movingCover", function(event) {
				$(document).off("mousemove.movingCover mouseup.movingCover");

				base.removeClass("active");

				self.drawing = false;
			});
	},

	"{image} touchstart": function(selection, event) {

		if (self.disabled || self.drawing) return;

		self.drawing = true;
		base.addClass("active");

		// Initial cover position
		var image = self.image(),
			position = self.image().css("backgroundPosition").split(" ");
			self.x = parseInt(position[0]) / 100;
			self.y = parseInt(position[1]) / 100;

		// Initial touch position
		var touch = event.originalEvent.targetTouches[0],
			x = event.pageX,
			y = event.pageY;

		$(document)
			.on("touchmove.movingCover", function(event) {

				if (!self.drawing) return;

				var touch = event.originalEvent.targetTouches[0];

				self.moveCover(
					(x - (x = touch.pageX)) * -1,
					(y - (y = touch.pageY)) * -1,
					image
				);

				event.preventDefault();
			})
			.on("touchend.movingCover", function(){

				$(document).off("touchstart.movingCover touchend.movingCover");

				base.removeClass("active");

				self.drawing = false;
			});
	},

	save: function() {

		self.uploading = true;

		var photoId = self.image().data("photoId");

		var task =
			EasySocial.ajax(
				"site/controllers/cover/create",
				{
					uid: self.options.uid,
					type: self.options.type,
					id: photoId,
					x: self.x,
					y: self.y,
					uploadNew: self.uploadNew ? 1 : 0
				}
			)
			.done(function(cover)
			{
				// Set cover
				base
					.attr("data-es-photo", photoId)
					.css({
						backgroundImage: $.cssUrl(cover.url),
						backgroundPosition: cover.position
					})
					.removeClass("no-cover");

				// Disable editing
				self.disable();
			}).always(function() {
				self.uploading = false;
			});

		return task;
	},

	"{doneButton} click": function(el, event) {

		// Prevent event bubbling
		if (self.uploading) {
			return;
		}

		self.save();
	},

	"{menu} shown.bs.dropdown": function() {
		self.element.addClass("show-all");
	},

	"{menu} hidden.bs.dropdown": function() {
		self.element.removeClass("show-all");
	},

	"{selectButton} click": function() {

		base.attr('data-es-photo-disabled', 1);

		EasySocial.photos.selectPhoto({
			"uid": self.options.uid,
			"type": self.options.type,
			"bindings": {
				"{self} photoSelected": function(el, event, photos) {

					// Photo selection dialog returns an array,
					// so just pick the first one.
					var photo = photos[0];

					// If no photo selected, stop.
					if (!photo) return;

					// Set it as cover to reposition
					self.setCover(photo.id, photo.sizes.large);

					this.parent.close();

					base.attr('data-es-photo-disabled', 0);
				},

				"{cancelButton} click": function(el, event) {
					this.parent.close();

					base.attr('data-es-photo-disabled', 0);
				}
			}
		});
	},

	"{uploadButton} click": function() {
		base.attr('data-es-photo-disabled', 1);

		EasySocial.dialog({
			content: EasySocial.ajax("site/views/cover/uploadDialog", { "uid" : opts.uid , "type" : opts.type }),
			bindings: {
				"{self} upload": function(el, event, task, filename) {

					task.done(function(photo){

						// If the user uploading new photo, flag it
						self.uploadNew = true;
						self.setCover(photo.id, photo.sizes.large.url);
					});
				},

				"{cancelButton} click": function() {
					this.parent.close();

					base.attr('data-es-photo-disabled', 0);
				}
			}
		});
	},

	"{removeButton} click": function() {
		// We should check if there's anything to delete.

		EasySocial.ajax("site/controllers/cover/remove", { "uid" : self.options.uid , "type" : self.options.type })
			.done(function(defaultCoverUrl)
			{
				base.css({
						backgroundImage: $.cssUrl(defaultCoverUrl),
						backgroundPosition: "50% 50%"
					})
					.addClass("no-cover")
					.removeAttr("data-es-photo");

				self.disable();
			});
	},

	"{flyout} click": function(el, ev) {
		if (el.is($(ev.target))) {
			ev.stopPropagation();
		}
	}
}});

module.resolve();

});
});
			EasySocial.module("site/cover/post.as", function($){

var module = this;

EasySocial
.require()
.done(function($) {

EasySocial.Controller("Postas", {
	defaultOptions: {
		"{postAsToggle}": "[data-postas-toggle]",
		"{postAsItem}": "[data-postas-menu] > [data-item]",
		"{postAsIcon}": "[data-postas-toggle] > [data-postas-icon]",
		"{postAsAvatar}": "[data-postas-toggle] > [data-postas-avatar]",
		"{postAsKey}": "[data-postas-hidden]"
	}
}, function(self, opts, base) { return {

	init: function() {
		var storyAvatar = $('[data-es-container] [data-story-avatar]');
		storyAvatar.attr("src",self.postAsAvatar().find('img').attr('src'));
	},

	"{postAsItem} click" : function(item) {

		var data = $._.pick(item.data(), "value");

		data.icon = item.data('postas-icon');
		data.avatar = item.find('[data-postas-avatar]').html();
		data.name = item.find('[data-postas-avatar]').data('name');

		// Deactivate other Post As item
		self.postAsItem().removeClass("is-active");
		self.postAsItem('[data-value=' + data.value + ']').addClass('is-active');

		// Set Post As value
		self.postAsKey().val(data.value);

		// Update the display
		self.postAsIcon().attr("class", data.icon);
		self.postAsAvatar().html(data.avatar);
		self.postAsToggle().attr('data-original-title', 'View page as ' + data.name);

		// Update the story form avatar
		var storyAvatar = $('[data-es-container] [data-story-avatar]');
		storyAvatar.attr("src",self.postAsAvatar().find('img').attr('src'));
	},

}});

// Resolve module
module.resolve();

});

});
			EasySocial.module('site/dashboard/default' , function($){

var module = this;

EasySocial.require()
.library('history')
.script('site/stream/filter')
.done(function($){

EasySocial.Controller('Dashboard', {
	"defaultOptions": {
		"title": null,

		// Wrapper and content
		"{wrapper}": "[data-wrapper]",
		"{contents}": "[data-contents]",

		// Filter dropdown
		"{activeFilterText}": "[data-active-filter-text]",
		'{activeFilterButton}': "[data-active-filter-button]",
		"{filter}": "[data-filter-item]",
		"{filterWrapper}": "[data-filter-wrapper]",

		// Post type filters
		"{postTypeFilterWrapper}": "[data-filter-post-type-wrapper]",
		"{postTypeFilter}": "[data-filter-post-type]",
		"{postTypeFilterLabel}": "[data-filter-post-type-label]",

		// Hidden inputs to manipulate the states
		"{filterInput}": "[data-stream-filter]",

		// Custom filters
		"{createFilter}": "[data-filter-create]",
		"{editFilter}": "[data-edit-filter]",
		"{saveHashTag}": "[data-hashtag-filter-save]"
	}
}, function(self, opts) { return{

	init: function() {
		console.log('hello');
	},

	resetFilterCounters: function(filterItem) {
		// Clear the new feed notification counter.
		var counter = filterItem.find('[data-counter]');

		// Update the counter to 0
		counter.html("0");

		// Clear new feed counter
		filterItem.removeClass('has-notice');
	},

	setActiveFilter: function(filter) {
		// Find the wrapper
		var wrapper = filter.parents(self.filterWrapper.selector);
		var filters = wrapper.find(self.filter.selector);
		var type = filter.data('type');

		self.filterInput().val(type);

		filters.removeClass('active');
		filter.addClass('active');

		var title = filter.find('[data-filter-text]').html();
		var activeFilterText = wrapper.find(self.activeFilterText.selector);

		activeFilterText.html(title);
		wrapper.removeClass('open');
	},

	updateStream: function(filter, filterId, postTypes) {

		// Used only for custom filters
		var filterId = filterId != undefined ? filterId : '';

		// Used in combination with filter
		var postType = postType != undefined ? postType : '';

		// Notify the dashboard that it's starting to fetch the contents.
		self.updatingContents();

		// Remove empty state
		self.wrapper()
			.removeClass('is-empty');

		EasySocial.ajax('site/controllers/dashboard/getStream', {
			"type": filter,
			"postTypes": postTypes,
			"id": filterId,
			"view": 'dashboard',

		}).done(function(contents, count) {

			if (count == 0) {
				self.wrapper().addClass('is-empty');
			}

			// Trigger change for the stream
			self.trigger('onStreamUpdate', [filter]);

			// Trigger sidebar toggle for responsive view.
			self.trigger('onEasySocialFilterClick');

			window.streamFilter = filter;

			// Update the contents of the dashboard area
			self.updateContents(contents);

			// 3PD FIX: Kunena [text] replacement
			try {
				MathJax && MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
			} catch(err) {};

		}).fail(function(message) {
			return message;
		}).always(function() {

			// Give a tiny buffer to prevent call stack request from maxing out. #1733
			setTimeout(function() {
				self.clicked = false;
			}, 10);

		});
	},

	updatingContents: function() {
		self.contents().empty();
		self.wrapper().addClass('is-loading');
	},

	updateContents: function(contents) {
		self.wrapper().removeClass("is-loading");

		$('body').trigger('beforeUpdatingContents');

		// Hide the content first.
		$.buildHTML(contents)
			.appendTo(self.contents());

		$('body').trigger('afterUpdatingContents');
	},

	// Allows caller to remove all checked post types
	resetPostTypes: function() {
		self.postTypeFilter().removeAttr('checked');
	},

	// Prevent closing of dropdown
	"{postTypeFilterWrapper} click": function(element, event) {
		event.preventDefault();
		event.stopPropagation();
	},

	// Since we have prevented the closing of dropdown, we need to manually stop propagation here
	"{postTypeFilterLabel} click": function(element, event) {
		event.stopPropagation();
	},

	// Since we have prevented the closing of dropdown, we need to manually stop propagation here
	"{postTypeFilter} click": function(element, event) {
		event.stopPropagation();
	},

	"{postTypeFilter} change": function(element, event) {

		var active = self.getActiveFilter();
		var filter = active.data('type');
		var id = active.data('id');

		// Whenever there is a change of post type filter, we just recompute the value
		var postTypes = [];

		self.postTypeFilter(':checked').map(function() {
			postTypes.push($(this).val());
		});

		// Get the current filter on the page
		self.updateStream(filter, id, postTypes);
	},

	"{filter} click": function(filter, event) {

		// Prevent clicking any items more than once
		if (self.clicked) {
			return false;
		}

		self.resetPostTypes();
		self.clicked = true;

		// Prevent event from bubbling up
		event.preventDefault();
		event.stopPropagation();

		// Get the attributes of the item
		var type = filter.data('type');
		var id = filter.data('id');

		// Route the anchor links embedded
		var anchor = filter.find('> a');

		anchor.attr('title', opts.title);
		anchor.route();

		// Set the active filter
		self.setActiveFilter(filter);

		self.updateStream(type, id);
	},

	"{editFilter} click": function(element, event) {

		// Get the filter attributes
		var id = element.data('id');
		var type = element.data('type');

		EasySocial.dialog({
			"content": EasySocial.ajax('site/views/stream/getFilterFormDialog', {
				"type": type,
				"id": id
			})
		});
	},

	"{createFilter} click": function(element, event) {
		EasySocial.dialog({
			"content": EasySocial.ajax('site/views/stream/getFilterFormDialog', {"type": "user"})
		});
	},

	"{saveHashTag} click": function(el) {
		var hashtag = el.data('tag');

		EasySocial.dialog({
			"content": EasySocial.ajax('site/views/stream/getFilterFormDialog', {
				"type": "user",
				"hashtag": hashtag
			})
		});
	}
}});

module.resolve();

});

});
			EasySocial.module('site/discussions/browser', function($){

var module = this;

EasySocial.Controller('Discussions.Browser', {
	defaultOptions: {
		clusterType: false,
		clusterId: false,
		"{contents}": "[data-contents]",
		"{wrapper}": "[data-wrapper]",
		"{result}": "[data-result]"
	}
}, function(self,opts,base) { return {

	updatingContents: function() {
		self.wrapper().empty();
		self.contents().addClass('is-loading');
	},

	updateContents: function(html) {
		self.contents().removeClass('is-loading');
		self.wrapper().replaceWith(html);
	},

	getDiscussions: function(type, callback) {

		self.updatingContents();

		EasySocial.ajax('site/controllers/discussions/getDiscussions', {
			"id": opts.clusterId,
			"filter": type
		}).done(function(contents) {

			self.updateContents(contents);

			if (typeof(callback) == 'function') {
				callback.apply(contents);
			}

			// trigger sidebar toggle for responsive view.
			self.trigger('onEasySocialFilterClick');
		});
	}
}});

module.resolve();

});
			EasySocial.module('site/discussions/filter', function($){

var module = this;

EasySocial.require()
.script('site/discussions/browser')
.done(function($) {

EasySocial.Controller('Discussions.Filter', {
	defaultOptions: {
		clusterType: false,
		clusterId: false,
		"{filter}": "[data-es-discussions-filter] [data-filter-item]",
		"{discussionsController}": "[data-es-discussions][data-es-container]"
	}
}, function(self,opts,base) { return {

	init : function() {
		self.controller = self.getController();
	},

	getController: function() {
		var controller = self.discussionsController().controller();
		return controller;
	},

	setActiveFilter: function(filter) {

		var activeClass = (window.es.mobile || window.es.tablet || window.es.ios) ? 'is-active' : 'active';

		self.filter().removeClass(activeClass);

		filter.addClass(activeClass);
	},

	"{filter} click": function(filter, event) {

		if (self.controller === undefined) {
			return;
		}

		event.preventDefault();
		event.stopPropagation();

		// Route the anchor links embedded
		var anchor = filter.find('> .o-tabs__link');
		anchor.route();

		var type = filter.data('filter-item');

		self.setActiveFilter(filter);

		self.controller.getDiscussions(type, function(contents) {
			filter.removeClass('is-loading');
		});
	}
}});

module.resolve();

});
});
			EasySocial.module('site/events/browser', function($) {

var module = this;

EasySocial.require()
.done(function($) {


EasySocial.Controller('Events.Browser', {
	defaultOptions: {

		// Filters
		"{filterItem}": "[data-filter-item]",
		"{ordering}": "[data-ordering]",

		// Contents
		'{contents}': '[data-contents]',
		'{list}': '[data-events-list]',
		'{wrapper}': '[data-wrapper]',
		'{subWrapper}': '[data-sub-wrapper]',

		// Fetching location wrapper
		"{location}": "[data-fetching-location]",
		"{locationMessage}": "[data-detecting-location-message]",
		"{osmMap}": "[data-osm-map]",

		// Date navigation
		"{navigate}": "[data-navigation-date]",

		// Calendar
		'{calendar}': '[data-events-calendar]',
		"{calendarWrapper}": "[data-events-calendar-wrapper]",

		// Include past events options
		'{includePastCheckbox}': '[data-events-past]',
		'{includePastLink}': '[data-include-past-link]',

		// Hide repetition events options
		'{hideRepetitionCheckbox}': '[data-events-repetition]',
		'{hideRepetitionLink}': '[data-hide-repetition-link]',

		// Distance searches
		'{radius}': '[data-radius]',

		filter: null,
		categoryId: 0,
		delayed: false,
		includePast: false,
		ordering: 'start',
		hasLocation: false,
		userLatitude: '',
		userLongitude: '',
		distance: 10,
		group: null,
		page: null,
		isModule: false,
		clusterId: null
	}
}, function(self, opts) { return {

	init: function() {
		opts.filter = self.element.data('filter');
		opts.categoryId = self.element.data('categoryid');
		opts.clusterId = self.element.data('clusterid');

		self.isUpdating = false;

		if (self.options.delayed) {
			self.delayedInit();
		}
	},

	delayedInit: function() {
		// It is possible that view is flagging it as "delayed" in order for javascript to make an ajax call to retrieve the data instead

		// delayed init will have some preset parameter coming from url, hence we don't use the filterbynearby method

		if (opts.filter === 'nearby') {
			self.filterEventsNearby();
		}
	},

	setActiveFilter: function(filterItem) {
		self.filterItem().removeClass('active');
		filterItem.addClass('active is-loading');

		self.activeFilter = filterItem;
	},

	setLocation: function(latitude, longitude) {
		opts.latitude = latitude;
		opts.longitude = longitude;
	},

	setUserId: function(userId) {
		opts.userId = userId;
	},

	setFilter: function(filter) {
		opts.filter = filter;
	},

	setCategoryId: function(categoryId) {
		opts.categoryId = categoryId;
	},

	clearContents: function(showLoading) {
		var showLoading = showLoading === undefined ? true : showLoading;

		self.element.removeClass('is-detecting-location');
		self.contents().empty();

		if (showLoading) {
			self.wrapper().addClass('is-loading');
		}
	},

	updatingContents: function() {
		self.contents().empty();
		self.wrapper().addClass('is-loading');
		self.element.removeClass('is-detecting-location');
	},

	updateContents: function(html) {
		self.wrapper().removeClass('is-loading');

		if (self.activeFilter) {
			self.activeFilter.removeClass('is-loading');
		}

		self.contents().html(html);
	},

	updatingListing: function() {
		self.list().empty();
		self.subWrapper().addClass('is-loading');
	},

	updateListing: function(html) {

		self.subWrapper().removeClass('is-loading');
		self.list().html(html);
	},

	updateIncludePastLink: function(link) {
		self.includePastLink().attr('href', link);
	},

	updateHideRepetitionLink: function(link) {
		self.hideRepetitionLink().attr('href', link);
	},


	setSortLink: function(type, link) {
		var sortUrl = $('a[data-ordering="' + type + '"]');

		if (sortUrl.length > 0) {
			sortUrl.attr('href', link);
		}
	},

	getEvents: function(isSorting, callback) {
		// Include past
		var includePast = opts.includePast ? 1 : 0;

		// Include past
		var hideRepetition = opts.hideRepetition ? 1 : 0;

		// When user clicked on My Event filter
		// We will always include past event
		if ((opts.filter == 'mine' || opts.filter == 'createdbyme') && isSorting === false) {
			includePast = 1;
		}

		EasySocial.ajax('site/controllers/events/filter', {
			"type": opts.filter,
			"date": opts.date,
			"categoryId": opts.categoryId,
			"sort": isSorting ? 1 : 0,
			"ordering": opts.ordering,
			"includePast": includePast,
			"hideRepetition": hideRepetition,
			"latitude": opts.userLatitude,
			"longitude": opts.userLongitude,
			"distance": opts.distance,
			"clusterId": opts.clusterId,
			"activeUserId": opts.activeUserId,
			"browseView": opts.browseView
		}).done(function(contents, includePastUrl, hideRepetitionUrl, recentSortingUrl, startSortingUrl, distanceSortingUrl) {

			if ($.isFunction(callback)) {
				callback.call(this, contents, includePastUrl, hideRepetitionUrl, recentSortingUrl, startSortingUrl, distanceSortingUrl);
			}

			if (isSorting) {

				// update all the sorting urls.
				self.updateSortingUrls(includePastUrl, hideRepetitionUrl, recentSortingUrl, startSortingUrl, distanceSortingUrl);

				self.updateListing(contents);
				return;
			}

			self.updateContents(contents);

			$('body').trigger('afterUpdatingContents', [contents]);

			if (!isSorting) {
				// trigger sidebar toggle for responsive view.
				self.trigger('onEasySocialFilterClick');
			}
		}).always(function() {
			self.isUpdating = false;
		});
	},

	filterEventsNearby: function() {

		// Set loading indicator
		self.updatingListing();

		// Ensure that we already have the necessary location values
		if (opts.hasLocation && opts.userLatitude && opts.userLongitude) {
			return self.getEvents(false);
		}

		// Try to get the location first
		self.element.addClass('is-detecting-location');
		self.contents().empty();

		if (self.osmMap().length > 0) {
			self.locateOsm();
		} else {
			self.locateGmaps();
		}
	},

	locateOsm: function () {
		EasySocial.require()
		.library('leaflet')
		.done(function() {
			if (self.osm === undefined) {
				self.osm = L.map('map');
			}
			self.osm.locate();
			self.osm.on('locationfound', function(e) {
				self.element.removeClass('is-detecting-location');

				opts.userLatitude = e.latitude;
				opts.userLongitude = e.longitude;

				opts.hasLocation = true;

				return self.getEvents(false);
			});

			self.osm.on('locationerror', function(e) {
				self.filterItem().removeClass('is-loading');
				self.location().addClass('t-text--danger');
				self.location().find('>i').addClass('t-text--danger');
				self.locationMessage().html(e.message);
			});
		});
	},

	locateGmaps: function() {
		EasySocial.require()
		.library('gmaps')
		.done(function() {
			$.GMaps.geolocate({
				success: function(position) {

					self.element.removeClass('is-detecting-location');

					opts.userLatitude = position.coords.latitude;
					opts.userLongitude = position.coords.longitude;

					opts.hasLocation = true;

					return self.getEvents(false);
				},
				error: function(error) {
					self.filterItem().removeClass('is-loading');
					self.location().addClass('t-text--danger');
					self.location().find('>i').addClass('t-text--danger');
					self.locationMessage().html(error.message);
				}
			});
		});
	},

	"{filterItem} click": function(filterItem, event) {
		event.preventDefault();
		event.stopPropagation();

		if (self.isUpdating) {
			return;
		}

		self.isUpdating = true;

		// Find the anchor for the filter
		var anchor = filterItem.find('> a');
		anchor.route();

		// Set active and loading states
		self.setActiveFilter(filterItem);

		// Reset the options
		opts.date = false;
		opts.filter = filterItem.data('type');
		opts.categoryId = filterItem.data('id');

		// If this is filtering by nearby we need to get the user coordinates
		if (opts.filter == 'nearby') {
			return self.filterEventsNearby();
		}

		// If it's not filtering by nearby, we need to update the ordering accordingly.
		if (opts.filter != 'nearby') {
			opts.ordering = 'start';
		}

		// Set loading indicator
		self.updatingContents();

		// Get the events
		self.getEvents(false);
	},

	'{ordering} click': function(button, event) {
		// Remove active classes on the button
		self.ordering().removeClass('active');
		button.addClass('active');

		opts.ordering = button.data('ordering');

		// here we need to update the includePast or hideRepetitive Events or not.
		opts.includePast = self.includePastCheckbox().is(':checked');
		opts.hideRepetition = self.hideRepetitionCheckbox().is(':checked');

		// Route now to set the correct url
		button.route();

		// Set loading indicator
		self.updatingListing();

		// Get the events
		self.getEvents(true);
	},

	updateSortingUrls: function(includePastUrl, hideRepetitionUrl, recentSortingUrl, startSortingUrl, distanceSortingUrl) {

		self.updateIncludePastLink(includePastUrl);
		self.updateHideRepetitionLink(hideRepetitionUrl);

		self.setSortLink('recent', recentSortingUrl);
		self.setSortLink('start', startSortingUrl);
		self.setSortLink('distance', distanceSortingUrl);
	},

	toggleOrdering: function() {
		self.ordering().parents('[data-event-sorting]').toggleClass('t-hidden', opts.includePast);
	},

	'{includePastCheckbox} change': function(checkbox, event) {

		if (self.isUpdating) {
			return;
		}

		self.isUpdating = true;
		self.includePastCheckbox().attr('disabled', 'disabled');

		opts.includePast = checkbox.is(':checked');

		// Route the include past link
		self.includePastLink().route();

		// Set loading indicator
		self.updatingListing();

		// Show or Hide the sorting button
		self.toggleOrdering();

		// Get the events
		self.getEvents(true, function() {
			self.includePastCheckbox().removeAttr('disabled');
		});
	},

	'{hideRepetitionLink} click': function(link, event) {
		event.preventDefault();
		event.stopPropagation();

		self.hideRepetitionCheckbox().trigger('click');
	},

	'{hideRepetitionCheckbox} change': function(checkbox, event) {

		if (self.isUpdating) {
			return;
		}

		self.isUpdating = true;
		self.hideRepetitionCheckbox().attr('disabled', 'disabled');

		opts.hideRepetition = checkbox.is(':checked');

		// Route the include past link
		self.hideRepetitionLink().route();

		// Set loading indicator
		self.updatingListing();

		// Get the events
		self.getEvents(true, function() {
			self.hideRepetitionCheckbox().removeAttr('disabled');
		});
	},

	'{includePastLink} click': function(link, event) {
		event.preventDefault();
		event.stopPropagation();

		self.includePastCheckbox().trigger('click');
	},



	'{navigate} click': function(link, event) {
		event.preventDefault();
		event.stopPropagation();

		if (self.isUpdating) {
			return;
		}

		self.isUpdating = true;


		// Route the link
		link.route();

		// Set the filter
		opts.filter = 'date';
		opts.date = link.data('navigation-date');

		// Set loading indicator
		self.updatingListing();

		self.getEvents(false);
	},

	'{radius} click': function(dropdown, event) {

		// Get the distance
		opts.distance = dropdown.data('radius');
		opts.ordering = 'distance';

		// Set loading indicator
		// since added to show feature events in nearby event filter then have to refresh the whole content
		self.updatingContents();

		// Update the listing
		self.getEvents(false, function(contents, includePastUrl, hideRepetitionUrl, recentSortingUrl, startSortingUrl, distanceSortingUrl) {

			// Update the current url
			History.pushState({state:1}, document.title, distanceSortingUrl);

			// Update the include past link
			self.updateIncludePastLink(includePastUrl);

			// update hide repetitive event link
			self.updateHideRepetitionLink(includePastUrl);
		});
	}
}});

module.resolve();
});

});
			EasySocial.module('site/events/calendar', function($) {

var module = this;

EasySocial.Controller('Events.Browser.Calendar', {
	defaultOptions: {
		'{nav}': '[data-calendar-nav]',
		'{day}': '.day',
		'{month}': '[data-month]',

		filter: null,
		categoryId: null,
		clusterId: null,
		calendarWrapper: null,

		isModule: false
	}
}, function(self, opts) { return {

	init: function() {
		var wrapper = self.element.find('[data-es-calendar]');

		opts.filter = wrapper.data('filter');
		opts.categoryId = wrapper.data('categoryid');
		opts.clusterId = wrapper.data('clusterid');
	},

	getCalendarWrapper: function() {
		if (opts.calendarWrapper) {
			return opts.calendarWrapper;
		}

		return self.parent.calendarWrapper();
	},

	loading: function() {
		self.getCalendarWrapper().addClass('is-loading');
		self.element.html('&nbsp;');
	},

	updateContents: function(html) {
		self.element.html(html).trigger('calendarLoaded');
	},

	'{self} calendarLoaded': function() {
		self.getCalendarWrapper().removeClass('is-loading');

		self.day('.has-events').each(function(index, el) {
			el = $(el);

			var content = el.find('.es-event-details').html();

			el.popbox({
				content: content,
				id: 'es',
				component: '',
				type: 'events-calendar-filter',
				position: 'bottom-left',
				toggle: 'hover'
			});
		});

		var month = self.month('.has-events');

		if (month.length > 0) {
			var content = month.find('.es-event-details').html();
			month.popbox({
				content: content,
				id: 'es',
				component: '',
				type: 'events-calendar-filter',
				position: 'bottom-left',
				toggle: 'hover'
			});
		}
	},

	'{nav} click': function(nav, event) {
		var date = nav.data('calendar-nav');

		self.loading();

		EasySocial.ajax('site/views/events/renderCalendar', {
			"date": date,
			"filter": opts.filter,
			"categoryId": opts.categoryId,
			"clusterId": opts.clusterId
		}).done(function(html) {
			self.updateContents(html);
		});
	},

	'{day} click': function(day, event) {

		if (!opts.isModule) {
			event.preventDefault();
			event.stopPropagation();

			var date = day.data('date');

			// Update the url in the address bar
			day.find('a[data-route]:first').route();

			self.loadEvents(date);
		}
	},

	'{day} popboxActivate': function(day, event, popbox) {
		popbox.tooltip.find('a[data-route]').on('click', function(event) {

			if (!opts.isModule) {
				event.preventDefault();
				event.stopPropagation();

				$(this).route();

				self.loadEvents($(this).data('date'));
			}
		});
	},

	'{month} click': function(el, event) {
		if (!opts.isModule) {
			event.preventDefault();

			// Update the url in the address bar
			el.find('a[data-route]:first').route();

			self.loadEvents(el.data('month'));
		}
	},

	'{month} popboxActivate': function(el, ev, popbox) {
		popbox.tooltip.find('a[data-route]').on('click', function(event) {
			if (!opts.isModule) {
				event.preventDefault();

				$(this).route();

				self.loadEvents($(this).data('month'));
			}
		});
	},

	loadEvents: function(date) {

		var parent = self.parent;

		// Update the parent's filter type
		parent.options.filter = 'date';
		parent.options.date = date;

		// Show loading
		parent.updatingContents();

		parent.getEvents(false, function() {

		});
	}
}});

module.resolve();
});
			EasySocial.module('site/events/create', function($) {
	var module = this;

	EasySocial.require()
	.script('shared/fields/validate', 'shared/fields/base', 'shared/fields/conditional')
	.done(function() {
		EasySocial.Controller('Events.Create', {
			defaultOptions: {
				'previousLink': null,
				'{fields}': '[data-field-item]',
				'{previous}': '[data-create-previous]',
				'{postForm}': '[data-post-form]',
				'{next}': '[data-create-submit]',


				// Category select page
				"{toggleSub}": "[data-toggle-subcategories]",
				"{categoryItem}": "[data-category-item]",
				"{itemsContainer}": "[data-es-items-container]",
				"{backButton}": "[data-select-category-back]"
			}
		}, function(self, opts, base) {
			return {
				init: function() {
					self.fields().addController('EasySocial.Controller.Field.Base');

					self.fields().addController('EasySocial.Controller.Field.Conditional')
				},

				'{previous} click': function() {
					window.location = self.options.previousLink;
				},

				'{next} click': function(el) {
					if (el.enabled()) {
						el.disabled(true);

						el.addClass('btn-loading');

						self.element.validate({fieldSelector : self.fields.selector})
							.done(function() {
								el.removeClass('btn-loading');
								el.enabled(true);

								self.postForm().submit();
								// self.element.submit();
							})
							.fail(function() {
								el.removeClass('btn-loading');
								el.enabled(true);

								EasySocial.dialog({
									content: EasySocial.ajax('site/views/profile/showFormError')
								});
							});
					}
				},

				hideChild: function(id) {
					var items = document.querySelectorAll(self.categoryItem.selector + '[data-parent-id="' + id + '"]');

					items = Array.prototype.slice.call(items,0);

					items.forEach(function(item){ 
						var childId = $(item).data('id');
						self.hideChild(childId);
					});

					$(items).remove();
				},

				"{backButton} click": function(el) {
					// We need to get the first item's parent id
					var parentId = self.itemsContainer().find(self.categoryItem.selector).data('back-id');

					EasySocial.ajax('site/controllers/events/getSubcategories', {
						"parentId": parentId
					})
					.done(function(html) {
						self.itemsContainer().html(html);
						self.backButton().toggleClass('t-hidden', parentId == 0);
					});
				},

				"{toggleSub} click": function(el) {

					var itemWrapper = el.parent(self.categoryItem.selector);
					var parentId = itemWrapper.data('id');
					var backId = itemWrapper.data('parent-id');

					var groupId = base.data('group-id') ? base.data('group-id') : 0;
					var pageId = base.data('page-id') ? base.data('page-id') : 0;

					EasySocial.ajax('site/controllers/events/getSubcategories', {
						"parentId": parentId,
						"groupId": groupId,
						"pageId": pageId,
						"backId": backId
					})
					.done(function(html) {
						self.itemsContainer().html(html);
						self.backButton().removeClass('t-hidden');
					});
				}
			}
		});

		module.resolve();
	});
});
			EasySocial.module('site/events/createRecurring', function($) {
	var module = this;

	EasySocial.Controller('Events.CreateRecurring', {
		defaultOptions: {
			schedule: [],
			totalRecurringEvents: 0,
			eventId: null,

			'{progress}': '[data-progress-bar]',
			'{form}': '[data-form]'
		}
	}, function(self) {
		return {
			init: function() {
				self.start();
			},

			counter: 0,

			start: function() {
				if (self.options.schedule[self.counter] === undefined) {
					return self.completed();
				}

				self.create(self.options.schedule[self.counter])
					.done(function() {
						self.counter++;

						var percentage = Math.ceil((self.counter / self.options.schedule.length) * 100);

						self.progress().css({
							width: percentage + '%'
						});

						self.start();
					})
					.fail(function(msg) {
						console.log(msg);
					});
			},

			create: function(datetime) {

				var isLastRecurringEvent = 0;

				// determine which recurring event process now
				var currentRecurringCounter = self.counter + 1;

				// determine if this recurring proceed the last event 
				if (currentRecurringCounter == self.options.totalRecurringEvents) {
					var isLastRecurringEvent = 1;
				}

				return EasySocial.ajax('site/controllers/events/createRecurring', {
					eventId: self.options.eventId,
					datetime: datetime,
					isLastRecurringEvent: isLastRecurringEvent
				});
			},

			completed: function() {
				self.progress().parent().removeClass('progress-info').addClass('progress-success');
				self.form().submit();
			}
		}
	})

	module.resolve();
});
			EasySocial.module('site/events/edit', function($) {
	var module = this;

	EasySocial.require()
	.script('shared/fields/validate', 'shared/fields/base', 'shared/fields/conditional')
	.done(function() {
		EasySocial.Controller('Events.Edit', {
			defaultOptions: {
				id: null,

				isRecurring: 0,
				hasRecurring: 0,

				'{form}': '[data-form]',
				'{taskHiddenInput}': '[data-task-hidden-input]',

				'{nav}': '[data-step-nav]',
				'{content}': '[data-step-content]',
				'{fields}': '[data-field-item]',
				'{saveButton}': '[data-edit-save]',

				'{saveApply}': 'input[name="applyRecurring"]'
			}
		}, function(self) {
			return {
				init: function() {
					self.fields().addController('EasySocial.Controller.Field.Base', {
						mode: 'edit'
					});

					self.fields().addController('EasySocial.Controller.Field.Conditional');
				},

				errorFields: [],
				errorTabs: [],

				'{nav} click': function(el, ev) {
					var id = $(el).data('for');

					self.content().hide();

					self.nav().removeClass('active');

					el.addClass('active');

					self.content().filterBy('id', id)
						.show()
						.find(self.fields.selector).trigger('show');
				},

				'{nav} error': function(el) {
					el.addClass('error');
				},

				'{nav} clear': function(el) {
					if (self.errorFields.length < 1) {
						el.removeClass('error');
					}
				},

				'{fields} error': function(el, ev) {
					self.triggerStepError(el);
				},

				'{fields} clear': function(el, ev) {
					self.clearStepError(el);
				},

				'{fieldItem} onError': function(el, ev) {
					self.triggerStepError(el);
				},

				triggerStepError: function(el) {
					var fieldid = el.data('id'),
						stepid = el.parents(self.content.selector).data('id');

					if ($.inArray(fieldid, self.errorFields) < 0) {
						self.errorFields.push(fieldid);

						// push the step id into an array for those required field haven't fill in yet
						self.errorTabs.push(stepid);
					}

					self.nav().filterBy('for', stepid).trigger('error');
				},

				clearStepError: function(el) {
					var fieldid = el.data('id'),
						stepid = el.parents(self.content.selector).data('id');

					self.errorFields = $.without(self.errorFields, fieldid);

					self.nav().filterBy('for', stepid).trigger('clear');
				},

				'{saveButton} click': function(el, ev) {

					// Get the task for this action
					var task = el.data('task');

					ev.preventDefault();

					el.addClass('btn-loading');

					self.form().validate({fieldSelector : self.fields.selector})
						.done(function() {
							// Check if this buttons has a value for data-edit-save to indicate if recurring should save all
							if (el.data('editSave') === 'all') {
								self.saveApply().val(1);
							}

							if (task == 'approve' | task == 'reject') {
								task = task + 'Event';

								// Change the task hidden input
								self.taskHiddenInput().val(task);
							}

							self.form().submit();
						})
						.fail(function() {
							el.removeClass('btn-loading');
							EasySocial.dialog({
								content: EasySocial.ajax('site/views/profile/showFormError', {
									"stepIds": self.errorTabs,
									"fieldIds": self.errorFields
								})
							});
						});

					// Need to clear those step id from this error tab when click the submit button
					self.errorTabs = [];
				}
			}
		});

		module.resolve();
	});
});
			EasySocial.module('site/events/filter', function($) {

var module = this;

EasySocial.require()
.script('site/events/browser', 'site/events/calendar')
.done(function($) {

EasySocial.Controller('Events.Filter', {
	defaultOptions: {
		"{listController}": "[data-es-structure] [data-es-events]",
		"{filter}": "[data-es-event-filters] [data-filter-item]",

		// Calendar
		'{calendar}': '[data-events-calendar]',
		"{calendarWrapper}": "[data-events-calendar-wrapper]",

		// Calendar in module
		'{calendarModule}': '[data-events-calendar-module]'
	}
}, function(self, opts) { return {

	init: function() {
		opts.filter = self.element.data('filter');
		opts.categoryId = self.element.data('categoryid');
		opts.clusterId = self.element.data('clusterid');

		self.renderCalendar();
	},

	getController: function() {
		var controller = self.listController().controller();

		return controller;
	},

	setActiveFilter: function(filter) {
		self.filter().removeClass('active');

		filter.addClass('active');

		// Update the URL on the browser
		filter.find('a').route();

		// Set loading on the correct filter
		filter.addClass('is-loading');
	},

	filterNearby: function() {

		// Claer the contents in the controller
		var controller = self.getController();

		controller.clearContents(false);

		// Try to get the location first
		controller.element.addClass('is-detecting-location');

		EasySocial.require()
		.library('gmaps')
		.done(function() {

			$.GMaps.geolocate({
				success: function(position) {
					self.filter().removeClass('is-loading');

					controller.element.removeClass('is-detecting-location');
					controller.setLocation(position.coords.latitude, position.coords.longitude);

					controller.getEvents();
				},

				error: function(error) {

					self.filter().removeClass('is-loading');

					controller.location().addClass('t-text--danger');
					controller.location().find('>i').addClass('t-text--danger');

					controller.locationMessage().html(error.message);
				}
			});
		});
	},

	renderCalendar: function() {
		self.calendarWrapper().addClass('is-loading');

		EasySocial.ajax('site/views/events/renderCalendar', {
			"filter": opts.filter,
			"categoryId": opts.categoryId,
			"clusterId": opts.clusterId
		}).done(function(html) {

			var calendar = self.calendar();

			if (opts.isModule) {
				calendar = self.calendarModule();
			}

			calendar
				.html(html)
				.addController('EasySocial.Controller.Events.Browser.Calendar', {
					'{parent}': self.getController(),
					calendarWrapper: self.calendarWrapper(),
					isModule: opts.isModule
				});

			calendar.trigger('calendarLoaded');
		});
	},

	"{filter} click": function(filter, event) {

		var controller = self.getController();

		if (controller === undefined) {
			return;
		}

		event.preventDefault();
		event.stopPropagation();

		var filterType = filter.data('type');

		// Set active filter state
		self.setActiveFilter(filter);

		controller.setFilter(filterType);

		controller.setCategoryId(null);

		if (filterType == 'category') {
			controller.setCategoryId(filter.data('id'));
		}

		// If this is filtering by nearby we need to get the user coordinates
		if (filterType == 'nearby' && !opts.latitude && !opts.longitude) {
			return self.filterNearby();
		}

		// Claer the contents in the controller
		controller.clearContents(true);

		controller.getEvents(false, function() {
			filter.removeClass('is-loading');
		});
	}
}});

module.resolve();

});
});
			EasySocial.module('site/events/guests', function($) {

	var module = this;

	EasySocial.Controller('Events.App.Guests', {
		defaultOptions: {

			// Wrapper
			"{wrapper}": "[data-wrapper]",
			"{contents}": "[data-contents]",

			// Item
			"{item}": "[data-item]",

			// Actions
			"{remove}": "[data-guest-remove]",
			"{approve}": "[data-guest-approve]",
			"{promote}": "[data-guest-promote]",
			"{demote}": "[data-guest-demote]",
			"{reject}": "[data-guest-reject]",

			"{searchInput}": "[data-search-input]",

			// Filters
			"{filter}": "[data-filter]",

			// Checkbox
			'{checkbox}': '[data-event-item-checkbox]',
			'{checkAll}': '[data-event-item-checkall]',

			// Actions button
			'{actionsWrapper}': '[data-event-actions-wrapper]',
			'{actionsApply}': '[data-event-actions-apply]',
			"{actionsTask}": '[data-event-actions-task]'
		}
	}, function(self, opts) { return {

		init : function() {
			// Get the id of the page
			opts.id = self.element.data('id');
			opts.returnUrl = self.element.data('return');
		},

		clearSelectedCheckboxes: function() {
			self.checkAll().prop('checked', false);
			self.checkAll().trigger('change');
		},

		updateCheckboxSelection: function() {
			// Check if all checkbox is selected
			if (self.isAllCheckboxSelected()) {
				self.checkAll().prop('checked', true);
			} else {
				self.checkAll().prop('checked', false);
			}
		},

		isAllCheckboxSelected: function() {
			var totalSelected = self.getSelectedCheckbox().length;
			var totalCheckbox = self.checkbox().length;

			if (totalSelected == totalCheckbox) {
				return true;
			}

			return false;
		},

		getSelectedCheckbox: function() {
			var items = [];
			var selected = self.checkbox(':checked');

			selected.each(function(i, el) {
				items.push($(el).val());
			});

			return items;
		},

		"{checkbox} change" : function(input, event) {
			var selected = self.getSelectedCheckbox();

			var parent = input.parents(self.item.selector);

			parent.removeClass('is-selected');

			// Check if all checkbox is selected
			self.updateCheckboxSelection();

			if (selected.length > 0) {
				self.actionsWrapper().removeClass('t-hidden');
				parent.addClass('is-selected');
				return;
			}

			self.actionsWrapper().addClass('t-hidden');
		},

		'{checkAll} change': function(input, event) {
			var checked = input.is(':checked');

			if (checked) {
				self.actionsWrapper().removeClass('t-hidden');
			} else {
				self.actionsWrapper().addClass('t-hidden');
			}

			self.checkbox().not(':disabled').prop('checked', checked);
			self.checkbox().not(':disabled').trigger('change');
		},

		"{actionsApply} click": function(button, event) {
			var controllerTask = $.trim(self.actionsTask().val());

			if (controllerTask == '') {
				return false;
			}

			var confirmation = self.actionsTask().find(':selected').data('confirmation');

			// If there is no confirmation, just submit the form
			if (!confirmation) {
				self.taskInput().val(controllerTask);
				self.submitForm();

				return false;
			}

			// Get selected items
			var items = self.getSelectedCheckbox();
			var returnUrl = $('[data-item]').data('return');

			EasySocial.dialog({
				"content": EasySocial.ajax(confirmation, {'userId': items, 'id': opts.id, 'return': returnUrl})

			});
		},

		search: function(keyword) {
			var type = $('[data-filter].active').data('type');

			self.updatingContents();

			EasySocial.ajax('apps/event/guests/controllers/events/getGuests', {
				"id": opts.id,
				"keyword": keyword,
				"filter": type
			}).done(function(contents) {

				self.updateContents(contents);

				if (!self.item().length) {
					self.contents().addClass('is-empty');
				}
			});
		},

		setActiveFilter: function(filter) {
			self.filter().removeClass('active');
			filter.addClass('active');
		},

		getItems: function(type, clusterId, callback) {

			if (self.searchInput().val() != '') {
				this.search(self.searchInput().val());
				return;
			}

			var id = clusterId ? clusterId : opts.id;

			self.updatingContents();

			EasySocial.ajax('apps/event/guests/controllers/events/getGuests', {
				"id": id,
				"filter": type
			}).done(function(contents) {

				if ($.isFunction(callback)) {
					callback.call(this, contents);
				}

				self.updateContents(contents);

				// Show empty if necessary
				self.contents().toggleClass('is-empty', !self.item().length);

				$('body').trigger('afterUpdatingContents', [contents]);

			});
		},

		updatingContents: function() {
			self.wrapper().empty();
			self.contents().addClass('is-loading');
		},

		updateContents: function(html) {
			self.contents().removeClass('is-loading');
			self.wrapper().replaceWith(html);
		},

		"{remove} click" : function(link, event) {

			// Get the user id
			var userId = link.closest(self.item.selector).data('id');
			var returnUrl = link.closest(self.item.selector).data('return');

			EasySocial.dialog({
				content: EasySocial.ajax('site/views/events/confirmRemoveGuest', {"id": userId, "return": returnUrl})
			});
		},

		// Approve a follower
		"{approve} click" : function(link, event) {
			// Get the user id
			var userId = link.closest(self.item.selector).data('id');
			var returnUrl = link.closest(self.item.selector).data('return');

			EasySocial.dialog({
				content: EasySocial.ajax('site/views/events/confirmApproveGuest', {
					"userId": userId,
					"id": opts.id,
					"return": returnUrl
				})
			});
		},

		"{promote} click": function(link, event) {
			// Get the user id
			var userId = link.closest(self.item.selector).data('id');
			var returnUrl = link.closest(self.item.selector).data('return');

			EasySocial.dialog({
				content: EasySocial.ajax('site/views/events/confirmPromoteGuest', {
					"uid" : userId,
					"id" : opts.id,
					"return" : returnUrl
				})
			});
		},

		"{demote} click": function(link, event) {

			// Get the user id
			var userId = link.closest(self.item.selector).data('id');
			var returnUrl = link.closest(self.item.selector).data('return');

			EasySocial.dialog({
				content: EasySocial.ajax('site/views/events/confirmDemoteGuest', {
					"uid" : userId,
					"id" : opts.id,
					"return" : returnUrl
				})
			});
		},

		"{reject} click" : function(link, event) {
			// Get the user id
			var userId = link.closest(self.item.selector).data('id');
			var returnUrl = link.closest(self.item.selector).data('return');

			EasySocial.dialog({
				content: EasySocial.ajax('site/views/events/confirmRejectGuest', {
					"userId": userId,
					"id": opts.id,
					"return": returnUrl
				})
			});
		},

		"{searchInput} keyup": $.debounce(function(textInput){
			var keyword = $.trim(textInput.val());
			self.search(keyword);
		}, 250),
	}});

	module.resolve();
});

			EasySocial.module('site/events/update', function($) {
    var module = this;

    EasySocial.Controller('Events.Update', {
        defaultOptions: {
            postdata: {},
            updateids: [],
            schedule: [],
            isNew: 0,
            eventId: null,

            '{progress}': '[data-progress-bar]',
            '{form}': '[data-form]'
        }
    }, function(self) {
        return {
            init: function() {
                self.startUpdate();
            },

            updateCounter: 0,
            createCounter: 0,
            isNewEvent: 0,

            updateProgressBar: function() {
                var percentage = Math.ceil(((self.updateCounter + self.createCounter) / (self.options.updateids.length + self.options.schedule.length)) * 100);

                self.progress().css({
                    width: percentage + '%'
                });
            },

            startUpdate: function() {
                if (self.options.updateids[self.updateCounter] === undefined) {
                    return self.startCreate();
                }

                self.update(self.options.updateids[self.updateCounter])
                    .done(function() {
                        self.updateCounter++;

                        self.updateProgressBar();

                        self.startUpdate();
                    })
                    .fail(function(msg, errors) {
                        console.log(msg, errors);
                    });
            },

            update: function(id) {

                var isLastRecurringEvent = 0;

                // determine which recurring event process now
                var currentRecurringCounter = self.updateCounter + 1;

                // determine if this recurring proceed the last event
                if (currentRecurringCounter == self.options.updateids.length) {
                    var isLastRecurringEvent = 1;
                }

                self.isNewEvent = self.options.isNew;

                var post = $.extend({}, self.options.postdata, {
                    id: id,
                    applyRecurring: 1,
                    isLastRecurringEvent: isLastRecurringEvent,
                    isNew: self.isNewEvent
                });

                return EasySocial.ajax('site/controllers/events/update', post);
            },

            startCreate: function() {
                if (self.options.schedule[self.createCounter] === undefined) {
                    return self.completed();
                }

                self.create(self.options.schedule[self.createCounter])
                    .done(function() {
                        self.createCounter++;

                        self.updateProgressBar();

                        self.startCreate();
                    })
                    .fail(function(msg, errors) {
                        console.log(msg, errors);
                    });
            },

            create: function(datetime) {
                return EasySocial.ajax('site/controllers/events/createRecurring', {
                    eventId: self.options.eventId,
                    datetime: datetime
                });
            },

            completed: function() {
                self.progress().parent().removeClass('progress-info').addClass('progress-success');
                self.form().submit();
            }
        }
    });

    module.resolve();
});
			EasySocial.module("site/explorer/explorer", function($) {

var module = this;

var CLASS_SELECTED = "is-selected",
	STATE_SELECTED = ".is-selected",
	CLASS_CHECKED = "is-checked",
	STATE_CHECKED = ".is-checked",
	STATE_NOT_SELECTED = ":not(.is-selected)",
	CLASS_ACTIVE = "is-active",
	STATE_ACTIVE = ".is-active",
	EVENT_FILE_SELECT = "fileSelect",
	EVENT_FILE_DESELECT = "fileDeselect",
	EVENT_FOLDER_ACTIVATE = "folderActivate",
	EVENT_FOLDER_DEACTIVATE = "folderDeactivate",
	EVENT_FILE_INSERT = "fileInsert",
	EVENT_FOLDER_INSERT = "folderInsert",
	EVENT_FILE_REMOVE = "fileRemove",
	EVENT_FOLDER_REMOVE = "folderRemove",
	EVENT_FILE_USE = "fileUse",
	EVENT_SERVICE_REQUEST = "serviceRequest";

	$.template("explorer/folder", '<div class="fd-explorer-folder" data-id="[%== data.id %]"><i class="fa fa-folder"></i> [%== data.name %]<a href="javascript: void(0);" class="fd-folder-remove-button" data-fd-explorer-delete-folder-button><i class="fa fa-times"></i></a></div>');
	$.template("explorer/fileGroup", '<div class="fd-explorer-file-group" data-folder="[%== data.id %]" data-plupload-dropsite></div>');
	$.template("explorer/file", '<div class="fd-explorer-file" data-id="[%== data.id %]">[%== data.name %]</div>');

EasySocial.require()
.script("site/explorer/uploader")
.done();

$.Controller("Explorer", {
	pluginName: "explorer",
	hostname: "explorer",

	defaultOptions: {
		view: {
			folder: "explorer/folder",
			fileGroup: "explorer/fileGroup",
			file: "explorer/file"
		},

		layout: {
			fileItemHeight: 52
		},

		isMobile: null,

		uid: null,
		type: null,
		disableValidation: false,
		mockError: false,
		controllerName: null,
		allowedExtensions: null,

		"{browser}"    : ".fd-explorer-browser",
		"{viewport}"   : ".fd-explorer-viewport",
		"{folderGroup}": ".fd-explorer-folder-group",
		"{folder}"     : ".fd-explorer-folder",
		"{fileGroup}"  : ".fd-explorer-file-group",
		"{file}"       : ".fd-explorer-file",
		"{button}"     : "[data-fd-explorer-button]",

		"{mockError}"  : "[name=mock_error]",
		"{disableValidation}": "[name=disable_validation]",
		"{fileInput}"  : "[name=file]",
		"{logs}"       : "[data-alertlog]",
		"{togglefunky}": ".togglefunky",
		"{funky}": ".fd-explorer-funky",
		"{serviceState}": ".service-state",

		// Back button for mobile navigation
		"{backButton}": "[data-es-explorer-back]",

		"{selectAllCheckbox}": "[data-fd-explorer-select-all]",
		"{selectCheckbox}"   : "[data-fd-explorer-select]",

		// Preview
		"{previewButton}": "[data-fd-explorer-preview-button]",

		"{deleteButton}": "[data-fd-explorer-delete-button]",
		"{deleteFolderButton}": "[data-fd-explorer-delete-folder-button]"
	}
}, function(self, opts, base) { return {

	init: function() {

		// Set the type and uid
		self.options.type = self.element.data('type');
		self.options.uid  = self.element.data('uid');
		self.options.controllerName = self.element.data('controller-name');
		self.options.allowedExtensions = self.element.data('allowed-extensions');

		// Extend with uploader plugin
		// TODO: Move this to Foundry
		$.module("easysocial/site/explorer/uploader")
			.done(function(controller){
				self.addPlugin("uploader", controller, {
					settings: {
						filters: [{extensions: self.options.allowedExtensions}]
					}
				});
			});

		// Get folder list
		self.services.getFolders()
			.done(function(data){

				// Generate folder list
				self.insertFolder(data);

				// Activate first folder
				if (!opts.isMobile) {
					self.folder(":first").click();
				}
			});

		self.viewport().on("scroll", $.debounce(self.viewportScroll, 250));
	},

	baseParams: function() {

		return {
			uid: base.data("uid"),
			type: base.data("type")
		};
	},

	exception: function(ex) {

		var logs = self.logs();

		if (!$.isPlainObject(ex)) {
			ex = {
				message: ex,
				type: "error"
			};
		};

		switch (ex.type) {

			case "error":
				logs.switchClass("o-alert--error")
					.html(ex.message);
				EasySocial.debug && console.error(ex.message);
				break;

			case "warning":
				logs.switchClass("o-alert--warning")
					.html(ex.message);
				EasySocial.debug && console.warn(ex.message);
				break;

			case "success":
				logs.switchClass("o-alert--success")
					.html(ex.message);
				EasySocial.debug && console.log(ex.message);
				break;

			case "info":
			default:
				logs.switchClass("o-alert--info")
					.html(ex.message);
				EasySocial.debug && console.log(ex.message);
				break;
		}

		return ex;
	},

	library: {
		file: {},
		folder: {}
	},

	data: function(type, id) {

		return self.library[type][id];
	},

	addData: function(type, data) {

		// Normalize arguments
		if ($.isPlainObject(data)) data = [data];

		if (!$.isArray(data)) {
			return self.exception("Unable to add " + type + " to library due to invalid data given.");
		}

		$.each(data, function(i){

			if (!$.isPlainObject(this)) {
				self.exception("Skipping invalid " + type + " data at index " + i + ".");
			}

			// TODO: Server should return proper 0 value.
			if (this.id===null) this.id = 0;

			/*
			var existing = self.library[type][this.id];
			if (existing) {
				self.exception("Replacing existing " + type + " in library for id " + this.id + ".");
			}
			*/

			self.library[type][this.id] = this;
		});
	},

	removeData: function(type, id) {

		delete self.library[type][id];
	},

	// Navigation
	"{folder} click": function(folder) {
		self.activateFolder(folder.data("id"));

		// Activate or deactivate sidebar
		if (opts.isMobile) {
			self.toggleSidebar();
		}
	},

	"{backButton} click": function() {
		self.toggleSidebar();
	},

	toggleSidebar: function() {
		self.element.toggleClass('is-side-open');
	},

	currentFolder: function() {

		return self.folder(STATE_ACTIVE).data("id");
	},

	activateFolder: function(id) {

		var folder = self.folder().filterBy("id", id),
			data = self.data("folder", id);

		if (folder.length < 1) return;

		// Deactivate currently active folder
		self.deactivateFolder(self.folder(STATE_ACTIVE).data("id"));

		// Activate this folder
		folder.addClass(CLASS_ACTIVE);
		self.trigger(EVENT_FOLDER_ACTIVATE, [id, folder, data]);
	},

	deactivateFolder: function(id) {

		var folder = self.folder().filterBy("id", id),
			data = folder.data("folder");

		if (folder.length < 1) return;

		folder.removeClass(CLASS_ACTIVE);
		self.trigger(EVENT_FOLDER_DEACTIVATE, [id, folder, data]);
	},

	selectedFolder: function() {

		return self.currentFolder();
	},

	"{file} click": function(file, event) {

		var multiple = event.metaKey || event.ctrlKey;

		// Deselect existing selection if we're not
		// selecting multiple selection.
		if (!multiple) self.deselectAllFiles();

		// Select or deselect file
		self.toggleFile(file.data("id"));
	},

	toggleFile: function(id) {

		var file = self.file().filterBy("id", id),
			method = file.hasClass(CLASS_SELECTED) ? "deselectFile" : "selectFile";

		if (file.length < 1) return;

		self[method](id);
	},

	selectFile: function(id) {

		var file = self.file().filterBy("id", id),
			data = self.data("file", id);

		if (file.length < 1) return;

		file.addClass(CLASS_SELECTED);
		// file.find(self.selectCheckbox.selector).prop("checked", true);

		self.trigger(EVENT_FILE_SELECT, [id, file, data]);
	},

	deselectFile: function(id) {

		var file = self.file().filterBy("id", id),
			data = file.data("file", id);

		if (file.length < 1) return;

		file.removeClass(CLASS_SELECTED);
		// file.find(self.selectCheckbox.selector).prop("checked", false);

		self.trigger(EVENT_FILE_DESELECT, [id, file, data]);
	},

	selectAllFiles: function() {

		self.file(STATE_NOT_SELECTED).each(function(){
			self.selectFile($(this).data("id"));
		});
	},

	deselectAllFiles: function() {

		self.file(STATE_SELECTED).each(function(){
			self.deselectFile($(this).data("id"));
		});
	},

	selectedFile: function() {
		return self.selectedFiles()[0];
	},

	selectedFiles: function() {

		var files = [];
		var selectedFiles;

		// TODO: Need to rethink this.
		// Prefer checked files over selected files
		var selectedFiles = self.file(STATE_CHECKED);

		if (selectedFiles.length < 1) {
			selectedFiles = self.file(STATE_SELECTED);
		}

		selectedFiles
			.each(function(){
				var id = $(this).data("id");
				files.push(id);
			});

		return files;
	},

	insertFolder: function(data) {

		// Normalize arguments.
		if (!$.isArray(data)) data = [data];

		// Validate data.
		var sample = data[0];

		if (!$.isPlainObject(sample)) {
			return self.exception("Invalid folder data given to be inserted into the folder group.");

		}

		// Find folder group.
		var folderGroup = self.folderGroup();

		if (folderGroup.length < 1) {
			return self.exception("Could not locate folder group element.");
		}

		// Generate folders html in a bulk to speeed up DOM insertion.
		var folders = "";

		$.each(data, function(){

			// Server should return proper 0 value.
			if (this.id===null) {
				this.id = 0;
			}

			var folder = self.view.folder(true, {data: this});

			// If the folder is not deleteable the delete icon should be hidden
			if (!this.deleteable) {

				folder = $(folder);
				folder.find(self.deleteFolderButton.selector).addClass('t-hidden');
				folder = $('<div>').append(folder).html();
			}

			folders += folder;
		});

		// Insert folders into folder group.
		folders = $.buildHTML(folders).appendTo(folderGroup);

		// Trigger folder insert event.
		self.trigger(EVENT_FOLDER_INSERT, [folders, data]);
	},

	prependFile: function(data) {

		if (!$.isPlainObject(data)) {
			return self.exception("Invalid file data given to be inserted.");
		}

		// Find file group
		var fileGroup = self.fileGroup().filterBy("folder", data.folder);

		if (fileGroup.length < 1) {
			return self.exception("Could not locate file group element for folder id " + data.folder + ".");
		}

		var html = data.html || self.view.file(true, {data: data});

		$.buildHTML(html)
			.data("finalized", true)
			.prependTo(fileGroup);

		// #2788
		// If >0 means the active folder is not All Files
		// We also need to prepend file in All Files folder
		if (fileGroup.data('folder') > 0) {
			var fileGroupAll = self.fileGroup().filterBy("folder", 0);

			$.buildHTML(html)
				.data("finalized", true)
				.prependTo(fileGroupAll);
		}
	},

	insertFile: function(data, id) {

		// Normalize arguments.
		if (!$.isArray(data)) data = [data];

		if (id===undefined) {

			// Validate data.
			var sample = data[0];

			if (!$.isPlainObject(sample)) {
				return self.exception("Invalid file data given to be inserted.");
			}

			id = sample.folder;
		}

		// Find file group
		var fileGroup = self.fileGroup().filterBy("folder", id);

		if (fileGroup.length < 1) {
			return self.exception("Could not locate file group element for folder id " + data.folder + ".");
		}

		var files = [];

		$.each(data, function(){

			var filedata = this;

			self.file().filterBy("id", this.id).each(function(){

				var file = $(this);

				if (file.data("finalized")) return;

				var html = $.buildHTML(filedata.html || self.view.file(true, {data: filedata})).data("finalized", true);

				file.replaceWith(html);

			});
		});

		// Generate files html in bulk to speed up DOM insertion.
		// var files = "";

		// $.each(data, function(){
		// 	files += self.view.file(true, {data: this});
		// });

		// Insert files into file group.
		// files = $.buildHTML(files).appendTo(fileGroup);

		// Trigger file insert event.
		self.trigger(EVENT_FILE_INSERT, [files, data]);
	},

	removeFolder: function(id) {

		// Remove folder.
		var folder = self.folder().filterBy("id", id), failed;

		if (folder.length < 1) {
			failed = self.exception("Could not locate to remove folder element for folder id " + id + ".");
		}

		folder.remove();

		// Remove file group of this folder.
		var fileGroup = self.fileGroup().filterBy("folder", id);

		if (fileGroup.length < 1) {
			failed = self.exception("Could not locate to remove file group element for folder id " + id + ".");
		}

		fileGroup.remove();

		self.trigger(EVENT_FOLDER_REMOVE, [id, failed]);
	},

	removeFile: function(id) {

		// Remove file.
		var file = self.file().filterBy("id", id), failed;

		if (file.length < 1) {
			failed = self.exception("Could not locate to remove file element for file id " + id + ".");
		}

		file.remove();

		self.trigger(EVENT_FILE_REMOVE, [id, failed]);
	},

	// Service
	service: function(hook, params, ajaxOptions) {

		self.serviceState().switchClass("state-busy");

		var task =
			EasySocial.ajax(
					base.data("url"),
					$.extend({
						hook: hook,
						error: opts.mockError
					}, params),
					ajaxOptions
				)
				.always(function(){
					// self.exception({
					// 	type: "info",
					// 	message: "Log message will show here."
					// })
					self.serviceState().switchClass("state-idle");
				})
				.fail(function(ex){
					self.exception(ex);
				});

		// Trigger an event for this service request
		self.trigger(EVENT_SERVICE_REQUEST, [hook, task, params]);

		return task;
	},

	"{button} click": function(button) {

		var hook = button.attr('data-fd-explorer-button');
		var method = self.services[hook];

		// Execute hook
		method && method();
	},

	services: {

		getFolders: function(params) {

			var defaultParams = {
				start: 0,
				limit: 100
			};

			var task =
				self.service("getFolders",
						$.extend(
							self.baseParams(),
							defaultParams,
							params
						)
					)
					.done(function(data){
						self.addData("folder", data);
					});

			return task;
		},

		addFolder: function(params) {

			if (!params) {
				params = {name: prompt(opts.languages.create)};
			}

			var defaultParams = {
				name: ''
			};

			params = $.extend(self.baseParams() , defaultParams, params);

			if (!params.name && !opts.disableValidation) {
				self.exception({
					message: opts.languages.invalid,
					type: "error"
				});
				return;
			}

			var task =
				self.service("addFolder", params)
					.done(function(data){
						self.addData("folder", data);
						self.insertFolder(data);
					});

			return task;
		},

		removeFolder: function(params) {

			var defaultParams = {
				id: self.selectedFolder()
			};

			if (!opts.disableValidation && self.selectedFolder()===undefined) {
				self.exception("No folder selected");
				return;
			}

			var task =
				self.service("removeFolder", $.extend( self.baseParams() , defaultParams, params))
					.done(function(id){
						self.removeFolder(id);
					});

			return task;
		},

		getFiles: function(params) {

			var defaultParams = {
				start: 0,
				limit: 100
			};

			var task =
				self.service("getFiles", $.extend(self.baseParams() , defaultParams, params))
					.done(function(data){
						self.addData("file", data);
					});

			return task;
		},

		addFile: function(params) {

			// params: {id: id, file: file}
			var defaultParams = {
				id: self.currentFolder(),
				files: self.fileInput()
			};

			if (!opts.disableValidation && !self.fileInput().val()) {
				self.exception("No file chosen yet.");
				return;
			}

			var task =
				self.service("addFile", $.extend( self.baseParams(), defaultParams, params), {type: 'iframe'})
					.done(function(data){
						console.log("Upload returned data:", data);
						self.addData("file", data);
						self.prependFile(data);

						self.exception({
							message: "Added file " + data.name,
							type: "success"
						});
					});

			return task;
		},

		removeFile: function(params) {

			var defaultParams = {
				id: self.selectedFiles()
			};

			var params = $.extend(self.baseParams(), defaultParams, params);

			if (!opts.disableValidation && $.isArray(params.id) && params.length < 1) {
				self.exception("No file selected");
				return;
			}

			var task =
				self.service("removeFile", params)
					.done(function(id){

						if ($.isArray(id)) {
							$.each(id, function(){
								self.removeFile(this);
							});
						} else {
							self.removeFile(id);
						}

						self.selectAllCheckbox().prop("checked", false);
					});

			return task;
		},

		useFile: function() {
			var ids = self.selectedFiles();
			var files = [];
			var data = [];

			$.each(ids, function(){
				files.push(self.file().filterBy("id", this));
				data.push(self.data("file", this));
			});

			if (files.length < 1) {
				return;
			}

			self.trigger(EVENT_FILE_USE, [ids, files, data]);
		},

		previewFile: function(file) {

			if (!file) {
				var id = self.selectedFile();
				var file = self.file().filterBy("id", id);
			}

			var url = file.data("previewUri");

			if (!url) {
				return;
			}

			window.open(url, "_blank");
		}
	},

	// UI
	"{self} folderActivate": function(explorer, event, id, folder, data) {

		// Find file group.
		var fileGroups = self.fileGroup(),
			fileGroup = fileGroups.filterBy("folder", id);

		// Deactivate other groups
		fileGroups.removeClass(CLASS_ACTIVE);

		// If file group hasn't been created before
		if (fileGroup.length < 1) {

			// TODO: Server should return an empty map.
			if (!data.map) data.map = [];

			var map = '<div class="fd-explorer-file" data-id="' + data.map.join('">&nbsp;</div><div class="fd-explorer-file" data-id="') + '">&nbsp;</div>';

			// Create file group
			fileGroup =
				self.view.fileGroup({data: data})
					.html(map)
					.appendTo(self.viewport());

			// Get files from server
			self.services.getFiles({id: id})
				.done(function(data){

					// and insert file into file group
					self.insertFile(data, id);
				});
		}

		// Activate group
		fileGroup.addClass("is-active");
	},

	// "{viewport} scroll": function(viewport) {

		// TODO: Determine position of list

		// cosole.log("scrolling");
	// }

	viewportScroll: function() {

		var viewport = self.viewport()[0],
			viewportHeight = self.viewport().height(),
			scrollHeight = viewport.scrollHeight,
			scrollTop = viewport.scrollTop,
			top = scrollTop - viewportHeight,
			itemHeight = self.file(":nth(2)").outerHeight(true);

		// console.log(viewport.scrollHeight);

		var index = Math.floor(scrollTop / itemHeight),
			tolerance = 3,
			fileGroup = self.fileGroup(".is-active"),
			id = fileGroup.data("folder");


		self.services.getFiles({id: id, start: index - tolerance})
			.done(function(data){
				self.insertFile(data, id);
			});
	},

	"{togglefunky} click": function() {
		self.funky().toggle();
	},

	"{disableValidation} change": function(input) {

		opts.disableValidation = !!input.prop("checked");

		self.exception({
			message: "Client-side validation is " + ((!opts.disableValidation) ? "ON!" : "OFF!"),
			type: "info"
		});
	},

	"{mockError} change": function(input) {

		opts.mockError = !!input.prop("checked");
		self.exception({
			message: "Error mocking is " + ((opts.mockError) ? "ON!" : "OFF!"),
			type: "info"
		});
	},

	"{selectAllCheckbox} click": function(checkbox) {

		var checked = checkbox.prop("checked");

		self.fileGroup(STATE_ACTIVE)
			.find(self.selectCheckbox.selector)
			.prop("checked", checked)
			.trigger("change");
	},

	"{selectCheckbox} change": function(checkbox) {

		var file = self.file.of(checkbox),
			id = file.data("id"),
			checked = checkbox.prop("checked");

		file.toggleClass("is-checked", checked);
	},

	"{previewButton} click": function(button, event) {
		event.preventDefault();
		event.stopPropagation();

		var file = self.file.of(button);
		var id = file.data('id');

		self.services.previewFile(file);
	},

	"{deleteButton} click": function(deleteButton) {

		var file = self.file.of(deleteButton),
			id   = file.data("id");

		// Request the user for confirmation before deleting
		EasySocial.dialog(
		{
			content : EasySocial.ajax( 'site/views/explorer/confirmDeleteFile' ,  { "id" : id } ),
			bindings:
			{
				"{deleteButton} click" : function()
				{
					EasySocial.dialog().close();
					self.services.removeFile({id: id});
				}
			}
		});

	},

	"{deleteFolderButton} click": function(deleteFolderButton , event ) {

		event.preventDefault();
		event.stopPropagation();

		var folder = self.folder.of(deleteFolderButton),
			id = folder.data("id");

		// Core folder cannot be deleted
		if (id===0) return;

		// Request the user for confirmation before deleting
		EasySocial.dialog({
			content : EasySocial.ajax( 'site/views/explorer/confirmDeleteFolder' ,  { "id" : id } ),
			bindings: {
				"{deleteButton} click" : function() {
					EasySocial.dialog().close();
					self.services.removeFolder({
						"id": id
					});
				}
			}
		});

	}
}});


module.resolve();
});
			EasySocial.module('site/explorer/popup', function($) {

var module = this;

$.template('explorer/popup', '<div id="es" class="es es-explorer-popup" data-explorer-popup><div class="es-popup-viewport" data-popup-viewport></div><div class="o-loader"></div></div>');

$.Controller("Explorer/Popup", {
	defaultOptions: {

		view: {
			popup: "explorer/popup"
		},

		"{popup}"   : "[data-explorer-popup]",
		"{viewport}": "[data-popup-viewport]",
		"{explorer}": "[data-explorer-popup] .fd-explorer",
		"{closeButton}": "[data-close]"
	}
}, function(self, opts, base) { return {

	init: function() {

	},

	"{window} resize": $.debounce(function() {
	}, 100),

	show: function() {

		var popup;
		var node = self.popup.node;

		// Create node if not exists
		if (!node) {
			popup = self.view.popup();
			node  = self.popup.node = popup[0];
		}

		// Append node if detached
		if (!$.contains(base, node)) {
			popup = $(node).appendTo(base);
		}

		if (!popup.is(":visible")) {
			popup.show().trigger("show");
		}

		if (window.es.mobile) {
			popup.addClass('is-mobile');
		}
	},

	hide: function() {

		self.popup()
			.hide()
			.trigger("hide")
			.detach();
	},

	// options: uid, type, url
	open: function(options) {

		// Show the popup dialog
		self.show();

		var task = $.Deferred();

		var existingExplorer = self.explorer();

		if (existingExplorer.length > 0 &&
			existingExplorer.data("uid")===options.uid &&
			existingExplorer.data("type")===options.type) {
			return task.resolve(existingExplorer.explorer("controller"), self);
		}

		EasySocial.ajax("site/views/explorer/browser", options)
			.done(function(html){

				var browser = $.buildHTML(html);

				self.viewport()
					.empty()
					.append(browser);

				var explorer = browser.filter("[data-es-explorer]").explorer("controller");

				task.resolve(explorer, self);
			})
			.fail(function(){
				task.reject();
			});

		return task;
	},

	"{self} click": function(el, event) {

		if (event.target===self.popup()[0]) {
			self.hide();
		}
	},

	"{closeButton} click": function() {
		self.hide();
	}

}});

var instance = EasySocial.explorer = $("body").addController("Explorer/Popup");

module.resolve(instance);

});
			EasySocial.module('site/explorer/uploader', function($) {

var module = this;

$.require()
.library("plupload")
.done(function(){

	var Controller =
	$.Controller("Explorer/Uploader", {
		defaultOptions: {

			settings: {},

			"{uploadItemGroup}": "[data-fd-explorer-upload-item-group]",
			"{uploadItem}"     : "[data-fd-explorer-upload-item]"
		}
	},
	function(self, opts, base) { return {

		init: function() {

			base.plupload(opts);

			// Set a reference to plupload
			self.plupload = base.plupload("controller").plupload;
		},

		settings: function(key, val) {

			var settings = self.plupload.settings;

			// Setter
			if (val!==undefined) {
				settings[key] = val;
			}

			// Getter
			return (key) ? settings[key] : settings;
		},

		"{self} folderActivate": function(explorer, event, id, folder, data) {


		},

		"{self} BeforeUpload": function(el, event, uploader, file) {

			var url =
				$.uri(EasySocial.ajaxUrl)
					.addQueryParam("controller", self.explorer.options.controllerName)
					.addQueryParam("task", "explorer")
					.addQueryParam("id", self.explorer.currentFolder())
					.addQueryParam("no_html", 1)
					.addQueryParam("format", "json")
					.addQueryParam("hook", "addFile")
					.addQueryParam("tmpl", "component")
					.addQueryParam("uid", base.data("uid"))
					.addQueryParam("type", base.data("type"))
					.addQueryParam(EasySocial.token(), 1)
					.toString();

			self.settings("url", url);
		},

		"{self} FilesAdded": function(el, event, uploader, file) {

			self.plupload.start();
		},

		"{self} UploadFile": function() {

			clearTimeout(self.loadTimer);
			base.addClass("is-loading");
		},

		"{self} FileUploaded": function(el, event, uploader, file, data) {

			self.loadTimer = setTimeout(function(){
				base.removeClass("is-loading");
			}, 1000);

			var explorer = self.explorer;

			// If the response is not a valid object
			if (!$.isPlainObject(data)) {
				self.setMessage("Server did not return proper data after uploading.", "error");
				return;
			}

			explorer.addData("file", data);
			explorer.prependFile(data);
		},

		"{self} FileError": function(el, event, uploader, file, response) {

			base.removeClass("is-loading");

			if ($.isPlainObject(response)) {
				self.setMessage(response.message, "error");
			}
		},

		"{self} Error": function(el, event, uploader, error) {

			base.removeClass("is-loading");

			self.setMessage(error.message, "error");
		}

	}});

	module.resolve(Controller);
});

});
			EasySocial.module('site/followers/browser', function($) {

var module = this;

EasySocial.Controller('Followers.Browser', {
	defaultOptions: {
		"{wrapper}": "[data-followers-wrapper]",
		"{content}": "[data-followers-content]",
		"{items}": "[data-followers-item]"
	}
}, function(self, opts) { return {

	init: function() {
		opts.userId = self.element.data('id');
	},

	updateContents: function(contents) {
		self.content().replaceWith(contents);

		$('body').trigger('afterUpdatingContents');
	},

	getFollowers: function(type, callback) {
		self.wrapper().addClass('is-loading');

		EasySocial.ajax("site/controllers/followers/filter", {
			"id": opts.userId,
			"type": type
		}).done(function(contents) {
			self.updateContents(contents);

			self.wrapper().removeClass('is-loading');

			// trigger sidebar toggle for responsive view.
			self.trigger('onEasySocialFilterClick');
		}).always(function() {
			if (typeof(callback) == 'function') {
				callback.apply();
			}
		});
	}

}});

module.resolve();
});
			EasySocial.module('site/followers/filter', function($) {

var module = this;

EasySocial.require()
.script('site/followers/browser')
.done(function($) {

EasySocial.Controller('Followers.Filter', {
	defaultOptions: {
		"{filter}": "[data-es-followers-filters] [data-filter-item]",
		"{browserController}": "[data-es-followers]"
	}
}, function(self, opts) { return {

	getController: function() {
		return self.browserController().controller();
	},

	setActiveFilter: function(item) {
		self.filter().removeClass('active');

		item.addClass('is-loading active');
	},

	"{filter} click": function(element, event) {
		var controller = self.getController();

		if (controller === undefined) {
			return;
		}

		event.preventDefault();
		event.stopPropagation();

		var anchor = element.find('> a');
		anchor.route();

		var type = element.data('type');
		var id = element.data('id');

		self.setActiveFilter(element);

		controller.getFollowers(type, function() {
			element.removeClass('is-loading');
		});
	}
}});

module.resolve();

});
});
			EasySocial.module('site/friends/browser', function($) {

var module 	= this;

EasySocial.require()
.script('site/friends/suggest')
.done(function($) {

EasySocial.Controller('Friends.Browser', {
	defaultOptions: {
		// Get the default active list if there is any.
		activeList: null,

		// Contents
		"{wrapper}": "[data-wrapper]",
		"{contents}": "[data-contents]",
		"{items}": "[data-items]",
		"{item}": "[data-item]",
		"{pagination}": "[data-pagination]",

		// Friend list actions
		"{listActions}": "[data-list-actions]",
		"{deleteList}": "[data-list-actions] [data-delete]",
		"{defaultList}": "[data-list-actions] [data-default]",
		"{addToList}": "[data-list-actions] [data-add]",
		"{removeFromList}": "[data-remove-from-list]"
	}
}, function(self, opts) { return {

	init: function() {
		opts.userId = self.element.data('userid');
	},

	insertItem: function(item) {

		// Hide any empty notices.
		self.items().removeClass('is-empty');

		// Update the counter for the list items.
		self.triggerUpdateListCounters();

		// Prepend the result back to the list
		$(item).prependTo(self.items());
	},

	triggerUpdateListCounters: function() {
		self.trigger('onEasySocialUpdateFriendListCounters');
	},

	triggerUpdateCounters: function() {
		self.trigger('onEasySocialUpdateFriendCounters');
	},

	// Update the content on the friends list.
	updateContents: function(html) {
		self.contents().html(html);

		$('body').trigger('afterUpdatingContents', [html]);
	},

	getFriends: function(filter, listId, callback) {
		self.wrapper().addClass('is-loading');
		self.contents().empty();

		var options = {
			"filter": filter,
			"userid": opts.userId
		};

		EasySocial.ajax("site/controllers/friends/filter", {
			"filter": filter,
			"userid": opts.userId,
			"id": listId !== undefined ? listId : ''
		}).done(function(html) {

			self.updateContents(html);

			// trigger sidebar toggle for responsive view.
			self.trigger('onEasySocialFilterClick');

		}).always(function() {
			self.wrapper().removeClass('is-loading');

			if (typeof(callback) == 'function') {
				callback.apply();
			}
		});
	},

	removeItem: function(id, source) {
		// Remove item from the list.
		var item = self.item('[data-id="' + id + '"]');

		item.remove();

		if (self.item().length <= 0) {
			self.items().addClass('is-empty');
			self.pagination().remove();
		}

		// Update the counter for the list items.
		if (source == 'list') {
			self.triggerUpdateListCounters();
			return;
		}

		self.triggerUpdateCounters();
	},

	"{addToList} click": function(link) {

		var wrapper = link.parents('[data-list-actions]');
		var id = wrapper.data('id');

		EasySocial.dialog({
			content: EasySocial.ajax('site/views/friends/assignList', {"id" : id}),
			bindings: {

				"{insertButton} click" : function() {
					var items = this.suggest().textboxlist("controller").getAddedItems();

					EasySocial.ajax('site/controllers/friends/assign', {
						"uid": $.pluck(items, "id"),
						"listId": id
					}).done(function(contents) {

						// Hide any notice messages.
						$('[data-assignFriends-notice]').hide();

						$(contents).each(function(i, item) {

							// Pass the item to the parent so it gets inserted into the friends list.
							self.insertItem(item);

							// Close the dialog
							EasySocial.dialog().close();
						});

					}).fail(function(message) {
						$('[data-assignFriends-notice]').addClass('alert alert-error')
							.html(message.message);
					});
				}
			}
		});
	},

	"{deleteList} click" : function(link) {
		var actions = link.parents(self.listActions.selector);
		var id = actions.data('id');

		EasySocial.dialog({
			content: EasySocial.ajax("site/views/friends/confirmDeleteList", {"id": id}),
			bindings: {
				"{deleteButton} click" : function() {
					$('[data-friends-list-delete-form]').submit();
				}
			}
		});
	},

	"{removeFromList} click" : function(link) {
		var id = link.parents(self.item.selector).data('id');

		EasySocial.ajax('site/controllers/friends/removeFromList', {
			"listId": self.options.activeList,
			"userId": id
		}).done(function() {

			self.removeItem(id, 'list');
		});
	},
}});

module.resolve();
});
});
			EasySocial.module('site/friends/filter', function($) {

var module 	= this;

EasySocial.require()
.script('site/friends/browser')
.done(function($) {

EasySocial.Controller('Friends.Filter', {
	defaultOptions: {

		"{counters}": "[data-counter]",
		"{filter}": "[data-es-friends-filters] [data-filter-item]",
		"{browserController}": "[data-es-friends-wrapper]"
	}
}, function(self, opts) { return {

	getController: function() {
		var controller = self.browserController().controller();

		return controller;
	},

	updateFriendRequestCount: function(value) {

		curCount = parseInt(self.requestCount().text(), 10);

		if (curCount != NaN) {
			curCount = curCount + value;
			self.requestCount().text(curCount);
		}
	},

	setActiveFilter: function(item) {
		self.filter().removeClass('active');

		item.addClass('is-loading active');
	},

	"{self} onEasySocialUpdateFriendCounters": function() {

		EasySocial.ajax('site/controllers/friends/getCounters')
		.done(function(all, pending, requests, suggestions) {

			self.filter('[data-type="all"]')
				.find(self.counters.selector)
				.html(all);

			self.filter('[data-type="pending"]')
				.find(self.counters.selector)
				.html(pending);

			self.filter('[data-type="request"]')
				.find(self.counters.selector)
				.html(requests);

			self.filter('[data-type="suggest"]')
				.find(self.counters.selector)
				.html(suggestions);
		});
	},

	"{self} onEasySocialUpdateFriendListCounters": function() {
		EasySocial.ajax('site/controllers/friends/getListCounts')
		.done(function(lists) {
			$(lists).each(function(i, list) {
				self.filter('[data-type="list"][data-id="' + list.id + '"]')
					.find(self.counters.selector)
					.html(list.count);
			});
		});
	},

	"{filter} click" : function(element, event) {
		var controller = self.getController();

		if (controller === undefined) {
			return;
		}

		event.preventDefault();
		event.stopPropagation();

		// Remove all active state on the filter links.
		self.setActiveFilter(element);

		var type = element.data('type');
		var anchor = element.find('> a');
		anchor.route();

		// If the type of filter is a list, we need to perform a different action
		var listId = (type == 'list') ? element.data('id') : undefined;

		controller.getFriends(type, listId, function() {
			element.removeClass('is-loading');
		});
	}
}});

module.resolve();
});
});
			EasySocial.module( 'site/friends/list' , function($){

	var module 	= this;

	EasySocial.require()
	.library('history')
	.script('site/friends/suggest')
	.done(function($){



		module.resolve();
	});
});
			EasySocial.module('site/friends/suggest', function($){

var module = this;

EasySocial.require()
.library('textboxlist')
.done(function($) {

EasySocial.Controller('Friends.Suggest', {
	defaultOptions: {
		max: null,
		exclusive: true,
		exclusion: [],
		minLength: 1,
		highlight: true,
		name: "uid[]",
		type: "",

		// Namespace to query for suggestions
		"query": {
			"friends": "site/controllers/friends/suggest",
			"list": "site/controllers/friends/suggestWithList",
			"clusters": "site/controllers/friends/suggestClusterMembers"
		},

		// Search for friend list as well
		friendList: false,
		friendListName: "",

		includeSelf: false,
		showNonFriend: false,
		privacyRule: "",

		// Add support to search for cluster members
		clusterId: false,
		clusterType: false
	}
}, function(self, opts, base) { return {

	init: function() {

		// Implement the textbox list on the implemented element.
		var autocompleteOptions = {
			"exclusive": opts.exclusive,
			"minLength": opts.minLength,
			"highlight": opts.highlight,
			"showLoadingHint": true,
			"showEmptyHint": true,

			query: function(keyword) {

				var options = {
						"search": keyword,
						"type": opts.type,
						"showNonFriend": opts.showNonFriend,
						"inputName": opts.name,
						"clusterId": opts.clusterId,
						"clusterType": opts.clusterType,
						"privacyRule": opts.privacyRule
					};

				if (opts.includeSelf) {
					options.includeme = true;
				}

				if (opts.clusterId) {
					return EasySocial.ajax(opts.query.clusters, options);
				}

				// Search for normal friends
				if (!opts.friendList) {
					return EasySocial.ajax(opts.query.friends, options);
				}

				// Suggest friend list
				return EasySocial.ajax(opts.query.list, {
					"search": keyword,
					"inputName": opts.name,
					"friendListName": opts.friendListName,
					"showNonFriend": opts.showNonFriend,
					"privacyRule": opts.privacyRule,
					"type": opts.type
				});
			}
		};

		if (opts.emptyMessage) {
			autocompleteOptions.emptyMessage = opts.emptyMessage;
		}

		self.element
			.textboxlist({
				"component": 'es',
				"name": opts.name,
				"max": opts.max,
				"plugin": {
					"autocomplete": autocompleteOptions
				}
			})
			.textboxlist("enable");
	},

	"{self} filterItem": function(el, event, item) {

		// If this suggest searches for friend list, we don't want to format the item result here.
		if (opts.friendList) {
			return;
		}

		var html = $('<div/>').html(item.html);
		var title = html.find('[data-suggest-title]').text();
		var id = html.find('[data-suggest-id]').val();

		item.id = id;
		item.title = title;
		item.menuHtml = item.html;
	},

	"{self} filterMenu": function(el, event, menu, menuItems, autocomplete, textboxlist) {

		// If this suggest searches for friend list, we don't want to format the item result here.
		if (opts.friendList) {
			return;
		}

		// Get list of excluded users
		var items = textboxlist.getAddedItems();
		var users = $.pluck(items, "id");
		var users = users.concat(self.options.exclusion);

		menuItems.each(function(){

			var menuItem = $(this);
			var item = menuItem.data("item");

			// If this user is excluded, hide the menu item
			menuItem.toggleClass("hidden", $.inArray(item.id.toString(), users) > -1);
		});
	}

}});

module.resolve();
});

});

			EasySocial.module('site/groups/browser', function($) {

var module = this;

EasySocial.require()
.done(function($) {

EasySocial.Controller('Groups.Browser', {
	defaultOptions: {
		"{wrapper}": "[data-wrapper]",
		"{subWrapper}": "[data-sub-wrapper]",
		'{contents}': '[data-contents]',
		"{list}": "[data-list]",

		// Fetching location wrapper
		"{location}": "[data-fetching-location]",
		"{locationMessage}": "[data-detecting-location-message]",

		"{ordering}": "[data-sorting]",
		'{radius}': '[data-radius]',
	}
}, function(self, opts) { return {

	clearContents: function(showLoading) {
		var showLoading = showLoading === undefined ? true : showLoading;

		self.element.removeClass('is-detecting-location');
		self.contents().empty();

		if (showLoading) {
			self.wrapper().addClass('is-loading');
		}
	},

	setContents: function(contents) {

		// Remove loading indicators
		self.wrapper().removeClass('is-loading');

		self.contents().html(contents);
	},

	updatingListing: function() {
		self.list().empty();
		self.subWrapper().addClass('is-loading');
	},

	updateListing: function(html) {
		self.subWrapper().removeClass('is-loading');
		self.list().html(html);
	},

	setLocation: function(latitude, longitude) {
		opts.latitude = latitude;
		opts.longitude = longitude;
	},

	setUserId: function(userId) {
		opts.userId = userId;
	},

	setFilter: function(filter) {
		opts.filter = filter;
	},

	setCategoryId: function(categoryId) {
		opts.categoryid = categoryId;
	},

	getItems: function(isOrdering, callback) {

		var options = {
			"userId": opts.userId,
			"filter": opts.filter,
			"categoryid": opts.categoryid,
			"ordering": opts.ordering,
			"sort": isOrdering ? 1 : 0,
			"browseView": opts.browseView
		};

		if (options.filter == 'nearby') {
			options["latitude"] = opts.latitude;
			options["longitude"] = opts.longitude;
			options["distance"] = opts.distance;
		}

		EasySocial.ajax('site/controllers/groups/filter', options)
		.done(function(contents, distanceUrl) {

			if ($.isFunction(callback)) {
				callback.call(this, contents, distanceUrl);
			}

			if (isOrdering) {
				self.updateListing(contents);
				return;
			}

			self.setContents(contents);

			$('body').trigger('afterUpdatingContents', [contents]);
		});
	},

	"{ordering} click" : function(ordering, event) {

		// Get the sort type
		var type = ordering.data('type');
		var categoryId = ordering.data('id');

		// Route the item so that we can update the url
		ordering.route();

		// Add the active state on the current element.
		opts.ordering = type;

		self.ordering().removeClass('active');
		ordering.addClass('active');

		self.updatingListing();
		self.getItems(true);
	},

	'{radius} click': function(dropdown, event) {

		// Get the distance
		opts.distance = dropdown.data('radius');

		self.updatingListing();

		self.getItems(true, function(contents, distanceUrl) {
			// Update the current URL now since the distance has changed
			History.pushState({state:1}, document.title, distanceUrl);
		});
	}
}});

module.resolve();

});
});
			EasySocial.module('site/groups/edit', function($) {

var module	= this;

EasySocial.require()
.script('shared/fields/validate', 'shared/fields/base', 'shared/fields/conditional')
.done(function($) {
EasySocial.Controller(
	'Groups.Edit', {
		defaultOptions: {
			id: null,

			"{stepContent}": "[data-group-edit-fields-content]",
			"{stepItem}": "[data-group-edit-fields-step]",

			// Forms.
			"{groupForm}": "[data-group-fields-form]",
			"{taskHiddenInput}": "[data-task-hidden-input]",

			// Content for group editing
			"{groupContent}": "[data-group-edit-fields]",

			"{fieldItem}": "[data-field-item]",

			// Submit buttons
			"{submit}": "[data-group-fields-submit]"
		}
	}, function(self) {
		return {

			init: function()
			{
				self.fieldItem().addController('EasySocial.Controller.Field.Base', {
					mode: 'edit'
				});

				self.fieldItem().addController('EasySocial.Controller.Field.Conditional');
			},

			errorFields: [],
			errorTabs: [],

			// Support field throwing error internally
			'{fieldItem} error': function(el, ev)
			{
				self.triggerStepError(el);
			},

			// Support for field resolving error internally
			'{fieldItem} clear': function(el, ev)
			{
				self.clearStepError(el);
			},

			// Support validate.js throwing error externally
			'{fieldItem} onError': function(el, ev)
			{
				self.triggerStepError(el);
			},

			triggerStepError: function(el)
			{
				var fieldid = el.data('id'),
					stepid = el.parents(self.stepContent.selector).data('id');

				if ($.inArray(fieldid, self.errorFields) < 0) {
					self.errorFields.push(fieldid);

					// push the step id into an array for those required field haven't fill in yet
					self.errorTabs.push(stepid);
				}

				self.stepItem().filterBy('for', stepid).trigger('error');
			},

			clearStepError: function(el)
			{
				var fieldid = el.data('id'),
					stepid = el.parents(self.stepContent.selector).data('id');

				self.errorFields = $.without(self.errorFields, fieldid);

				self.stepItem().filterBy('for', stepid).trigger('clear');
			},

			"{stepItem} click" : function(el, event)
			{
				var id 	= $(el).data('for');

				// group form should be hidden
				self.groupContent().show();

				// Hide all group steps.
				self.stepContent().hide();

				// Remove active class on step item
				self.stepItem().removeClass('active');

				// Add active class on the selected item.
				el.addClass('active');

				// Get the step content element
				var stepContent = self.stepContent('.step-' + id);

				// Show active group step.
				stepContent.show();

				// Trigger onShow on the field item in the content
				stepContent.find(self.fieldItem.selector).trigger('show');
			},

			"{stepItem} error": function(el)
			{
				el.addClass('error');
			},

			"{stepItem} clear": function(el)
			{
				if(self.errorFields.length < 1)
				{
					el.removeClass('error');
				}
			},

			"{submit} click" : function(el, event)
			{
				// Get the task for this action
				var task = el.data('task');

				if (task != 'update') {
					task = task + 'Group';
				}

				// Run some error checks here.
				event.preventDefault();

				el.addClass('btn-loading');

				self.groupForm()
					.validate({fieldSelector : self.fieldItem.selector})
					.fail(function()
					{
						el.removeClass('btn-loading');
						EasySocial.dialog({
							content : EasySocial.ajax('site/views/profile/showFormError', {
								"stepIds": self.errorTabs,
								"fieldIds": self.errorFields
							})
						});
					})
					.done(function()
					{
						// Change the task hidden input
						self.taskHiddenInput().val(task);

						self.groupForm().submit();
					});

				// Need to clear those step id from this error tab when click the submit button
				self.errorTabs = [];

				return false;
			}
		}
	}
);


module.resolve();
});
});

			EasySocial.module('site/groups/filter', function($) {

var module = this;

EasySocial.require()
.script('site/groups/browser')
.done(function($) {

EasySocial.Controller('Groups.Filter', {
	defaultOptions: {
		"{listController}": "[data-es-structure] [data-es-groups]",
		"{filter}": "[data-es-group-filters] [data-filter-item]",
		"{osmMap}": "[data-osm-map]"
	}
}, function(self, opts) { return {

	getController: function() {
		var controller = self.listController().controller();

		return controller;
	},

	setActiveFilter: function(filter) {
		self.filter().removeClass('active');

		filter.addClass('active');

		// Update the URL on the browser
		filter.find('a').route();

		// Set loading on the correct filter
		filter.addClass('is-loading');
	},

	filterNearby: function(filter) {

		// Claer the contents in the controller
		var controller = self.getController();

		controller.clearContents(false);

		// Try to get the location first
		controller.element.addClass('is-detecting-location');

		if (self.osmMap().length > 0) {
			self.locateOsm();
		} else {
			self.locateGmaps();
		}
	},

	locateOsm: function() {
		EasySocial.require()
		.library('leaflet')
		.done(function() {
			if (self.osm === undefined) {
				self.osm = L.map('map');
			}
			self.osm.locate();
			self.osm.on('locationfound', function(e) {
				self.getController().element.removeClass('is-detecting-location');
				self.getController().setLocation(e.latitude, e.longitude);

				self.getController().getItems(false, function() {
					self.filter().removeClass('is-loading');
				});
			});

			self.osm.on('locationerror', function(e) {
				self.filter().removeClass('is-loading');

				self.getController().location().addClass('t-text--danger');
				self.getController().location().find('>i').addClass('t-text--danger');

				self.getController().locationMessage().html(e.message);
			});
		});
	},

	locateGmaps: function() {
		EasySocial.require()
		.library('gmaps')
		.done(function() {

			var controller = self.getController();
			var filter = self.filter();

			$.GMaps.geolocate({
				success: function(position) {
					controller.element.removeClass('is-detecting-location');
					controller.setLocation(position.coords.latitude, position.coords.longitude);

					controller.getItems(false, function() {
						filter.removeClass('is-loading');
					});
				},

				error: function(error) {

					self.filter().removeClass('is-loading');

					controller.location().addClass('t-text--danger');
					controller.location().find('>i').addClass('t-text--danger');

					controller.locationMessage().html(error.message);
				}
			});
		});
	},

	"{filter} click": function(filter, event) {

		var controller = self.getController();

		if (controller === undefined) {
			return;
		}

		event.preventDefault();
		event.stopPropagation();

		var filterType = filter.data('type');

		// Set active filter state
		self.setActiveFilter(filter);

		controller.setFilter(filterType);

		controller.setCategoryId(null);

		if (filterType == 'category') {
			controller.setCategoryId(filter.data('id'));
		}

		// If this is filtering by nearby we need to get the user coordinates
		if (filterType == 'nearby' && !opts.latitude && !opts.longitude) {
			return self.filterNearby(filter);
		}

		// Claer the contents in the controller
		controller.clearContents(true);

		controller.getItems(false, function() {
			filter.removeClass('is-loading');
		});
	}
}});

module.resolve();

});

});
			EasySocial.module('site/groups/members', function($) {

var module = this;

EasySocial.Controller('Groups.App.Members', {
	defaultOptions: {

		// Wrapper
		"{wrapper}": "[data-wrapper]",
		"{contents}": "[data-contents]",

		// Item
		"{item}": "[data-item]",

		// Actions
		"{cancelInvite}": "[data-cancel]",
		"{remove}": "[data-remove]",
		"{approve}": "[data-approve]",
		"{promote}": "[data-promote]",
		"{revoke}": "[data-revoke]",
		"{reject}": "[data-reject]",

		// Search
		"{searchInput}": "[data-search-input]",

		// Filters
			"{filter}": "[data-filter]",

			// Checkbox
			'{checkbox}': '[data-group-item-checkbox]',
			'{checkAll}': '[data-group-item-checkall]',

			// Actions button
			'{actionsWrapper}': '[data-group-actions-wrapper]',
			'{actionsApply}': '[data-group-actions-apply]',
			"{actionsTask}": '[data-group-actions-task]'
	}
}, function(self, opts) { return {

	init : function() {
		// Get the id of the group
		opts.id = self.element.data('id');
		opts.returnUrl = self.element.data('return');
		opts.appId = self.element.data('appid');
		},

		clearSelectedCheckboxes: function() {
			self.checkAll().prop('checked', false);
			self.checkAll().trigger('change');
		},

		updateCheckboxSelection: function() {
			// Check if all checkbox is selected
			if (self.isAllCheckboxSelected()) {
				self.checkAll().prop('checked', true);
			} else {
				self.checkAll().prop('checked', false);
			}
		},

		isAllCheckboxSelected: function() {
			var totalSelected = self.getSelectedCheckbox().length;
			var totalCheckbox = self.checkbox().length;

			if (totalSelected == totalCheckbox) {
				return true;
			}

			return false;
		},

		getSelectedCheckbox: function() {
			var items = [];
			var selected = self.checkbox(':checked');

			selected.each(function(i, el) {
				items.push($(el).val());
			});

			return items;
		},

		"{checkbox} change" : function(input, event) {
			var selected = self.getSelectedCheckbox();

			var parent = input.parents(self.item.selector);

			parent.removeClass('is-selected');

			// Check if all checkbox is selected
			self.updateCheckboxSelection();

			if (selected.length > 0) {
				self.actionsWrapper().removeClass('t-hidden');
				parent.addClass('is-selected');
				return;
			}

			self.actionsWrapper().addClass('t-hidden');
		},

		'{checkAll} change': function(input, event) {
			var checked = input.is(':checked');

			if (checked) {
				self.actionsWrapper().removeClass('t-hidden');
			} else {
				self.actionsWrapper().addClass('t-hidden');
			}

			self.checkbox().not(':disabled').prop('checked', checked);
			self.checkbox().not(':disabled').trigger('change');
		},

		"{actionsApply} click": function(button, event) {
			var controllerTask = $.trim(self.actionsTask().val());

			if (controllerTask == '') {
				return false;
			}

			var confirmation = self.actionsTask().find(':selected').data('confirmation');

			// If there is no confirmation, just submit the form
			if (!confirmation) {
				self.taskInput().val(controllerTask);
				self.submitForm();

				return false;
			}

			// Get selected items
			var items = self.getSelectedCheckbox();
			var returnUrl = $('[data-item]').data('return');

			EasySocial.dialog({
				"content": EasySocial.ajax(confirmation, {'userId': items, 'id': opts.id, 'return': returnUrl})

			});
	},

	setActiveFilter: function(filter) {
		self.filter().removeClass('active');
		filter.addClass('active');
	},

	search: function(keyword) {
		var type = $('[data-filter].active').data('type');

		self.updatingContents();

		EasySocial.ajax('apps/group/members/controllers/groups/getMembers', {
			"id": opts.id,
			"keyword": keyword,
			"type": type,
			"appId": opts.appId
		}).done(function(contents) {

			self.updateContents(contents);

			// Show empty if necessary
			if (!self.item().length) {
				self.contents().addClass('is-empty');
			}

		});
	},

	getItems: function(type, clusterId, callback) {
		// If the input field is not empty, we filter by it instead
		if (self.searchInput().val() != '') {
			this.search(self.searchInput().val());
			return;
		}

		var id = clusterId ? clusterId : opts.id;

		self.updatingContents();

		EasySocial.ajax('apps/group/members/controllers/groups/getMembers', {
			"id": id,
			"type": type,
			"appId": opts.appId
		}).done(function(contents) {

			if ($.isFunction(callback)) {
				callback.call(this, contents);
			}

			self.updateContents(contents);

			// Show empty if necessary
			self.contents().toggleClass('is-empty', !self.item().length);

			$('body').trigger('afterUpdatingContents', [contents]);
		});
	},

	updatingContents: function() {
		self.wrapper().empty();
		self.contents().addClass('is-loading');
	},

	updateContents: function(html) {
		self.contents().removeClass('is-loading');
		self.wrapper().replaceWith(html);
	},

	"{cancelInvite} click": function(link, event) {
		// Get the user id
		var userId = link.closest(self.item.selector).data('id');
		var item = link.closest(self.item.selector);

		EasySocial.ajax('site/controllers/groups/cancelInvite' , {
			"id" : opts.id, "userId" : userId, "return": opts.returnUrl
		}).done(function() {
			item.remove();
		});
	},

	"{remove} click" : function(link, event) {

		// Get the user id
		var userId = link.closest(self.item.selector).data('id');
		var returnUrl = link.closest(self.item.selector).data('return');

		EasySocial.dialog({
			content: EasySocial.ajax('site/views/groups/confirmRemoveMember', {"id": opts.id, "userId" : userId, "return": returnUrl})
		});
	},

	// Approve a member
	"{approve} click" : function(link, event) {
		// Get the user id
		var userId = link.closest(self.item.selector).data('id');
		var returnUrl = link.closest(self.item.selector).data('return');

		EasySocial.dialog({
			"content": EasySocial.ajax('site/views/groups/confirmApprove', {"id": opts.id, "userId" : userId, "return": returnUrl})
		});
	},

	"{promote} click": function(link, event) {
		// Get the user id
		var userId = link.closest(self.item.selector).data('id');
		var returnUrl = link.closest(self.item.selector).data('return');

		EasySocial.dialog({
			content: EasySocial.ajax('site/views/groups/confirmPromote' , { "id" : self.options.id, "userId": userId, "return": returnUrl})
		});
	},

	"{revoke} click": function(link, event) {

		// Get the user id
		var userId = link.closest(self.item.selector).data('id');
		var returnUrl = link.closest(self.item.selector).data('return');

		EasySocial.dialog({
			content: EasySocial.ajax('site/views/groups/confirmDemote', {"id": self.options.id, "userId": userId, "return": returnUrl})
		});
	},

	"{reject} click" : function(link, event) {
		// Get the user id
		var userId = link.closest(self.item.selector).data('id');
		var returnUrl = link.closest(self.item.selector).data('return');

		EasySocial.dialog({
			content: EasySocial.ajax('site/views/groups/confirmReject', {"id": opts.id, "userId": userId, "return": returnUrl})
		});
	},

	"{searchInput} keyup": $.debounce(function(textInput) {

		var keyword = $.trim(textInput.val());
		self.search(keyword);

	}, 250),
}});

module.resolve();
});

			EasySocial.module("site/locations/gmaps", function($){

var module = this;

EasySocial
.require()
.library("scrollTo", "image", "gmaps")
.done(function($) {

// Constants
var KEYCODE = {
	BACKSPACE: 8,
	COMMA: 188,
	DELETE: 46,
	DOWN: 40,
	ENTER: 13,
	ESCAPE: 27,
	LEFT: 37,
	RIGHT: 39,
	SPACE: 32,
	TAB: 9,
	UP: 38
};

EasySocial.Controller("Gmaps", {
	defaultOptions: {

		// view: {
		// 	suggestion: "site/location/story.suggestion"
		// },

		map: {
			lat: 0,
			lng: 0
		},

		latitude: null,
		longitude: null,

		"{textField}": "[data-location-textField]",
		"{detectLocationButton}": "[data-detect-location-button]",

		'{autocomplete}'    : '[data-location-autocomplete]',
		"{suggestions}": "[data-location-suggestions]",
		"{suggestion}": "[data-story-location-suggestion]",

		"{mapImage}": "[data-location-map-image]",

		"{latitude}" : "[data-location-lat]",
		"{longitude}": "[data-location-lng]",

		"{removeButton}": "[data-location-remove-button]"
	}
}, function(self, opts, base) { return {

	init: function() {

		// Only show auto-detect button if the browser supports geolocation
		if (navigator.geolocation) {
			self.detectLocationButton().show();
		}

		// Allow textfield input only when controller is implemented
		EasySocial
			.require()
			.library("gmaps")
			.done(function(){
				self.textField().removeAttr("disabled");
			});


		// If caller specified a latitude or longitude, navigate the map
		setTimeout(function() {
			if (opts.latitude && opts.longitude) {
				self.navigate(opts.latitude, opts.longitude);

				self.detectLocationButton().hide();
			}
		}, 1);
	},

	deactivate: function() {
		// This should allow caller to deactivate the suggestions
	},

	navigate: function(lat, lng) {
		var apiKey = window.es.gmapsApiKey;

		var mapImage = self.mapImage();
		var width = mapImage.width();
		var height = mapImage.height();

		var	url =
				$.GMaps.staticMapURL({
					key: apiKey,
					size: [width, height],
					lat: lat,
					lng: lng,
					sensor: true,
					scale: 2,
					markers: [
						{lat: lat, lng: lng}
					]
				});

		$.Image.get(url)
			.done(function() {
				mapImage.css({
					"backgroundImage": $.cssUrl(url),
					"backgroundSize": "cover",
					"backgroundPosition": "center center"
				});

				base.addClass("has-location");
			});
	},

	// Memoized locations
	locations: {},

	lastQueryAddress: null,

	"{textField} keypress": function(textField, event) {

		switch (event.keyCode) {

			case KEYCODE.UP:

				var prevSuggestion = $(
					self.suggestion(".active").prev(self.suggestion.selector)[0] ||
					self.suggestion(":last")[0]
				);

				// Remove all active class
				self.suggestion().removeClass("active");

				prevSuggestion
					.addClass("active")
					.trigger("activate");

				self.suggestions()
					.scrollTo(prevSuggestion, {
						offset: prevSuggestion.height() * -1
					});

				event.preventDefault();

				break;

			case KEYCODE.DOWN:

				var nextSuggestion = $(
					self.suggestion(".active").next(self.suggestion.selector)[0] ||
					self.suggestion(":first")[0]
				);

				// Remove all active class
				self.suggestion().removeClass("active");

				nextSuggestion
					.addClass("active")
					.trigger("activate");

				self.suggestions()
					.scrollTo(nextSuggestion, {
						offset: nextSuggestion.height() * -1
					});

				event.preventDefault();

				break;

			case KEYCODE.ENTER:

				var activeSuggestion = self.suggestion(".active"),
					location = activeSuggestion.data("location");
					self.set(location);

				// self.suggestions().hide();
				break;

			case KEYCODE.ESCAPE:
				break;
		}

	},

	"{textField} keyup": function(textField, event) {

		switch (event.keyCode) {

			case KEYCODE.UP:
			case KEYCODE.DOWN:
			case KEYCODE.ENTER:
			case KEYCODE.ESCAPE:
				// Don't repopulate if these keys were pressed.
				break;

			default:
				var address = $.trim(textField.val());

				if (address==="") {
					// self.suggestions().hide();

				}

				if (address==self.lastQueryAddress) {
					return;
				}

				var locations = self.locations[address];

				// If this location has been searched before
				if (locations) {

					// Just use cached results
					self.suggest(locations);

					// And set our last queried address to this address
					// so that it won't repopulate the suggestion again.
					self.lastQueryAddress = address;

				// Else ask google to find it out for us
				} else {

					self.lookup(address);
				}
				break;
		}
	},

	lookup: $._.debounce(function(address){

		// TODO: difine is-busy

		EasySocial.ajax('site/controllers/location/suggestLocations', {
			"address": address,
		}).done(function(locations) {

			// Store a copy of the results
			self.locations[address] = locations;

			self.suggest(locations);
			self.textField().focus();
			self.element.addClass("has-suggested");
		});

	}, 250),

	suggest: function(locations) {

		var suggestions = self.suggestions();

		// Clear location suggestions
		suggestions.empty();

		var items = [];

		$.each(locations, function(i, location) {
			items.push(location.address);
		});

		EasySocial.ajax('site/views/location/format', {
			"locations": items
		}).done(function(rows) {

			$.each(rows, function(i, row) {

				$(row)
					.data('location', locations[i])
					.appendTo(suggestions);
			});
		});

		self.autocomplete().addClass("active");
	},

	"{suggestion} activate": function(suggestion, event) {

		var location = suggestion.data("location");

		self.navigate(location.latitude, location.longitude);
	},

	"{suggestion} mouseover": function(suggestion) {

		// Remove all active class
		self.suggestion().removeClass("active");

		suggestion
			.addClass("active")
			.trigger("activate");
	},

	"{suggestion} click": function(suggestion, event) {

		var location = suggestion.data("location");

		self.set(location);

		// Remove active class on the auto complete
		self.autocomplete().removeClass('active');

		// Hide the suggestions list
		// self.suggestions().hide();
		self.element.removeClass("has-suggested");
	},

	set: function(location) {

		self.currentLocation = location;

		var process = $.Deferred();

		if ($.isEmpty(location.fulladdress)) {
			self.getAddress(location.latitude, location.longitude)
				.done(function(address) {
					location.fulladdress = location.name + ', ' + address;

					process.resolve(location);
				});
		} else {
			process.resolve(location);
		}

		process.done(function(location) {
			self.textField().val(location.fulladdress);

			self.latitude()
				.val(location.latitude);

			self.longitude()
				.val(location.longitude);

			self.detectLocationButton().hide();

			self.trigger("locationChange", [location]);
		});
	},

	unset: function() {
		self.currentLocation = null;

		self.textField().val('');

		self.mapImage().attr("src", "");

		self.element.removeClass("has-location");

		self.detectLocationButton().show();
	},

	"{detectLocationButton} click": function() {

		var map = self.map;

		self.element.addClass("is-loading");

		$.GMaps.geolocate({
			success: function(position) {
				EasySocial.ajax('site/controllers/location/getLocations', {
					latitude: position.coords.latitude,
					longitude: position.coords.longitude
				}).done(function(locations) {

					self.element.removeClass("is-loading");

					self.element.addClass("has-suggested");

					self.suggest(locations);
					self.textField().focus();
				});
			},
			error: function(error) {
				// error.message
			},
			always: function() {

			}
		});
	},

	"{removeButton} click": function(removeButton, event) {
		self.unset();
	},

	getAddress: $.memoize(function(latitude, longitude) {
		var process = $.Deferred(),
			geocoder = new google.maps.Geocoder(),
			latlng = new google.maps.LatLng(latitude, longitude);

		geocoder.geocode({
			'latLng': latlng
		},
		function(results, status) {
			if (status == google.maps.GeocoderStatus.OK) {
				process.resolve(results[0].formatted_address);
			}
		});

		return process;
	}, function(lat, lng) {
		return lat + ',' + lng;
	}),

}});

// Resolve module
module.resolve();

});

});
			EasySocial.module("site/locations/osm", function($){

var module = this;

EasySocial
.require()
.library("scrollTo", "image", "leaflet", "leaflet-providers")
.done(function($) {

// Constants
var KEYCODE = {
	BACKSPACE: 8,
	COMMA: 188,
	DELETE: 46,
	DOWN: 40,
	ENTER: 13,
	ESCAPE: 27,
	LEFT: 37,
	RIGHT: 39,
	SPACE: 32,
	TAB: 9,
	UP: 38
};

EasySocial.Controller("OSM", {
	defaultOptions: {

		latitude: null,
		longitude: null,
		enableMarker: true,
		mapElementId: 'map',

		"{textField}": "[data-location-textField]",
		"{detectLocationButton}": "[data-detect-location-button]",

		'{autocomplete}': '[data-location-autocomplete]',
		"{suggestions}": "[data-location-suggestions]",
		"{suggestion}": "[data-story-location-suggestion]",

		"{latitude}" : "[data-location-lat]",
		"{longitude}": "[data-location-lng]",

		"{removeButton}": "[data-location-remove-button]"
	}
}, function(self, opts, base) { return {

	init: function() {

		if (self.options.mapElementId) {
			self.mapElementId = self.options.mapElementId;
		}

		// Only show auto-detect button if the browser supports geolocation
		if (navigator.geolocation && window.es.isHttps) {
			self.detectLocationButton().removeClass('t-hidden');
			self.detectLocationButton().show();
		}

		// Allow textfield input only when controller is implemented
		EasySocial
			.require()
			.library("leaflet")
			.done(function(){
				self.textField().removeAttr("disabled");
			});


		// If caller specified a latitude or longitude, navigate the map
		setTimeout(function() {
			if (opts.latitude && opts.longitude) {
				if (self.osm === undefined) {
					self.initMap();
				}

				self.navigate(opts.latitude, opts.longitude);

				self.detectLocationButton().hide();
			}
		}, 1);
	},

	initMap: function() {

		self.osm = L.map(self.mapElementId, {
			zoom: 12,
			attributionControl: false,
			zoomControl: false
		});

		// self.osm.fitWorld();

		L.tileLayer.provider('Wikimedia').addTo(self.osm);

		// Allow textField input only when controller is implemented
		self.textField().removeAttr("disabled");

		if (self.options.enableMarker) {
			function onMapClick(e) {
				var latlng = e.latlng;

				self.osm.removeLayer(self.marker);
				self.marker = L.marker(latlng).addTo(self.osm);
				self.osm.setView(latlng);
				self.lookupLatLng(latlng);
			}

			self.osm.on('click', onMapClick);
		}
	},

	deactivate: function() {
		// This should allow caller to deactivate the suggestions
	},

	navigate: function(lat, lng) {
		var latlng = {
					lat: parseFloat(lat),
					lng: parseFloat(lng)
				}

		if (self.marker !== undefined) {
			self.osm.removeLayer(self.marker);
		}

		self.osm.setView(latlng, 10);

		self.marker = L.marker(latlng).addTo(self.osm);

		base.addClass("has-location");
	},

	// Memoized locations
	locations: {},

	lastQueryAddress: null,

	"{textField} keypress": function(textField, event) {

		switch (event.keyCode) {

			case KEYCODE.UP:

				var prevSuggestion = $(
					self.suggestion(".active").prev(self.suggestion.selector)[0] ||
					self.suggestion(":last")[0]
				);

				// Remove all active class
				self.suggestion().removeClass("active");

				prevSuggestion
					.addClass("active")
					.trigger("activate");

				self.suggestions()
					.scrollTo(prevSuggestion, {
						offset: prevSuggestion.height() * -1
					});

				event.preventDefault();

				break;

			case KEYCODE.DOWN:

				var nextSuggestion = $(
					self.suggestion(".active").next(self.suggestion.selector)[0] ||
					self.suggestion(":first")[0]
				);

				// Remove all active class
				self.suggestion().removeClass("active");

				nextSuggestion
					.addClass("active")
					.trigger("activate");

				self.suggestions()
					.scrollTo(nextSuggestion, {
						offset: nextSuggestion.height() * -1
					});

				event.preventDefault();

				break;

			case KEYCODE.ENTER:

				var activeSuggestion = self.suggestion(".active"),
					location = activeSuggestion.data("location");
					self.set(location);

				// self.suggestions().hide();
				break;

			case KEYCODE.ESCAPE:
				break;
		}

	},

	"{textField} keyup": function(textField, event) {

		switch (event.keyCode) {

			case KEYCODE.UP:
			case KEYCODE.DOWN:
			case KEYCODE.ENTER:
			case KEYCODE.ESCAPE:
				// Don't repopulate if these keys were pressed.
				break;

			default:
				var address = $.trim(textField.val());

				if (address==="") {
					// self.suggestions().hide();

				}

				if (address==self.lastQueryAddress) {
					return;
				}

				var locations = self.locations[address];

				// If this location has been searched before
				if (locations) {

					// Just use cached results
					self.suggest(locations);

					// And set our last queried address to this address
					// so that it won't repopulate the suggestion again.
					self.lastQueryAddress = address;

				// Else ask google to find it out for us
				} else {

					self.lookup(address);
				}
				break;
		}
	},

	lookupLatLng: $.debounce(function(latlng) {

		self.element.addClass("is-loading");

		EasySocial.ajax('site/controllers/location/getLocations', {
			latitude: latlng.lat,
			longitude: latlng.lng
		})
		.done(function(results) {
			result = results[0];
			result.address = result.name;
			self.element.removeClass("is-loading");
			self.set(result);
		});
	}, 250),

	lookup: $._.debounce(function(address){

		self.element.addClass("is-loading");

		EasySocial.ajax('site/controllers/location/suggestLocations', {
			"address": address,
		}).done(function(locations) {

			// Store a copy of the results
			self.locations[address] = locations;

			self.suggest(locations);
			self.textField().focus();
			self.element.addClass("has-suggested");
			self.element.removeClass("is-loading");
		});

	}, 250),

	suggest: function(locations) {

		var suggestions = self.suggestions();

		// Clear location suggestions
		suggestions.empty();

		var items = [];

		$.each(locations, function(i, location) {
			items.push(location.formatted_address);
		});

		EasySocial.ajax('site/views/location/format', {
			"locations": items
		}).done(function(rows) {

			$.each(rows, function(i, row) {

				$(row)
					.data('location', locations[i])
					.appendTo(suggestions);
			});
		});

		self.autocomplete().addClass("active");
	},

	"{suggestion} activate": function(suggestion, event) {
		if (self.osm === undefined) {
			self.initMap();
		}

		var location = suggestion.data("location");

		self.navigate(location.latitude, location.longitude);
	},

	"{suggestion} mouseover": function(suggestion) {

		// Remove all active class
		self.suggestion().removeClass("active");

		suggestion
			.addClass("active")
			.trigger("activate");
	},

	"{suggestion} click": function(suggestion, event) {

		if (self.osm === undefined) {
			self.initMap();
		}

		var location = suggestion.data("location");

		self.set(location);

		// Remove active class on the auto complete
		self.autocomplete().removeClass('active');

		// Hide the suggestions list
		// self.suggestions().hide();
		self.element.removeClass("has-suggested");
	},

	set: function(location) {

		self.currentLocation = location;

		location.fulladdress = location.name;
		location.address = location.name;

		self.navigate(location.latitude, location.longitude);

		// Set the address on the field
		self.textField().val(location.fulladdress);

		self.latitude()
			.val(location.latitude);

		self.longitude()
			.val(location.longitude);

		self.detectLocationButton().hide();

		self.trigger("locationChange", [location]);

		self.lastQueryAddress = location.address;
	},

	unset: function() {
		self.currentLocation = null;

		self.textField().val('');

		self.element.removeClass("has-location");

		self.detectLocationButton().show();
	},

	"{detectLocationButton} click": function() {

		self.element.addClass("is-loading");

		if (self.osm === undefined) {
			self.initMap();
		}

		self.osm.locate();
		self.osm.on('locationfound', function(e) {
			self.detectLocationButton().removeClass('is-loading');
			lat = e.latitude,
			lng = e.longitude;

			self.navigate(lat, lng);

			EasySocial.ajax('site/controllers/location/getLocations', {
				latitude: lat,
				longitude: lng
			})
			.done(function(results) {
				result = results[0];
				result.address = result.name;

				self.element.removeClass("is-loading");

				self.set(result);

				// Remove active class on the auto complete
				self.autocomplete().removeClass('active');

				// Hide the suggestions list
				self.suggestions().hide();
				self.element.removeClass("has-suggested");
			});
		});

	},

	"{removeButton} click": function(removeButton, event) {
		self.unset();
	}

}});

// Resolve module
module.resolve();

});

});
			EasySocial.module('site/locations/popbox', function($){

	EasySocial.module("locations/popbox", function($){

		this.resolve(function(popbox){

			var button = popbox.button,
				lat = button.data("lat"),
				lng = button.data("lng"),
				language = window.es.locationLanguage || 'en',
				provider = button.data("location-provider");

				if (provider == 'osm') {
					link = "//www.openstreetmap.org/#map=16/" + lat + "/" + lng;
					url = "//maps.wikimedia.org/img/osm-intl,13," + lat + "," + lng + ",600x300.png";
				} else {
					apiKey = window.es.gmapsApiKey;
					link = "//maps.google.com/?q=" + lat + "," + lng,
					url = "//maps.googleapis.com/maps/api/staticmap?key=" + apiKey + "&size=400x200&sensor=true&zoom=15&center=" + lat + "," + lng + "&markers=" + lat + "," + lng + "&language=" + language;
				}
			return {
				id: "es",
				component: "",
				type: "location",
				content: '<a href="' + link + '" target="_blank"><img src="' + url + '" width="400" height="200" /></a>'
			}
		});

	});

	this.resolve();
});
			EasySocial.module('site/manage/clusters', function($) {

var module 	= this;

EasySocial.Controller('Clusters', {
	defaultOptions: {

		"{activeButton}": "[data-active-filter-button]",
		"{activeText}": "[data-active-filter-text]",

		// Filters
		"{filter}": "[data-filter-item]",
		"{filterText}": "[data-filter-item-text]",

		// Content area.
		"{wrapper}": "[data-wrapper]",
		"{contents}": "[data-contents]",

		// Result
		"{items}": "[data-items]",
		"{item}": "[data-item]",
		"{pagination}": "[data-pagination]",

		// Actions
		"{approve}": "[data-approve]",
		"{reject}": "[data-reject]",

		// Counters
		"{counters}": "[data-counter]"
	}
}, function(self, opts) { return {

	init: function() {
		self.initDefaultFilter();
	},

	initDefaultFilter: function() {
		var activeFilter = self.filter('.active');

		self.setActiveFilter(activeFilter);
	},

	updateCounter: function() {
		EasySocial.ajax('site/controllers/manage/getClusterCounters')
			.done(function(counters) {

				self.filter('[data-type="event"]')
					.find(self.counters.selector)
					.html(counters['event']);

				self.filter('[data-type="group"]')
					.find(self.counters.selector)
					.html(counters['group']);

				self.filter('[data-type="page"]')
					.find(self.counters.selector)
					.html(counters['page']);
			});
	},

	removeItem: function(id) {
		// Remove item from the list.
		var item = self.item('[data-id="' + id + '"]');

		item.remove();

		if (self.item().length <= 0) {
			self.items().addClass('is-empty');
			self.pagination().remove();
		}

		// Update the counter for the list items.
		self.updateCounter();
	},

	// Update the content on the items list.
	updateContents: function(html) {
		self.contents().html(html);

		$('body').trigger('afterUpdatingContents', [html]);
	},

	setActiveFilter: function(filter) {
		var text = filter.find(self.filterText.selector).clone();

		self.activeText().html(text);
		self.activeButton().removeClass('is-loading');

		// Remove all active classes
		self.filter().removeClass('active');

		// Add active class on itself
		filter.addClass('active');
	},

	"{filter} click" : function(filter, event) {
		event.preventDefault();
		event.stopPropagation();

		var type = filter.data('type');

		// Remove all active state on the filter links.
		self.setActiveFilter(filter);

		// Set the browsers attributes
		var anchor = filter.find('> a');
		anchor.route();

		self.wrapper().addClass('is-loading');
		self.contents().empty();

		// Simulate the click on the active button so we can hide the dropdown
		self.activeButton().click();

		EasySocial.ajax("site/controllers/manage/filterCluster", {
			"filter": type
		}).done(function(html){
			self.updateContents(html);

		}).always(function(){

			self.wrapper().removeClass('is-loading');
			filter.removeClass("is-loading");
		});
	},

	// Approve
	"{approve} click" : function(link, event) {
		// Get the cluster id
		var clusterId = link.closest(self.item.selector).data('id');
		var clusterType = link.closest(self.item.selector).data('type');

		EasySocial.dialog({
			content	: EasySocial.ajax("site/views/manage/confirmClusterApprove" , {"clusterId" : clusterId, "clusterType" : clusterType}),
			selectors: {
				"{sendMail}": "[data-send-email]",
				"{approveButton}": "[data-approve-button]",
				"{cancelButton}": "[data-cancel-button]"
			},
			bindings : {
				"{approveButton} click" : function() {

					var sendMail = this.sendMail().is(':checked') ? 1 : 0;

					EasySocial.ajax('site/controllers/manage/approveCluster', {
						"clusterId": clusterId,
						"clusterType": clusterType,
						"sendMail": sendMail
					})
					.done(function() {
						self.removeItem(clusterId);
						EasySocial.dialog().close();
					});
				},

				"{cancelButton} click": function() {
					EasySocial.dialog().close();
				}
			}
		});

	},

	// Reject
	"{reject} click" : function(link, event) {

		// Get the cluster id
		var clusterId = link.closest(self.item.selector).data('id');
		var clusterType = link.closest(self.item.selector).data('type');

		EasySocial.dialog({
			content: EasySocial.ajax("site/views/manage/confirmClusterReject" , {"clusterId" : clusterId, "clusterType": clusterType}),
			selectors: {
				"{rejectMessage}": "[data-reject-message]",
				"{rejectButton}": "[data-reject-button]",
				"{cancelButton}": "[data-cancel-button]",
				"{sendMail}": "[data-send-email]",
				"{deleteCluster}": "[data-delete-cluster]"
			},
			bindings : {
				"{rejectButton} click" : function() {
					var rejectMessage = this.rejectMessage().val();
					var sendMail = this.sendMail().is(':checked') ? 1 : 0;
					var deleteCluster = this.deleteCluster().is(':checked') ? 1 : 0;

					EasySocial.ajax('site/controllers/manage/rejectCluster', {
						"clusterId": clusterId,
						"clusterType": clusterType,
						"rejectMessage": rejectMessage,
						"sendMail": sendMail,
						"deleteCluster": deleteCluster
					})
					.done(function() {
						self.removeItem(clusterId);
						EasySocial.dialog().close();
					});
				},

				"{cancelButton} click": function() {
					EasySocial.dialog().close();
				}
			}
		});
	}
}});

module.resolve();
});
			EasySocial.module('site/members/filter', function($){

var module = this;

EasySocial.require()
.script('site/groups/browser', 'site/events/guests', 'site/pages/followers')
.done(function($) {

EasySocial.Controller('Members.Filter', {
	defaultOptions: {
		"{filterWrapper}": "[data-es-member-filter]",
		"{filter}": "[data-es-member-filter] [data-filter]",
		"{groupController}": "[data-es-group-members][data-es-container]",
		"{pageController}": "[data-es-page-followers][data-es-container]",
		"{eventController}": "[data-es-event-guests][data-es-container]"
	}
}, function(self,opts,base) { return {

	init : function() {
		self.clusterId = self.filterWrapper().data('clusterId');
		self.clusterType = self.filterWrapper().data('clusterType');

		self.controller = self.getController();
	},

	getController: function() {
		var controller = self[self.clusterType + "Controller"]().controller();
		return controller;
	},

	setActiveFilter: function(filter) {

		var activeClass = (window.es.mobile || window.es.tablet || window.es.ios) ? 'is-active' : 'active';

		self.filter().removeClass(activeClass);

		filter.addClass(activeClass);
	},

	"{filter} click": function(filter, event) {

		if (self.controller === undefined) {
			return;
		}

		event.preventDefault();
		event.stopPropagation();

		var type = filter.data('type');

		self.setActiveFilter(filter);

		self.controller.getItems(type, self.clusterId, function(contents) {
			filter.removeClass('is-loading');
		});
	}
}});

module.resolve();

});
});
			EasySocial.module('site/members/suggest', function($){

var module = this;

EasySocial.require()
.library('textboxlist')
.done(function($) {

EasySocial.Controller('Members.Suggest', {
	defaultOptions: {
		max: null,
		exclusive: true,
		exclusion: [],
		minLength: 1,
		highlight: true,
		uid: "",
		name: "user_id",
		type: "",

		// Namespace to query for suggestions
		"query": {
			"members": "site/controllers/members/suggest"
		},

		includeSelf: false,
		showNonFriend: false
	}
}, function(self, opts, base) { return {

	init: function() {

		// Implement the textbox list on the implemented element.
		self.element
			.textboxlist({
				"component": 'es',
				"name": opts.name,
				"max": opts.max,
				"plugin": {
					"autocomplete": {
						"exclusive": opts.exclusive,
						"minLength": opts.minLength,
						"highlight": opts.highlight,
						"showLoadingHint": true,
						"showEmptyHint": true,

						query: function(keyword) {

							var options = {
											"search": keyword,
											"type": opts.type,
											"inputName": opts.name,
											"uid": opts.uid
										};

							return EasySocial.ajax(opts.query.members, options);
						}
					}
				}
			})
			.textboxlist("enable");
	},

	"{self} filterItem": function(el, event, item) {

		var html = $('<div/>').html(item.html);
		var title = html.find('[data-suggest-title]').text();
		var id = html.find('[data-suggest-id]').val();

		item.id = id;
		item.title = title;
		item.menuHtml = item.html;
	},

	"{self} filterMenu": function(el, event, menu, menuItems, autocomplete, textboxlist) {

		// Get list of excluded users
		var items = textboxlist.getAddedItems();
		var users = $.pluck(items, "id");
		var users = users.concat(self.options.exclusion);

		menuItems.each(function(){

			var menuItem = $(this);
			var item = menuItem.data("item");

			// If this user is excluded, hide the menu item
			menuItem.toggleClass("hidden", $.inArray(item.id.toString(), users) > -1);
		});
	}

}});

module.resolve();
});

});

			EasySocial.module('site/mobile/filters', function($) {

var module = this;

EasySocial.require()
.library('swiper')
.done(function($) {

EasySocial.Controller('Mobile.Filters', {
	defaultOptions: {
		"{sliders}": "[data-es-swiper-slider]",
		"{sliderGroup}": "[data-es-swiper-slider-group]",
		"{group}": "[data-es-swiper-filter-group]",
		"{groupSection}": "[data-es-swiper-group]"
	}
}, function(self, opts, base) { return {

	init: function() {
		var activeGroup = self.getActiveGroup();
		var slider = self.getSliderFromGroup(activeGroup);

		// Init slider that is already visible
		self.initSlider(slider);

		if (self.sliderGroup().length > 0) {
			self.initSlider(self.sliderGroup());
		}

		// hide inactive slider
		self.hideInactiveSlider();
	},

	hideInactiveSlider: function() {
		setTimeout(function() {
			self.groupSection().addClass('t-hidden');
			self.getActiveGroup().removeClass('t-hidden');
		}, 150);
	},

	getActiveGroup: function() {
		return self.groupSection('.is-active');
	},

	getSliderFromGroup: function(group) {
		return group.find(self.sliders.selector);
	},

	initSlider: function(slider) {
		var sliderController = slider.controller();

		// Ensure that it hasn't been implemented before
		if (sliderController === undefined) {
			slider.implement(EasySocial.Controller.Mobile.Filters.Slider);
		}
	},

	"{group} click": function(element) {
		var group = element.data('type');
		var section = self.groupSection('[data-type=' + group + ']');
		var isDialog = element.data('dialog') !== undefined;

		if (!isDialog) {

			if (group) {
				self.groupSection().addClass('t-hidden');
				section.removeClass('t-hidden');
			}

			var slider = self.getSliderFromGroup(section);
			self.initSlider(slider);
			slider.controller().refresh();
		}

		// For dialogs, we need to render a dialog
		if (isDialog) {
			var child = section.children().clone();
			child.removeClass('t-hidden');

			EasySocial.dialog({
				"content": child[0]
			});
		}
	}
}});

EasySocial.Controller('Mobile.Filters.Slider', {
	defaultOptions: {
		sliderOptions: {
			init: false,
			slidesPerView: 'auto',
			spaceBetween: 8,
			resistance: false,
			freeMode: true,
			freeModeMomentum: false,
			freeModeMomentumBounce: false,
			centerInsufficientSlides: false,
			freeModeSticky: false,
			centeredSlides: false
		},

		// Slider item
		"{item}": "[data-es-swiper-item]",
		"{container}": "[data-es-swiper-container]"
	}
}, function(self, opts) { return {
	init: function() {
		self.initSlider();
	},

	getSelected: function() {
		var activeIndex = 0;

		self.item().each(function(index, item) {
			var item = $(item);

			if (item.hasClass('is-active')) {
				activeIndex = index;
			}
		});

		return activeIndex;
	},

	getSliderContainer: function() {
		return self.element.find(self.container.selector);
	},

	// Binded to sly/swiper
	onMove: function() {
		self.element.removeClass('is-end-left is-end-right');

		if (self.element.swiper.isBeginning) {
			self.element.addClass('is-end-left');
		}

		if (self.element.swiper.isEnd) {
			self.element.addClass('is-end-right');
		}
	},

	initSlider: function() {
		// Initialize selected
		var selectedIndex = self.getSelected();

		var options = $.extend({}, opts.sliderOptions, {
			initialSlide: selectedIndex
		});

		// Activate sly/swiper animation
		self.element.swiper = new Swiper(self.getSliderContainer(), options);
		self.element.swiper.init();

		// Capture move event
		self.element.swiper.on('touchMove', self.onMove);
	},

	refresh: function() {
		setTimeout(function() {
			self.element.swiper.update();
		}, 16);
	},

	"{item} click": function(element) {
		var isDialog = element.data('dialog') !== undefined;

		// Check if the filter is rendering dialog
		if (!isDialog) {
			self.item().removeClass('is-active');
			element.addClass('is-active');
		}
	}
}});

module.resolve();

});

});

			EasySocial.module( "site/notifications/list", function($){

var module = this;

EasySocial.Controller('NotificationsList', {
	defaultOptions: {
		"{item}": "[data-notifications-list-item]",
		"{unread}": "[data-unread]",
		"{read}": "[data-read]",
		"{delete}": "[data-delete]",
		"{list}": "[data-notifications-list]",
		"{markAllRead}": "[data-notification-all-read]",
		"{deleteAll}": "[data-notification-all-clear]",
		"{loadMore}": "[data-notification-loadmore-btn]"
	}
}, function(self, opts, base) { return {

	setItemLayout: function(item, className) {
		item.removeClass('is-read is-hidden is-unread')
			.addClass(className);
	},

	"{unread} click" : function(button) {
		var item = button.closest(self.item.selector);
		var id = item.data('id');

		EasySocial.ajax('site/controllers/notifications/setState', {
			"id" : id,
			"state"	: "unread"
		}).done(function() {
			self.setItemLayout(item, 'is-unread');
		});
	},

	"{read} click" : function(button) {
		var item = button.closest(self.item.selector);
		var id = item.data('id');

		EasySocial.ajax('site/controllers/notifications/setState', {
			"id" : id,
			"state"	: "read"
		}).done(function() {
			self.setItemLayout(item, 'is-read');
		});
	},

	"{delete} click" : function(button) {
		var item = button.closest(self.item.selector);
		var id = item.data('id');

		EasySocial.dialog({
			content: EasySocial.ajax("site/views/notifications/clearConfirm"),
			bindings: {
				"{clearButton} click": function() {

					EasySocial.ajax( 'site/controllers/notifications/setState', {
						"id": id,
						"state": "clear"
					}).done(function() {
						self.setItemLayout(item, 'is-remove is-read');

						EasySocial.dialog().close();
					});
				}
			}
		});
	},

	"{markAllRead} click" : function() {
		self.markAllRead().addClass('is-loading');

		EasySocial.ajax('site/controllers/notifications/setAllRead')
		.done(function() {
			self.setItemLayout(self.item(), 'is-read');
			$(window).trigger('easysocial.clearSystemNotification');
		}).always(function(){
			self.markAllRead().removeClass('is-loading');
		});
	},

	"{deleteAll} click" : function() {

		EasySocial.dialog({
			content: EasySocial.ajax("site/views/notifications/clearAllConfirm"),
			bindings: {
				"{clearButton} click": function() {

					EasySocial.ajax( 'site/controllers/notifications/setState', {
						"state"	: "clear"
					}).done(function() {
						self.setItemLayout(self.item(), 'is-remove is-read');

						EasySocial.dialog().close();
					})
				}
			}
		})
	},

	"{loadMore} click" : function(button, event) {
		var startlimit = button.data('startlimit');

		if (startlimit < 0) {
			return;
		}

		EasySocial.ajax('site/controllers/notifications/loadmore', {
			"startlimit" : startlimit
		}).done(function(contents, nextlimit) {
			
			// update next limit
			button.data('startlimit', nextlimit);

			if (contents.length > 0) {
				
				$.buildHTML(contents)
				 	.insertBefore(button);
			}

			// If there's nothing to read, just hide the button
			if (nextlimit < 0) {
				button.hide();
			}

		});
	}
}});

module.resolve();
});
			EasySocial.module('site/pages/browser', function($) {

var module	= this;

EasySocial.Controller('Pages.Browser', {
	defaultOptions: {

		// Result
		"{wrapper}": "[data-wrapper]",
		"{result}": "[data-result]",
		"{list}": "[data-list]",
		"{header}": "[data-header]",

		// Sorting
		"{sortItem}": "[data-sorting]",
		"{items}": "[data-pages-item]",
		"{featured}": "[data-pages-featured-item]",
		"{listContents}": "[data-es-pages-list]"
	}
}, function(self, opts) { return {

	setActiveSort: function(sortItem) {

		// Set the correct active state
		self.sortItem().removeClass('active');
		sortItem.addClass('active');

		// Only remove the contents of the page listings
		self.list().empty();

		// Set the loading indicator of the result area
		self.result().addClass('is-loading')
	},

	getPages: function(filterType, options, callback) {

		// Remove all result
		self.result().empty();

		// Set loading indicator on wrapper
		self.wrapper().addClass('is-loading');

		options = $.extend({
						"filter": filterType
					}, options);

		EasySocial.ajax('site/controllers/pages/filter', options)
		.done(function(contents) {

			if (typeof(callback) == 'function') {
				callback.apply(contents);
			}

			// Remove loading indicators
			self.wrapper().removeClass('is-loading');

			// Update the contents
			self.wrapper().html(contents);

			$('body').trigger('afterUpdatingContents', [contents]);

			// trigger sidebar toggle for responsive view.
			self.trigger('onEasySocialFilterClick');

		});
	},

	"{sortItem} click" : function(sortItem, event) {

		// Get the sort type
		var type = sortItem.data('type');
		var filter = sortItem.data('filter');
		var categoryId = sortItem.data('id');

		// Route the item so that we can update the url
		sortItem.route();

		// Add the active state on the current element.
		self.setActiveSort(sortItem);

		// Render the ajax to load the contents.
		EasySocial.ajax('site/controllers/pages/filter', {
			"ordering": type,
			"filter": filter,
			"categoryId": categoryId
		}).done(function(contents) {

			self.result().removeClass('is-loading');

			self.list().html(contents);
		});
	}

}});

module.resolve();
});
			EasySocial.module('site/pages/edit', function($) {

var module	= this;

EasySocial.require()
.script('shared/fields/validate', 'shared/fields/base', 'shared/fields/conditional')
.done(function($) {
EasySocial.Controller(
	'Pages.Edit', {
		defaultOptions: {
			id: null,

			"{stepContent}": "[data-page-edit-fields-content]",
			"{stepItem}": "[data-page-edit-fields-step]",

			// Forms.
			"{pageForm}": "[data-page-fields-form]",
			"{taskHiddenInput}": "[data-task-hidden-input]",

			// Content for page editing
			"{pageContent}": "[data-page-edit-fields]",

			"{fieldItem}": "[data-field-item]",

			// Submit buttons
			"{submit}": "[data-page-fields-submit]"
		}
	}, function(self) {
		return {

			init: function()
			{
				self.fieldItem().addController('EasySocial.Controller.Field.Base', {
					mode: 'edit'
				});

				self.fieldItem().addController('EasySocial.Controller.Field.Conditional');
			},

			errorFields: [],
			errorTabs: [],

			// Support field throwing error internally
			'{fieldItem} error': function(el, ev)
			{
				self.triggerStepError(el);
			},

			// Support for field resolving error internally
			'{fieldItem} clear': function(el, ev)
			{
				self.clearStepError(el);
			},

			// Support validate.js throwing error externally
			'{fieldItem} onError': function(el, ev)
			{
				self.triggerStepError(el);
			},

			triggerStepError: function(el)
			{
				var fieldid = el.data('id'),
					stepid = el.parents(self.stepContent.selector).data('id');

				if ($.inArray(fieldid, self.errorFields) < 0) {
					self.errorFields.push(fieldid);

					// push the step id into an array for those required field haven't fill in yet
					self.errorTabs.push(stepid);
				}

				self.stepItem().filterBy('for', stepid).trigger('error');
			},

			clearStepError: function(el)
			{
				var fieldid = el.data('id'),
					stepid = el.parents(self.stepContent.selector).data('id');

				self.errorFields = $.without(self.errorFields, fieldid);

				self.stepItem().filterBy('for', stepid).trigger('clear');
			},

			"{stepItem} click" : function(el, event)
			{
				var id 	= $(el).data('for');

				// page form should be hidden
				self.pageContent().show();

				// Hide all page steps.
				self.stepContent().hide();

				// Remove active class on step item
				self.stepItem().removeClass('active');

				// Add active class on the selected item.
				el.addClass('active');

				// Get the step content element
				var stepContent = self.stepContent('.step-' + id);

				// Show active page step.
				stepContent.show();

				// Trigger onShow on the field item in the content
				stepContent.find(self.fieldItem.selector).trigger('show');
			},

			"{stepItem} error": function(el)
			{
				el.addClass('error');
			},

			"{stepItem} clear": function(el)
			{
				if(self.errorFields.length < 1)
				{
					el.removeClass('error');
				}
			},

			"{submit} click" : function(el, event)
			{
				// Get the task for this action
				var task = el.data('task');

				if (task != 'update') {
					task = task + 'Page';
				}

				// Run some error checks here.
				event.preventDefault();

				el.addClass('btn-loading');

				self.pageForm()
					.validate({fieldSelector : self.fieldItem.selector})
					.fail(function() {

						el.removeClass('btn-loading');
						EasySocial.dialog({
							content : EasySocial.ajax('site/views/profile/showFormError', {
								"stepIds": self.errorTabs,
								"fieldIds": self.errorFields
							})
						});

					}).done(function() {

						// Change the task hidden input
						self.taskHiddenInput().val(task);

						self.pageForm().submit();
					});

				// Need to clear those step id from this error tab when click the submit button
				self.errorTabs = [];

				return false;
			}
		}
	}
);


module.resolve();
});
});

			EasySocial.module('site/pages/filter', function($) {

var module	= this;

EasySocial.require()
.script('site/pages/browser')
.done(function($) {

EasySocial.Controller('Pages.Filter', {
	defaultOptions: {
		"{filter}": "[data-es-page-filters] [data-filter-item]",
		"{browserController}": "[data-es-pages]"
	}
}, function(self, opts) { return {
	controller: null,

	init: function() {
		self.controller = self.getController();
	},

	getController: function() {
		var controller = self.browserController().controller();

		return controller;
	},

	setActiveFilter: function(filter) {
		// Set correct active state
		self.filter().removeClass('active');
		filter.addClass('active');

		filter.find('a').route();

		filter.addClass('is-loading');
	},

	"{filter} click": function(filter, event) {
		if (!self.controller) {
			return;
		}

		event.preventDefault();
		event.stopPropagation();

		// Set active filter state
		self.setActiveFilter(filter);

		var type = filter.data('type');
		var options = {
			'userId': opts.userId,
			'categoryId': filter.data('id')
		};

		self.controller.getPages(type, options, function() {
			filter.removeClass('is-loading');
		});
	}

}});

module.resolve();

});

});
			EasySocial.module('site/pages/followers', function($) {

	var module = this;

	EasySocial.Controller('Pages.App.Followers', {
		defaultOptions: {

			// Wrapper
			"{wrapper}": "[data-wrapper]",
			"{contents}": "[data-contents]",
			"{result}": "[data-result]",

			// Item
			"{item}": "[data-item]",

			// Actions
			"{cancelInvite}": "[data-cancel]",
			"{remove}": "[data-remove]",
			"{approve}": "[data-approve]",
			"{promote}": "[data-promote]",
			"{revoke}": "[data-revoke]",
			"{reject}": "[data-reject]",

			// Search
			"{searchInput}": "[data-search-input]",

			// Filters
			"{filter}": "[data-filter]",

			// Checkbox
			'{checkbox}': '[data-page-item-checkbox]',
			'{checkAll}': '[data-page-item-checkall]',

			// Actions button
			'{actionsWrapper}': '[data-page-actions-wrapper]',
			'{actionsApply}': '[data-page-actions-apply]',
			"{actionsTask}": '[data-page-actions-task]'
		}
	}, function(self, opts) { return {

		init : function() {
			// Get the id of the page
			opts.id = self.element.data('id');
			opts.returnUrl = self.element.data('return');
		},

		clearSelectedCheckboxes: function() {
			self.checkAll().prop('checked', false);
			self.checkAll().trigger('change');
		},

		updateCheckboxSelection: function() {
			// Check if all checkbox is selected
			if (self.isAllCheckboxSelected()) {
				self.checkAll().prop('checked', true);
			} else {
				self.checkAll().prop('checked', false);
			}
		},

		isAllCheckboxSelected: function() {
			var totalSelected = self.getSelectedCheckbox().length;
			var totalCheckbox = self.checkbox().length;

			if (totalSelected == totalCheckbox) {
				return true;
			}

			return false;
		},

		getSelectedCheckbox: function() {
			var items = [];
			var selected = self.checkbox(':checked');

			selected.each(function(i, el) {
				items.push($(el).val());
			});

			return items;
		},

		"{checkbox} change" : function(input, event) {
			var selected = self.getSelectedCheckbox();

			var parent = input.parents(self.item.selector);

			parent.removeClass('is-selected');

			// Check if all checkbox is selected
			self.updateCheckboxSelection();

			if (selected.length > 0) {
				self.actionsWrapper().removeClass('t-hidden');
				parent.addClass('is-selected');
				return;
			}

			self.actionsWrapper().addClass('t-hidden');
		},

		'{checkAll} change': function(input, event) {
			var checked = input.is(':checked');

			if (checked) {
				self.actionsWrapper().removeClass('t-hidden');
			} else {
				self.actionsWrapper().addClass('t-hidden');
			}

			self.checkbox().not(':disabled').prop('checked', checked);
			self.checkbox().not(':disabled').trigger('change');
		},

		"{actionsApply} click": function(button, event) {
			var controllerTask = $.trim(self.actionsTask().val());

			if (controllerTask == '') {
				return false;
			}

			var confirmation = self.actionsTask().find(':selected').data('confirmation');

			// If there is no confirmation, just submit the form
			if (!confirmation) {
				self.taskInput().val(controllerTask);
				self.submitForm();

				return false;
			}

			// Get selected items
			var items = self.getSelectedCheckbox();
			var returnUrl = $('[data-page-item-follower]').data('return');

			console.log(returnUrl);

			EasySocial.dialog({
				"content": EasySocial.ajax(confirmation, {'userId': items, 'id': opts.id, 'return': returnUrl})

			});
		},

		setActiveFilter: function(filter) {
			self.filter().removeClass('active');
			filter.addClass('active');
		},

		search: function(keyword) {
			var type = $('[data-filter].active').data('type');

			self.updatingContents();

			EasySocial.ajax('apps/page/followers/controllers/pages/getFollowers', {
				"id": opts.id,
				"keyword": keyword,
				"type": type
			}).done(function(contents) {

				self.updateContents(contents);

				// Show empty if necessary
				if (!self.item().length) {
					self.result().addClass('is-empty');
				}

			});
		},

		getItems: function(type, clusterId, callback) {

			if (self.searchInput().val() != '') {
				this.search(self.searchInput().val());
				return;
			}

			var id = clusterId ? clusterId : opts.id;

			self.updatingContents();

			EasySocial.ajax('apps/page/followers/controllers/pages/getFollowers', {
				"id": id,
				"type": type
			}).done(function(contents) {

				if ($.isFunction(callback)) {
					callback.call(this, contents);
				}

				self.updateContents(contents);

				// Show empty if necessary
				self.contents().toggleClass('is-empty', !self.item().length);

				$('body').trigger('afterUpdatingContents', [contents]);

			});
		},

		updatingContents: function() {
			self.wrapper().empty();
			self.contents().addClass('is-loading');
		},

		updateContents: function(html) {
			self.contents().removeClass('is-loading');
			self.wrapper().replaceWith(html);
		},

		"{cancelInvite} click": function(link, event) {
			// Get the user id
			var userId = link.closest(self.item.selector).data('id');
			var item = link.closest(self.item.selector);

			EasySocial.ajax('site/controllers/pages/cancelInvite' , {
				"id" : opts.id, "userId" : userId, "return": opts.returnUrl
			}).done(function() {
				item.remove();
			});
		},

		"{remove} click" : function(link, event) {

			// Get the user id
			var userId = link.closest(self.item.selector).data('id');

			EasySocial.dialog({
				content: EasySocial.ajax('site/views/pages/confirmRemoveFollower', {"id": opts.id, "userId" : userId, "return": opts.returnUrl})
			});
		},

		// Approve a follower
		"{approve} click" : function(link, event) {
			// Get the user id
			var userId = link.closest(self.item.selector).data('id');
			var returnUrl = link.closest(self.item.selector).data('return');

			EasySocial.dialog({
				"content": EasySocial.ajax('site/views/pages/confirmApprove', {"id": opts.id, "userId" : userId, "return": returnUrl})
			});
		},

		"{promote} click": function(link, event) {
			// Get the user id
			var userId = link.closest(self.item.selector).data('id');
			var returnUrl = link.closest(self.item.selector).data('return');

			EasySocial.dialog({
				content: EasySocial.ajax('site/views/pages/confirmPromote', { "id" : self.options.id, "userId": userId, "return": returnUrl})
			});
		},

		"{revoke} click": function(link, event) {

			// Get the user id
			var userId = link.closest(self.item.selector).data('id');
			var returnUrl = link.closest(self.item.selector).data('return');

			EasySocial.dialog({
				content: EasySocial.ajax('site/views/pages/confirmDemote', {"id": self.options.id, "userId": userId, "return": returnUrl})
			});
		},

		"{reject} click" : function(link, event) {
			// Get the user id
			var userId = link.closest(self.item.selector).data('id');
			var returnUrl = link.closest(self.item.selector).data('return');

			EasySocial.dialog({
				content: EasySocial.ajax('site/views/pages/confirmReject', {"id": opts.id, "userId": userId, "return": returnUrl})
			});
		},

		"{searchInput} keyup": $.debounce(function(textInput) {

			var keyword = $.trim(textInput.val());
			self.search(keyword);

		}, 250),
	}});

	module.resolve();
});

			EasySocial.module("site/photos/avatar", function($){

var module = this;

EasySocial.require()
.library("imgareaselect")
.done(function(){

EasySocial.Controller("Photos.Avatar", {
	defaultOptions: {
		"uid": null,
		"type": null,
		"redirect": true,
		"redirectUrl" : "",
		"{image}": "[data-photo-image]",
		"{viewport}": "[data-photo-avatar-viewport]",
		"{photoId}": "[data-photo-id]",
		"{userId}": "[data-user-id]",
		"{createButton}": "[data-create-button]",
		"{selection}": "[data-selection-box]",
		"{loadingIndicator}": "[data-photos-avatar-loading]"
	}
}, function(self, opts) { return {

	init: function() {
		self.setLayout();
	},

	data: function() {

		var viewport = self.viewport();
		var width  = viewport.width();
		var height = viewport.height();

		var selection = viewport.imgAreaSelect({"instance": true}).getSelection();
		var data = {
					"id": self.photoId().val(),
					"uid": self.options.uid,
					"type": self.options.type,
					"top": selection.y1 / height,
					"left": selection.x1 / width,
					"width": selection.width / width,
					"height": selection.height / height
				};

		return data;
	},

	imageLoaders: {},

	setLayout: function() {

		var imageHolder = self.image();

		// Using this instead of the other one above for urls that may have /*/ in it.
	    // imageUrl = $.uri(imageHolder.css("backgroundImage")).extract(0),
		var imageUrl = imageHolder.css("backgroundImage").replace(/^url\(['"]?/,'').replace(/['"]?\)$/,'');
		var imageLoaders = self.imageLoaders;
		var imageLoader = imageLoaders[imageUrl] || (self.imageLoaders[imageUrl] = $.Image.get(imageUrl));

		imageLoader
			.done(function(imageEl, image) {

				var size = $.Image.resizeWithin(image.width, image.height, imageHolder.width(), imageHolder.height());

				var min = Math.min(size.width, size.height);
				var x1  = Math.floor((size.width  - min) / 2);
				var y1  = Math.floor((size.height - min) / 2);
				var x2  = x1 + min;
				var y2  = y1 + min;

				setTimeout(function() {
					// Enable the create avatar button
					self.createButton().enabled(true);

					self.viewport()
						.css(size)
						.imgAreaSelect({
							handles: true,
							aspectRatio: "1:1",
							parent: self.image(),
							x1: x1,
							y1: y1,
							x2: x2,
							y2: y2,
							onSelectEnd: function(viewport, selection) {
								var hasSelection = !(selection.width=="0" && selection.height=="0");

								// This ensures that the user selects an area at least
								self.createButton().enabled(hasSelection);
							}
						});
					}, 450);
		    });
	},

	"{createButton} click": function(createButton, event) {
		var data = self.data();

		// Disabled the button
		createButton.attr('disabled', 'disabled');
		createButton.find('[data-create-button-loader]').addClass('is-active');
		var task = EasySocial.ajax("site/controllers/photos/createAvatar", data)
						.done(function(photo, user) {
							if (opts.redirect) {
								var url = self.options.redirectUrl;
								url = url.replace('&amp;', '&');

								window.location = url;
							}
							
						}).fail(function(message, type) {
							self.setMessage(message, type);
						});

		self.trigger("avatarCreate", [task, data, self]);
	}

}});

module.resolve();

});

});
			EasySocial.module("site/photos/browser", function($){

var module = this;

EasySocial.Controller("Photos.Browser", {
	defaultOptions: {

		// For masonry
		tilesPerRow: 4,

		"{sidebar}": "[data-photo-browser-sidebar]",
		"{content}": "[data-photo-browser-content]",
		"{wrapper}": "[data-photo-browser-wrapper]",

		"{backButton}": "[data-photo-back-button]",

		"{listItemGroup}" : "[data-photo-list-item-group]",
		"{listItem}"      : "[data-photo-list-item]",
		"{listItemLink}"  : "[data-photo-list-item] > a",
		"{listItemTitle}" : "[data-photo-list-item-title]",
		"{listItemCover}" : "[data-photo-list-item-cover]",
		"{listItemImage}" : "[data-photo-list-item-image]",

		"{featuredListItem}"      : "[data-photo-list-item].featured",
		"{featuredListItemImage}" : "[data-photo-list-item].featured [data-photo-list-item-image]",

		"{photoItem}": "[data-photo-item]"
	}
},
function(self) { return {

	init: function() {

		// Load masonry and set layout
		EasySocial.require()
			.script('site/vendors/masonry')
			.done(function(){
				self.setLayout();
			});
	},

	setLayout: function() {

		var listItemGroup = $('#es ' + self.listItemGroup.selector);
		var masonry = $.data(listItemGroup[0], "masonry");

		// Ensure group width is divisible by 4
		listItemGroup.width(Math.floor(listItemGroup.width() / 4) * 4);

		if (masonry) {

			listItemGroup
				.masonry("reloadItems")
				.masonry("layout");

		// Else recalculate sizes
		} else {

			listItemGroup
				.masonry({
					columnWidth: ".es-thumb.grid-sizer",
					itemSelector: self.listItem.selector
				});
		}

		// Save current layout
		self.setLayout.seed = listItemGroup.width();
	},

	open: function(view) {

		var args = $.makeArray(arguments);

		self.trigger("contentLoad", args);

		var method = "view" + $.String.capitalize(view),
			loader = self[method].apply(self, args.slice(1));

		loader
			.done(self.displayContent(function(){
				self.trigger("contentDisplay", args);
				return arguments;
			}))
			.fail(function(){
				self.trigger("contentFail", args);
			})
			.always(function(){
				self.trigger("contentComplete", args);
			});

		return loader;
	},

	displayContent: $.Enqueue(function(html){

		var scripts = [],
			content = $($.buildFragment([html], document, scripts));

		// Insert content
		self.content().html(content);

		// Remove scripts
		$(scripts).remove();
	}),

	viewPhoto: function(photoId) {

		var state = "active loading",

			listItem =
				self.listItem()
					.removeClass(state)
					.filterBy("photoId", photoId)
					.addClass(state),

			loader =
				EasySocial.ajax(
					"site/views/photos/item", {
						id: photoId,
						browser: false
					})
					.always(function(){
						listItem.removeClass("loading");
					});

		return loader;
	},

	"{listItem} click": function(listItem) {

		var photoId = listItem.data("photoId");

		// Load album
		self.open("Photo", photoId);

		// Change address bar url
		listItem.find("> a").route();
	},

	"{listItemLink} click": function(listItemLink, event) {

		// Progressive enhancement, no longer refresh the page.
		event.preventDefault();

		// Prevent item from getting into :focus state
		listItemLink.blur();
	},

	"{backButton} click": function(button, event) {

		// If albums browser exists, use it to load album
		var browser = self.browser;

		if (browser) {
			event.preventDefault();
			event.stopPropagation();

			button.route();

			var albumId = self.element.data("albumId");

			browser.open("album", albumId);

			// To quickly change back to album
			browser.setLayout("album");

			self.element.remove();
		}
	},

	getListItem: function(photoId, context) {

		var listItem =
			(!photoId) ?
				self.listItem(".new") :
				self.listItem().filterBy("photoId", photoId);

		if (!context) return listItem;

		return listItem.find(self["listItem" + $.String.capitalize(context)].selector);
	},

	getNextListItem: function(photoId) {

		var listItem =
			self.getListItem(photoId)
				.next(self.listItem.selector);

		if (listItem.length < 1) {
			listItem = self.listItem(":first");
		}

		return listItem;
	},

	getPrevListItem: function(photoId) {

		var listItem =
			self.getListItem(photoId)
				.prev(self.listItem.selector);

		if (listItem.length < 1) {
			listItem = self.listItem(":last");
		}

		return listItem;
	},

	removeListItem: function(photoId, loadPreviousItem) {

		var listItem = self.getListItem(photoId),
			prevListItem = self.getPrevListItem(photoId);

		// Remove list item
		listItem.remove();

		// Reset list item masonry layout
		self.setLayout();

		// If there are no more items on the list
		if (self.listItem().length < 1) {

			self.element.addClass("loading");

			// Go back to albums
			return window.location = self.backButtonLink().attr("href");
		}

		// Else load previous item
		if (loadPreviousItem) {

			prevListItem.click();
		}
	},

	"{photoItem} init.photos.item": function(el, event, photoItem) {

		// Attach browser plugin to album
		self.addSubscriber(photoItem);
	},

	"{photoItem} photoSave": function(el, event, task) {

		// Update list item title when photo is updated.
		task.done(function(photo, html){

			// Update item link & route url
			self.getListItem(photo.id)
				.find("> a")
				.attr({
					href : photo.permalink,
					title: photo.title
				})
				.route();

			self.getListItem(photo.id, "title")
				.html(photo.title);
		});
	},

	"{photoItem} photoNext": function(el, event, photo) {

		var listItem = self.getNextListItem(photo.id);
		listItem.click();
	},

	"{photoItem} photoPrev": function(el, event, photo) {

		var listItem = self.getPrevListItem(photo.id);
		listItem.click();
	},

	"{photoItem} photoMove": function(el, event, task, photo) {

		task
			.done(function(){
				self.removeListItem(photo.id, true);
			});
	},

	"{photoItem} photoDelete": function(el, event, task, photo) {

		task
			.done(function(){
				self.removeListItem(photo.id, true);
			});
	},

	"{photoItem} photoFeature": function(el, event, task, photo, featured) {

		var item = self.getListItem(photo.id);

		item.toggleClass("featured", featured);
		self.setLayout();

		task
			.fail(function(){
				item.toggleClass("featured", !featured);
				self.setLayout();
			});
	},

	"{sidebar} sidebarToggle": function() {

		self.setLayout();
	},

	"{self} contentLoad": function() {

		// Display the loading indication
		self.wrapper().addClass('is-loading');

		// Hide the content
		self.content().addClass('t-hidden');
	},

	"{self} contentDisplay": function() {
		self.wrapper().removeClass('is-loading');
		self.content().removeClass('t-hidden');
	}

}});

module.resolve();

});
			EasySocial.module("site/photos/editor", function($){

var module = this;

EasySocial.Controller("Photos.Editor", {
	defaultOptions: {

		"{titleField}" : "[data-photo-title-field]",
		"{captionField}": "[data-photo-caption-field]",
		"{descriptionField}" : "[data-photo-description-field]",

		"{location}" : "[data-photo-location]",
		"{locationCaption}" : "[data-photo-location-caption]",
		"{addLocationButton}" : "[data-photo-addLocation-button]",
		"{date}" : "[data-photo-date]",
		"{dateCaption}" : "[data-photo-date-caption]",
		"{addDateCaption}" : "[data-photo-adddate-button]",

		"{locationWidget}" : ".es-photo-location-form .es-locations",
		"{latitude}" : "[data-location-lat]",
		"{longitude}" : "[data-location-lng]",

		"{dateDay}" : "[name=date-day]",
		"{dateMonth}" : "[name=date-month]",
		"{dateYear}" : "[name=date-year]",

		"{actionsMenu}" : "[data-item-actions-menu]",
		"{featureButton}" : "[data-photo-feature-button]",
		"{coverButton}" : "[data-photo-cover-button]",

		"{editButton}" : "[data-photo-edit-button]",
		"{editButtonLink}" : "[data-photo-edit-button] > a",

		"{cancelButton}" : "[data-photo-cancel-button]",

		"{doneButton}" : "[data-photo-done-button]",
		"{doneButtonLink}" : "[data-photo-done-button] > a",

		"{moveButton}" : "[data-photo-move-button]",
		"{deleteButton}" : "[data-photo-delete-button]",

		"{rotateLeftButton}" : "[data-photo-rotateLeft-button]",
		"{rotateRightButton}" : "[data-photo-rotateRight-button]",

		"{profileAvatarButton}" : "[data-photo-profileAvatar-button]",
		"{profileCoverButton}" : "[data-photo-profileCover-button]"
	}
}, function(self, opts, base) { return {

	init: function() {

		// Quick fix for mobile dropdown menu. #3233
		// Need to find better alternative to this fix.
		if (window.es.mobile) {
			self.moveButton().on('click', function() {
				self.moveImage();
			});

			self.deleteButton().on('click', function() {
				self.deleteImage();
			});

			self.coverButton().on('click', function() {
				self.setCover();

				// Close the menu
				$(document).trigger('click.bs.dropdown.data-api');
			});
		}
	},

	data: function() {

		return {
			id : self.photo.id,
			title : self.titleField().val(),
			caption : self.captionField().val(),
			date : self.formatDate(),
			address : self.locationCaption().html(),
			latitude : self.latitude().val(),
			longitude : self.longitude().val()
		}
	},

	save: function() {

		var data = self.data();

		self.clearMessage();

		var task =
			EasySocial.ajax(
				"site/controllers/photos/update",
				data
			)
			.done(function(photo){

				self.photo.setLayout("item");
			})
			.fail(function(){

				self.setMessage(message, "error");
			})
			.progress(function(message, type){

				if (type=="success") {
					self.setMessage(message);
				}
			});

		self.trigger("photoSave", [task, self]);

		return task;
	},

	enable: function() {

		self.photo.setLayout("form");

		// If we are running under an album frame
		var album = self.photo.album;

		if (album) {
			base.addClass("active");
		}

		self.trigger("enabled", [self]);
	},

	disable: function() {

		self.photo.setLayout("item");

		// If we are running under an album frame
		var album = self.photo.album;

		if (album) {
			base.removeClass("active");
		}

		self.trigger("disabled", [self]);
	},

	imageLoader: {},

	setImage: function(type) {

		var image = self.photo.image(),
			imageCss = self.photo.imageCss(),
			imageSource = image.data(type + "Src"),
			imageLoader = self.imageLoader[imageSource];

		// If this image hasn't been loaded before
		if (!imageLoader) {

			// Create an image loader
			imageLoader = $.Image.get(imageSource);

			// Store a reference of the loader within the element
			self.imageLoader[imageSource] = imageLoader;
		}

		imageLoader
			.done(function(){
				image.attr("src", imageSource);
				imageCss.css({
					backgroundImage: $.cssUrl(imageSource)
				});
			});

		return imageLoader;
	},

	moveImage: function() {
		var photo = self.photo;

		var dialog =
			EasySocial.dialog({
				content: EasySocial.ajax(
					"site/views/photos/moveToAnotherAlbum",
					{
						id: photo.id
					}
				),
				bindings: {
					"{moveButton} click": function() {

						var targetAlbumId = this.albumSelection().val();

						var task =
							EasySocial.ajax(
								"site/controllers/photos/move",
								{
									id: photo.id,
									albumId: targetAlbumId
								}
							)
							.always(function(){
								dialog.close();
							});

						self.trigger("photoMove", [task, photo, false, targetAlbumId]);
					}
				}
			});
	},

	deleteImage: function() {
		var photo = self.photo;

		EasySocial.dialog({
			"content": EasySocial.ajax("site/views/photos/confirmDelete", {
						"id": photo.id
					}),
			"bindings": {
				"{deleteButton} click": function(deleteButton) {
					var deleteButton = $(deleteButton);
					var dialog = this.parent;

					deleteButton.disabled(true);

					var task = EasySocial.ajax("site/controllers/photos/delete", {
								"id": photo.id
							}).always(function(){
								dialog.close();
							});

					self.trigger("photoDelete", [task, photo]);
				}
			}
		});
	},

	setCover: function() {
		var album = self.photo.album;

		// When viewing photos invidually,
		// there is no reference to album,
		// the button itself should't be visible anyway.
		if (!album) return;

		// If the editor is available, set cover.
		album.editor && album.editor.setCover(self.photo.id);
	},

	"{descriptionField} focus": function(el, ev) {
		if (self.baseScrollHeight) {
			return;
		}

		var textarea = $(el);
		var savedValue = textarea.val();

		textarea.val('');

		self.baseScrollHeight = el[0].scrollHeight;

		textarea.val(savedValue);
	},

	"{descriptionField} input": function(el ,ev) {
		var textarea = $(el);

		textarea.height(self.baseScrollHeight);
		textarea.height(textarea.prop('scrollHeight'));
	},

	"{featureButton} click": function(featureButton, event) {

		event.stopPropagation();

		var isPopup =
			self.photo.element.parents("[data-photo-popup]").length > 0 ||
			self.photo.element.parents("[data-photo-browser-content]").length > 0;

		var isFeatured = base.hasClass("featured");

		base.toggleClass("featured", !isFeatured);

		!isPopup && self.setImage((isFeatured) ? "thumbnail" : "featured");

		// Perform an ajax call to mark the photo as featured
		var task =
			EasySocial.ajax(
				"site/controllers/photos/feature", {
					id: self.photo.id
				}
			)
			.done(function( message , isFeatured ) {

				// If this is not under album, show a message
				// if (!self.photo.album) {
				// 	self.clearMessage();
				// 	self.setMessage( message );
				// }

				featureButton.toggleClass('is-featured', isFeatured);
			})
			.fail(function() {

				base.removeClass("featured");
				!isPopup && self.setImage((!isFeatured) ? "thumbnail" : "featured");
			});

		self.trigger("photoFeature", [task, self.photo, !isFeatured]);
	},

	"{coverButton} click": function() {
		self.setCover();
	},

	"{dateDay} keyup": function() {
		self.updateDate();
	},

	"{dateMonth} change": function() {
		self.updateDate();
	},

	"{dateYear} keyup": function() {
		self.updateDate();
	},

	updateDate: function() {

		setTimeout(function(){
			self.date().addClass("has-data");
			var dateCaption = self.dateDay().val() + ' ' + $.trim(self.dateMonth().find(":selected").text() + ' ' + self.dateYear().val());
			self.dateCaption().html(dateCaption);
		}, 1);
	},

	formatDate: function() {
		var day = self.dateDay().val() || self.dateDay().data('date-default'),
			month = self.dateMonth().val() || self.dateMonth().data('date-default'),
			year = self.dateYear().val() || self.dateYear().data('date-default');

		return year + '-' + month + '-' + day;
		},

	"{locationWidget} locationChange": function(el, event, location) {
		var address = location.fulladdress || location.address || location.formatted_address || location.name;

		// Update the info
		self.locationCaption().html(address);
		self.location().addClass("has-data");

		// Hide the location poopup
		self.addLocationButton().click();
	},

	rotate: function(angle) {

		var photo = self.photo;

		self.rotateLeftButton().disabled(true);
		self.rotateRightButton().disabled(true);

		// Show loading indicator
		photo.content().addClass("loading");

		var task =
			EasySocial.ajax(
				"site/controllers/photos/rotate",
				{
					id: photo.id,
					angle: angle
				}
			)
			.done(function(photoObj) {

				var url;

				if (self.photo.album) {
					url = photoObj.sizes.thumbnail.url;
				} else {
					url = photoObj.sizes.large.url;
				}

				// So that it actual loads a new one
				url += "?" + $.uid();

				// Replace image url
				photo.image()
					.attr("src", url);

				photo.imageCss()
					.css({
						backgroundImage: $.cssUrl(url)
					});

				base
					.addTransitionClass("rotating-ready", 150)
					.removeClass("rotating-right rotating-left");
			})
			.fail(function(message, type) {

				self.setMessage(message, type);
			})
			.always(function(){

				photo.content().removeClass("loading");
				self.rotateLeftButton().disabled(false);
				self.rotateRightButton().disabled(false);
			});

		self.trigger("photoRotate", [task, angle, photo])
	},

	"{rotateRightButton} click": function() {

		base.addClass("rotating-right");
		self.rotate(90);
	},

	"{rotateLeftButton} click": function() {

		base.addClass("rotating-left");
		self.rotate(-90);
	},

	"{moveButton} click": function() {
		self.moveImage();
	},

	"{deleteButton} click": function() {
		self.deleteImage();
	},

	"{editButton} click": function() {

		// Change viewer layout
		self.photo.setLayout("form");

		// Change address bar url
		self.editButtonLink().route();
	},

	"{editButtonLink} click": function(editButtonLink, event) {

		event.preventDefault();
	},

	"{cancelButton} click": function(button, event) {
		event.preventDefault();
		event.stopPropagation();

		// Change album layout
		self.photo.setLayout("item");

		// Change address bar url
		self.doneButtonLink().route();
	},

	"{doneButton} click": function(button, event) {
		event.preventDefault();
		event.stopPropagation();

		self.save()
			.done(function(){

				// Change album layout
				self.photo.setLayout("item");

				// Change address bar url
				self.doneButtonLink().route();
			})
			.fail(function(){

			});
	},

	"{doneButtonLink} click": function(doneButtonLink, event) {
		event.preventDefault();
	},

	"{profileAvatarButton} click": function() {
		EasySocial.photos.crop(self.photo.id);
	}
}});

module.resolve();

});
			EasySocial.module("site/photos/item", function($){

var module = this;

// Essential dependencies
EasySocial.require()
.library("image")
.script(
	"site/photos/tags",
	"site/photos/editor",
	"site/photos/tagger",
	"site/photos/navigation",
	"site/vendors/masonry"
)
.done(function() {

var Controller =
EasySocial.Controller("Photos.Item", {
	hostname: "photo",

	defaultOptions: {
		isStreamView: false,
		editable: false,
		taggable: false,
		navigation: false,
		clusterId: false,
		clusterType: false,
		clusterPrivate: false,

		"{header}" : "[data-photo-header]",
		"{content}" : "[data-photo-content]",
		"{footer}" : "[data-photo-footer]",
		"{viewport}" : "[data-photo-viewport]",

		"{info}" : "[data-photo-info]",
		"{title}" : "[data-photo-title]",
		"{titleLink}" : "[data-photo-title-link]",
		"{caption}" : "[data-photo-caption]",

		"{image}" : "[data-photo-image]",
		"{imageCss}" : "[data-photo-image-css]",
		"{imageLink}" : "[data-photo-image-link]",

		"{menu}" : "[data-photo-menu]",
		"{actions}" : "[data-item-actions]",
		"{actionsMenu}" : "[data-item-actions-menu]",
		"{checkboxWrapper}" : "[data-photo-checkbox-wrapper]",

		"{comments}" : "[data-comments]",
		"{share}" : "[data-repost-action]",
		"{likes}" : "[data-likes-action]",
		"{likeContent}" : "[data-likes-content]",
		"{repostContent}" : "[data-repost-content]",
		"{counterBar}" : "[data-stream-counter]",

		"{privacy}" : "[data-es-privacy-container]",

		"{likeCount}" : "[data-photo-like-count]",
		"{commentCount}" : "[data-photo-comment-count]",
		"{tagCount}" : "[data-photo-tag-count]"
	}
}, function(self, opts) { return {

	init: function() {

		self.id = self.element.data("photoId");

		self.tags = self.addPlugin('tags', EasySocial.Controller.Photos.Tags);

		// If this photos is editable, load & implement editor.
		if (opts.editable) {
			self.editor = self.addPlugin("editor", EasySocial.Controller.Photos.Editor);
		}

		if (opts.taggable) {
			EasySocial.module("site/photos/tagger")
				.done(function(TaggerController){
					self.tagger = self.addPlugin("tagger", TaggerController, {
						clusterId : opts.clusterId,
						clusterType : opts.clusterType,
						clusterPrivate : opts.clusterPrivate
					});
				});
		}

		if (opts.navigation) {
			EasySocial.module("site/photos/navigation")
				.done(function(NavigationController){
					self.navigation = self.addPlugin("navigation", NavigationController);
				});
		}

		self.trigger("photoLoaded", [self]);
	},

	data: function() {

		var image = self.image();

		return {
			id        : self.id,
			title     : $.trim(self.title().text()),
			caption   : $.trim(self.caption().text()),
			sizes: {
				thumbnail: image.data("thumbnailSrc"),
				featured : image.data("featuredSrc"),
				large    : image.data("largeSrc")
			}
		}
	},

	setLayout: function(layoutName) {

		// Switch layout
		self.element
			.data("photoLayout", layoutName)
			.switchClass("layout-" + layoutName);

		// Trigger layout change event
		self.trigger("layoutChange", [layoutName, self]);
	},

	"{self} click": function(el, event) {

		// If using photo popup, stop.
		if (!el.data("esPhotoDisabled")) return;

		var target = $(event.target),
			menu = self.menu(),
			checkbox = self.checkboxWrapper();

		// If the area being click is the photo menu and checkbox, stop.
		if (target.parents().andSelf().filter(menu, checkbox).length > 0) return;

		// Activate item
		self.trigger("activate", [self]);
	},

	"{self} photoSave": function(el, event, task) {

		task
			.done(function(photo, html){
				self.info().replaceWith(html);
			});
	},

	"{self} photoDelete": function(el, event, task) {

		task
			.done(function(message, type){
			})
			.fail(function(message, type){
				self.setMessage(message, type);
			});
	},

	"{imageLink} click": function(imageLink, event) {

		event.preventDefault();
	},

	"{titleLink} click": function(titleLink, event) {

		// event.preventDefault();
	},

	"{self} shown.bs.dropdown": function() {
		 self.element.addClass("show-all");
	},

	"{self} hidden.bs.dropdown": function() {
		 self.element.removeClass("show-all");
	},

	"{share} create": function(el, event, itemHTML) {
		self.counterBar().removeClass('hide');
	},

		"{likes} onLiked": function(el, event, data) {

		//need to make the data-stream-counter visible
		self.counterBar().removeClass( 'hide' );
		self.count("like", 1, true);
	},

	"{likes} onUnliked": function(el, event, data) {

		var isLikeHide 		= self.likeContent().hasClass('hide');
		var isRepostHide 	= self.repostContent().hasClass('hide');

		if( isLikeHide && isRepostHide )
		{
			self.counterBar().addClass( 'hide' );
		}

		self.count("like", -1, true);
	},

	"{self} tagAdd": function() {
		self.count("tag", 1, true);
	},

	"{self} tagRemove": function() {
		self.count("tag", -1, true);
	},

	"{comments} newCommentSaved": function() {
		self.count("comment", 1, true);
	},

	"{comments} commentDeleted": function() {
		self.count("comment", -1, true);
	},

	"{privacy} activate": function() {
		setTimeout(function(){
			self.element.addClass("show-all")
		}, 0);
	},

	"{privacy} deactivate": function() {
		self.element.removeClass("show-all");
	},

	count: function(subject, val, append) {

		var statSelector = self[subject + "Count"];

		if (!$.isFunction(statSelector)) return;

		// Get stat element
		var stat = statSelector();

		// If no stat element found, stop.
		if (stat.length < 0) return;

		// Get current stat count
		var statCount;

		if (append) {
			statCount = (parseInt(stat.text()) || 0) + (parseInt(val) || 0);
		} else {
			statCount = val;
		}

		// Always stays at 0 if less than that
		if (statCount < 0) statCount = 0;

		// Update stat count
		stat.text(statCount);
	}

}});

module.resolve(Controller);

});

});
			EasySocial.module("site/photos/navigation", function($){
	$.fn.intersectsWith = function(top, left, width, height) {

		var offset = this.offset(),

			reference = {
				top   : offset.top,
				left  : offset.left,
				bottom: offset.top  + (sourceHeight = this.height()),
				right : offset.left + (sourceWidth  = this.width()),
				width : sourceWidth,
				height: sourceHeight
			},

			subject = {
				top   : top,
				left  : left,
				bottom: top  + (height || (height = 0)),
				right : left + (width  || (width  = 0)),
				width : width,
				height: height
			},

			intersects = (
				reference.left <= subject.right    &&
				subject.left   <= reference.right  &&
				reference.top  <= subject.bottom   &&
				subject.top    <= reference.bottom
			);

		return (intersects) ? {reference: reference, subject: subject} : false;
	};

	var module = this;

	var Controller =

		EasySocial.Controller("Photos.Navigation",
		{
			hostname: "navigation",

			defaultOptions: {
				"{navButton}" : ".es-photo-nav-button",
				"{nextButton}": "[data-photo-next-button]",
				"{prevButton}": "[data-photo-prev-button]"
			}
		},
		function(self, opts, base) { return {

			init: function() {

				self.setDirection(window.esPhotosNavigationLastDirection);
			},

			disabled: true,

			disable: function() {
				self.disabled = true;
				self.navButton().addClass("disabled");
			},

			enable: function() {
				self.disabled = false;
				self.navButton().removeClass("disabled");
			},

			setDirection: function(direction) {

				self.navButton().removeClass("active");

				window.esPhotosNavigationLastDirection = self.currentDirection = direction;

				if (direction) {
					// Show button
					self[direction + "Button"]().addClass("active");
				}
			},

			"{window} mousemove": function(el, event) {

				// If navigation is disabled, don't do anything.
				if (self.disabled) return;

				self.setDirection(null);
				self.photo.trigger("directionstop");

				// If user is not moving within the photo content, stop.
				if ($(event.target).parents().filter(self.photo.content.selector).length < 1) return;

				var offset =
						self.photo.content()
							.intersectsWith(event.pageY, event.pageX);

				if (offset) {

					var direction =
						(offset.subject.left < (offset.reference.right - (offset.reference.width / 2))) ?
							"prev" : "next";

					self.setDirection(direction);

					self.photo.trigger("directionmove", [offset, direction]);
				}
			},

			"{self} tagEnter": function() {
				self.disable();
			},

			"{self} tagLeave": function() {
				self.enable();
			},

			"{self} click": function(el, event) {

				if (self.disabled) return;

				// If user is not clicking within the photo content, stop.
				if ($(event.target).parents().filter(self.photo.content.selector).length < 1) return;

				var direction = self.currentDirection;

				if (!direction) return;

				self.trigger("photo" + $.String.capitalize(direction), [self.photo]);
			},

			"{self} photoNext": function() {
				// Photo browser handles this
			},

			"{self} photoPrev": function() {
				// Photo browser handles this
			}

		}});

	module.resolve(Controller);

});
			EasySocial.module("site/photos/popup", function($){

var module = this;

// Album playlist
//
// <div data-es-photo-group="album:4">
//     <a data-es-photo="499">
// </div>

// Element-based playlist
//
// <div data-es-photo-group>
//     <a data-es-photo="1">
//     <a data-es-photo="2">
//     <a data-es-photo="3">
// </div>

// Custom playlist
// Ideal for large playlist where not all items are shown.
//
// <div data-es-photo-group="photos:400,401,402,403,405,406,407,408">
//     <a data-es-photo="400">
//     <a data-es-photo="401">
//     <a data-es-photo="402">
//     <a data-es-photo="403">
//     <a data-es-photo="404">
//     <!-- The rest of the thumbnails not shown, but the popup will have it. -->
// </div>

// TODO: Move this away
$.fn.at = function(key) {
	return this.find("[data-" + key.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase() + "]");
}

$.template('photos/popup', '<div id="es" class="es-photo-popup" data-photo-popup><div class="es-popup-viewport es-media-browser" data-popup-viewport></div><div class="o-loader"></div></div>');


var controller =
	EasySocial.Controller("Photos.Popup", {
		defaultOptions: {

			"{popup}"   : "[data-photo-popup]",
			"{viewport}": "[data-popup-viewport]",
			"{handle}"  : "[data-popup-handle]",

			"{photoGroup}": "[data-es-photo-group]",
			"{photo}"     : "[data-es-photo]",

			"{photoHeader}": "[data-photo-popup] [data-photo-header]",
			"{photoContent}": "[data-photo-popup] [data-photo-content]",

			"{navButton}" : ".es-photo-nav-button",
			"{closeButton}": "[data-popup-close-button]",

			"{photoItem}": "[data-photo-popup] [data-photo-item]",

			'{desTagItem}': '[data-photo-des-tag-item]'
		}
	}, function(self, opts, base, body) { return {

		init: function() {

			body = $("body");

			self.bodyOverflow = {
				overflow: body.css("overflow"),
				overflowX: body.css("overflowX"),
				overflowY: body.css("overflowY")
			};

			// Listen to body events
			$(document).on('keyup.photos.popup', body, function(event) {
				var popup = self.popup();
				var visible = popup.is(':visible');

				if (!visible) {
					return;
				}

				// When the target is the comments area, it shouldn't be navigating the photos
				var targetIsComment = $(event.target).is('[data-comments-form-input]') || $(event.target).is('[data-comment-input]');

				if (targetIsComment) {
					return;
				}

				// Right
				if (event.keyCode == 39) {
					self.next();
				}

				// Left
				if (event.keyCode == 37) {
					self.prev();
				}
			});
		},

		setLayout: function() {

			// Disable body scrollbar on narrow layout
			var popup = self.popup();

			if (popup.is(":visible")) {

				// Set image size again
				var image = self.viewport().find("img[data-photo-image]")[0];

				if (image) {
					ESImage(image);
				}

				body.css({
					overflow: "hidden",
					overflowX: "hidden",
					overflowY: "hidden"
				});

				var photoItem = self.photoItem();

				// Update tag position
				var tags = photoItem.controller("EasySocial.Controller.Photos.Tags");
				tags && tags.setLayout();

				// Disable navigation controller if there's only one photo or tagging is active
				var navigation = photoItem.controller("EasySocial.Controller.Photos.Navigation");
				var tagger = photoItem.controller("EasySocial.Controller.Photos.Tagger");

				navigation && navigation[
					(tagger && !tagger.disabled) || (self.playlist.length < 2) ? "disable" : "enable"]();

			} else {

				body.css(self.bodyOverflow);
			}
		},

		'{desTagItem} mouseover': function(el, ev) {
			var tags = self.photoItem().controller("EasySocial.Controller.Photos.Tags");

			tags && tags.getTagItem(el.data('photoDesTagId'))
				.addClass('focus');
		},

		'{desTagItem} mouseout': function(el, ev) {
			var tags = self.photoItem().controller("EasySocial.Controller.Photos.Tags");

			tags && tags.getTagItem(el.data('photoDesTagId'))
				.removeClass('focus');
		},

		"{window} resize": $.debounce(function() {

			self.setLayout();

		}, 250),

		"{self} responsive": function() {
			self.setLayout();
		},

		playlist: [],

		show: function() {

			var popup;
			var node = self.popup.node;

			// Create node if not exists
			if (!node) {
				popup = $.template('photos/popup');
				node = self.popup.node = popup;
			}

			// Append node if detached
			if (!$.contains(base, node)) {
				popup = $(node).addClass("is-loading").appendTo(base);
			}

			if (!popup.is(":visible")) {

				// inject 'is-es-photo-popup' so that conversekit icon will be hidden. #588
				$('body').addClass('is-es-photo-popup');

				if (! window.es.mobile) {
					popup.addClass('is-desktop');
				}

				// Show popup
				popup.show();

				// Trigger responsive event
				$(window).trigger("resize.responsive");

				// Trigger show event
				popup.trigger("show");
			}
		},

		hide: function() {

			self.popup()
				.hide()
				.trigger("hide")
				.detach();

			if (! window.es.mobile) {
				self.popup().removeClass('is-desktop');
			}

			// remove 'is-es-photo-popup' so that conversekit icon will be displayed. #588
			$('body').removeClass('is-es-photo-popup');

			// Restore body layout
			body.css(self.bodyOverflow);
		},

		// open(photoId)
		// open(albumId, photoId)
		// open(type, id)
		// open([photoId, photoId, photoId], photoId)
		open: function() {

			// Normalize arguments
			var args = arguments;
			var albumId;
			var photoId;
			var playlist = [];

			// open(photoId)
			if (args.length===1) {
				photoId = args[0];
				playlist = [photoId];
			}

			// open([photoId, photoId, photoId], photoId)
			// open([photoId, photoId, photoId])
			if ($.isArray(args[0])) {
				playlist = args[0];
				photoId = args[1] || playlist[0];

			// open(albumId, photoId)
			// open(type, id)
			} else if (args.length >= 2) {

				var type = args[0];
				var autoplay = true;
				var albumId;
				var streamId;

				// open(albumId, photoId)
				if ($.isNumeric(type)) {
					type = "album";
					autoplay = false;
					albumId = args[0];
					photoId = args[1];
					if (args[2] != undefined) {
						streamId = args[2];
					}
					playlist = [photoId];
				}

				// open("photo", 32)
				if (type=="photo") {
					photoId = args[1];
					playlist = [photoId];
				}

				// open("album", 64)
				if (type=="album") {

					// Get the playlist
					EasySocial.ajax("site/controllers/albums/playlist", {
						"albumId": albumId || args[1],
						"streamId": streamId
					}).done(function(photos){

						// Update the playlist afterwards
						self.playlist = $.map(photos, function(photo){
							return photo.id;
						});

						// Play the first playlist
						if (autoplay) {
							self.display(playlist[0]);
						}

						// This ensure navigation is re-enabled
						self.setLayout();

					}).fail(function() {
					});

				}

			}

			self.playlist = playlist;

			// Show popup if hidden
			self.show();

			self.display(photoId);

		},

		handles: {},

		display: function(photoId) {

			if (!photoId) {
				return;
			}

			var previousId = self.currentPhotoId;

			self.currentPhotoId = photoId;

			var handle = self.handles[photoId];

			// Detach any existing views
			self.handle().detach();

			if (!handle) {

				var popup = self.popup();

				popup.addClass("is-loading");

				EasySocial.ajax("site/views/photos/item", {
					"id": photoId,
					"browser": 0,
					"popup": 1,
				}).done(function(html){

					var handle = $.buildHTML('<div class="es-popup-handle" data-popup-handle>' + html + "</div>");

					self.handles[photoId] = handle;

					self.display(photoId);

					if (window.es.mobile) {
						// Render the reactions when viewing in mobile device.
						window.es.initReactions();
					}

				}).fail(function(){
					alert("There was a problem loading this photo.");
					self.display(previousId);
				}).always(function(){
					popup.removeClass("is-loading");
				});

				return;
			} else {
				self.popup().removeClass("is-loading");
			}

			// Show current handle
			self.viewport().empty().append(handle);

			// Only store the node of the photo handle, discarding scripts.
			if (handle instanceof $) {
				self.handles[photoId] = handle.filter("[data-popup-handle]")[0];
			}

			// Set layout
			self.setLayout();
		},

		current: function() {

			var id = self.currentPhotoId,
				playlist = self.playlist,
				i = $.indexOf(playlist, id);

			// No matching item, revert to 0.
			if (i < 0) i = 0;

			return i;
		},

		next: function() {

			var playlist = self.playlist;

			if (playlist.length < 2) return;

			var i = self.current() + 1;

			// Cycle to the beginning
			if (i > playlist.length - 1) i = 0;

			self.display(playlist[i]);
		},

		prev: function() {

			var playlist = self.playlist;

			if (playlist.length < 2) return;

			var i = self.current() - 1;

			// Cycle to the end
			if (i < 0) i = playlist.length - 1;

			self.display(playlist[i]);
		},

		"{self} click": function(el, event) {

			if (event.target===self.popup()[0]) {
				self.hide();
			}
		},

		"{photo} click": function(photo, event) {

			// If this photo is disabled, stop.
			if (photo.attr("data-es-photo-disabled")=="1") {
				return;
			}

			// if user is tagging something, we stop.
			if (photo.hasClass("tagging")) {
				return;
			}


			var target = $(event.target);
			var targetTree = target.parents().andSelf();

			// Quick fix
			if (target.filter("[data-es-photo]").length < 1 && targetTree.filter(".es-photo-hint, .tag-hint, [data-photo-info], [data-photo-footer], [data-photo-menu], [data-cover-menu], [data-photo-checkbox-wrapper]").length > 0) {
				return;
			}

			// Retrieve photo id and photo group
			var photoId = photo.attr("data-es-photo");
			var photoGroup = self.photoGroup.of(photo);

			// If this is not part of any photo group, don't show popup.
			if (photoGroup.length < 0) {
				return;
			}

			// Stop browser from loading full page photo
			event.preventDefault();
			event.stopPropagation();

			// Retrieve playlist from photo group
			var data = (photoGroup.attr("data-es-photo-group") || "element").split(":");
			var streamId = photoGroup.attr("data-es-photo-streamid");
			var type = data[0];

			opts.isSingleStreamView = photoGroup.data('stream-item') == 1;

			if (type == 'album') {
				var albumId = data[1];
				self.open(albumId, photoId, streamId);
			}

			// Custom playlist
			if (type == 'photos') {
				var list = data[1].split(",");
				self.open(list, photoId);
			}

			// Element-based playlist
			if (type == 'element') {
				var list = [];

				photoGroup.at("esPhoto").each(function(){
					list.push($(this).attr("data-es-photo"));
				});

				self.open(list, photoId);
			}
		},


		"{photoItem} directionmove": function(photoItem, event, offset, direction) {

			// Don't show navigation buttons when playlist still loading,
			// or when there's only a single photo in this playlist.
			if (self.playlist.length < 2) {
				self.navButton().removeClass("active");
			}
		},

		"{photoItem} directionstop": function() {

			// self.photoHeader().removeClass("active");
		},

		"{photoItem} photoNext": function() {
			self.next();
		},

		"{photoItem} photoPrev": function() {
			self.prev();
		},

		"{photoItem} photoLoaded": function() {
			var photoItem = self.photoItem();
			var navigation = photoItem.controller("EasySocial.Controller.Photos.Navigation");
			var tagger = photoItem.controller("EasySocial.Controller.Photos.Tagger");

			navigation && navigation[
				(tagger && !tagger.disabled) || (self.playlist.length < 2) ? "disable" : "enable"]();
		},

		"{photoItem} photoDelete": function(el, event, task, photoItem) {

			task.done(function() {

				// Nothing more
				if (self.playlist.length < 2) {

					EasySocial.ajax('site/views/photos/processDeleteLastPhoto')
						.done(function(dashboardUrl) {
							self.hide();

							if (opts.isSingleStreamView) {
								window.location = dashboardUrl;
								return;
							}

							// On normal views, we just reload the page
							window.location.reload();
						});
					return;
				}

				// If there are stil photos on the playlist, let it loop
				self.next();

				self.playlist = jQuery.grep(self.playlist, function(value) {
					return value != photoItem.id;
				});

			});
		},

		"{closeButton} click": function() {

			self.hide();
		}

	}});

	module.resolve(controller);

});
			EasySocial.module("site/photos/tagger", function($){

var module = this;

var KEYCODE = {
	BACKSPACE: 8,
	COMMA: 188,
	DELETE: 46,
	DOWN: 40,
	ENTER: 13,
	ESCAPE: 27,
	LEFT: 37,
	RIGHT: 39,
	SPACE: 32,
	TAB: 9,
	UP: 38
};

var Controller =
EasySocial.Controller("Photos.Tagger", {
	hostname: "tagger",

	defaultOptions: {
		width: 100,
		height: 100,

		drawTolerance: 30,
		clusterId: false,
		clusterType: false,
		clusterPrivate: false,

		"{viewport}"    : "[data-photo-tag-viewport]",
		"{tagItem}"     : "[data-photo-tag-item]",
		"{tagSelection}": "[data-photo-tag-item].new",
		"{tagButton}"   : "[data-photo-tag-button]",

		"{infoTagListItemGroup}": "[data-photoinfo-tag-list-item-group]",
		"{tagListItemGroup}": "[data-photo-tag-list-item-group]",
		"{tagListItem}"     : "[data-photo-tag-list-item]",

		"{tagRemoveButton}" : "[data-photo-tag-remove-button]"
	}
}, function(self, opts) { return {

	init: function() {
		// Get the tagging template first
		opts.tagItemTemplate = $('[data-tag-form-wrapper]').children().clone();
	},

	newTagItem: function() {

		// Use existing tag item if created
		var viewport = self.viewport();
		var newTagItem = self.tagItem(".new");

		// Else create one
		if (newTagItem.length < 1) {
			newTagItem = opts.tagItemTemplate.clone()
							.addClass("new")
							.appendTo(viewport);

			self.addSubscriber(
				newTagItem.addController("EasySocial.Controller.Photos.Tag", {
					clusterId: opts.clusterId,
					clusterType: opts.clusterType,
					clusterPrivate : opts.clusterPrivate
				})
			);
		}

		return newTagItem;
	},

	"{tagButton} click": function(tagButton) {
		self[tagButton.data("photoTagButton") || "toggle"]();
	},

	disabled: true,

	enable: function() {

		// This prevents image link from being clicked
		self.photo.imageLink()
			.on("click.tagger", function(event){
				event.preventDefault();
			});

		self.disabled = false;
		self.element.addClass("tagging");

		// // If there is scrollTo
		// if ($.scrollTo) {
		// 	$.scrollTo(self.photo.content(), 250, {offset: {top: -100}});
		// }

		self.trigger("tagEnter");
	},

	disable: function() {

		self.photo.imageLink()
			.off("click.tagger");

		// Remove tag selection
		self.tagSelection().remove();

		// Unfocus any tags which are in focus
		self.tagItem(".focus").removeClass("focus");

		self.disabled = true;
		self.element.removeClass("tagging");

		self.trigger("tagLeave");
	},

	toggle: function() {

		self[(self.disabled) ? "enable" : "disable"]();
	},

	area: {},

	calculateArea: function(collision, offset) {

		// Normalize arguments
		if (!collision) { collision = "clip" };
		if (!offset)    { offset = {x: 0, y: 0} };

		// Calculate image area
		var viewportEl   = self.viewport(),
			viewport        = viewportEl.offset();
			viewport.width  = viewportEl.width();
			viewport.height = viewportEl.height();
			viewport.right  = viewport.width  + viewport.left;
			viewport.bottom = viewport.height + viewport.top;

		// Calculate area relative to screen
		// top, left, width, height, right, bottom
		var area = self.area;
		area.top    = ((area.startY <= area.endY) ? area.startY : area.endY) + offset.y;
		area.left   = ((area.startX <= area.endX) ? area.startX : area.endX) + offset.x;
		area.width  = Math.abs(area.endX - area.startX);
		area.height = Math.abs(area.endY - area.startY);
		area.right  = area.width  + area.left;
		area.bottom = area.height + area.top;

		// Collision handling
		if (collision=="clip") {

			// Cap area within image boundaries
			if (area.top    <= viewport.top   ) {area.top    = viewport.top;   }
			if (area.bottom >= viewport.bottom) {area.bottom = viewport.bottom;}
			if (area.left   <= viewport.left  ) {area.left   = viewport.left;  }
			if (area.right  >= viewport.right ) {area.right  = viewport.right; }

			// Resize tag
			area.width  = area.right  - area.left;
			area.height = area.bottom - area.top;
		}

		// Reposition tag
		if (collision=="flip") {

			if (area.top <= viewport.top) {
				area.top = viewport.top;
			}

			if (area.left <= viewport.left) {
				area.left = viewport.left;
			}

			if (area.right >= viewport.right) {
				area.right = viewport.right;
				area.left  = area.right - area.width;
			}

			if (area.bottom >= viewport.bottom) {
				area.bottom = viewport.bottom;
				area.top    = area.bottom - area.height;
			}
		}

		// Pixel unit
		area.pixel = {
			top   : area.top  - viewport.top,
			left  : area.left - viewport.left,
			width : area.width,
			height: area.height
		};

		// Decimal unit
		area.decimal = {
			top   : area.pixel.top  / viewport.height,
			left  : area.pixel.left / viewport.width,
			width : area.width      / viewport.width,
			height: area.height     / viewport.height
		}

		// Percentage unit
		area.percentage = {
			top   : (area.decimal.top    * 100) + "%",
			left  : (area.decimal.left   * 100) + "%",
			width : (area.decimal.width  * 100) + "%",
			height: (area.decimal.height * 100) + "%"
		};

		// Decide whether tag should be on custom size
		var tolerance = self.options.drawTolerance;

		self.autodraw =
			(area.width  < tolerance &&
			 area.height < tolerance);

		return area;
	},

	setPivot: function(type, x, y) {

		var area = self.area;
			area[type + "X"] = x;
			area[type + "Y"] = y;
	},

	drawing: false,

	autodraw: false,

	drawTag: function() {

		var area = self.calculateArea();
		var options = self.options;

		if (self.autodraw) {

			area.endX = area.startX + options.width;
			area.endY = area.startY + options.height;

			self.calculateArea("flip", {
				x: options.width / -2,
				y: options.height / -2
			});
		}

		self.newTagItem()
			.css(area.percentage)
			.trigger("focusInput");
	},

	"{viewport} mousedown": function(viewport, event) {

		if (self.disabled) {
			return;
		}

		if (event.target!==viewport[0]) {
			return;
		}

		event.preventDefault();

		// Hide last created tag item which are curresntly in focus
		self.tagItem(".focus")
			.removeClass("focus");

		self.drawing = true;
		self.setPivot("start", event.pageX, event.pageY);


		$(document)
			.on("mousemove.tagger", function(event) {
				if (!self.drawing) {
					return;
				}

				self.setPivot("end", event.pageX, event.pageY);
				self.drawTag();
			})
			.on("mouseup.tagger", function(event) {

				self.setPivot("end", event.pageX, event.pageY);
				self.drawTag();
				$(document).off("mousemove.tagger mouseup.tagger");
			});
	},

	createTag: function(data) {

		var data = $.extend(
			{photo_id: self.photo.id}, data, self.area.decimal
		);

		var task = EasySocial.ajax("site/controllers/photos/createTag", data);

		self.trigger("tagCreate", [task, data, self]);

		return task;
	},

	removeTag: function(id) {

		var task = EasySocial.ajax("site/controllers/photos/removeTag", {id: id});

		self.trigger("tagRemove", [task, id, self]);

		return task;
	},

	addTag: function(data, tagItemHtml, tagListItemHtml, infoTagListItemHtml) {

		// Add tag to viewport and focus on tag
		var tagItem =
			$.buildHTML(tagItemHtml)
				.addClass("focus")
				.appendTo(self.viewport());

		// Add tag list item to tag list
		var tagListItem =
			$.buildHTML(tagListItemHtml)
				.appendTo(self.tagListItemGroup());

		//before we append the tag into info, we need to check if there is any tags or not. if not, we will apend a dash
		var taglen = self.infoTagListItemGroup().children().length;

		if (taglen == 0) {
			self.infoTagListItemGroup().append(' - ');
		}

		// Add tag list item to tag list at info section
		var infoTagListItem =
			$.buildHTML(infoTagListItemHtml)
				.appendTo(self.infoTagListItemGroup());

		self.trigger("tagAdd", [data, tagItem, tagListItem, self]);
	},

	"{self} avatarEnter": function() {

		// When entering avatar mode, hide all tags.
		self.tagItem().hide();

		// Disable tagging mode
		self.disable();
	},

	"{self} avatarLeave": function() {

		// When leaving avatar mode, display all tags.
		self.tagItem().show();
	},

	"{tagRemoveButton} click": function(button, event) {

		var tagId = button.data("photoTagId");

		self.removeTag(tagId);

		event.stopPropagation();
	},

	// Give priority to remove button,
	// make tag viewport appear above of
	// navigation buttons when they are hovered.
	"{tagRemoveButton} mouseover": function() {
		self.viewport().addClass("active");
	},

	"{tagRemoveButton} mouseout": function() {
		self.viewport().removeClass("active");
	}

}});

$.template('tags/menu.item', '<div class="es-photo-tag-menu-item" data-photo-tag-menu-item><div class="es-photo-tag-menu-name"><img src="[%= item.avatar %]" />[%= item.title %]</div></div>');

EasySocial.Controller("Photos.Tag", {
	defaultOptions: {
		clusterId: false,
		clusterType: false,
		clusterPrivate: false,

		"{form}": "[data-photo-tag-form]",
		"{title}": "[data-photo-tag-title]",
		"{removeButton}": "[data-photo-tag-remove-button]",
		"{textField}": "[data-photo-tag-input]",
		"{menu}": "[data-photo-tag-menu]",
		"{menuItem}": "[data-photo-tag-menu-item]"
	}
}, function(self, opts) { return {

	init: function() {
		self.data = opts.data;
	},

	"{self} focusInput": function() {
		self.textField().focus();
	},

	"{textField} keyup": $._.debounce(function(el, event) {

		var keyword = $.trim(self.textField().val());

		var unwantedKeys = [KEYCODE.UP, KEYCODE.DOWN, KEYCODE.ENTER, KEYCODE.ESCAPE];

		if ($.inArray(event.keyCode, unwantedKeys) != -1) {
			return;
		}

		// Build a list of users to exclude
		var users = self.tagger.photo.tags.getTaggedUsers();

		// Determine if we should get the result from cluster member only
		var namespace = 'site/controllers/friends/suggest';
		var options = {
				"search": keyword,
				"exclude": users,
				"includeme": 1,
				"privacy": "photos.tagme"
		}

		if (opts.clusterId && opts.clusterType && opts.clusterPrivate) {
			namespace = 'site/controllers/friends/suggestClusterMembers';
			options = $.extend(options, {
				"clusterId" : opts.clusterId,
				"clusterType": opts.clusterType
			});
		}

		EasySocial.ajax(namespace, options).done(self.render());

	}, 250),

	"{textField} keypress": function(textField, event) {

		var keyword = $.trim(self.textField().val());

		// Get active menu item
		var activeMenuItem = self.menuItem(".active");

		switch (event.keyCode) {

			// If up key is pressed
			case KEYCODE.UP:

				// Deactivate all menu item
				self.menuItem().removeClass("active");

				// If no menu items are activated,
				if (activeMenuItem.length < 1) {

					// activate the last one.
					self.menuItem(":last").addClass("active");

				// Else find the menu item before it,
				} else {

					// and activate it.
					activeMenuItem.prev(self.menuItem.selector)
						.addClass("active");
				}

				event.preventDefault();
				break;

			// If down key is pressed
			case KEYCODE.DOWN:

				// Deactivate all menu item
				self.menuItem().removeClass("active");

				// If no menu items are activated,
				if (activeMenuItem.length < 1) {

					// activate the first one.
					self.menuItem(":first").addClass("active");

				// Else find the menu item after it,
				} else {

					// and activate it.
					activeMenuItem.next(self.menuItem.selector)
						.addClass("active");
				}

				event.preventDefault();
				break;

			// If enter is pressed
			case KEYCODE.ENTER:

				// Use menu item
				if (activeMenuItem.length > 0) {

						activeMenuItem.trigger("click");

					// Create custom label
					} else {
					self.create({
						type: "label",
						label: keyword
					});
					};

				self.menu().hide();
				break;

			// If escape is pressed,
			case KEYCODE.ESCAPE:

				// hide menu.
				self.menu().hide();
				break;
		}
	},

	"{menuItem} mouseover": function(menuItem) {

		self.menuItem().removeClass("active");

		menuItem.addClass("active");
	},

	"{menuItem} mouseout": function(menuItem) {

		self.menuItem().removeClass("active");
	},

	render: $.Enqueue(function(items) {

		var menu = self.menu();

		if (!items || items.length < 1) {
			menu.hide();
			return;
		}

		menu.empty();

		$.each(items, function(i, item) {
			var itemTemplate = $('<div/>').html(item);
			var prop = {
				"title": itemTemplate.find('[data-suggest-title]').val(),
				"avatar": itemTemplate.find('[data-suggest-avatar]').attr('src'),
				"id": itemTemplate.find('[data-suggest-id]').val()
			};

			var tmpl = $.View('tags/menu.item', {"item": prop});

			$(tmpl)
				.data("item", prop)
				.appendTo(menu);


			menu.show();
		});
	}),

	create: function(data) {

		var tag = self.element;

		// Store tag data
		self.data = data;

		// Update tag title
		self.title()
			.html(data.label);

		// Do not submit empty label
		if ($.trim(data.label)==="") return;

		// Create tag
		self.tagger.createTag(data)
			.done(function(tag, tagItemHtml, tagListItemHtml, infoTagListItemHtml){

				// Add new tag
				self.tagger.addTag(tag, tagItemHtml, tagListItemHtml, infoTagListItemHtml);

				// Destroy myself
				self.element.remove();
			})
			.fail(function(message){
				tag.remove();
			});
	},

	remove: function() {

		var tag = self.element;
		var tagId = (self.data || {}).id;

		// If this is a new tag, just remove element;
		if (!tagId) return tag.remove();

		// Remove tag
		self.tagger.removeTag(tagId)
			.done(function(){
				tag.remove();
			});
	},

	"{menuItem} click": function(menuItem, event) {
		event.preventDefault();
		event.stopPropagation();

		var item = menuItem.data("item");

		self.create({
			"uid": item.id,
			"type": "person",
			"label": item.title,
		});
	},


	"{removeButton} click": function() {
		self.remove();
	}

}});

module.resolve(Controller);

});
			EasySocial.module("site/photos/tags", function($){

var module = this;

// Non essential dependencies
EasySocial.require()
.library("scrollTo")
.done();

EasySocial.Controller("Photos.Tags", {
	hostname: "tags",

	defaultOptions: {

		"{viewport}": "[data-photo-tag-viewport]",
		"{tagItem}": "[data-photo-tag-item]",
		"{tagButton}": "[data-photo-tag-button]",
		"{tagLink}": "[data-photo-tag-link]",
		"{infoTagListItemGroup}": "[data-photoinfo-tag-list-item-group]",
		"{infoTagListItem}": "[data-photo-tags-user]",
		"{tagListItemGroup}": "[data-photo-tag-list-item-group]",
		"{tagListItem}"     : "[data-photo-tag-list-item]",
		"{descTagItem}": "[data-photo-tags-user]"
	}
}, function(self, opts, base) { return {

	init: function() {
		self.setLayout();
	},

	imageLoaders: {},

	setLayout: function(callback) {

		var viewport = self.photo.viewport();
		var image = self.photo.image();
		var imageUrl = image.attr("src");
		var imageLoaders = self.imageLoaders;
		var imageLoader  = imageLoaders[imageUrl] || (self.imageLoaders[imageUrl] = $.Image.get(imageUrl));

		imageLoader
			.done(function(){

				var imageOffset = image.offset(),
					viewportOffset = viewport.offset();

				self.viewport()
					.css({
						top: imageOffset.top - viewportOffset.top,
						width: image.width(),
						height: image.height()
					});

				if (window.es.direction == 'rtl') {
					self.viewport().css({right: imageOffset.left - viewportOffset.left,});
				}
				else {
					self.viewport().css({left: imageOffset.left - viewportOffset.left,});	
				}


				callback && callback();
			});
	},

	"{window} resize": $.debounce(function(){

		self.setLayout();

	}, 1000),

	getTagItem: function(tagId) {
		return self.tagItem().filterBy("photoTagId", tagId);
	},

	getTagListItem: function(tagId) {
		return self.tagListItem().filterBy("photoTagId", tagId);
	},

	getInfoTagListItem: function(tagId) {
		return self.infoTagListItem().filterBy("photoTagId", tagId);
	},

	getTaggedUsers: function() {

		var users = [];

		self.tagListItem("[data-photo-tag-uid]")
			.each(function(){
				users.push($(this).data("photoTagUid"));
			});

		return $.uniq(users);
	},

	activateTag: function(tagId) {

		self.getTagItem(tagId)
			.addClass("active");

		self.getTagListItem(tagId)
			.addClass("active");
	},

	deactivateTag: function(tagId) {

		self.getTagItem(tagId)
			.removeClass("active");

		self.getTagListItem(tagId)
			.removeClass("active");
	},

	"{tagLink} click": function(el, event) {

		event.stopPropagation();
	},

	"{tagListItem} click": function(el) {

		var method = (el.hasClass('active') ? "deactivate" : "activate") + "Tag",
			tagId  = el.data("photoTagId");

		// Toggle tag
		self[method](tagId);
	},

	"{tagListItem} mouseover": function(el) {

		self.getTagItem(el.data("photoTagId"))
			.addClass("focus");
	},

	"{tagListItem} mouseout": function(el) {

		self.getTagItem(el.data("photoTagId"))
			.removeClass("focus");
	},

	"{descTagItem} mouseover": function(el) {
		self.getTagItem(el.data("photoTagId"))
			.addClass("focus");
	},

	"{descTagItem} mouseout": function(el) {
		self.getTagItem(el.data("photoTagId"))
			.removeClass("focus");
	},

	"{self} tagCreate": function(el, event, task) {

		task.done(function(){
		})
		.always(function(){
			setTimeout(function(){
				self.tagListItemGroup()
					.removeClass('empty-tags');
			}, 1);
		});
	},

	"{self} tagRemove": function(el, event, task, tagId) {

		task.done(function(){

			// Remove tag item
			self.getTagItem(tagId).remove();

			// Remove tag list item
			self.getTagListItem(tagId).remove();

			// Remove info's tag list item
			self.getInfoTagListItem(tagId).remove();

			// if length is zero, lets clear the html content.
			var taglen = self.infoTagListItemGroup().children().length;

			if (taglen == 0) {
				self.infoTagListItemGroup().empty();
			}

			if (taglen == 1) {
				var tag = self.infoTagListItemGroup().children().first();
				var tagcontent = tag.text();
				tagcontent = tagcontent.replace(',', '');

				tag.text(tagcontent);
			}

		})
		.always(function(){

			self.tagListItemGroup()
				.toggleClass("empty-tags", self.tagListItem().length < 1);
		});
	},

	"{self} photoRotate": function(el, event, task, angle, photo) {

		task.done(function(photoObj, tags){

			setTimeout(function(){

				self.setLayout(function(){

					var tagItems = self.tagItem();

					$.each(tags, function(i, tag){

						var tagItem = tagItems.filterBy("photoTagId", tag.id);

						tagItem
							.css({
								width : (tag.width  * 100) + "%",
								height: (tag.height * 100) + "%",
								top   : (tag.top    * 100) + "%",
								left  : (tag.left   * 100) + "%"
							});
					});

				});

			}, 1);

		});

	}
}});

module.resolve();
});
			EasySocial.module('site/polls/browser', function($){

var module = this;

EasySocial.Controller('Polls.Browser', {
	defaultOptions: {
		clusterType: false,
		clusterId: false,
		"{contents}": "[data-contents]",
		"{wrapper}": "[data-wrapper]",
		"{result}": "[data-result]"
	}
}, function(self,opts,base) { return {

	updatingContents: function() {
		self.wrapper().empty();
		self.contents().addClass('is-loading');
	},

	updateContents: function(html) {
		self.contents().removeClass('is-loading');
		self.wrapper().replaceWith(html);
	},

	getPolls: function(type, callback) {
		self.updatingContents();

		EasySocial.ajax('site/views/polls/filter', {
			"type": type,
			"clusterId": opts.clusterId,
			"clusterType": opts.clusterType,
			"userid": opts.userId
		}).done(function(html) {

			self.updateContents(html);

			if (typeof(callback) == 'function') {
				callback.apply(html);
			}

			// trigger sidebar toggle for responsive view.
			self.trigger('onEasySocialFilterClick');
		});
	}
}});

module.resolve();

});
			EasySocial.module('site/polls/filter', function($){

var module = this;

EasySocial.require()
.script('site/polls/browser')
.done(function($) {

EasySocial.Controller('Polls.Filter', {
	defaultOptions: {
		clusterType: false,
		clusterId: false,
		"{filter}": "[data-es-polls-filter] [data-filter-item]",
		"{pollsController}": "[data-es-polls][data-es-container]"
	}
}, function(self,opts,base) { return {

	init : function() {
		self.controller = self.getController();
	},

	getController: function() {
		var controller = self.pollsController().controller();
		return controller;
	},

	setActiveFilter: function(filter) {

		var activeClass = (window.es.mobile || window.es.tablet || window.es.ios) ? 'is-active' : 'active';

		self.filter().removeClass(activeClass);

		filter.addClass(activeClass)
 			  .addClass('is-loading');
	},

	"{filter} click": function(filter, event) {

		if (self.controller === undefined) {
			return;
		}

		event.preventDefault();
		event.stopPropagation();

		// Route the anchor links embedded
		var anchor = filter.find('> .o-tabs__link');
		anchor.route();

		var type = filter.data('filter-item');

		self.setActiveFilter(filter);

		self.controller.getPolls(type, function(contents) {
			filter.removeClass('is-loading');
		});
	}
}});

module.resolve();

});
});
			EasySocial.module('site/polls/polls', function($){

var module = this;
var lang = EasySocial.options.momentLang;

EasySocial.require()
.library('datetimepicker', 'moment/' + lang)
.done(function($) {

EasySocial.Controller('Polls.Vote', {
	defaultOptions: {
		"multiple": false,

		// Editing
		"{edit}": "[data-edit]",

		// Item
		"{item}": "[data-option]",
		"{checkbox}": "[data-checkbox]",
		"{progress}": "[data-progress]",
		"{counter}": "[data-counter]",
		"{viewVoters}": "[data-view-voters]",
		"{voters}": "[data-voters]"
	}
}, function(self,opts,base) { return {

	init : function() {
		opts.id = base.data("id");
	},

	updateProgressBar: function() {
		var total = 0;

		// Get the total number of votes
		self.item().each(function(index, item) {
			total += $(item).data('count');
		})

		// Now we need to update each other's progress bar
		self.item().each(function(index, item) {

			var item = $(item);
			var count = item.data('count');
			var id = item.data('id');
			var percentage = (count / total) * 100;

			// Update the progress bar
			item.find(self.progress.selector)
				.css('width', percentage + '%');

			// Update the label counter
			item.find(self.counter.selector)
				.text(count);

		});
	},

	"notify": function(action, itemId, isVoted) {

		if (isVoted || action == 'unvote') {
			return true;
		}

		EasySocial.ajax("site/controllers/polls/notify", {
			"id": opts.id,
			"itemId": itemId,
			"action": action
		});
	},

	updateVote: function(optionId, action, item, notify, checkbox) {

		// prevent the message to stack
		self.clearMessage();

		EasySocial.ajax("site/controllers/polls/vote", {
			"id": opts.id,
			"itemId": optionId,
			"act": action
		}).done(function(msg, items, isVoted, userid) {

			// Do not proceed for guest user and uncheck the checkbox that the guest had checked it
			if (opts.guest) {
				checkbox.prop('checked', false);
				return;
			}

			// Update the counter
			var count = item.data('count');

			voter = self.voters().find('[data-user-id="'+ userid +'"]')

			if (action == 'vote') {
				count += 1;

				// Update the voters
				EasySocial.ajax('site/views/polls/voters', {
					"id": opts.id,
					"optionId": optionId
				}).done(function(contents) {

					if ($.trim(contents) == "") {
						return;
					}

					item.find(self.voters.selector)
						.html(contents)
						.removeClass('t-hidden');
				});

			} else {
				count -= 1;

				// Remove the voter
				voter.remove();
			}

			item.data('count', count);

			// Update the progress bar
			self.updateProgressBar();

			var isVoted = isVoted;

			// Notify polls owner
			if (notify) {
				self.notify(action, optionId, isVoted);
			}
		}).fail(function(message){

			self.setMessage(message);

			// uncheck it since non-member is not allowed to vote
			checkbox.prop('checked', false);
		});
	},

	getItem: function(element) {
		var item = element.closest(self.item.selector);
		return item;
	},

	"{checkbox} change": function(checkbox, event){  	
		
		var item = self.getItem(checkbox);
		var id = item.data('id');

		var checked = checkbox.is(':checked') ? true : false;
		var action = checked ? 'vote' : 'unvote';

		// Update the vote
		self.updateVote(id, action, item, true, checkbox);

		// If it is checked, we need to uncheck the rest of the items if it is not a multiple choices
		if (checked && !opts.multiple) {

			self.item().each(function(i, item) {
				var item = $(item);
				var checkbox = item.find(self.checkbox.selector);

				if (item.data('id') != id && checkbox.is(':checked')) {
					checkbox.prop('checked', false);
					self.updateVote(item.data('id'), 'unvote', item, false, checkbox);
				}
			});
		}

		return;
	},

	"{viewVoters} click": function(button, event) {
		var item = self.getItem(button);
		var id = item.data('id');

		if (button.hasClass('disabled')) {
			return;
		}

		EasySocial.ajax('site/views/polls/voters', {
			"id": opts.id,
			"optionId": id
		}).done(function(contents) {

			if ($.trim(contents) == "") {
				return;
			}

			item.find(self.voters.selector)
				.html(contents)
				.removeClass('t-hidden');
		});
	}

}});

EasySocial.Controller('Polls.Form', {
	defaultOptions: {

		// Actions
		"{add}": "[data-polls-add]",
		"{delete}": "[data-polls-item-delete]",

		// Options
		"{options}": "[data-polls-options]",
		"{option}": "[data-polls-option]",
		"{input}": "[data-polls-option-input]",

		// Template
		"{template}": "[data-polls-option-template]",

		// Elements
		"{itemList}": "[data-polls-list]",

		// inputs
		"{title}": "[data-polls-title]",
		"{multiple}": "[data-polls-multiple]",
		"{expiration}": "[data-polls-expiration]",

		// Hidden input
		"{removeItems}": "[data-remove]"
	}
}, function(self, opts, base) { return {

		init : function() {
			// When initialized, grab the template
			opts.template = self.template().clone();
			opts.id = base.data('id');
			opts.uid = base.data('uid');
			opts.element = base.data('element');
			opts.clusterId = base.data('cluster');

			self.expiration().addController('EasySocial.Controller.Polls.Datetime', {
				'{parent}': self
			});
		},

		insertItem: function() {
			var tmpl = opts.template.clone();

			//remove data attribute.
			tmpl.removeAttr("data-polls-option-template")
				.attr("data-polls-option", "")
				.show();

			// Traverse inside the input textbox and change the name.
			tmpl.find("input[name='copied']")
				.attr("name", "pollItems[]")
				.attr("data-polls-option-input","");

			self.options().append(tmpl);

			return tmpl.find(self.input.selector);
		},

		"{input} keydown": function(input, event) {

			if (event.keyCode == 13) {
				event.stopPropagation();
				event.preventDefault();

				var newInput = self.insertItem();
				newInput.focus();
				return;
			}
		},

		"{delete} click": function(button, event) {
			var total = self.option().length;

			if (total <= 1) {
				return;
			}

			// Remove the item
			var item = button.closest(self.option.selector);
			var id = item.data('id');

			if (id) {
				var temp = self.removeItems().val();

				temp = temp == '' ? id : temp + ',' + id;

				self.removeItems().val(temp);
			}

			item.remove();
		},

		"{add} click": function(button, event) {
			var input = self.insertItem();
			input.focus();
		},

		toData: function(){

			var data = {
				"id": opts.id,
				"uid": opts.uid,
				"element": opts.element,
				"title": self.title().val(),
				"items": [],
				"multiple": self.multiple().is(':checked') ? 1: 0,
				"toberemove": self.removeItems().val(),
				"sourceid": opts.clusterId
			};

			// Get the date
			self.expiration().trigger('datetimeExport', [data]);

			if (self.input().length <= 0) {
				return data;
			}

			// Get each input
			self.input().each(function(i, item) {

				var item = $(item);
				var val = item.val();

				// Get the container
				var wrapper = item.closest(self.option.selector);
				var id = wrapper.data('id') ? wrapper.data('id') : 0;

				if ($.trim(val) != '') {
					data.items.push({
						"id": id,
						"text": val
					});
				}
			});

			return data;
		},

		validateForm: function() {
			var data = self.toData();

			if ($.isEmpty(data.title) || data.items.length == 0) {
				return false;
			}

			if (data.items.length <= 0) {
				return false;
			}

			return true;
		}

	}
});


EasySocial.Controller('Polls.Datetime', {
	defaultOptions: {
		'{picker}': '[data-picker]',
		'{toggle}': '[data-picker-toggle]',
		'{datetime}': '[data-datetime]'
	}
}, function(self) {
	return {
		init: function() {

			var minDate = new $.moment();
			var yearto = new Date().getFullYear() + 10;
			var dateFormat = 'DD-MM-YYYY';

			// Minus 1 on the date to allow today
			// Correction, we don't allow user to select today as expiry date. #2276
			minDate.date(minDate.date());

			self.picker()._datetimepicker({
				component: "es",
				useCurrent: false,
				format: dateFormat,
				minDate: minDate,
				maxDate: new $.moment({y: yearto}),
				icons: {
					time: 'fa fa-time',
					date: 'fa fa-calendar',
					up: 'fa fa-chevron-up',
					down: 'fa fa-chevron-down'
				},
				sideBySide: false,
				pickTime: false,
				minuteStepping: 1,
				language: lang
			});

			var curActiveDateTime = self.element.data('value');
			if (curActiveDateTime != '') {
				var dateObj = $.moment(curActiveDateTime);
				self.datetimepicker('setDate', dateObj);
			}
		},

		datetimepicker: function(name, value) {
			return self.picker().data('DateTimePicker')[name](value);
		},

		'{toggle} click': function() {
			self.picker().focus();
		},

		'{picker} dp.change': function(el, ev) {
			self.setDateValue(ev.date.toDate());

			//self.parent.element.trigger('event' + $.String.capitalize(self.options.type), [ev.date]);
		},

		'{picker} change': function(el, ev) {

			// if there is empty value for datetime then have to update the hidden value to empty as well
			if ($.isEmpty(el.val())) {
				self.datetime().val('');
			}
		},

		setDateValue: function(date) {
			// Convert the date object into sql format and set it into the input
			self.datetime().val(date.getFullYear() + '-' +
								('00' + (date.getMonth()+1)).slice(-2) + '-' +
								('00' + date.getDate()).slice(-2) + ' ' +
								('00' + date.getHours()).slice(-2) + ':' +
								('00' + date.getMinutes()).slice(-2) + ':' +
								('00' + date.getSeconds()).slice(-2));
		},

		'{self} datetimeExport': function(el, ev, data) {
			data['expirydate'] = self.datetime().val();
		}
	}
})

module.resolve();

});

});
			EasySocial.module('site/profile/edit', function($){

var module = this;

EasySocial.require()
.script('shared/fields/validate', 'shared/fields/base', 'shared/fields/conditional')
.done(function($){

EasySocial.Controller('Profile.Edit', {
	defaultOptions: {
		userid: null,
		saveLogic: 'default',

		"{stepContent}": "[data-profile-edit-fields-content]",
		"{stepItem}": "[data-profile-edit-fields-step]",

		// Forms.
		"{profileForm}": "[data-profile-fields-form]",
		"{actions}": "[data-profile-actions]",
		"{fieldItem}": "[data-field-item]",

		// Submit buttons
		"{save}": "[data-profile-fields-save]",
		"{saveClose}": "[data-profile-fields-save-close]",
		"{switchSave}": "[data-profile-switch-save]",

		// Delete Profile
		"{deleteProfile}": "[data-profile-edit-delete]",

		'{taskInput}': 'input[name="task"]'
	}
}, function(self) { return {

	init: function() {
		self.fieldItem().addController('EasySocial.Controller.Field.Base', {
			userid: self.options.userid,
			mode: 'edit'
		});

		self.fieldItem().addController('EasySocial.Controller.Field.Conditional');
	},

	errorFields: [],
	errorTabs: [],

	// Support field throwing error internally
	'{fieldItem} error': function(el, ev) {
		self.triggerStepError(el);
	},

	// Support for field resolving error internally
	'{fieldItem} clear': function(el, ev) {
		self.clearStepError(el);
	},

	// Support validate.js throwing error externally
	'{fieldItem} onError': function(el, ev) {
		self.triggerStepError(el);
	},

	triggerStepError: function(el) {
		var fieldid = el.data('id'),
			stepid = el.parents(self.stepContent.selector).data('id');

		if ($.inArray(fieldid, self.errorFields) < 0) {
			self.errorFields.push(fieldid);

			// push the step id into an array for those required field haven't fill in yet
			self.errorTabs.push(stepid);
		}

		self.stepItem().filterBy('for', stepid).trigger('error');
	},

	clearStepError: function(el) {
		var fieldid = el.data('id'),
			stepid = el.parents(self.stepContent.selector).data('id');

		self.errorFields = $.without(self.errorFields, fieldid);

		self.stepItem().filterBy('for', stepid).trigger('clear');
	},

	doSave: function(el, task) {

		// Run some error checks here.
		self.profileForm()
			.validate({fieldSelector : self.fieldItem.selector})
			.fail(function() {

				if (self.options.saveLogic == 'steps') {
					// turn off the laoding on current sidebar if clicked
					self.stepItem().removeClass('is-loading');
				}

				$(el).removeClass('btn-loading');
				$(el).disabled(false);

				EasySocial.dialog({
					content : EasySocial.ajax('site/views/profile/showFormError', {
						"stepIds": self.errorTabs,
						"fieldIds": self.errorFields
					})
				});

			}).done(function() {
				self.taskInput().val(task);
				self.profileForm().submit();
			});

		// Need to clear those step id from this error tab when click the submit button
		self.errorTabs = [];
	},

	"{stepItem} click" : function(stepItem, event) {
		var id = stepItem.data('for');
		var actions = stepItem.data('actions') == 1 ? true : false;

		if (self.options.saveLogic == 'steps' && actions) {
			self.profileForm().find('input[name="nextStepId"]').val(id);

			$(stepItem).addClass('is-loading');

			// trigger save button.
			self.save().click();

			return;
		}

		self.stepItem().removeClass('active');
		stepItem.addClass('active');

		// Remove active class on step content
		self.stepContent().removeClass('active');

		// Get the step content element
		var stepContent = self.stepContent().filterBy('id', id);

		// Add active class on the selected content
		stepContent.addClass('active');

		// Trigger onShow on the field item in the content
		stepContent.find(self.fieldItem.selector).trigger('show');

		// Determines if we should show or hide the actions
		self.actions().toggleClass('t-hidden', !actions);

		$('body').trigger('afterUpdatingContents');
	},

	"{stepItem} error": function(el) {
		el.addClass('error');
	},

	"{stepItem} clear": function(el) {
		if(self.errorFields.length < 1) {
			el.removeClass('error');
		}
	},

	"{save} click": function(el, event) {
		// Run some error checks here.
		event.preventDefault();

		$(el).addClass('btn-loading');
		$(el).disabled(true);

		// self.profileForm()
		// 	.validate({fieldSelector : self.fieldItem.selector})
		// 	.fail(function()
		// 	{
		// 		$(el).removeClass('btn-loading');
		// 		EasySocial.dialog(
		// 		{
		// 			content 	: EasySocial.ajax('site/views/profile/showFormError')
		// 		});
		// 	})
		// 	.done(function()
		// 	{
		// 		self.taskInput().val('save');
		// 		self.profileForm().submit();
		// 	});


		self.doSave(el, 'save');

		return false;
	},

	"{switchSave} click": function(el, event) {
		// Run some error checks here.
		event.preventDefault();

		$(el).addClass('btn-loading');

		self.profileForm()
			.validate({fieldSelector : self.fieldItem.selector})
			.fail(function() {
				$(el).removeClass('btn-loading');
				EasySocial.dialog({
					content : EasySocial.ajax('site/views/profile/showFormError', {
						"stepIds": self.errorTabs,
						"fieldIds": self.errorFields
					})
				});
			})
			.done(function() {
				self.taskInput().val('completeSwitch');
				self.profileForm().submit();
			});

		// Need to clear those step id from this error tab when click the submit button
		self.errorTabs = [];

		return false;
	},

	"{saveClose} click": function(el, event) {
		event.preventDefault();

		$(el).addClass('btn-loading');
		$(el).disabled(true);

		self.doSave(el, 'saveclose');

		return false;
	},

	"{deleteProfile} click" : function() {
		EasySocial.dialog({
			content: EasySocial.ajax('site/views/profile/confirmDelete')
		});
	}
}});

module.resolve();
});

});
			EasySocial.module('site/profile/privacy', function($) {

var module 	= this;

EasySocial.require()
.library('textboxlist')
.done(function($) {

EasySocial.Controller('Profile.Privacy', {
	defaultOptions: {

		"{filterItem}": "[data-filter-item]",
		"{activeFilter}": "[data-privacy-active]",
		"{contents}": "[data-contents]",
		"{privacyItem}" : "[data-privacy-item]",
		"{privacyForm}" : "[data-profile-privacy-form]",
		"{formActions}": "[data-form-actions]"
	}
}, function(self, opts, base) { return {

	init : function() {
		self.privacyItem().implement(EasySocial.Controller.Profile.Privacy.Item, {
			"{parent}"	: self
		});
	},

	updateContents: function(group) {
		self.contents().hide();
		self.contents().filter('[data-type=' + group + ']').show();

		if (group == 'blocked') {
			self.formActions().hide();
		} else {
			self.formActions().show();
		}
	},

	setActiveFilter: function(filter) {
		var group = filter.data('filter-item');

		self.activeFilter().val(group);

		self.filterItem().removeClass('active');
		filter.addClass('active');
	},

	"{filterItem} click" : function(filterItem, event) {
		var group = filterItem.data('filter-item');

		self.setActiveFilter(filterItem);
		self.updateContents(group);
	}
}});

EasySocial.Controller('Profile.Privacy.Item', {
	defaultOptions : {
		"{selection}": "[data-privacy-select]",
		"{hiddenCustom}" 	: "[data-hidden-custom]",
		"{customForm}" 		: "[data-privacy-custom-form]",

		"{customTextInput}" : "[data-textfield]",
		"{customItems}"		: "input[]",
		"{customHideBtn}"	: "[data-privacy-custom-hide-button]",
		"{customInputItem}"	: "[data-textboxlist-item]",
		"{customEditBtn}"   : "[data-privacy-custom-edit-button]"
	}
}, function(self, opts, base) { return {

	init : function() {
		self.customTextInput().textboxlist({
				component: 'es',
				unique: true,
				plugin: {
					autocomplete: {
						exclusive: true,
						minLength: 2,
						cache: false,
						query: function( keyword ) {

							var users = self.getTaggedUsers();

							var ajax = EasySocial.ajax("site/views/privacy/getfriends", {
								q: keyword,
								exclude: users
							});
							return ajax;
						}
					}
				}
			}
		);

		self.textboxlistLib = self.customTextInput().textboxlist("controller");
	},

	getTaggedUsers: function() {
		var users = [];
		var items = self.customInputItem();

		if( items.length > 0 )
		{
			$.each( items, function( idx, element ) {
				users.push( $( element ).data('id') );
			});
		}

		return users;
	},

	// event listener for adding new name
	"{customTextInput} addItem": function(el, event, data) {

		// lets get the exiting ids string
		var ids    = self.hiddenCustom().val();
		var values = '';

		if( ids == '')
		{
			values = data.id;
		}
		else
		{
			var idsArr = ids.split(',');
			idsArr.push( data.id );

			values = idsArr.join(',');
		}

		//now update the customhidden value.
		self.hiddenCustom().val( values );
	},

	// event listener for removing name
	"{customTextInput} removeItem": function(el, event, data ) {
		// lets get the exiting ids string
		var ids    = self.hiddenCustom().val();
		var values = '';
		var newIds = [];

		var idsArr = ids.split(',');

		for( var i = 0; i < idsArr.length; i++ )
		{
			if( idsArr[i] != data.id )
			{
				newIds.push( idsArr[i] );
			}
		}

		if( newIds.length <= 0 )
		{
			values = '';
		}
		else
		{
			values = newIds.join(',');
		}

		//now update the customhidden value.
		self.hiddenCustom().val( values );
	},

	"{customEditBtn} click" : function( el ) {
		self.customForm().toggle();
	},

	"{selection} change" : function( el ) {
		var selected = el.val();

		if( selected == 'custom' )
		{
			self.customForm().show();
			self.customEditBtn().show();
		}
		else
		{
			self.customForm().hide();
			self.customEditBtn().hide();
		}

		return;
	},

	"{customHideBtn} click" : function()
	{
		self.customForm().hide();

		self.customEditBtn().show();

		self.textboxlistLib.autocomplete.hide();

		return;
	}
}});


module.resolve();
});

});
			EasySocial.module('site/quickpost/quickpost', function($){

var module = this;

EasySocial.Controller('Quickpost', {
	defaultOptions: {
		'{storyButton}': '[data-es-quickpost-button]',
		'{storyPopup}': '[data-es-quickpost-popup]',
		'{storyClose}': '[data-es-quickpost-close]',
		'{storyForm}': '[data-es-quickpost-form]',
		'{storyWrapper}': '[data-es-quickpost-wrapper]',
		'{storyTitle}': '[data-es-quickpost-title]'
	}
}, function(self,opts,base) { return {

	init: function() {
		self.initKeyBinding();
	},

	initKeyBinding: function() {
		$(document).keyup(function(e) {
			if (e.keyCode == 27) {
				self.storyClose().trigger('click');
			}
		})
	},

	open: function() {
		$('body').addClass('is-es-quickpost-popup');

		self.storyPopup().removeClass('t-hidden');
		self.storyWrapper().addClass('t-hidden');
	},

	close: function() {
		// Clear up any content inside the form
		self.storyForm().html('');

		self.storyWrapper().addClass('t-hidden');
		self.storyPopup().addClass('t-hidden');

		$('body').removeClass('is-es-quickpost-popup');
	},

	loading: function() {
		self.storyPopup().toggleClass('is-loading');
	},

	renderStoryForm: function(type, title) {

		// Open form
		self.open();

		// Show loading while the ajax load
		self.loading();

		EasySocial.ajax('site/views/story/renderForm', {
			"type": type
		})
		.done(function(content) {
			self.storyForm().html(content);
			self.storyTitle().html(title);

			self.loading();
			self.storyWrapper().removeClass('t-hidden');
		})
	},

	"{storyClose} click": function(el, ev) {
		self.close();
	},

	"{storyButton} click": function(el, ev) {
		var type = el.data('type');
		var title = el.data('title');

		self.renderStoryForm(type, title);
	}
}});

module.resolve();

});
			EasySocial.module( 'site/registrations/registrations' , function($){

var module = this;

EasySocial.require()
.script('shared/fields/validate', 'shared/fields/base', 'shared/fields/conditional')
.done(function($){


EasySocial.Controller('Registrations.Form', {
	defaultOptions: {
		previousLink: null,

		"{item}": "[data-field-item]",
		"{submit}": "[data-registration-submit]",
		"{previous}": "[data-registration-previous]",
		"{itemInput}": "[data-input-trigger]"
	}
}, function(self, opts, base) { return {

	init: function() {

		// Implement controller on each field item
		self.item().addController(EasySocial.Controller.Field.Base, {
			"mode": "register"
		});

		// Implement conditional field controller
		self.item().addController(EasySocial.Controller.Field.Conditional);
	},

	"{previous} click" : function(button, event) {
		event.preventDefault();
		event.stopPropagation();

		window.location.href = opts.previousLink;

		return false;
	},

	"{submit} click" : function(button, event) {
		event.preventDefault();
		event.stopPropagation();

		// Apply loading class on button
		button.addClass('is-loading');

		// Apply validation
		self.element.validate({fieldSelector : self.item.selector})
			.done(function() {
				self.element.submit();
			})
			.fail(function() {

				// Remove loading class
				button.removeClass('is-loading');

				EasySocial.dialog({
					"content": EasySocial.ajax('site/views/registration/getErrorDialog')
				});
			});

		return false;
	}
}});

module.resolve();
});

});
			EasySocial.module( 'site/search/advanced' , function(){

var module	= this;

var lang = EasySocial.options.momentLang;

EasySocial.require()
.library('datetimepicker', 'moment/' + lang)
.script('site/search/map', 'site/search/osm')
.done(function($) {

EasySocial.Controller('Search.Advanced', {
	defaultOptions: {

		// Results
		"{result}": "[data-result]",

		// Criteria item
		"{criterias}": "[data-criterias]",
		"{item}": "[data-item]",
		"{criteriaTemplate}": "[data-item-template]",

		// Actions
		"{addCriteria}": "[data-insert-criteria]",
		"{editCriteria}": "[data-edit-criteria]",
		"{saveFilter}": "[data-save-filter]",
		"{deleteFilter}" : "[data-delete-filter]",

		// Wrapper
		"{contents}": "[data-contents]",
		"{searchForm}": "[data-search-form]",

		// Sidebar
		"{sidebar}": "[data-sidebar]",
		"{filterItem}": "[data-filter-item]",

		// Pagination
		"{pagination}": "[data-pagination]"
	}
}, function(self, opts, base) { return {

	init: function() {
		// Duplicate the template
		opts.tmpl = self.criteriaTemplate().clone();

		self.item()
			.addController(EasySocial.Controller.Search.Advanced.Criteria, {"{parent}" : self});

	},

	getSerializedForm: function() {
		var form = self.searchForm().find('> form');
		var data = form.serializeJSON();

		return data;
	},

	setActiveFilter: function(filter) {
		self.filterItem().removeClass('active');
		filter.addClass('active');
	},

	updatingContents: function() {
		self.contents().empty();
		self.element.addClass("is-loading");
	},

	updateContents: function(contents) {
		self.element.removeClass("is-loading");
		self.contents().html(contents);
	},

	loadMore: function() {

		var next_limit = self.pagination().data('last-limit');
		var data = self.getSerializedForm();

		if (next_limit == '-1') {
			self.pagination().hide();
			return;
		}

		self.pagination().addClass('is-loading');

		EasySocial.ajax('site/controllers/search/loadmore', {
			"data" : data,
			"nextlimit" : next_limit
		}).done(function(contents, next_limit) {

			// update next last-update
			self.pagination().data('last-limit', next_limit);

			// Append result to the list
			self.result().append(contents);

			if (next_limit == '-1') {
				self.pagination().hide();
			}

			self.pagination().removeClass('is-loading');
		});
	},

	"{pagination} click": function(){
		self.loadMore();
	},

	"{filterItem} click" : function(item, event) {
		event.stopPropagation();
		event.preventDefault();

		self.setActiveFilter(item);

		var id = item.data('id');

		// Update the url
		var anchor = item.find('> a');
		anchor.route();

		self.updatingContents();

		EasySocial.ajax('site/controllers/search/getFilterResults', {
			"id": id,
		}).done(function(contents) {

			var contents = $.buildHTML(contents);

			contents.find(self.item.selector)
				.addController(EasySocial.Controller.Search.Advanced.Criteria, {
					"{parent}" : self.root
				});

			self.updateContents(contents);
		});
	},

	"{deleteFilter} click": function(button, event) {
		var id = button.data('id');

		EasySocial.dialog({
			content: EasySocial.ajax( 'site/views/search/confirmDeleteFilter', {"id": id})
		});

	},

	"{saveFilter} click" : function() {
		var data = self.searchForm().find('form').serializeJSON();

		EasySocial.dialog({
			content: EasySocial.ajax('site/views/search/confirmSaveFilter', {
				"type": opts.type,
				"data": data
			})
		});
	},

	"{editCriteria} click": function(button, event) {
		button.addClass('t-hidden');

		self.searchForm().removeClass('t-hidden');
	},

	"{addCriteria} click" : function(button, event) {
		var template = opts.tmpl.clone();

		// Remove any unecessary attributes for the template
		template
			.removeClass('t-hidden')
			.removeAttr('data-item-template')
			.addController(
				EasySocial.Controller.Search.Advanced.Criteria, {
					"{parent}" : self
				});

		// Append the template to the list now.
		self.criterias().append(template);
	}
}});



EasySocial.Controller('Search.Advanced.Criteria', {
	defaultOptions: {

		// Actions
		"{remove}": "[data-remove-criteria]",

		// Wrappers
		"{operatorWrapper}": "[data-wrapper-operator]",
		"{conditionWrapper}": "[data-wrapper-condition]",
		"{keysWrapper}": "[data-wrapper-keys]",

		// Conditions
		"{field}": "[data-field]",
		"{operator}": "[data-operator]",
		"{condition}": "[data-condition]",
		"{key}": "[data-key]",

		"{itemConditionDiv}": "[data-itemConditionDiv]",

		"{dateStart}": "[data-start]",
		"{dateEnd}": "[data-end]",
		"{dataCondition}": "[data-condition]",

		'{frmDistance}': '[data-distance]',
		'{frmAddress}': '[data-address]',
		'{frmLatitude}': '[data-latitude]',
		'{frmLongitude}': '[data-longitude]',
		'{osmMap}': '[data-osm-map]',

		"{locationLabel}": "[data-location-label]",
		"{textField}": "[data-location-textfield]",

		// to support 3rd party custom fields that has range condition
		"{itemStart}": "[data-item-start]",
		"{itemEnd}": "[data-item-end]"
	}
}, function(self, opts, base) { return {

	init : function() {


		if (self.osmMap().length > 0) {
			self.element.addController(EasySocial.Controller.Search.Osm);
		} else {
			self.element.addController(EasySocial.Controller.Search.Map);
		}

		if (self.frmAddress().val() != undefined && self.frmAddress().val() != '') {
			self.textField().val(self.frmAddress().val());
			self.locationLabel().removeClass('t-hidden');
		}

		opts.searchType = $('input[name="type"]').val();
	},

	getFieldData: function(value) {

		var data = value.split('|');

		return {
			"key": data[0],
			"type": data[1]
		};
	},

	getConditions : function(type, operation, datakey) {

		// lets destroy all the datetimpicker here.
		self.conditionWrapper().find('.datepicker').each(function(idx, el) {

			var datepicker = $(el).data('DateTimePicker');
			if (datepicker != undefined) {
				datepicker.destroy();
			}
		});

		EasySocial.ajax("site/controllers/search/getConditions", {
			"type": opts.searchType,
			"element": type,
			"operator": operation,
			"datakey": datakey
		}).done(function(condition) {
			self.condition().replaceWith(condition);

			// start date and end date
			var start = self.conditionWrapper().find('[data-start]');
			var end = self.conditionWrapper().find('[data-end]');

			if (type != 'numeric' && datakey != 'age' && start.length > 0) {
				self.attachDateTimePicker(start);
				self.attachDateTimePicker(end);
			}

			// console.log(self.dataCondition());

			//single date
			var singleDate = self.dataCondition().find('[data-isdate]');
			if (type != 'numeric' && datakey != 'age' && singleDate.length > 0) {
				self.attachDateTimePicker(singleDate);
			}
		});
	},

	attachDateTimePicker : function(element) {

		// do not limit the min date in date field.
		var minDate = new $.moment({ y: 1900 });

		element._datetimepicker({
			component: "es",
			useCurrent: false,
			format: "DD-MM-YYYY",
			minDate: minDate,
			sideBySide: false,
			pickTime: false,
			minuteStepping: 1,
			language: lang,
			icons: {
				time: 'far fa-clock',
				date: 'fa fa-calendar',
				up: 'fa fa-chevron-up',
				down: 'fa fa-chevron-down'
			}
		});

	},

	"{frmDistance} change" : function() {

		var distance = self.frmDistance().val();
		var address = self.frmAddress().val();
		var lat = self.frmLatitude().val();
		var lng = self.frmLongitude().val();

		var computedVal = distance + '|' + lat + '|' + lng + '|' + address;
		self.dataCondition().val(computedVal);
	},

	"{itemStart} change" : function( el ) {
		start 	= self.itemStart().val();
		end 	= self.itemEnd().val();

		var data = start;

		if (end.length > 0) {
			data = data + '|' + end;
		}

		if (data == '|') {
			data = '';
		}

		// update value
		self.dataCondition().val( data );
	},

	"{itemEnd} change" : function() {
		start 	= self.itemStart().val();
		end 	= self.itemEnd().val();

		var data = start;
		data = data + '|' + end;

		if (data == '|') {
			data = '';
		}

		// update value
		self.dataCondition().val( data );
	},

	"{dateStart} change" : function( el ) {
		start 	= self.dateStart().val();
		end 	= self.dateEnd().val();


		var data = start;

		if( end.length > 0 )
		{
			data = data + '|' + end;
		}

		// update value
		self.dataCondition().val( data );
	},

	"{dateEnd} change" : function() {
		start 	= self.dateStart().val();
		end 	= self.dateEnd().val();

		var data = start;
		data = data + '|' + end;

		// update value
		self.dataCondition().val( data );
	},

	"{field} change" : function(field, event) {
		var value = field.val();

		if (!value || value == '') {
			return;
		}

		var data = self.getFieldData(value);

		EasySocial.ajax("site/controllers/search/getCriteria", {
			"type": opts.searchType,
			"key": data.key,
			"element": data.type
		}).done(function(hasKey, datakeys, operators, conditions) {

			if (data.type != 'address') {
				self.locationLabel().addClass('t-hidden');
			}

			// Insert the new operators
			self.operatorWrapper().html(operators);

			// Adding new operators keys
			self.keysWrapper()
				.html(datakeys)
				.addClass('t-hidden');

			if (hasKey) {
				self.keysWrapper()
					.removeClass('t-hidden');
			}

			// Insert conditions
			self.conditionWrapper().html(conditions);
		});
	},

	"{operator} change" : function(dropdown, event) {

		var field = self.field();
		var datakey = self.key();
		var operator = self.operator();
		var data = field.val().split('|');
		var key = data[0];
		var type = data[1];

		var operation = operator.val();
		var datakey = datakey.val();

		if (operation == 'blank' || operation == 'notblank') {
			self.condition().hide();

			return;
		}

		var dateTypes = ['datetime', 'birthday', 'startend', 'joomla_lastlogin', 'joomla_joindate'];

		if ($.inArray(type, dateTypes)) {

			if (operation == 'between' || self.dateStart().length > 0) {
				self.getConditions(type, operation, datakey);
			}
		}

		// if this is true, this mean the operator is not meant for range condition. lets get the correct condition again.
		if (self.condition().is('[data-range]')) {
			self.getConditions(type, operation, datakey);
		}

		if (self.condition().is(":hidden") || self.condition().hasClass('t-hidden')) {

			self.condition().show();
			self.condition().removeClass('t-hidden')
		}
	},

	"{key} change" : function(dropdown, event) {
		var field = self.field();
		var data = self.getFieldData(field.val());
		var datakey = dropdown.val();

		EasySocial.ajax("site/controllers/search/getOperators", {
			"type": opts.searchType,
			"key": data.key,
			"element": data.type,
			"datakey" : datakey
		}).done(function(operators, conditions) {

			self.operator().replaceWith(operators);
			self.condition().replaceWith(conditions);

			if (datakey == 'distance') {
				self.locationLabel().removeClass('t-hidden');
			} else {
				self.locationLabel().addClass('t-hidden');
			}

			if (datakey == 'age' || datakey == 'date' || datakey == 'numeric') {
				// start date and end date
				var start = self.conditionWrapper().find('[data-start]');
				var end = self.conditionWrapper().find('[data-end]');

				if (datakey != 'numeric' && datakey != 'age' && start.length > 0) {
					self.attachDateTimePicker(start);
					self.attachDateTimePicker(end);
				}

				//single date
				var singleDate = self.dataCondition().find('[data-condition]');

				if (datakey != 'numeric' && datakey != 'age' && singleDate.length > 0) {
					self.attachDateTimePicker(singleDate);
				}
			}

		});
	},

	"{remove} click" : function() {
		var criterias = self.parent.criterias();

		// If this is the last item on the list, don't allow
		if (criterias.children().length == 1) {
			return;
		}

		self.element.remove();
	}
}});

module.resolve();
});
});
			EasySocial.module( 'site/search/customfield' , function($){
	var module = this;

	EasySocial.require()
	.script('shared/fields/conditional')
	.done(function(){

		EasySocial.Controller('Search.Customfield', {
			defaultOptions: {
				"{fieldItem}": "[data-field-item]",
				"{dataCondition}" : "[data-condition]",
				"{dataCheckbox}" : "[data-checkbox-option]",
				"{dataDropdown}" : "[data-dropdown-field]",
				"{dataBoolean}" : "[data-boolean-field]"
			}
		},
		function(self) {
			return {

				init : function() {
					self.fieldItem().each(function() {
						var field = $(this);
						var fieldSearchItem = field.parents('[data-customfield-search-item]');
						field.addController(EasySocial.Controller.Field.Conditional);

						if (!field.hasClass('t-hidden')) {
							fieldSearchItem.removeClass('t-hidden');
						}

						field.on('onFieldShow', function() {
							fieldSearchItem.removeClass('t-hidden');
						});

						field.on('onFieldHide', function() {
							fieldSearchItem.addClass('t-hidden');

							// reset the field value so that it wont affect query
							self.resetField();
						});
					});
				},

				"{dataCheckbox} click" : function(el) {

					var fieldItem = el.parents(self.fieldItem().selector);

					// get all checked item
					var checkedItems = fieldItem.find(self.dataCheckbox().selector + ':checked');
					var values = [];

					checkedItems.each(function(){
						values.push($(this).val());
					});

					var conditions = values.join('|');

					self.dataCondition().val(conditions);
				},

				"{dataDropdown} change" : function(el) {
					self.dataCondition().val(el.val());
				},

				"{dataBoolean} change" : function(el) {
					self.dataCondition().val(el.val());
				},

				resetField: function() {
					self.dataCondition().val('');
					self.dataDropdown().prop('selectedIndex',0);
					self.dataCheckbox().prop('checked', false);
				}
			}
		});

		module.resolve();

	});

});
			EasySocial.module( 'site/search/dating' , function($){
	var module = this;

	EasySocial.require()
	.script('site/search/map', 'site/search/osm')
	.done( function(){

		EasySocial.Controller(
		'Search.Dating',
		{
			defaultOptions:
			{
				"{itemCriteria}" : "[data-itemCriteria]",
				"{itemDataKey}" : "[data-itemDataKey]",
				"{itemOperator}" : "[data-itemOperator]",
				"{itemCondition}" : "[data-itemCondition]",

				"{dateStart}" : "[data-start]",
				"{dateEnd}" : "[data-end]",
				"{dataCondition}" : "[data-condition]",

				"{dataGender}" : "[data-gender-radio]",
				"{dataRelationship}" : "[data-relationship-radio]",

				'{frmDistance}' : '[data-distance]',
				'{frmAddress}' : '[data-address]',
				'{frmLatitude}' : '[data-latitude]',
				'{frmLongitude}' : '[data-longitude]',

				"{locationLabel}" : "[data-location-label]",
				"{textField}" : "[data-location-textfield]"
			}
		},
		function( self ){
			return {

				init : function()
				{
					self.base = self.element.parents('[data-mod-dating-search]');
					var locationProvider = self.base.data('location-provider');

					if (locationProvider == 'osm') {
						self.element.addController(EasySocial.Controller.Search.Osm);
					} else {
						self.element.addController(EasySocial.Controller.Search.Map);
					}

					if (self.frmAddress().val() != '') {
						self.textField().val(self.frmAddress().val());
					}
				},

				"{frmDistance} change" : function() {
					var distance = self.frmDistance().val();
					var address = self.frmAddress().val();
					var lat = self.frmLatitude().val();
					var lng = self.frmLongitude().val();

					var computedVal = distance + '|' + lat + '|' + lng + '|' + address;
					self.dataCondition().val(computedVal);
				},

				"{dataGender} click" : function(el) {
					self.dataCondition().val( el.val() );
				},

				"{dataRelationship} click" : function(el) {
					self.dataCondition().val( el.val() );
				},

				"{dateStart} change" : function() {
					start 	= self.dateStart().val();
					end 	= self.dateEnd().val();

					var data = start;

					// if (end.length > 0) {
						data = data + '|' + end;
					// }

					// update value
					self.dataCondition().val( data );
				},

				"{dateEnd} change" : function() {
					start 	= self.dateStart().val();
					end 	= self.dateEnd().val();

					var data = end;

					// if( start.length > 0 )
					// {
						data = start + '|' + data;
					// }

					// update value
					self.dataCondition().val( data );
				}


			} //return
		});

		module.resolve();

	});

});
			EasySocial.module('site/search/default' , function($){

var module	= this;

EasySocial.Controller('Search.List', {
	defaultOptions: {
		"{pagination}": "[data-search-pagination]",
		"{moreButton}": "[data-more]"
	}
}, function(self, opts, base) { return {

	init : function() {

		self.on("scroll.search", window, $._.debounce(function(){

			if (self.loading) {
				return;
			}

			if (self.pagination().visible()) {

				self.loadMore();
			}

		}, 250));
	},

	"{moreButton} click": function(button, event) {
		self.loadMore();
	},

	loadMore: function() {

		var query = $("[data-search-query]").val();
		var type = $("[data-sidebar-menu].active").data( 'type' );
		var next_limit = self.pagination().data('limitstart');

		var filters = [];

		$("[data-search-filtertypes]:checked").each( function(idx, ele) {
			filters.push($(ele).val());
		});

		if (next_limit == '-1') {
			self.pagination().empty();
			return;
		}

		self.loading = true;

		self.moreButton().addClass('is-loading');

		EasySocial.ajax('site/controllers/search/getItems', {
			"next_limit": next_limit,
			"type": type,
			"q": query,
			"loadmore" : '1',
			'filtertypes' : filters
		}).done(function(contents, limitstart) {

			// update next last-update and last-type
			self.pagination().data('limitstart', limitstart);

			// append stream into list.
			self.pagination().before(contents);

			if (limitstart == '-1') {
				self.pagination().empty();
			}

		}).always(function(){

			self.loading = false;
		});
	}
}});

module.resolve();
});
			EasySocial.module( 'site/search/map' , function($){

var module	= this;

// Create search template first
$.template('easysocial/maps.suggestion', '<div class="es-location-suggestion" data-location-suggestion><span class="formatted_address">[%= location.formatted_address %]</span></div>');

EasySocial.require()
.library('gmaps')
.done(function() {

// Constants
var KEYCODE = {
	BACKSPACE: 8,
	COMMA: 188,
	DELETE: 46,
	DOWN: 40,
	ENTER: 13,
	ESCAPE: 27,
	LEFT: 37,
	RIGHT: 39,
	SPACE: 32,
	TAB: 9,
	UP: 38
};

EasySocial.Controller('Search.Map', {
	defaultOptions: {
		"{icon}" : "[data-loaction-icon]",
		"{locationLabel}" : "[data-location-label]",
		'{textField}'       : '[data-location-textfield]',

		"{detectButton}" : "[data-location-detect]",
		"{suggestions}"  : "[data-location-suggestions]",
		"{suggestion}"      : "[data-location-suggestion]",
		"{autocomplete}" : "[data-location-autocomplete]",

		// form elements
		"{dataCondition}" : "[data-condition]",
		"{frmDistance}" : "[data-distance]",
		"{frmAddress}" : "[data-address]",
		"{frmLatitude}" : "[data-latitude]",
		"{frmLongitude}" : "[data-longitude]",

		// error messages
		"{errorPermission}": "[data-error-map-permission]",
		"{errorTimeout}": "[data-error-map-timeout]",
		"{errorUnavailable}": "[data-error-map-unavailable]",

		view: {
			suggestion: 'maps.suggestion'
		}
	}
}, function(self, opts, base){ return {

	init : function() {

	},

	locations: {},

	lastQueryAddress: null,

	results: [],

	result: null,

	"{detectButton} click": function() {

		self.detectButton().addClass('is-loading');

		clearTimeout(self.detectTimer);


		$.GMaps.geolocate({
			success: function(position) {
				$.GMaps.geocode({
					lat: position.coords.latitude,
					lng: position.coords.longitude,
					callback: function(locations, status) {
						if (status=="OK") {
							self.suggest(locations);
						}
					}
				});
			},
			error: function(error) {
				var message = "";

				switch (error.code) {

					case 1:
						message = self.errorPermission().text();
						break;

					case 2:
						message = self.errorTimeout().text();
						break;

					case 3:
					default:
						message = self.errorUnavailable().text();
						break;
				}

				EasySocial.dialog({
					content: message
				});
			},
			always: function() {
				clearTimeout(self.detectTimer);
				self.detectButton().removeClass('is-loading');
			}
		});
	},

	lookup: $.debounce(function(address) {

		$.GMaps.geocode({
			address: address,
			callback: function(locations, status) {

				if (status=="OK") {

					// Store a copy of the results
					self.locations[address] = locations;

					// Suggestion locations
					self.suggest(locations);

					self.lastQueryAddress = address;
				}
			}
		});

	}, 250),


	"{textField} keypress": function(textField, event) {

		switch (event.keyCode)
		{
			case KEYCODE.UP:

				var prevSuggestion = $(
					self.suggestion(".active").prev(self.suggestion.selector)[0] ||
					self.suggestion(":last")[0]
				);

				// Remove all active class
				self.suggestion().removeClass("active");

				prevSuggestion
					.addClass("active")
					.trigger("activate");

				self.suggestions()
					.scrollTo(prevSuggestion, {
						offset: prevSuggestion.height() * -1
					});

				event.preventDefault();

				break;

			case KEYCODE.DOWN:

				var nextSuggestion = $(
					self.suggestion(".active").next(self.suggestion.selector)[0] ||
					self.suggestion(":first")[0]
				);

				// Remove all active class
				self.suggestion().removeClass("active");

				nextSuggestion
					.addClass("active")
					.trigger("activate");

				self.suggestions()
					.scrollTo(nextSuggestion, {
						offset: nextSuggestion.height() * -1
					});

				event.preventDefault();

				break;

			case KEYCODE.ENTER:

				var activeSuggestion = self.suggestion(".active"),
					location = activeSuggestion.data("location");
					self.set(location);

				self.hideSuggestions();

				event.preventDefault();
				break;

			case KEYCODE.ESCAPE:
				self.hideSuggestions();
				event.preventDefault();
				break;
		}

	},

	"{textField} keyup": function(textField, event) {

		switch (event.keyCode) {

			case KEYCODE.UP:
			case KEYCODE.DOWN:
			case KEYCODE.LEFT:
			case KEYCODE.RIGHT:
			case KEYCODE.ENTER:
			case KEYCODE.ESCAPE:
				// Don't repopulate if these keys were pressed.
				break;

			default:
				var address = $.trim(textField.val());

				if (address==="") {
					// self.base().removeClass("has-location");
					self.hideSuggestions();
				}

				// if (address==self.lastQueryAddress) return;

				var locations = self.locations[address];

				// If this location has been searched before
				if (locations) {

					// And set our last queried address to this address
					// so that it won't repopulate the suggestion again.
					self.lastQueryAddress = address;

					// Just use cached results
					self.suggest(locations);

				// Else ask google to find it out for us
				} else {

					self.lookup(address);
				}
				break;
		}
	},

	set: function(location) {

		var lat = location.geometry.location.lat(),
			lng = location.geometry.location.lng(),
			address = location.formatted_address,
			distance = self.frmDistance().val();

		self.frmAddress().val(address);
		self.frmLatitude().val(lat);
		self.frmLongitude().val(lng);

		var computedVal = distance + '|' + lat + '|' + lng + '|' + address;
		self.dataCondition().val(computedVal);

		self.textField().val(address);
		// self.locationLabel().removeClass('hide');

		self.hideSuggestions();

	},

	"{suggestion} click": function(suggestion, event) {
		var location = suggestion.data("location");
		self.set(location);
	},

	suggest: function(locations) {

		self.hideSuggestions();

		var suggestions = self.suggestions();

		if (locations.length < 0) return;

		self.results = locations;

		$.each(locations, function(i, location){
			// Create suggestion and append to list
			self.view.suggestion({
					location: location
				})
				.data("location", location)
				.appendTo(suggestions);
		});

		self.showSuggestions();
	},

	showSuggestions: function() {

		self.focusSuggestion = true;

		setTimeout(function(){

			self.autocomplete().addClass("active");

			var doc = $(document),
				hideOnClick = "click.es.advancedsearch.location";

			doc
				.off(hideOnClick)
				.on(hideOnClick, function(event){

					// Collect list of bubbled elements
					var targets = $(event.target).parents().andSelf();

					if (targets.filter(self.element).length > 0) return;

					doc.off(hideOnClick);

					self.hideSuggestions();
				});

		}, 500);
	},

	hideSuggestions: function() {

		// Clear location suggestions
		self.suggestions().empty();

		self.focusSuggestion = false;

		self.autocomplete().removeClass("active");

		$(document).off("click.es.advancedsearch.location");

	}
}});

module.resolve();

});

});
			EasySocial.module('site/search/osm', function($){

var module = this;

// Create search template first
$.template('easysocial/maps.suggestion', '<div class="es-location-suggestion" data-location-suggestion><span class="formatted_address">[%= location.formatted_address %]</span></div>');

EasySocial.require()
.library('leaflet', 'leaflet-providers')
.done(function() {

// Constants
var KEYCODE = {
	BACKSPACE: 8,
	COMMA: 188,
	DELETE: 46,
	DOWN: 40,
	ENTER: 13,
	ESCAPE: 27,
	LEFT: 37,
	RIGHT: 39,
	SPACE: 32,
	TAB: 9,
	UP: 38
};

EasySocial.Controller('Search.Osm', {
	defaultOptions: {
		"{icon}" : "[data-loaction-icon]",
		"{locationLabel}" : "[data-location-label]",
		'{textField}'       : '[data-location-textfield]',

		"{detectButton}" : "[data-location-detect]",
		"{suggestions}"  : "[data-location-suggestions]",
		"{suggestion}"      : "[data-location-suggestion]",
		"{autocomplete}" : "[data-location-autocomplete]",

		// form elements
		"{dataCondition}" : "[data-condition]",
		"{frmDistance}" : "[data-distance]",
		"{frmAddress}" : "[data-address]",
		"{frmLatitude}" : "[data-latitude]",
		"{frmLongitude}" : "[data-longitude]",

		// error messages
		"{errorPermission}": "[data-error-map-permission]",
		"{errorTimeout}": "[data-error-map-timeout]",
		"{errorUnavailable}": "[data-error-map-unavailable]",

		view: {
			suggestion: 'maps.suggestion'
		}
	}
}, function(self, opts, base){ return {

	init : function() {
	},

	locations: {},

	lastQueryAddress: null,

	results: [],

	result: null,

	initMap: function() {
		self.osm = L.map('map', {
			zoom: 12
		});
	},

	"{detectButton} click": function() {
		self.detectButton().addClass('is-loading');

		if (self.osm == undefined) {
			self.initMap();
		}

		clearTimeout(self.detectTimer);

		self.osm.locate();
		self.osm.on('locationfound', function(e) {
			lat = e.latitude,
			lng = e.longitude;

			EasySocial.ajax('site/controllers/location/getLocations', {
				latitude: lat,
				longitude: lng
			})
			.done(function(results) {
				self.set(results[0]);

				clearTimeout(self.detectTimer);
				self.detectButton().removeClass('is-loading');
			});
		});

		self.osm.on('locationerror', function(error) {
			var message = "";

			switch (error.code) {

				case 1:
					message = self.errorPermission().text();
					break;

				case 2:
					message = self.errorTimeout().text();
					break;

				case 3:
				default:
					message = self.errorUnavailable().text();
					break;
			}

			EasySocial.dialog({
				content: message
			});
		});


	},

	lookup: $.debounce(function(address) {
		self.detectButton().addClass('is-loading');

		EasySocial.ajax('site/controllers/location/getLocations', {
			query: address
		})
		.done(function(locations) {
			// Store a copy of the results
			self.locations[address] = locations;

			// Suggestion locations
			self.suggest(locations);

			self.lastQueryAddress = address;

			self.detectButton().removeClass('is-loading');
		});
	}, 250),


	"{textField} keypress": function(textField, event) {

		switch (event.keyCode)
		{
			case KEYCODE.UP:

				var prevSuggestion = $(
					self.suggestion(".active").prev(self.suggestion.selector)[0] ||
					self.suggestion(":last")[0]
				);

				// Remove all active class
				self.suggestion().removeClass("active");

				prevSuggestion
					.addClass("active")
					.trigger("activate");

				self.suggestions()
					.scrollTo(prevSuggestion, {
						offset: prevSuggestion.height() * -1
					});

				event.preventDefault();

				break;

			case KEYCODE.DOWN:

				var nextSuggestion = $(
					self.suggestion(".active").next(self.suggestion.selector)[0] ||
					self.suggestion(":first")[0]
				);

				// Remove all active class
				self.suggestion().removeClass("active");

				nextSuggestion
					.addClass("active")
					.trigger("activate");

				self.suggestions()
					.scrollTo(nextSuggestion, {
						offset: nextSuggestion.height() * -1
					});

				event.preventDefault();

				break;

			case KEYCODE.ENTER:

				var activeSuggestion = self.suggestion(".active"),
					location = activeSuggestion.data("location");
					self.set(location);

				self.hideSuggestions();

				event.preventDefault();
				break;

			case KEYCODE.ESCAPE:
				self.hideSuggestions();
				event.preventDefault();
				break;
		}

	},

	"{textField} keyup": function(textField, event) {

		switch (event.keyCode) {

			case KEYCODE.UP:
			case KEYCODE.DOWN:
			case KEYCODE.LEFT:
			case KEYCODE.RIGHT:
			case KEYCODE.ENTER:
			case KEYCODE.ESCAPE:
				// Don't repopulate if these keys were pressed.
				break;

			default:
				var address = $.trim(textField.val());

				if (address==="") {
					// self.base().removeClass("has-location");
					self.hideSuggestions();
				}

				// if (address==self.lastQueryAddress) return;

				var locations = self.locations[address];

				// If this location has been searched before
				if (locations) {

					// And set our last queried address to this address
					// so that it won't repopulate the suggestion again.
					self.lastQueryAddress = address;

					// Just use cached results
					self.suggest(locations);

				// Else ask google to find it out for us
				} else {

					self.lookup(address);
				}
				break;
		}
	},

	set: function(location) {

		var lat = location.latitude,
			lng = location.longitude,
			address = location.formatted_address,
			distance = self.frmDistance().val();

		self.frmAddress().val(address);
		self.frmLatitude().val(lat);
		self.frmLongitude().val(lng);

		var computedVal = distance + '|' + lat + '|' + lng + '|' + address;
		self.dataCondition().val(computedVal);

		self.textField().val(address);
		// self.locationLabel().removeClass('hide');

		self.hideSuggestions();

	},

	"{suggestion} click": function(suggestion, event) {
		var location = suggestion.data("location");
		self.set(location);
	},

	suggest: function(locations) {

		self.hideSuggestions();

		var suggestions = self.suggestions();

		if (locations.length < 0) return;

		self.results = locations;

		$.each(locations, function(i, location){
			// Create suggestion and append to list
			self.view.suggestion({
					location: location
				})
				.data("location", location)
				.appendTo(suggestions);
		});

		self.showSuggestions();
	},

	showSuggestions: function() {

		self.focusSuggestion = true;

		setTimeout(function(){

			self.autocomplete().addClass("active");

			var doc = $(document),
				hideOnClick = "click.es.advancedsearch.location";

			doc
				.off(hideOnClick)
				.on(hideOnClick, function(event){

					// Collect list of bubbled elements
					var targets = $(event.target).parents().andSelf();

					if (targets.filter(self.element).length > 0) return;

					doc.off(hideOnClick);

					self.hideSuggestions();
				});

		}, 500);
	},

	hideSuggestions: function() {

		// Clear location suggestions
		self.suggestions().empty();

		self.focusSuggestion = false;

		self.autocomplete().removeClass("active");

		$(document).off("click.es.advancedsearch.location");

	}
}});

module.resolve();

});

});
			EasySocial.module("site/search/toolbar", function($){

var module	= this;

EasySocial.Controller("Search.Toolbar", {
	defaultOptions: {
		popboxWrapper: "",
		showadvancedlink: true,
		enforceMinimumLength: false,
		minimumLength: 2,
		"{textfield}": "[data-nav-search-input]",
		"{filters}": "[data-filters]",

		"{suggestItem}": "[data-search-suggestion]"
	}
}, function(self, opts, base) { return {

	init : function() {

		self.options.showadvancedlink = self.element.data('showadvancedlink') == 0 ? 0 : 1 ;

		self.filters().addController(EasySocial.Controller.Search.Toolbar.Filter, {
			"{parent}": self
		});
	},

	cache: {},

	showPopBox: false,

	rePopBox: null,

	showSuggest: true,

	search: $.debounce(function(keyword) {

		if (self.loading) {
			return;
		}

		var length = keyword.length;

		// if (!keyword || !(keyword = $.trim(keyword)) || ((length < opts.minimumLength && opts.enforceMinimumLength) || length < 3) ) {
		if (!keyword || $.trim(keyword) == '' || ((length < opts.minimumLength && opts.enforceMinimumLength) || length < 3) ) {
			return;
		}

		var length = keyword.length;

		var textfield = self.textfield();

		var cacheIndex = keyword;

		// Cheap fix
		textfield.popbox("widget").hide();
		textfield.popbox("widget").destroy();

		var filters = [];
		$("[data-search-filtertypes]:checked").each( function(idx, ele) {

			filterValue = $(ele).val();
			filters.push(filterValue);
		});

		var task =
			// Take from cache if keyword has been searched before
			// self.cache[cacheIndex] ||
			// Else make and ajax call
			EasySocial.ajax("site/controllers/search/getItems", {
				"q": keyword,
				"mini": "1",
				"showadvancedlink": self.options.showadvancedlink,
				"filtertypes" : filters,
				"showSuggest": self.showSuggest ? 1 : 0
			});

		task
			// .done(function(contents) {

			// 	var items = $(contents).find('[data-search-suggestion]');

			// 	items.each(function() {
			// 		var item = $(this);

			// 		item.attr('hello', 'testing');

			// 		console.log(item[0]);
			// 	});
			// 	// x.on('click', function() {
			// 	// 	alert('hello');
			// 	// });
			// 	// var x = $('.es-search-mini-result-wrap [data-search-suggestion]');

			// 	// console.log($('body'));

			// 	// x.on('click', function() {
			// 	// 	console.log('clicked');
			// 	// });
			// })
			.fail(function(message) {
				console.log(message);
			}).always(function(){
				self.loading = false;
			});

		self.hide();

		base.popbox({
			content: task,
			id: "es",
			component: opts.popboxWrapper,
			type: "nav-search",
			toggle: "click",
			cache: false,
			offset: 0
		});

		var popbox = base.popbox("widget");

		popbox.show();
		popbox.keyword = keyword;

	}, 250),


	reSearch: function(keyword) {

		if (self.loading) {
			return;
		}

		if (!keyword || $.trim(keyword) == '' || keyword.length <= 2) {
			return;
		}

		var textfield = self.textfield();

		var cacheIndex = keyword;

		// Cheap fix
		self.textfield().popbox("widget").hide();
		self.textfield().popbox("widget").destroy();

		var filters = [];
		$("[data-search-filtertypes]:checked").each( function(idx, ele) {

			filterValue = $(ele).val();
			filters.push(filterValue);

			// valueInteger = parseInt(filterValue);
			// cacheIndex += valueInteger.toString();
		});

		var task =
			// Else make and ajax call
			EasySocial.ajax("site/controllers/search/getItems", {
				"q": keyword,
				"mini": "1",
				"showadvancedlink": self.options.showadvancedlink,
				"filtertypes" : filters,
				"showSuggest": self.showSuggest ? 1 : 0
			})
			.done(function(){
			});

		task
			.fail(function(message) {
				console.log(message);
			})
			.always(function(){
				self.loading = false;
				self.showPopBox = true;
			});

		self.hide();

		base.popbox({
			content: task,
			id: "es",
			component: "",
			type: "search",
			toggle: "click",
			cache: false,
			offset: 0
		});

	},

	hide: function() {
		var popbox = base.popbox("widget");

		if (popbox) {
			popbox.hide();
		}
	},

	show: function() {
		var popbox = base.popbox("widget");
		popbox.show();
	},

	"{textfield} keydown": function() {
		self.hide();
	},

	"{textfield} keyup": function(textfield, event) {

		// 27 == escape
		if (event.which===27) {
			return;
		}

		var keyword = textfield.val();

		self.showSuggest = true;
		self.search(keyword);
	},

	"{self} popboxLoading": function(el, event, popbox) {

		popbox.loader.width(base.width());

		popbox.loader
			.position(popbox.position);

		base.addClass("is-active");
	},

	"{self} popboxActivate": function(el, event, popbox) {
		popbox.tooltip.width(base.width());

		popbox.tooltip
			.position(popbox.position);

		base.addClass("is-active");


		var items = popbox.tooltip.find('[data-search-suggestion]');
		// do the binding here
		if (items.length > 0) {
			items.on('click', function() {

				var keyword = $(this).data('search-suggestion-value');

				var textfield = self.textfield();

				self.hide();

				textfield.popbox("widget").hide();
				textfield.popbox("widget").destroy();

				// console.log(textfield);
				textfield.val(keyword);

				self.showSuggest = false;

				self.search(keyword);
			});
		}
	},

	"{self} popboxDeactivate": function(el, event, popbox) {

		base.removeClass("is-active");
	}

}});



EasySocial.Controller("Search.Toolbar.Filter", {
	defaultOptions: {
		"{wrapper}": "[data-filters-wrapper]",

		"{filterButton}": "[data-filter-button]",

		"{filterDropdown}" : ".dropdown-menu",
		"{filterDropdownInput}" : ".dropdown-menu input",
		"{filterDropdownLabel}" : ".dropdown-menu label",

		"{filterBox}" : "[data-search-filtertypes]",
		"{filter}": "[data-filter]"

	}
}, function(self, opts, base) { return {
	init : function() {
	},

	"{self} blur": function(ele, event) {

		if (self.parent.showPopBox) {
			self.parent.show();
		}
	},

	"{wrapper} click": function(wrapper, event) {
		event.preventDefault();
		event.stopPropagation();

		// Prevent closing of search dropdown
	},

	"{filter} click": function(link, event) {
		event.preventDefault();
		event.stopPropagation();

		var checked = link.data('filter') == 'select' ? true : false;

		self.filterBox().prop('checked', checked);
	},

	"{filterButton} click": function(ele, event) {

		// When filter button is clicked, we should hide the popbox
		if (self.element.hasClass('open')) {
			// we are doing a close action here.
			// if (self.parent.showPopBox) {
			//     self.parent.show();
			// }
			// self.parent.hide();

			var keyword = self.parent.textfield().val();
			self.parent.showSuggest = true;
			self.parent.search(keyword);
		} else {
			self.parent.hide();
		}
	},

	"{filterDropdownInput} click": function (el, ev) {
		ev.stopPropagation();

		// var keyword = self.parent.textfield().val();

		// console.log(keyword, self.parent.textfield());

		// self.parent.reSearch(keyword);
	},

	"{filterDropdownLabel} click": function (el, ev) {
		ev.stopPropagation();
	}

}});

module.resolve();

});
			EasySocial.require()
.script(
	'site/api/data',
	'site/api/admin',
	'site/api/popbox',
	'site/api/likes',
	'site/api/repost',
	'site/api/photos',
	'site/api/oauth',
	'site/api/share',
	'site/api/stream',
	'site/locations/popbox',
	'site/api/floatlabels',
	'site/api/mobile',

	// Layouts
	'shared/responsive',
	'shared/elements',
	'shared/popdown',
	'shared/privacy'
)
.library('history', 'dialog').done(function(){

	if (window.es.mobile) {
		EasySocial.require()
		.library('swiper')
		.done(function($) {

			var swiper = new Swiper('.swiper-container', {
				"freeMode": true,
				"slidesPerView": 'auto',
				"visibilityFullFit": true,
				"freeModeFluid": true,
				"slidesOffsetAfter": 88

			});
		});

		// Fixed issue with link opening new tab in mobile safari #1681
		(function(document,navigator,standalone) {

			if ((standalone in navigator) && navigator[standalone]) {
				var curnode,
					location = document.location,
					stop = /^(a|html)$/i;

				document.addEventListener('click', function(e) {
					curnode = e.target;

					while (!(stop).test(curnode.nodeName)) {
						curnode = curnode.parentNode;
					}

					if ('href' in curnode && (curnode.href.indexOf('http') || ~curnode.href.indexOf(location.host))) {
						e.preventDefault();
						location.href = curnode.href;
					}
				},false);
			}
		})(document, window.navigator, 'standalone');
	}
});
			EasySocial.module("site/story/audios", function($){

var module = this;

EasySocial.require()
.library('image', 'plupload')
.done(function($){

EasySocial.Controller("Story.Audios", {
	defaultOptions: {
		// This is the main wrapper for the form
		"{form}": "[data-audio-form]",

		// This is audio panel button
		"{panelButton}": '[data-story-plugin-name="audios"]',

		// Audio links
		"{insertAudio}": "[data-insert-audio]",
		"{audioLink}": "[data-audio-link]",
		"{audioGenre}": "[data-audio-genre]",

		// Audio uploads
		"{uploaderForm}": "[data-audio-uploader]",
		"{uploaderButton}": "[data-audio-uploader-button]",
		"{uploaderDropsite}": "[data-audio-uploader-dropsite]",
		"{uploaderProgressBar}": "[data-audio-uploader-progress-bar]",
		"{uploaderProgressText}": "[data-audio-uploader-progress-text]",

		"{uploaderUploadBar}": "[data-audio-uploader-upload-bar]",
		"{uploaderUploadText}": "[data-audio-uploader-upload-text]",

		// Audio preview
		"{removeButton}": "[data-remove-audio]",
		"{previewImageWrapper}": "[data-audio-preview-image]",
		"{previewTitle}": "[data-audio-preview-title]",
		"{title}": "[data-audio-title]",
		"{previewDescription}": "[data-audio-preview-description]",
		"{description}": "[data-audio-description]",
		"{previewArtist}": "[data-audio-preview-artist]",
		"{artist}": "[data-audio-artist]",
		"{previewAlbum}": "[data-audio-preview-album]",
		"{album}": "[data-audio-album]"
	}
}, function(self, opts, base) { return {

	init: function() {
		// If audio uploader form doesn't exist, perhaps the admin already disabled this
		if (self.uploaderForm().length == 0 && self.audioLink().length == 0) {
			return;
		}

		// Only implement uploader if the upload form exists
		if (self.uploaderForm().length > 0) {
			self.uploader = self.uploaderForm().addController("plupload", $.extend({
					"{uploadButton}": self.uploaderButton.selector,
					"{uploadDropsite}": self.uploaderDropsite.selector
				}, opts.uploader)
			);

			self.plupload = self.uploader.plupload;
		}

		if (opts.isEdit) {
			self.audio = {
				"type": opts.audio.source,
				"title": opts.audio.title,
				"artist": opts.audio.artist,
				"album": opts.audio.album,
				"description": opts.audio.description,
				"link": opts.audio.link,
				"id": opts.audio.id,
				"isEncoding": opts.audio.isEncoding
			};
		}
	},

	renderDefaultPlaceholderArtist: false,
	renderDefaultPlaceholderAlbum: false,
	renderDefaultPlaceholderDescription: false,
	clickedRemoveButton: false,

	isProcessed: function() {
		self.form().switchClass('is-processed');

		self.processing = false;
	},

	isUploading: function() {
		self.form().switchClass('is-uploading');
	},

	isProcessing: function() {
		self.form().switchClass('is-processing');

		self.processing = true;
	},

	isEncoding: function() {
		self.form().switchClass('is-encoding');
	},

	isInitial: function() {
		self.form().switchClass('is-waiting');
	},

	currentGenre: null,
	processing: false,
	audio: null,
	audioType: null,

	updatePreview: function(type, data, imageUrl) {

		self.audio = {
			"type": type,
			"title": data.title,
			"artist": data.artist,
			"album": data.album,
			"description": data.description,
			"link": data.link,
			"id": data.id ? data.id : '',
			"isEncoding": false
		};

		// Retrieve placeholder value for each of the field from the form
		titleContent = self.title().attr("placeholder");
		artistContent = self.artist().attr("placeholder");
		albumContent = self.album().attr("placeholder");
		descriptionContent = self.description().attr("placeholder");

		if ($.trim(data.title) != '') {
			titleContent = data.title;
			self.title().val(titleContent);
		}

		if ($.trim(data.artist) != '') {
			artistContent = data.artist;
			self.artist().val(artistContent);
		}

		if ($.trim(data.album) != '') {
			albumContent = data.album;
			self.album().val(albumContent);
		}

		if ($.trim(data.description) != '') {
			descriptionContent = data.description;
			self.description().val(descriptionContent);

			self.previewDescription().removeClass("no-description");
		}

		self.previewTitle().html(titleContent);
		self.previewArtist().html(artistContent);
		self.previewAlbum().html(albumContent);
		self.previewDescription().html(descriptionContent);

		// Load the image
		$.Image.get(imageUrl).done(function(image){
			image.appendTo(self.previewImageWrapper());
		});

	},

	resetProgress: function() {

		// Reset the progress bar
		self.uploaderProgressBar().css('width', '0%');
		self.uploaderProgressText().html('0%');
	},

	clearForm: function(resetAudio) {

		if (resetAudio) {
			self.audio = null;
		}

		// Set to initial position
		self.isInitial();

		// Reset all the form values
		self.audioLink().val('');

		self.previewImageWrapper().empty();

		self.previewTitle().empty();
		self.title().val('');

		self.previewArtist().empty();
		self.artist().val('');

		self.previewAlbum().empty();
		self.album().val('');

		self.previewDescription().empty();
		self.description().val('');
	},

	editArtistEvent: "click.es.story.audio.editLinkArtist",
	editAlbumEvent: "click.es.story.audio.editLinkAlbum",
	editTitleEvent: "click.es.story.audio.editLinkTitle",
	editDescriptionEvent: "click.es.story.audio.editLinkDescription",

	editTitle: function() {

		// Apply the class to the form wrapper
		self.form().addClass('editing-title');

		setTimeout(function(){

			self.title()
				.val(self.previewTitle().text())
				.focus()[0]
				.select();

			// Save the title when there is changes in the textbox. #3321
			$(self.title()).on('change keyup paste', function() {
				self.saveTitle("apply");
			});

			$(document).on(self.editTitleEvent, function(event) {

				if (event.target !== self.title()[0]) {
					self.saveTitle("save");
				}
			});

		}, 1);
	},

	saveTitle: function(operation) {

		// Do not proceed this if doesn't have data for this
		if (!self.audio) {
			return;
		}

		if (!operation) {
			operation = 'save';
		}

		var value = self.title().val();

		// Changing the title from the textbox
		if (operation == 'apply') {
			self.audio.title = value;
			return;
		}

		// Ensure that the title field has value.
		if (value.length > 0 && $.trim(value) != "") {
			if (operation == 'save') {
				self.previewTitle().html(value);
			}

			self.audio.title = value;
		}

		// Remove the editing title class
		self.form().removeClass('editing-title');

		if (self.audio.title == '' && self.previewTitle().html().length > 0) {
			self.audio.title = self.previewTitle().html();
		}

		$(document).off(self.editTitleEvent);
	},

	editArtist: function() {

		// Apply the class to the form wrapper
		self.form().addClass('editing-artist');

		setTimeout(function(){
			self.artist()
				.focus()[0]
				.select();

			// Save the artist when there is changes in the textbox. #3321
			$(self.artist()).on('change keyup paste', function() {
				self.saveArtist("apply");
			});

			$(document).on(self.editArtistEvent, function(event) {

				if (event.target !== self.artist()[0]) {
					self.saveArtist("save");
				}
			});

		}, 1);
	},

	saveArtist: function(operation) {

		// Do not proceed this if doesn't have data for this
		if (!self.audio) {
			return;
		}

		if (!operation) {
			operation = 'save';
		}

		var value = self.artist().val();

		// Changing the title from the textbox
		if (operation == 'apply') {
			self.audio.artist = value;
			return;
		}

		self.renderDefaultPlaceholderArtist = false;

		if (operation == 'save') {

			// trim the space first before do validation
			// just in case those user only type space in artist field
			var noValue = ($.trim(value) === "");

			if (noValue) {

				// Retrieve placeholder value
				value = self.artist().attr("placeholder");

				// Set a flag to determine that currently render back placeholder value
				self.renderDefaultPlaceholderArtist = true;

				// if the field doesn't have any custom content, then only replace to use placeholder value
				if (value) {
					self.previewArtist()
						.html(value.replace(/\n/g, "<br>"));
				}

			} else {

				// Ensure that only has value then only preview it
				self.previewArtist().html(value);
			}
		}

		// Remove the editing artist class
		self.form().removeClass('editing-artist');

		self.audio.artist = value;

		$(document).off(self.editArtistEvent);
	},

	editAlbum: function() {

		// Apply the class to the form wrapper
		self.form().addClass('editing-album');

		setTimeout(function(){

			self.album()
				.focus()[0]
				.select();

			// Save the album when there is changes in the textbox. #3321
			$(self.album()).on('change keyup paste', function() {
				self.saveAlbum("apply");
			});

			$(document).on(self.editAlbumEvent, function(event) {

				if (event.target !== self.album()[0]) {
					self.saveAlbum("save");
				}
			});

		}, 1);
	},

	saveAlbum: function(operation) {

		// Do not proceed this if doesn't have data for this
		if (!self.audio) {
			return;
		}

		if (!operation) {
			operation = 'save';
		}

		var value = self.album().val();

		// Changing the title from the textbox
		if (operation == 'apply') {
			self.audio.album = value;
			return;
		}

		self.renderDefaultPlaceholderAlbum = false;

		if (operation == 'save') {

			// trim the space first before do validation
			// just in case those user only type space in album field
			var noValue = ($.trim(value) === "");

			// Ensure that album name not only return you a space
			if (!noValue) {
				self.previewAlbum().html(value);
			} else {

				// Retrieve placeholder value
				value = self.album().attr("placeholder");

				// Set a flag to determine that currently render back placeholder value
				self.renderDefaultPlaceholderAlbum = true;

				// if the field doesn't have any custom content, then only replace to use placeholder value
				if (value) {
					self.previewAlbum()
						.html(value.replace(/\n/g, "<br>"));
				}
			}
		}

		// Remove the editing album class
		self.form().removeClass('editing-album');

		self.audio.album = value;

		$(document).off(self.editAlbumEvent);
	},

	checkAudioStatus: function(audioId, percentage) {
		EasySocial.ajax('site/controllers/audios/status', {
			"id": audioId,
			"uid": opts.audio.uid,
			"type": opts.audio.type,
			"createStream": 0,
			"percentage": percentage,
			"unpublished": 1
		}).done(function(permalink, percent, data, albumArt) {

			if (percent === 'done') {

				self.processing = false;

				// Set the progress bar to 100%
				self.uploaderProgressBar().css('width', '100%');
				self.uploaderProgressText().html('100%');

				// Update the state
				self.isProcessed();

				// Update the preview
				self.updatePreview('upload', data, albumArt);

				// Reset the progress bar
				self.resetProgress();

				return;
			}

			// There is a possibility that the progress is throwing errors on the line so we should skip this
			if (percent == 'ignore') {
				self.checkAudioStatus(audioId, percentage);
				return;
			}

			// Set the progress bar width
			var progress = percent + '%';
			self.uploaderProgressBar().css('width', progress);
			self.uploaderProgressText().html(progress);

			// This should run in a loop
			self.checkAudioStatus(audioId, percent);
		});
	},

	editDescription: function() {

		self.form().addClass('editing-description');

		setTimeout(function(){

			var descriptionClone = self.previewDescription().clone();
			var noDescription = descriptionClone.hasClass("no-description");

			descriptionClone.wrapInner(self.description());

			var previewDescriptionText = self.previewDescription().text();

			if (opts.isEdit && noDescription) {

				self.description()
					.val("")
					.focus()[0].select();

			} else if (noDescription) {
				self.description()
					.val("")
					.focus()[0].select();

			} else {
				self.description()
					.val(previewDescriptionText)
					.focus()[0].select();
			}

			// Save the description when there is changes in the textbox. #819
			$(self.description()).on('change keyup paste', function() {
				self.saveDescription("apply");
			});

			$(document).on(self.editDescriptionEvent, function(event) {

				if (event.target !== self.description()[0]) {
					self.saveDescription("save");
				}
			});
		}, 1);
	},

	saveDescription: function(operation) {

		// Do not proceed this if doesn't have data for this
		if (!self.audio) {
			return;
		}

		if (!operation) {
			operation = 'save';
		}

		// only handle for editing process
		if (opts.isEdit && $.trim(self.audio.description) == '' && self.previewDescription().html().length > 0) {
			self.audio.description = self.previewDescription().html();
			return;
		}

		var value = self.description().val();

		if (value) {
			value = value.replace(/\n/g, "<br//>");
		}

		// Always set this flag to false here so it will re-calculate again for different operation
		self.renderDefaultPlaceholderDescription = false;

		switch (operation) {

			case "save":

				// trim the space first before do validation
				// just in case those user only type space in description
				var noValue = ($.trim(value) === "");

				self.previewDescription()
					.toggleClass("no-description", noValue);

				if (noValue) {
					value = self.description().attr("placeholder");

					// Determine currently render the placeholder description now
					self.renderDefaultPlaceholderDescription = true;
				}

				// Only process this if there got the value for the description
				if (value) {
					self.previewDescription()
						.html(value.replace(/\n/g, "<br>"));
				}

				self.audio.description = value;

				self.form().find(".textareaClone").remove();

				self.form().removeClass("editing-description");

				$(document).off(self.editDescriptionEvent);
				break;
			case "apply":

				// Determine currently whether got value for the description or not
				if (value === "") {
					self.renderDefaultPlaceholderDescription = true;
				}

				self.audio.description = value;
			case "revert":
				break;
		}
	},

	"{window} easysocial.story.audio.panel.insertaudiolink" : function(el, ev, url) {

		if (self.audio || self.processing || !url) {
			return;
		}

		// Switch to audio panel
		self.panelButton().click();

		// Clear up any data inside the form
		self.clearForm(true);

		// Append the audio link
		self.audioLink().val(url);

		// Process audio link
		self.insertAudio().click();
	},

	"{uploaderForm} FilesAdded": function() {

		// Set the state to uploading
		self.isUploading();

		// Start the upload
		self.plupload.start();
	},

	"{uploaderForm} UploadProgress": function(el, event, uploader, file) {
		// Set the progress bar width
		var progress = file.percent + '%';

		self.uploaderUploadBar().css('width', progress);
		self.uploaderUploadText().html(progress);

	},

	"{uploaderForm} FileUploaded": function(uploaderForm, event, uploader, file, response) {

		// Server thrown an error
		if (response.error) {

			// Set the message
			self.clearMessage();
			self.setMessage(response.error);

			// Display the audio upload form again
			self.clearForm(true);

			return false;
		}

		// If the server isn't encoding on the fly, we should display some message
		if (!response.isEncoding) {

			self.processing = false;

			// Set the progress bar to 100%
			self.uploaderProgressBar().css('width', '100%');
			self.uploaderProgressText().html('100%');

			// Update the state
			self.isProcessed();

			// Update the preview
			self.updatePreview('upload', response.data, response.thumbnail);

			self.audio.isEncoding = true;

			// Reset the progress bar
			self.resetProgress();

			return;
		}

		// Set status to encoding
		self.isEncoding();

		self.processing = true;

		// Update the progress since the audio needs to be converted.
		self.checkAudioStatus(response.data.id, 0);
	},

	"{uploaderForm} Error": function(el, event, uploader, error) {

		// Get the error message
		var message = opts.errors[error.code];

		self.story.setMessage(message, "error");
	},

	"{previewTitle} click": function() {

		var editing = self.form().hasClass('editing-title');

		self.form().toggleClass('editing-title', !editing);

		if (!editing) {
			self.editTitle();
		}
	},

	"{previewArtist} click": function() {

		var editing = self.form().hasClass('editing-artist');

		self.form().toggleClass('editing-artist', !editing);

		if (!editing) {
			self.editArtist();
		}
	},

	"{previewAlbum} click": function() {

		var editing = self.form().hasClass('editing-album');

		self.form().toggleClass('editing-album', !editing);

		if (!editing) {
			self.editAlbum();
		}
	},

	"{previewDescription} click": function() {
		var editing = self.form().hasClass('editing-description');

		self.form().toggleClass('editing-description', !editing);

		// Do not execute this if that is not editing and clicked remove button from the form
		if (!editing && !self.clickedRemoveButton) {
			self.editDescription();
		}
	},

	"{audioGenre} change": function(audioGenre) {
		self.currentGenre = audioGenre.val();
	},

	"{audioLink} paste": function() {
		setTimeout(function() {
			self.insertAudio().click();
		}, 100);
	},

	"{insertAudio} click": function() {

		var url = self.audioLink().val();

		if (!url || self.processing) {
			return;
		}

		// Hide the form
		self.isProcessing();

		EasySocial.ajax('ajax:/apps/user/audios/controllers/process/process', {
			"type": "link",
			"link": url
		}).done(function(data, image, embed) {
			self.isProcessed();

			data.link = url;

			self.updatePreview('link', data, image);
		}).fail(function(message){

			self.isProcessed();

			self.clearForm(true);

			self.story.setMessage(message, "error");
		});
	},

	"{removeButton} click": function(removeButton) {
		// set this flag to true because use to determine that no need to go through the saveDescription process
		self.clickedRemoveButton = true;

		self.clearForm(true);

		// set this flag to false back after clear the form
		self.clickedRemoveButton = false;
		self.renderDefaultPlaceholderArtist = false;
		self.renderDefaultPlaceholderAlbum = false;
		self.renderDefaultPlaceholderDescription = false;
	},

	//
	// Saving
	//

	"{story} save": function(element, event, save) {

		if (save.currentPanel != 'audios') {
			return;
		}

		// Here we save everything before submit
		if (opts.isEdit) {
			self.saveAlbum();
			self.saveArtist();
			self.saveTitle('apply');
			self.saveDescription();
		}

		var url = self.audioLink().val();

		// If uploading an audio link
		if (url && !self.audio) {
			save.reject(opts.errors.messages.insert);
			return;
		}

		// If sharing an audio without link and upload
		if (!url && !self.audio) {
			save.reject(opts.errors.messages.empty);
			return;
		}

		// If sharing a audio without title.
		if (!self.audio.title || $.trim(self.audio.title) == "") {
			save.reject(opts.errors.messages.title);
			return;
		}

		// Add the task for uploading audio
		self.uploadingAudio = save.addTask("uploadingAudio");

		self.save(save);
	},

	"{story} afterSubmit": function() {

		var uploadingAudio = self.uploadingAudio;

		if (!uploadingAudio) {
			return;
		}

		// Reset the form upon submission
		self.clearForm(true);

		delete self.uploadingAudio;

		if (self.audio && self.audio.isEncoding) {

			EasySocial.dialog({
				content: EasySocial.ajax('site/views/audios/showEncodingMessage')
			});

			delete self.audio;
			return;
		}

		delete self.audio;
	},

	save: function(save) {

		var uploadingAudio = self.uploadingAudio;

		if (!uploadingAudio) {
			return;
		}

		if (self.processing) {
			save.reject(opts.errors.messages.processing);
			return;
		}

		// Attach the genre to the audio data
		self.audio.genre = self.audioGenre().val();

		if (!self.audio.genre || self.audio.genre == 0) {
			save.reject(opts.errors.messages.genre);
			return;
		}

		// Set the artist to empty if detected currently render the default placeholder artist before save
		if (self.renderDefaultPlaceholderArtist) {
			self.audio.artist = '';
		}

		// Set the album to empty if detected currently render the default placeholder album before save
		if (self.renderDefaultPlaceholderAlbum) {
			self.audio.album = '';
		}

		// Set the description to empty if detected currently render the default placeholder description before save
		if (self.renderDefaultPlaceholderDescription) {
			self.audio.description = '';
		}

		save.addData(self, self.audio);

		uploadingAudio.resolve();

		self.audioType = self.audio.type;
	},

	"{story} clear": function() {
		self.clearForm(false);

		self.renderDefaultPlaceholderArtist = false;
		self.renderDefaultPlaceholderAlbum = false;
		self.renderDefaultPlaceholderDescription = false;
	},

	"{window} easysocial.story.audio.panel.insertaudiolink" : function(el, ev, url) {

		if (self.audio || self.processing || !url) {
			return;
		}

		// Switch to audio panel
		self.panelButton().click();

		// Clear up any data inside the form
		self.clearForm(true);

		// Append the audio link
		self.audioLink().val(url);

		// Process audio link
		self.insertAudio().click();
	}
}});

// Resolve module
module.resolve();

});

});
			EasySocial.module("site/story/broadcast", function($){

var module = this;
var lang = EasySocial.options.momentLang;

EasySocial.require()
.library('datetimepicker', 'moment/' + lang)
.done(function($) {

EasySocial.Controller("Story.Broadcast", {
	defaultOptions: {
		'{base}': '[data-story-event-base]',
		"{profile}" : "[data-broadcast-profile]",
		"{title}" : "[data-broadcast-title]",
		"{link}" : "[data-broadcast-link]",
		"{message}": "[data-broadcast-message]",
		"{type}": "[data-broadcast-type]",

		// Broadcast context
		"{context}": "[data-broadcast-context]",

		// send to all or selected
		"{sendType}": "[data-broadcast-send-type]",

		// Multilist form
		"{multilist}": "[data-broadcast-multilist]",

		// multilist value
		"{sendList}": "[data-broadcast-send-list]",

		"{broadcastExpiry}": "[data-broadcast-expirydate]"
	}
}, function(self, opts) { return {

	init: function() {
		self.broadcastExpiry().addController('EasySocial.Controller.Broadcast.Datetime', {
			'{parent}': self
		});

		if (self.sendType().val() == 'all') {
			self.multilist().hide();
		} else {
			self.multilist().show();
		}

		self.loadSelection(self.context().val());
	},

	"{sendType} change": function(sendType, event){
		if (sendType.val() == 'all') {
			self.multilist().hide();
		} else {
			self.multilist().show();
		}
	},

	"{context} change": function(context, event){
		self.loadSelection(context.val());
	},

	"{story} save": function(element, event, save) {
		
		if (save.currentPanel != 'broadcast') {
			return;
		}

		self.savePost = save.addTask('savePost');

		self.save(save);

	},

	loadSelection: function(context) {
		EasySocial.ajax('apps/user/broadcast/controllers/broadcast/getSelectionItems', {
			"type": context,
		}).done(function(html) {
			self.sendList().html(html);
		});
	},

	save: function(save) {

		var savePost = self.savePost;

		if (!savePost) {
			return;
		}

		var profileId = new Array();

		if (self.sendType().val() != 'all') {
			profileId = self.sendList().val();
		}

		// Determines which profile we should broadcast to
		var	title = self.title().val(),
			link = self.link().val(),
			content = self.message().val(),
			type = self.type().val(),
			context = self.context().val();

		// Check if user doesn't fill in title or accidently add a space
		if ($.isEmpty($.trim(title))) {
			self.clearMessage();
			save.reject(opts.error);
			return false;
		}

		if ($.isEmpty($.trim(content))) {
			self.clearMessage();
			save.reject(opts.error);
			return false;
		}

		if (self.sendType().val() != 'all' && profileId == '') {
			self.clearMessage();
			save.reject(opts.error);
			return false;
		}

		var data = {"broadcast": "1", "profileId" : profileId, "title" : title, "content" : content, "link" : link, "type" : type, "context" : context};
								self.broadcastExpiry().trigger('datetimeExport', [data]);

		save.addData(self, data);

		savePost.resolve();

		delete self.savePost;
	},

	"{story} beforeSubmit": function(element, event, save) {
		
		if (save.currentPanel != 'broadcast') {
			return;
		}

		save.data.content = self.message().val();
	}
}});

EasySocial.Controller('Broadcast.Datetime', {
	defaultOptions: {
		'{picker}': '[data-picker]',
		'{toggle}': '[data-picker-toggle]',
		'{datetime}': '[data-datetime]'
	}
}, function(self) { return {
	init: function() {

		var minDate = new $.moment();
		var yearto = new Date().getFullYear() + 10;
		var datetimeFormat = self.picker().data('datetimeFormat');

		// 12 hour format
		var dateFormat = 'DD-MM-YYYY hh:mm A';

		// 24 hour format
		if (datetimeFormat == 24) {
			var dateFormat = 'DD-MM-YYYY HH:mm';            
		}

		// Minus 1 on the date to allow today
		minDate.date(minDate.date() - 1);

		self.picker()._datetimepicker({
			component: "es",
			useCurrent: false,
			format: dateFormat,
			minDate: minDate,
			maxDate: new $.moment({y: yearto}),
			icons: {
				time: 'far fa-clock',
				date: 'fa fa-calendar',
				up: 'fa fa-chevron-up',
				down: 'fa fa-chevron-down'
			},
			sideBySide: false,
			pickTime: 1,
			minuteStepping: 1,
			language: lang
		});

		var curActiveDateTime = self.element.data('value');
		if (curActiveDateTime != '') {
			var dateObj = $.moment(curActiveDateTime);
			self.datetimepicker('setDate', dateObj);
		}
	},

	datetimepicker: function(name, value) {
		return self.picker().data('DateTimePicker')[name](value);
	},

	'{toggle} click': function() {
		self.picker().focus();
	},

	'{picker} dp.change': function(el, ev) {
		self.setDateValue(ev.date.toDate());

		//self.parent.element.trigger('event' + $.String.capitalize(self.options.type), [ev.date]);
	},

	setDateValue: function(date) {
		// Convert the date object into sql format and set it into the input
		self.datetime().val(date.getFullYear() + '-' +
							('00' + (date.getMonth()+1)).slice(-2) + '-' +
							('00' + date.getDate()).slice(-2) + ' ' +
							('00' + date.getHours()).slice(-2) + ':' +
							('00' + date.getMinutes()).slice(-2) + ':' +
							('00' + date.getSeconds()).slice(-2));
	},

	'{self} datetimeExport': function(el, ev, data) {
		data['expirydate'] = self.datetime().val();
	}
}});

// Resolve module
module.resolve();

});
});
			EasySocial.module('site/story/event', function($) {

var module = this;
var lang = EasySocial.options.momentLang;

EasySocial.require()
.library('datetimepicker', 'moment/' + lang)
.done(function() {


EasySocial.Controller('Story.Event', {
	defaultOptions: {
		'{base}': '[data-story-event-base]',
		'{category}': '[data-story-event-category]',
		'{form}': '[data-story-event-form]',
		'{timezone}': '[data-event-timezone]',
		'{datetimeForm}': '[data-event-datetime-form]',
		'{datetime}': '[data-event-datetime]',
		'{title}': '[data-event-title]',
		'{description}': '[data-event-description]',
		"{submitButton}": '[data-story-submit]'

	}
}, function(self, opts, base) { return {

	init: function() {
		var data = self.base().htmlData();
		opts.error = data.error || {};
	},

	'{category} change': function(dropdown, event) {
		var value = dropdown.val();

		if (!value) {
			self.base().removeClass('is-loading');
			self.form().hide().empty();
			return;
		}


		// Show the form and load the loading indicator
		self.base().addClass('is-loading');
		self.form().show();

		self.loadStoryForm(value)
			.done(function(html) {
				
				self.base().removeClass('is-loading');
				self.form().html(html);
				self.submitButton().removeAttr('disabled');

				if (self.form().find('[data-event-form-error]').length > 0) {
					self.submitButton().attr('disabled', 'disabled');

					return;
				}

				var data = self.datetimeForm().htmlData();
				var yearto;

				if (!$.isEmpty(data.yearto)) {
					yearto = parseInt(data.yearto) + 1;
				} else {
					yearto = new Date().getFullYear() + 100
				}

				$.extend(self.options, {
					yearfrom: data.yearfrom || 1930,
					yearto: yearto,
					allowTime: data.allowtime,
					allowTimezone: data.allowtimezone,
					dateFormat: data.dateformat,
					disallowPast: data.disallowpast,
					minuteStepping: parseInt(data.minutestepping)
				});

				self.datetime().addController('EasySocial.Controller.Story.Events.Datetime', {
					'{parent}': self
				});
			});
	},

	loadStoryForm: $.memoize(function(id) {
		return EasySocial.ajax('apps/user/events/controllers/events/loadStoryForm', {
			id: id
		});
	}),

	'{story} activatePanel': function(element, event, pluginName) {
		if (pluginName != 'event') {
			return;
		}

		if (self.form().find('[data-event-form-error]').length > 0) {
			self.submitButton().attr('disabled', 'disabled');

			return;
		}
	},

	'{story} save': function(element, event, save) {

		if (save.currentPanel != 'event') {
			return;
		}

		var data = {
			title: self.title().val(),
			description: self.description().val(),
			category: self.category().val()
		};

		if (self.options.allowTimezone) {
			data.timezone = self.timezone().val()
		}

		self.datetime().trigger('datetimeExport', [data]);

		self.options.name = 'event';

		var task = save.addTask('validateEventForm');

		self.save(task, data);
	},

	save: function(task, data) {
		if ($.isEmpty(data.title) || $.isEmpty(data.category) || $.isEmpty(data.start)) {
			return task.reject(opts.error.empty);
		}

		if (!$.isEmpty(data.start) && !$.isEmpty(data.end) && data.end < data.start) {
			return task.reject(opts.error.datetime);
		}

		task.save.addData(self, data);
		task.resolve();
	}
}});

EasySocial.Controller('Story.Events.Datetime', {
	defaultOptions: {
		type: null,

		'{picker}': '[data-picker]',
		'{toggle}': '[data-picker-toggle]',
		'{datetime}': '[data-datetime]'
	}
}, function(self, opts, base) { return {
	
	init: function() {
		opts.type = self.element.data('event-datetime');

		var minDate = new $.moment();

		if (self.parent.options.disallowPast) {
			// Minus 1 on the date to allow today
			minDate.date(minDate.date() - 1);
		} else {
			minDate.year(self.parent.options.yearfrom);
		}

		self.picker()._datetimepicker({
			component: "es",
			useCurrent: false,
			format: self.parent.options.dateFormat,
			minDate: minDate,
			maxDate: new $.moment({y: self.parent.options.yearto}),
			icons: {
				time: 'far fa-clock',
				date: 'fa fa-calendar',
				up: 'fa fa-chevron-up',
				down: 'fa fa-chevron-down'
			},
			sideBySide: false,
			pickTime: self.parent.options.allowTime == 1,
			minuteStepping: self.parent.options.minuteStepping,
			language: lang
		});

		var dateObj = $.moment();

		dateObj.minute(0);
		dateObj.second(0);

		// If this is end, manually add 1 hour
		// if (self.options.type == 'end') {
		//     dateObj.hour(dateObj.hour() + 1);
		// }

		// self.datetimepicker('setDate', dateObj);

		// We need to allow user to leave the end date empty
		if (self.options.type != 'end') {
			self.datetimepicker('setDate', dateObj);
		}
	},

	datetimepicker: function(name, value) {
		return self.picker().data('DateTimePicker')[name](value);
	},

	'{toggle} click': function() {
		self.picker().focus();
	},

	'{picker} dp.change': function(el, ev) {
		self.setDateValue(ev.date.toDate());

		self.parent.element.trigger('event' + $.String.capitalize(self.options.type), [ev.date]);
	},

	'{picker} change': function(el, ev) {
		if ($.isEmpty(el.val())) {
			self.datetime().val('');
		}
	},

	setDateValue: function(date) {
		// Convert the date object into sql format and set it into the input
		self.datetime().val(date.getFullYear() + '-' +
							('00' + (date.getMonth()+1)).slice(-2) + '-' +
							('00' + date.getDate()).slice(-2) + ' ' +
							('00' + date.getHours()).slice(-2) + ':' +
							('00' + date.getMinutes()).slice(-2) + ':' +
							('00' + date.getSeconds()).slice(-2));
	},

	'{parent} eventStart': function(el, ev, date) {
		if (self.options.type === 'start') {
			return;
		}

		// self.datetimepicker('setMinDate', date ? date : new $.moment({y: self.parent.options.yearfrom}));
	},

	'{parent} eventEnd': function(el, ev, date) {
		if (self.options.type === 'end') {
			return;
		}

		// self.datetimepicker('setMaxDate', date ? date : new $.moment({y: self.parent.options.yearto}));
	},

	'{self} datetimeExport': function(el, ev, data) {
		data[self.options.type] = self.datetime().val();
	}
}});

module.resolve();
});
});
			EasySocial.module("site/story/files", function($){

var module = this;

EasySocial.require()
.library('plupload')
.done(function(){

	EasySocial.Controller("Story.Files", {
		defaultOptions: {

			"{canvas}": "[data-files-canvas]",
			"{dropsite}": "[data-files-dropsite]",
			"{upload}": "[data-files-upload]",

			"{uploadGroup}": "[data-files-items]",
			"{fileItem}": "[data-files-item]",
			"{fileNewItem}" : "[data-files-item][data-edit='0']",

			"{removeItem}": "[data-files-item-remove]",
			"{uploadItem}": "[data-files-upload-item]",

			"{progressTemplate}": "[data-files-progress]",

			settings: {
				url: null,
				max_file_size: null,
				filters: []
			}
		}
	}, function(self, opts) { return {

		items: {},

		init: function() {

			// To keep files tobe removed.
			opts.filesRemove = [];

			// Get the progress html
			opts.hints = {
					"progress": self.progressTemplate().clone().html()
			};
			// Remove the progress template
			self.progressTemplate().remove();


			// Initialize plupload's settings
			var options = $.extend({
								"{uploadButton}": self.upload.selector,
								"{uploadDropsite}": self.dropsite.selector
							}, {
								"settings": self.options.settings
						});


			// Implement plupload controller on the canvas
			self.uploader = self.canvas().addController('plupload', options);

			// Plupload
			self.plupload = self.uploader.plupload;

			// Add the uploader
			self.addPlugin("uploader", self.uploader);

			// Indicate uploader supports drag & drop
			if (!$.IE && self.plupload.runtime=="html5") {
				self.canvas().addClass("can-drop-file");
			}

			// Indicate uploader is ready
			self.canvas().addClass("can-upload");

			self.setLayout();
		},

		hasItems: function() {
			var hasItem = self.fileItem().length > 0;
			var hasUploadItem = self.uploadItem().length > 0;

			return hasItem || hasUploadItem;
		},

		setLayout: function() {

			// Show upload hint when content is empty
			self.canvas().toggleClass("has-items", self.hasItems());
		},

		removeFile: function(id) {

			var file = self.fileItem()
				.where('id', id);

			// only if this is a existing file.
			if (file.data('edit') == '1') {
				opts.filesRemove.push(id);
			}

			// Remove file item from container
			file.remove();

			self.setLayout();
		},

		clearFiles: function(){

			self.fileItem().remove();
			self.uploadItem().remove();

			self.setLayout();
		},

		removeFileItem: function(id) {

			var item = self.getItem(id);

			if (!item) {
				return;
			}


			// Remove item
			self.plupload.removeFile(item.file());
			item.element.remove();
			delete self.items[id];

			self.setLayout();
		},

		getItem: function(file) {

			var id;

			// By id
			if ($.isString(file)) {
				id = file;
			}

			// By file object
			if (file && file.id) {
				id = file.id;
			}

			return self.items[id];
		},

		createItem: function(file) {

			// Get the view item
			var item = $(opts.hints.progress);
			item.attr('id', file.id);

			// Add to item group
			self.uploadGroup().append(item);

			// Keep a copy of the item in our registry
			self.items[file.id] = item;

			self.setLayout();

			self.trigger("QueueCreated", [item]);

			return item;
		},

		"{uploader} FilesAdded": function(el, event, uploader, files) {

			// Wrap the entire body in a try...catch scope to prevent
			// browser from trying to redirect and load the file if anything goes wrong here.
			try {

				// Reverse upload ordering as we are prepending.
				files.reverse();

				$.each(files, function(i, file) {

					// The item may have been created before, e.g.
					// when plupload error event gets triggered first.
					if (self.getItem(file)) {
						return;
					}

					self.createItem(file);
				});

			} catch (e) {
				console.error(e);
			};

			self.setLayout();

			// Begin the upload process
			self.uploader.plupload.start();
		},

		"{uploader} FileUploaded": function(el, event, uploader, file, response) {

			var progress = self.getItem(file);

			var attachmentItem = $(response.preview);

			// Insert the preview after the progress
			attachmentItem
				.data('file-id', response.id)
				.addClass('new-item')
				.insertAfter(progress);

			// Remove the progress
			progress.remove();

			self.setLayout();

			// Remove the new-item class since we want it to be displayed on the screen once it is added
			setTimeout(function(){
				attachmentItem.removeClass("new-item");
			}, 1);
		},

		"{uploader} UploadProgress": function(el, event, uploader, file) {

			var item = self.getItem(file);

			if (!item) {
				return;
			}

			var noFilesize = (file.size===undefined || file.size=="N/A");
			file.percentage = file.percent + "%";
			file.filesize   = (noFilesize) ? "" : $.plupload.formatSize(file.size);
			file.remaining  = (noFilesize) ? "" : $.plupload.formatSize(file.size - (file.loaded || 0));

			var percentage = file.percentage;

			// Never use 100% because users might think
			// the photo is completely uploaded when it might
			// still be working.
			if (percentage=="100%") {
				percentage = "99%";
			}

			if (percentage=="0%") {
				percentage = "1%";
			}

			item.find('.upload-progress-bar')
				.width(percentage);

			// Set the percentage
			item.find('.upload-percentage')
				.html(percentage);
		},


		"{uploader} FileError": function(el, event, uploader, file, response) {

			self.story.setMessage(response.message, "error");

			var uploadingFile = self.uploadingFile;

			if (uploadingFile) {
				uploadingFile.reject();

				delete self.uploadingFile;
			}

			self.setLayout();
		},

		"{uploader} Error": function(el, event, uploader, error) {

			var message = opts.errors[error.code] || error.message;

			self.story.setMessage(message, "error");

			var uploadingFile = self.uploadingFile;

			if (uploadingFile) {
				uploadingFile.reject();

				delete self.uploadingFile;
			}

			// Temporary workaround. Delegated event don't work
			// because the element has been removed.
			self.removeItem()
				.click(function(){
					setTimeout(function(){
						self.setLayout();
					}, 1);
				});

			self.setLayout();
		},

		"{removeItem} click": function(el) {

			var id = el.parent(self.fileItem.selector).data('id');

			// Remove item
			self.removeFile(id);
		},

		//
		// Saving
		//
		"{story} save": function(element, event, save) {

			if (!self.hasItems()) {
				return;
			}

			self.uploadingFile = save.addTask('uploadingFile');
			self.save();
		},

		save: function() {

			var uploadingFile = self.uploadingFile;

			if (!uploadingFile) {
				return;
			}

			var items = self.fileItem();

			if (items.length) {

				var files = []
					save = uploadingFile.save;

				// new files
				self.fileNewItem().each(function(){
					files.push($(this).data('id'));
				});

				// files to be removed
				if (opts.filesRemove.length > 0) {
					$.each(opts.filesRemove, function(idx, val){
						var remove = {'remove':val};
						files.push(remove);
					});
				}

				save.addData(self, files);

				uploadingFile.resolve();

				delete self.uploadingFile;
			}
		},

		"{story} clear": function() {

			self.clearFiles();
		}
	}}
);

// Resolve module
module.resolve();

});

});
			EasySocial.module("site/story/friends", function($){

var module = this;

EasySocial.require()
.library("textboxlist")
.done(function(){

	EasySocial.Controller("Story.Friends", {
		defaultOptions: {
			namespace: 'site/controllers/friends/suggest',
			clusterId: null,
			clusterType: null,

			"{wrapper}": "[data-friends-wrapper]",
			"{field}": "[data-friends-wrapper] [data-textboxlist-textfield]"
		}
	}, function(self, opts) { return {

		init: function() {

			// Apply placeholder compatibility
			self.field().placeholder();

			// Friend tagging
			self.wrapper()
				.textboxlist({
					component: 'es',
					plugin: {
						autocomplete: {
							exclusive : true,
							cache: false,
							query: self.search,
							component: "es",
							modifier: "es-story-friends-autocomplete",
							sticky: true,
							shadow: true
						}
					}
				});
		},

		search: function(keyword) {

			var users = self.getTaggedUsers();

			return EasySocial.ajax(opts.namespace, {
								"search": keyword,
								"exclude": users,
								"clusterId": opts.clusterId,
								"clusterType": opts.clusterType
							});
		},

		getTaggedUsers: function() {

			var users = [];
			var items = $("[data-textboxlist-item]");

			if (items.length <= 0) {
				return users;
			}

			$.each(items, function(i, element) {

				var id = $(element).data('id');

				users.push(id);
			});

			return users;
		},

		"{wrapper} filterItem": function(el, event, item) {

			var html = $('<div/>').html(item.html);
			var title = html.find('[data-suggest-title]').text();
			var id = html.find('[data-suggest-id]').val();

			item.id = id;
			item.title = title;
			item.menuHtml = item.html;
		},

		mention: function(mode, query, callback) {

			self.search(query)
				.done(function(users){

					var friends = [];

					$.each(users, function(i, user) {
						friends.push({
							id: user.id,
							name: user.screenName,
							avatar: user.avatar,
							type: 'contact'
						});
					});

					callback(friends);
				});
		},

		updateMeta: function() {

			var controller = self.wrapper().controller("textboxlist");
			var friends = controller.getAddedItems();

			if (friends.length < 1) {
				self.story.setMeta("friends", "");
				return;
			}

			var ids = [];

			$.each(friends, function(i, user) {
				ids.push(user.id);
			});

			EasySocial.ajax('site/views/story/buildStoryMeta', {
				"ids": ids
			}).done(function(caption) {
				self.story.setMeta('friends', caption);
			});
		},

		"{wrapper} addItem": function() {
			self.updateMeta();
		},

		"{wrapper} removeItem": function() {
			self.updateMeta();
		},

		"{story} activateMeta": function(el, event, meta) {

			if (meta.name==="friends") {
				setTimeout(function(){
					self.field().focus();
				}, 1);
			}
		},

		"{story} save": function(el, event, save) {

			var controller = self.wrapper().controller("textboxlist");

			var tags = controller.getAddedItems().map(function(friend){
				return friend.id;
			});

			save.data['friends_tags'] = tags;
		},

		"{story} clear": function() {
			var controller = self.wrapper().controller("textboxlist");
			var friends = controller.getAddedItems();

			$.each(friends, function(i, user) {
				controller.deleteItem(user.id);
			});

			self.story.setMeta("friends", "");

		}

	}});

	// Resolve module
	module.resolve();

});

});
			EasySocial.module("site/story/gmaps", function($){

var module = this;

EasySocial.require()
.library("gmaps", "scrollTo", "image")
.done(function() {

// Constants
var KEYCODE = {
	BACKSPACE: 8,
	COMMA: 188,
	DELETE: 46,
	DOWN: 40,
	ENTER: 13,
	ESCAPE: 27,
	LEFT: 37,
	RIGHT: 39,
	SPACE: 32,
	TAB: 9,
	UP: 38
};

EasySocial.Controller("Story.Gmaps", {
	defaultOptions: {

		map: {
			lat: 0,
			lng: 0
		},

		staticMap: true,

		"{base}": "[data-story-location]",
		"{form}": "[data-story-location-form]",

		"{textField}": "[data-story-location-textField]",
		"{detectButton}": "[data-story-location-detect-button]",

		"{autocomplete}"	: "[data-story-location-autocomplete]",
		"{suggestions}"		: "[data-story-location-suggestions]",
		"{suggestion}"		: "[data-story-location-suggestion]",

		"{textbox}": "[data-story-location-textbox]",
		"{removeButton}": "[data-story-location-remove-button]",

		"{map}"     : "[data-story-location-map]",
		"{mapImage}": "[data-story-location-map-image]",

		"{meta}": "[data-story-meta-location]",
	}
}, function(self, opts) { return {

	init: function() {

		var currentLocation = self.options.currentLocation;

		// Only show auto-detect button if the browser supports geolocation
		if (navigator.geolocation) {
			self.base().addClass("is-detectable");
			// self.detectButton().show();
		}

		// Add placeholder support for IE9
		self.textField().placeholder();

		// Allow textfield input only when controller is implemented
		self.textField().removeAttr("disabled");

		if (currentLocation) {
			self.mapImage().width(458);
			self.mapImage().height(115);
			self.set(currentLocation);
		}
	},

	"{window} resize": $.debounce(function() {

		var currentLocation = self.currentLocation;

		if (!currentLocation) return;

		var mapImage = self.mapImage();

		if (mapImage.data("width") !== mapImage.width()) {

			self.navigate(currentLocation.latitude, currentLocation.longitude);
		}

	}, 250),

	renderDynamicMap: function(latitude, longitude) {

		if (typeof gmap === 'undefined') {

			// Init for the dynamic map
			gmap = new $.GMaps({
				div: '#map',
				lat: latitude,
				lng: longitude,
				zoom: 15,
				mapTypeId: 'roadmap',
				zoomControl: true,
				clickableIcons: false,
				streetViewControl: false,
				mapTypeControl: false
			});
		} else {
			gmap.setCenter(latitude, longitude);
		}

		// This event listener will call addMarker() when the map is clicked.
		gmap.addListener('click', function(event) {
			var location = event.latLng;

			// Populate the marker on the map
			self.populateMarker(location.lat(), location.lng(), 'addmarker');
		});
	},

	populateMarker: function(lat, lng, action) {
		// We will remove all markers first (if any)
		gmap.removeMarkers();

		// Add the new marker on the map
		var marker = gmap.addMarker({
			lat: lat,
			lng: lng
		});

		gmap.setCenter(lat, lng);

		var currentZoom = gmap.map.zoom;

		// If the current zoom too far,
		// we zoom in a bit
		if (currentZoom < 13) {
			gmap.fitZoom();
			gmap.zoomOut(9);
		}

		// If this comes from addmarker action,
		// we need to get the correct address and update the field
		if (action == 'addmarker') {
			self.processMarker(marker);
		}
	},

	processMarker: function(marker, oldMarkerId) {

		markerLat = marker.getPosition().lat();
		markerLng = marker.getPosition().lng();

		// markers[markerId] = marker;

		var markerObj = {
					lat: markerLat,
					lng: markerLng
				}

		// Try to get the address from the given lat lng
		self.lookupLatLng(markerObj);
	},

	updateField: function(markerObj, venue) {

		// Fill in the field with address
		self.textField().val(markerObj.name);

		var location = {
			latitude: markerObj.lat,
			longitude: markerObj.lng,
			fulladdress: venue.formatted_address
		}

		self.currentLocation = location;

		var process = $.Deferred();

		process.resolve(location);

		process.done(function(location) {

			// Get the caption
			EasySocial.ajax('site/views/location/getStoryCaption', {
				"address": markerObj.name
			}).done(function(caption) {
				self.story.setMeta("location", caption);
			})

			self.lastQueryAddress = location.fulladdress;

			self.base()
				.removeClass('is-loading')
				.addClass("has-location");
		});
	},

	navigateDynamic: function(lat, lng) {
		self.renderDynamicMap(lat, lng);
		self.populateMarker(lat, lng);
	},

	navigate: function(lat, lng) {

		var apiKey = window.es.gmapsApiKey;

		var mapImage = self.mapImage(),
			width    = mapImage.width(),
			height   = mapImage.height(),
			url =
				$.GMaps.staticMapURL({
					key: apiKey,
					size: [width, height],
					lat: lat,
					lng: lng,
					sensor: true,
					scale: 2,
					markers: [
						{lat: lat, lng: lng}
					]
				});

		$.Image.get(url)
			.done(function() {
				mapImage.css({
					"backgroundImage": $.cssUrl(url),
					"backgroundSize": "cover",
					"backgroundPosition": "center center"
				});

				self.base()
					.removeClass("is-loading")
					.addClass("has-location");
			});
	},

	// Memoized locations
	locations: {},

	lastQueryAddress: null,

	"{textField} keydown": function(textField, event) {

		switch (event.keyCode)
		{
			case KEYCODE.UP:

				var prevSuggestion = $(
					self.suggestion(".active").prev(self.suggestion.selector)[0] ||
					self.suggestion(":last")[0]
				);

				// Remove all active class
				self.suggestion().removeClass("active");

				prevSuggestion
					.addClass("active")
					.trigger("activate");

				self.suggestions()
					.scrollTo(prevSuggestion, {
						offset: prevSuggestion.height() * -1
					});

				event.preventDefault();

				break;

			case KEYCODE.DOWN:

				var nextSuggestion = $(
					self.suggestion(".active").next(self.suggestion.selector)[0] ||
					self.suggestion(":first")[0]
				);

				// Remove all active class
				self.suggestion().removeClass("active");

				nextSuggestion
					.addClass("active")
					.trigger("activate");

				self.suggestions()
					.scrollTo(nextSuggestion, {
						offset: nextSuggestion.height() * -1
					});

				event.preventDefault();

				break;

			case KEYCODE.ENTER:

				var activeSuggestion = self.suggestion(".active"),
					location = activeSuggestion.data("location");
					self.set(location);

				self.hideSuggestions();
				break;

			case KEYCODE.ESCAPE:
				self.hideSuggestions();
				break;
		}

	},

	"{textField} keyup": function(textField, event) {

		switch (event.keyCode) {

			case KEYCODE.UP:
			case KEYCODE.DOWN:
			case KEYCODE.LEFT:
			case KEYCODE.RIGHT:
			case KEYCODE.ENTER:
			case KEYCODE.ESCAPE:
				// Don't repopulate if these keys were pressed.
				break;

			default:
				var address = $.trim(textField.val());

				if (address === "") {
					self.base().removeClass("has-location");
					self.hideSuggestions();
				}

				var locations = self.locations[address];

				// If this location has been searched before
				if (locations) {

					// And set our last queried address to this address
					// so that it won't repopulate the suggestion again.
					self.lastQueryAddress = address;

					// Just use cached results
					self.suggest(locations);

				// Else ask google to find it out for us
				} else {

					self.lookup(address);
				}
				break;
		}
	},

	lookupLatLng: $.debounce(function(markerObj) {

		self.base().addClass("is-loading");

		$.GMaps.geocode({
			lat: markerObj.lat,
			lng: markerObj.lng,
			callback: function(locations, status) {

				self.base().removeClass("is-loading");

				if (status == "OK") {
					markerObj.name = locations[0].formatted_address;
					self.updateField(markerObj, locations[0]);
				}
			}
		});

	}, 250),

	lookup: $.debounce(function(address) {

		self.base().addClass("is-loading");

		EasySocial.ajax('site/controllers/location/getLocations', {
			query: address
		}).done(function(locations) {

			self.base().removeClass("is-loading");

			// Store a copy of the results
			self.locations[address] = locations;

			// Suggestion locations
			self.suggest(locations);

			self.lastQueryAddress = address;
		}).fail(function(msg) {
		});
	}, 250),

	suggest: function(locations) {

		var suggestions = self.suggestions();

		// Clear location suggestions
		suggestions
			.empty();

		if (locations.length < 0) {
			return;
		}

		var items = [];

		$.each(locations, function(i, location) {
			items.push(location.address);
		});

		EasySocial.ajax('site/views/location/format', {
			"locations": items
		}).done(function(rows) {

			$.each(rows, function(i, row) {

				$(row)
					.data('location', locations[i])
					.appendTo(suggestions);
			});
		});

		self.showSuggestions();
	},

	showSuggestions: function() {

		self.focusSuggestion = true;

		self.element.find(".es-story-footer")
			.addClass("swap-zindex");

		self.story.clearMessage();

		setTimeout(function(){

			self.autocomplete().addClass("active");

			var doc = $(document),
				hideOnClick = "click.es.story.location";

			doc
				.off(hideOnClick)
				.on(hideOnClick, function(event){

					// Collect list of bubbled elements
					var targets = $(event.target).parents().andSelf();

					if (targets.filter(self.element).length > 0) return;

					doc.off(hideOnClick);

					self.hideSuggestions();
				});

		}, 500);
	},

	hideSuggestions: function() {

		self.focusSuggestion = false;

		self.autocomplete().removeClass("active");

		$(document).off("click.es.story.location");

		setTimeout(function(){

			if (self.focusSuggestion) return;

			self.element.find(".es-story-footer")
				.removeClass("swap-zindex");

		}, 500);
	},

	"{suggestion} activate": function(suggestion, event) {

		var location = suggestion.data("location");

		var lat = location.latitude,
			lng = location.longitude;

		if (opts.staticMap) {
			self.navigate(lat, lng);
		} else {
			self.navigateDynamic(lat, lng);
		}
	},

	"{suggestion} mouseover": function(suggestion) {

		// Remove all active class
		self.suggestion().removeClass("active");

		suggestion
			.addClass("active")
			.trigger("activate");
	},

	"{suggestion} click": function(suggestion, event) {

		var location = suggestion.data("location");

		self.set(location);

		self.hideSuggestions();
	},

	set: function(location) {

		self.currentLocation = location;

		var process = $.Deferred();

		if ($.isEmpty(location.fulladdress)) {
			self.getAddress(location.latitude, location.longitude)
				.done(function(address) {
					location.fulladdress = location.name + ', ' + address;

					process.resolve(location);
				});
		} else {
			process.resolve(location);
		}

		process.done(function(location) {
			self.navigate(location.latitude, location.longitude);

			// Set the address on the field
			self.textField().val(location.fulladdress);

			self.lastQueryAddress = location.address;

			// Get the caption
			EasySocial.ajax('site/views/location/getStoryCaption', {
				"address": location.fulladdress
			}).done(function(caption) {
				self.story.setMeta("location", caption);
			})


			self.base()
				.removeClass('is-loading')
				.addClass("has-location");
		});
	},

	unset: function() {

		self.currentLocation = null;

		self.textField().val('');

		self.story.removePanelCaption("locations");

		self.mapImage().attr("src", "");

		self.story.setMeta("location", "");

		self.base().removeClass("has-location");
	},

	activatePanel: function() {

		setTimeout(function(){
			self.textField().focus();
		}, 500);
	},

	deactivatePanel: function() {

		var location = self.currentLocation;

		if (location) {
			self.set(location);
		}
	},

	detectTimer: null,

	"{detectButton} click": function() {

		var story = self.story;
		var textbox = self.textbox();

		self.base().addClass("is-loading");

		clearTimeout(self.detectTimer);

		self.detectTimer = setTimeout(function(){
			story.clearMessage();

			EasySocial.ajax('site/views/location/getErrorMessage', {
				"code": 1
			}).done(function(message) {
				story.setMessage(message);

				self.base().removeClass("is-loading");
			});


		}, 8000);



		$.GMaps.geolocate({
			success: function(position) {

				// story.clearMessage();

				EasySocial.ajax('site/controllers/location/getLocations', {
					latitude: position.coords.latitude,
					longitude: position.coords.longitude
				}).done(function(locations) {
					self.suggest(locations);
					self.textField().focus();
				}).fail(function(msg) {
				});
			},
			error: function(error) {

				story.clearMessage();

				EasySocial.ajax('site/views/location/getErrorMessage', {
					"code": error.code
				}).done(function(contents) {
					story.setMessage(contents);
				});
			},
			always: function() {
				clearTimeout(self.detectTimer);
				self.base().removeClass("is-loading");
			}
		});
	},

	"{removeButton} click": function() {
		self.unset();
		self.hideSuggestions();
	},

	"{meta} click": function() {
		self.story.activateMeta("location");
	},

	"{story} activateMeta": function(el, event, meta) {

		if (meta.name==="location") {
			setTimeout(function(){
				self.textField().focus();
			}, 1);
		}
	},

	"{story} save": function(event, element, save) {

		var currentLocation = self.currentLocation;

		if (!currentLocation) return;

		var task = save.addTask('saveLocation');

		if ($.isEmpty(currentLocation.fulladdress)) {
			self.getAddress(currentLocation.latitude, currentLocation.longitude).done(function(address) {
				currentLocation.fulladdress = currentLocation.name + ', ' + address;

				self.save(task, currentLocation);
			});
		} else {
			self.save(task, currentLocation);
		}
	},

	getAddress: $.memoize(function(latitude, longitude) {
		var process = $.Deferred(),
			geocoder = new google.maps.Geocoder(),
			latlng = new google.maps.LatLng(latitude, longitude);

		geocoder.geocode({
			'latLng': latlng
		},
		function(results, status) {
			if (status == google.maps.GeocoderStatus.OK) {
				process.resolve(results[0].formatted_address);
			}
		});

		return process;
	}, function(lat, lng) {
		return lat + ',' + lng;
	}),

	save: function(task, location) {
		task.save.data['locations_short_address'] = location.name;
		task.save.data['locations_lat'] = location.latitude;
		task.save.data['locations_lng'] = location.longitude;
		task.save.data['locations_formatted_address'] = location.fulladdress;
		task.save.data['locations_data'] = JSON.stringify(location);

		task.resolve();
	},

	"{story} clear": function() {
		self.unset();
		self.hideSuggestions();
	}
}});

// Resolve module
module.resolve();

});

});
			EasySocial.module("site/story/links", function($){

var module = this;

EasySocial.Controller("Story.Links", {
	defaultOptions: {
		urlParser: null,
		validateUrl: false,

		// Attachment item
		"{linkForm}": "[data-story-link-form]",
		"{linkInput}": "[data-story-link-input]",

		"{linkContent}": "[data-story-link-content]",
		"{linkItem}": "[data-story-link-item]",
		"{linkTitle}": "[data-story-link-title]",
		"{linkDescription}": "[data-story-link-description]",
		"{linkImages}": "[data-story-link-images]",
		"{linkImage}": "[data-story-link-image]",
		"{imageWrapper}": "[data-story-link-image-wrapper]",

		"{linkVideo}": "[data-story-link-video]",
		"{titleTextfield}": "[data-story-link-title-textfield]",
		"{descriptionTextfield}": "[data-story-link-description-textfield]",

		"{panelButton}"     : "[data-story-link-panel-button]",
		"{attachButton}"    : "[data-story-link-attach-button]",
		"{removeButton}"    : "[data-story-link-remove-button]",
		"{removeThumbnail}" : "[data-story-link-remove-image]"
	}
}, function(self, opts, base) { return {

	init: function() {

		self.linkInput().placeholder();

		if (opts.isEdit) {
			var link = {
				"title": opts.link.title,
				"description": opts.link.description,
				"url": opts.link.url,
				"image": opts.link.image
			};

			var preview = $('[data-story-link-edit]');

			link.item = $(preview).data("link", link);
			link.item.addController(EasySocial.Controller.Story.Links.Preview);

			// self.links[link.url] = link;
			self.currentLink = link;
		}
	},

	activateAttachment: function() {

		if (self.doNotFocus) {
			return;
		}

		setTimeout(function(){
			self.linkInput().focus();
			self.doNotFocus = false;
		}, 500);
	},

	//
	// Link manipulation
	//
	links: {},

	currentLink: null,

	crawling: false,

	extractUrls: function(str) {

		var urlParser = self.options.urlParser;
		var urls = str.match(urlParser);

		// Discard non http/https protocols
		if ($.isArray(urls)) {
			return $.map(urls, function(url, i){
				return $.trim(url);
			});
		} else {
			return [];
		}
	},

	fixUrl: function(url) {

		// If there's no protocol, use "http".
		var url = $.uri(url);

		if (!/http|https/.test(url.protocol())) {
			url.setProtocol("http");
		}

		return url.toString();
	},

	getLink: function(urls) {

		// If a block of string was given,
		// extract urls from it.
		if ($.isString(urls)) {
			urls = self.extractUrls(urls);
		}

		if (urls.length < 1) {
			var dfd = $.Deferred();
			dfd.reject(opts.errors.messages.tlds);

			return dfd;
		}

		// Get only the first url
		var url = urls[0];

		// If this is a new url,
		// create a new link object for it.
		link = self.links[url] || self.createLink(url);

		// When the link is resolved,
		// add link to the attachment item.
		return link;
	},

	createLink: function(url) {

		// Create a new link object
		var link = self.links[url] = $.Deferred();

		// Add url property
		link.url = url;

		self.crawling = true;

		// Get link info from crawler
		EasySocial.ajax('site/controllers/crawler/fetch', {
			"url": url,
			"preview": 1
		}).done(function(data, preview) {

			if (!data) {
				link.reject();
			}

			// Create link item
			link.item = $(preview).data("link", data);

			link.item.addController(EasySocial.Controller.Story.Links.Preview);

			link.resolve(link);
		})
		.fail(function(msg){
			link.reject(msg);
		})
		.always(function() {
			self.crawling = false;
		});

		return link;
	},

	addLink: function(link) {

		// Add link item to attachment item
		self.linkContent()
			.empty()
			.append(link.item);

		self.linkForm()
			.hide();

		self.currentLink = link;
	},

	removeLink: function() {

		self.linkItem()
			.detach();

		self.linkForm()
			.show();

		self.currentLink = null;
	},

	checkAllowedPanel: function() {

		var allowedPanel = ["links", "text"];
		var allow = false;

		$.each(allowedPanel, function(index, panelName){
			var pluginSelector = '[data-story-plugin-name="' + panelName + '"]';
			var panel = $(pluginSelector);

			if (panel.hasClass('active')) {
				allow = true;
				return false;
			}
		});

		return allow;
	},

	checkVideoLink: function(url) {

		var pluginContent = self.story.panelContent('[data-story-plugin-name="videos"]');
		var allowLink = $(pluginContent).find('[data-video-form]').data('allow-link');

		if (!allowLink) {
			return false;
		}

		// General video url
		var videoURL = url.match(/(youtube|youtu|dailymotion|twitch|liveleak)\.(com|be|tv)\/((watch\?v=([-\w]+))|(view\?i=([-\w]+))|((video|videos)\/([-\w]+)))/);

		// Vimeo url checking eg. https://vimeo.com/123456
		var vimeoURL = url.match(/(vimeo)\.(com)\/(([-\w]+))/);
		var twitchURL = url.match(/twitch.tv/);

		if (videoURL !== null || vimeoURL !== null || twitchURL !== null) {
			return true;
		}

		return false;
	},

	checkAudioLink: function(url) {

		var pluginContent = self.story.panelContent('[data-story-plugin-name="audios"]');
		var allowLink = $(pluginContent).find('[data-audio-form]').data('allow-link');

		if (!allowLink) {
			return false;
		}

		// General audio url
		var spotifyURL = url.match(/^(spotify:|https:\/\/(open|play)+\.spotify\.com\/)/);
		var soundcloudURL = url.match(/^https?:\/\/(soundcloud\.com|snd\.sc)\/(.*)$/);

		if (spotifyURL !== null || soundcloudURL !== null) {
			return true;
		}

		return false;
	},

	//
	// Link form
	//
	"{attachButton} click": function() {

		var linkInput = self.linkInput();
		var linkForm  = self.linkForm();
		var url = $.trim(self.linkInput().val());

		// If there's no url, stop.
		if (url === "") {
			return;
		}

		// Fix the url
		url = self.fixUrl(url);

		// Set fixed link back to input box
		self.linkInput().val(url);

		// Set link form as busy
		linkForm.addClass("busy");

		// Get link
		self.getLink(url)
			.done(function(link){
				self.addLink(link);
			})
			.fail(function(error){
				self.story.setMessage(error, "error");
			})
			.always(function(){
				linkForm.removeClass("busy");
			});
	},

	"{removeButton} click": function(button) {

		self.currentLink.disabled = true;

		self.removeLink();
	},


	"{linkInput} keyup": function(input, event) {

		if (event.keyCode == 13) {
			self.attachButton().click();
		}
	},

	"{linkInput} paste": function(input, event) {
		setTimeout(function() {
			self.attachButton().click();
		}, 100);
	},

	"{story.textField} input": $._.debounce(function(textField, event) {

		// Don't look for links if we've already added one
		if (self.currentLink || self.crawling) {
			return;
		}

		// Retrieve the last typed url
		var content = textField.val();
		var urls = self.extractUrls(content);
		var url = urls[urls.length - 1];

		if (!url) {
			return;
		}

		videoLink = self.checkVideoLink(url);

		// We let video panel to handle video link
		if (videoLink) {
			$(window).trigger('easysocial.story.video.panel.insertvideolink', [url]);
			return;
		}

		audioLink = self.checkAudioLink(url);

		// We let audio panel to handle audio link
		if (audioLink) {
			$(window).trigger('easysocial.story.audio.panel.insertaudiolink', [url]);
			return;
		}

		// Check for allowed panel for the link to active
		if (!self.checkAllowedPanel()) {
			return;
		}

		// Check if link has been crawled before
		var url = self.fixUrl(url);
		var link = self.links[url];

		if (link && link.disabled) {
			return;
		}

		if (self.options.validateUrl) {
			var failed = false;

			EasySocial.ajax('site/controllers/crawler/validate', {
				"url": url
			}).done(function() {

				// Set the url as the value
				self.linkInput().val(url);

				// Do not focus when attachment is activated
				self.doNotFocus = true;

				// Trigger links attachment
				self.panelButton().click();

				// Add link
				self.attachButton().click();
			});

			return;
		}

		// Set the url as the value
		self.linkInput().val(url);

		// Do not focus when attachment is activated
		self.doNotFocus = true;

		// Trigger links attachment
		self.panelButton().click();

		// Add link
		self.attachButton().click();

	}, 950),

	//
	// Saving
	//
	"{story} save": function(element, event, save) {

		if (save.currentPanel != 'links') {
			return;
		}

		if (!self.currentLink) {
			save.reject(opts.errors.messages.insert);
			return;
		}

		var data = {
					title: self.titleTextfield().val(),
					description: self.descriptionTextfield().val(),
					url: self.currentLink.url,
					video: self.linkVideo().val()
				};

		if (!self.removeThumbnail().is(":checked")) {

			data.image = self.imageWrapper('.active')
							.find('img')
							.attr('src');
		}

		save.addData(self, data);
	},

	"{story} clear": function() {

		self.linkInput().val("");

		self.removeLink();
	}
}});

EasySocial.Controller('Story.Links.Preview', {
	defaultOptions: {

		"{previousImage}": "[data-story-link-image-prev]",
		"{nextImage}": "[data-story-link-image-next]",
		"{image}": "[data-story-link-image]",
		"{imageWrapper}": "[data-story-link-image-wrapper]",
		"{imagesWrapper}"   : "[data-story-link-images]",
		"{imageIndex}"      : "[data-story-link-image-index]",
		"{removeThumbnail}" : "[data-story-link-remove-image]",
		"{imageDimensions}": "[data-story-link-image-dimensions]",
		"{imageWidth}": "[data-image-width]",
		"{imageHeight}": "[data-image-height]",

		"{title}": "[data-story-link-title]",
		"{description}": "[data-story-link-description]",
		"{titleTextfield}"      : "[data-story-link-title-textfield]",
		"{descriptionTextfield}": "[data-story-link-description-textfield]"
	}
}, function(self, opts, base) {

	return {

	init: function() {

		// Init dimensions
		self.initDimensions();
	},

	initDimensions: function() {

		// When the images are loaded, set the width and height accordingly.
		self.image()
			.on('load', function() {
				var width = this.naturalWidth;
				var height = this.naturalHeight;

				var wrapper = $(this).parent();

				// Set the width and height on the width and height
				wrapper.find(self.imageWidth.selector)
					.html(width);

				wrapper.find(self.imageHeight.selector)
					.html(height);
			});
	},

	"{removeThumbnail} click" : function() {
		var isChecked = self.removeThumbnail().is(':checked');

		if (isChecked) {
			self.imagesWrapper().hide();
		} else {
			self.imagesWrapper().show();
		}

		self.element.toggleClass("has-images", !isChecked);
	},

	"{previousImage} click" : function() {
		var currentImage = self.imageWrapper('.active');
		var prevImage = currentImage.prev();
		var index = parseInt(self.imageIndex().html());
		var nextIndex = index - 1;

		if (prevImage.length > 0) {
			currentImage.removeClass('active');
			prevImage.addClass('active');

			self.imageIndex().html(nextIndex);
		}
	},

	"{nextImage} click" : function() {
		var currentImage = self.imageWrapper('.active');
		var nextImage = currentImage.next();

		var index = parseInt(self.imageIndex().html());
		var nextIndex = index + 1;

		if (nextImage.length > 0) {
			currentImage.removeClass('active');
			nextImage.addClass('active');

			self.imageIndex().html(nextIndex);
		}
	},

	"{title} click": function() {

		var editingTitle = self.element.hasClass("editing-title");

		self.element.toggleClass("editing-title", !editingTitle);

		if (!editingTitle) {
			self.editTitle();
		}
	},

	editTitleEvent: "click.es.story.editLinkTitle",

	editTitle: function() {

		self.element.addClass("editing-title");

		setTimeout(function(){

			self.titleTextfield()
				.val(self.title().text())
				.focus()[0].select();

			$(document).on(self.editTitleEvent, function(event) {
				if (event.target!==self.titleTextfield()[0]) {
					self.saveTitle("save");
				}
			});
		}, 1);
	},

	saveTitle: function(operation) {

		if (!operation) {
			operation = save;
		}

		var value = self.titleTextfield().val();

		if (operation == 'save') {
			if (value === '') {
				value = self.title().data('default');
			}

			self.title().html(value);
		}

		self.element.removeClass("editing-title");

		$(document).off(self.editTitleEvent);
	},

	"{titleTextfield} keyup": function(el, event) {

		// Escape
		if (event.keyCode==27) {
			self.saveTitle("revert");
		}
	},

	"{description} click": function() {

		var editingDescription = self.element.hasClass("editing-description");

		self.element.toggleClass("editing-description", !editingDescription);

		if (!editingDescription) {
			self.editDescription();
		}
	},

	editDescriptionEvent: "click.es.story.editLinkDescription",

	editDescription: function() {

		self.element.addClass("editing-description");

		setTimeout(function(){

			var descriptionClone = self.description().clone(),
				noDescription = descriptionClone.hasClass("no-description");

			descriptionClone.wrapInner(self.descriptionTextfield());

			if (noDescription) {
				self.descriptionTextfield().val("");
			}

			// self.descriptionTextfield()
			//  .expandingTextarea();

			self.descriptionTextfield()
				.focus()[0].select();

			$(document).on(self.editDescriptionEvent, function(event) {

				if (event.target!==self.descriptionTextfield()[0]) {
					self.saveDescription("save");
				}
			});
		}, 1);
	},

	saveDescription: function(operation) {
		if (!operation) operation = save;

		var value = self.descriptionTextfield().val().replace(/\n/g, "<br//>");

		switch (operation) {

			case "save":

				var noValue = (value==="");

				self.description()
					.toggleClass("no-description", noValue);

				if (noValue) {
					value = self.descriptionTextfield().attr("placeholder");
				}

				self.description()
					.html(value);
				break;

			case "revert":
				break;
		}

		self.element.find(".textareaClone").remove();

		self.element.removeClass("editing-description");

		$(document).off(self.editDescriptionEvent);
	},

	"{descriptionTextfield} keyup": function(el, event) {
		// Escape
		if (event.keyCode==27) {
			self.saveDescription("revert");
		}
	}
}});

module.resolve();

});
			EasySocial.module("site/story/locations", function($){

var module = this;

EasySocial.require()
.library("gmaps", "scrollTo", "image")
.done(function() {

// Constants
var KEYCODE = {
	BACKSPACE: 8,
	COMMA: 188,
	DELETE: 46,
	DOWN: 40,
	ENTER: 13,
	ESCAPE: 27,
	LEFT: 37,
	RIGHT: 39,
	SPACE: 32,
	TAB: 9,
	UP: 38
};

EasySocial.Controller("Story.Locations", {
	defaultOptions: {

		map: {
			lat: 0,
			lng: 0
		},

		staticMap: true,

		"{base}": "[data-story-location]",
		"{form}": "[data-story-location-form]",

		"{textField}": "[data-story-location-textField]",
		"{detectButton}": "[data-story-location-detect-button]",

		"{autocomplete}"	: "[data-story-location-autocomplete]",
		"{suggestions}"		: "[data-story-location-suggestions]",
		"{suggestion}"		: "[data-story-location-suggestion]",

		"{textbox}": "[data-story-location-textbox]",
		"{removeButton}": "[data-story-location-remove-button]",

		"{map}"     : "[data-story-location-map]",
		"{mapImage}": "[data-story-location-map-image]",

		"{meta}": "[data-story-meta-location]",
	}
}, function(self, opts) { return {

	init: function() {

		var currentLocation = self.options.currentLocation;

		// Only show auto-detect button if the browser supports geolocation
		if (navigator.geolocation) {
			self.base().addClass("is-detectable");
			// self.detectButton().show();
		}

		// Add placeholder support for IE9
		self.textField().placeholder();

		// Allow textfield input only when controller is implemented
		self.textField().removeAttr("disabled");

		if (currentLocation) {
			self.mapImage().width(458);
			self.mapImage().height(115);
			self.set(currentLocation);
		}
	},

	"{window} resize": $.debounce(function() {

		var currentLocation = self.currentLocation;

		if (!currentLocation) return;

		var mapImage = self.mapImage();

		if (mapImage.data("width") !== mapImage.width()) {

			self.navigate(currentLocation.latitude, currentLocation.longitude);
		}

	}, 250),

	renderDynamicMap: function(latitude, longitude) {

		if (typeof gmap === 'undefined') {

			// Init for the dynamic map
			gmap = new $.GMaps({
				div: '#map',
				lat: latitude,
				lng: longitude,
				zoom: 15,
				mapTypeId: 'roadmap',
				zoomControl: true,
				clickableIcons: false,
				streetViewControl: false,
				mapTypeControl: false
			});
		} else {
			gmap.setCenter(latitude, longitude);
		}

		// This event listener will call addMarker() when the map is clicked.
		gmap.addListener('click', function(event) {
			var location = event.latLng;

			// Populate the marker on the map
			self.populateMarker(location.lat(), location.lng(), 'addmarker');
		});
	},

	populateMarker: function(lat, lng, action) {
		// We will remove all markers first (if any)
		gmap.removeMarkers();

		// Add the new marker on the map
		var marker = gmap.addMarker({
			lat: lat,
			lng: lng
		});

		gmap.setCenter(lat, lng);

		var currentZoom = gmap.map.zoom;

		// If the current zoom too far,
		// we zoom in a bit
		if (currentZoom < 13) {
			gmap.fitZoom();
			gmap.zoomOut(9);
		}
		
		// If this comes from addmarker action,
		// we need to get the correct address and update the field
		if (action == 'addmarker') {
			self.processMarker(marker);
		}
	},

	processMarker: function(marker, oldMarkerId) {

		markerLat = marker.getPosition().lat();
		markerLng = marker.getPosition().lng();

		// markers[markerId] = marker;

		var markerObj = {
					lat: markerLat,
					lng: markerLng
				}

		// Try to get the address from the given lat lng
		self.lookupLatLng(markerObj);
	},

	updateField: function(markerObj, venue) {

		// Fill in the field with address
		self.textField().val(markerObj.name);

		var location = {
			latitude: markerObj.lat,
			longitude: markerObj.lng,
			fulladdress: venue.formatted_address
		}

		self.currentLocation = location;

		var process = $.Deferred();

		process.resolve(location);

		process.done(function(location) {
			
			// Get the caption
			EasySocial.ajax('site/views/location/getStoryCaption', {
				"address": markerObj.name
			}).done(function(caption) {
				self.story.setMeta("location", caption);
			})

			self.lastQueryAddress = location.fulladdress;

			self.base()
				.removeClass('is-loading')
				.addClass("has-location");
		});
	},

	navigateDynamic: function(lat, lng) {
		self.renderDynamicMap(lat, lng);
		self.populateMarker(lat, lng);
	},

	navigate: function(lat, lng) {

		var apiKey = window.es.gmapsApiKey;

		var mapImage = self.mapImage(),
			width    = mapImage.width(),
			height   = mapImage.height(),
			url =
				$.GMaps.staticMapURL({
					key: apiKey,
					size: [width, height],
					lat: lat,
					lng: lng,
					sensor: true,
					scale: 2,
					markers: [
						{lat: lat, lng: lng}
					]
				});

		$.Image.get(url)
			.done(function() {
				mapImage.css({
					"backgroundImage": $.cssUrl(url),
					"backgroundSize": "cover",
					"backgroundPosition": "center center"
				});

				self.base()
					.removeClass("is-loading")
					.addClass("has-location");
			});
	},

	// Memoized locations
	locations: {},

	lastQueryAddress: null,

	"{textField} keydown": function(textField, event) {

		switch (event.keyCode)
		{
			case KEYCODE.UP:

				var prevSuggestion = $(
					self.suggestion(".active").prev(self.suggestion.selector)[0] ||
					self.suggestion(":last")[0]
				);

				// Remove all active class
				self.suggestion().removeClass("active");

				prevSuggestion
					.addClass("active")
					.trigger("activate");

				self.suggestions()
					.scrollTo(prevSuggestion, {
						offset: prevSuggestion.height() * -1
					});

				event.preventDefault();

				break;

			case KEYCODE.DOWN:

				var nextSuggestion = $(
					self.suggestion(".active").next(self.suggestion.selector)[0] ||
					self.suggestion(":first")[0]
				);

				// Remove all active class
				self.suggestion().removeClass("active");

				nextSuggestion
					.addClass("active")
					.trigger("activate");

				self.suggestions()
					.scrollTo(nextSuggestion, {
						offset: nextSuggestion.height() * -1
					});

				event.preventDefault();

				break;

			case KEYCODE.ENTER:

				var activeSuggestion = self.suggestion(".active"),
					location = activeSuggestion.data("location");
					self.set(location);

				self.hideSuggestions();
				break;

			case KEYCODE.ESCAPE:
				self.hideSuggestions();
				break;
		}

	},

	"{textField} keyup": function(textField, event) {

		switch (event.keyCode) {

			case KEYCODE.UP:
			case KEYCODE.DOWN:
			case KEYCODE.LEFT:
			case KEYCODE.RIGHT:
			case KEYCODE.ENTER:
			case KEYCODE.ESCAPE:
				// Don't repopulate if these keys were pressed.
				break;

			default:
				var address = $.trim(textField.val());

				if (address === "") {
					self.base().removeClass("has-location");
					self.hideSuggestions();
				}

				var locations = self.locations[address];

				// If this location has been searched before
				if (locations) {

					// And set our last queried address to this address
					// so that it won't repopulate the suggestion again.
					self.lastQueryAddress = address;

					// Just use cached results
					self.suggest(locations);

				// Else ask google to find it out for us
				} else {

					self.lookup(address);
				}
				break;
		}
	},

	lookupLatLng: $.debounce(function(markerObj) {

		self.base().addClass("is-loading");

		$.GMaps.geocode({
			lat: markerObj.lat,
			lng: markerObj.lng,
			callback: function(locations, status) {

				self.base().removeClass("is-loading");

				if (status == "OK") {
					markerObj.name = locations[0].formatted_address;
					self.updateField(markerObj, locations[0]);
				}
			}
		});

	}, 250),

	lookup: $.debounce(function(address) {

		self.base().addClass("is-loading");

		EasySocial.ajax('site/controllers/location/getLocations', {
			query: address
		}).done(function(locations) {

			self.base().removeClass("is-loading");

			// Store a copy of the results
			self.locations[address] = locations;

			// Suggestion locations
			self.suggest(locations);

			self.lastQueryAddress = address;
		}).fail(function(msg) {
		});
	}, 250),

	suggest: function(locations) {

		var suggestions = self.suggestions();

		// Clear location suggestions
		suggestions
			.empty();

		if (locations.length < 0) {
			return;
		}

		var items = [];

		$.each(locations, function(i, location) {
			items.push(location.address);
		});

		EasySocial.ajax('site/views/location/format', {
			"locations": items
		}).done(function(rows) {

			$.each(rows, function(i, row) {

				$(row)
					.data('location', locations[i])
					.appendTo(suggestions);
			});
		});

		self.showSuggestions();
	},

	showSuggestions: function() {

		self.focusSuggestion = true;

		self.element.find(".es-story-footer")
			.addClass("swap-zindex");

		self.story.clearMessage();

		setTimeout(function(){

			self.autocomplete().addClass("active");

			var doc = $(document),
				hideOnClick = "click.es.story.location";

			doc
				.off(hideOnClick)
				.on(hideOnClick, function(event){

					// Collect list of bubbled elements
					var targets = $(event.target).parents().andSelf();

					if (targets.filter(self.element).length > 0) return;

					doc.off(hideOnClick);

					self.hideSuggestions();
				});

		}, 500);
	},

	hideSuggestions: function() {

		self.focusSuggestion = false;

		self.autocomplete().removeClass("active");

		$(document).off("click.es.story.location");

		setTimeout(function(){

			if (self.focusSuggestion) return;

			self.element.find(".es-story-footer")
				.removeClass("swap-zindex");

		}, 500);
	},

	"{suggestion} activate": function(suggestion, event) {

		var location = suggestion.data("location");

		var lat = location.latitude,
			lng = location.longitude;

		if (opts.staticMap) {
			self.navigate(lat, lng);
		} else {
			self.navigateDynamic(lat, lng);
		}
	},

	"{suggestion} mouseover": function(suggestion) {

		// Remove all active class
		self.suggestion().removeClass("active");

		suggestion
			.addClass("active")
			.trigger("activate");
	},

	"{suggestion} click": function(suggestion, event) {

		var location = suggestion.data("location");

		self.set(location);

		self.hideSuggestions();
	},

	set: function(location) {

		self.currentLocation = location;

		var process = $.Deferred();

		if ($.isEmpty(location.fulladdress)) {
			self.getAddress(location.latitude, location.longitude)
				.done(function(address) {
					location.fulladdress = location.name + ', ' + address;

					process.resolve(location);
				});
		} else {
			process.resolve(location);
		}

		process.done(function(location) {
			self.navigate(location.latitude, location.longitude);

			// Set the address on the field
			self.textField().val(location.fulladdress);

			self.lastQueryAddress = location.address;

			// Get the caption
			EasySocial.ajax('site/views/location/getStoryCaption', {
				"address": location.fulladdress
			}).done(function(caption) {
				self.story.setMeta("location", caption);
			})


			self.base()
				.removeClass('is-loading')
				.addClass("has-location");
		});
	},

	unset: function() {

		self.currentLocation = null;

		self.textField().val('');

		self.story.removePanelCaption("locations");

		self.mapImage().attr("src", "");

		self.story.setMeta("location", "");

		self.base().removeClass("has-location");
	},

	activatePanel: function() {

		setTimeout(function(){
			self.textField().focus();
		}, 500);
	},

	deactivatePanel: function() {

		var location = self.currentLocation;

		if (location) {
			self.set(location);
		}
	},

	detectTimer: null,

	"{detectButton} click": function() {

		var story = self.story;
		var textbox = self.textbox();

		self.base().addClass("is-loading");

		clearTimeout(self.detectTimer);

		self.detectTimer = setTimeout(function(){
			story.clearMessage();

			EasySocial.ajax('site/views/location/getErrorMessage', {
				"code": 1
			}).done(function(message) {
				story.setMessage(message);

				self.base().removeClass("is-loading");
			});


		}, 8000);



		$.GMaps.geolocate({
			success: function(position) {

				// story.clearMessage();

				EasySocial.ajax('site/controllers/location/getLocations', {
					latitude: position.coords.latitude,
					longitude: position.coords.longitude
				}).done(function(locations) {
					self.suggest(locations);
					self.textField().focus();
				}).fail(function(msg) {
				});
			},
			error: function(error) {

				story.clearMessage();

				EasySocial.ajax('site/views/location/getErrorMessage', {
					"code": error.code
				}).done(function(contents) {
					story.setMessage(contents);
				});
			},
			always: function() {
				clearTimeout(self.detectTimer);
				self.base().removeClass("is-loading");
			}
		});
	},

	"{removeButton} click": function() {
		self.unset();
		self.hideSuggestions();
	},

	"{meta} click": function() {
		self.story.activateMeta("location");
	},

	"{story} activateMeta": function(el, event, meta) {

		if (meta.name==="location") {
			setTimeout(function(){
				self.textField().focus();
			}, 1);
		}
	},

	"{story} save": function(event, element, save) {

		var currentLocation = self.currentLocation;

		if (!currentLocation) return;

		var task = save.addTask('saveLocation');

		if ($.isEmpty(currentLocation.fulladdress)) {
			self.getAddress(currentLocation.latitude, currentLocation.longitude).done(function(address) {
				currentLocation.fulladdress = currentLocation.name + ', ' + address;

				self.save(task, currentLocation);
			});
		} else {
			self.save(task, currentLocation);
		}
	},

	getAddress: $.memoize(function(latitude, longitude) {
		var process = $.Deferred(),
			geocoder = new google.maps.Geocoder(),
			latlng = new google.maps.LatLng(latitude, longitude);

		geocoder.geocode({
			'latLng': latlng
		},
		function(results, status) {
			if (status == google.maps.GeocoderStatus.OK) {
				process.resolve(results[0].formatted_address);
			}
		});

		return process;
	}, function(lat, lng) {
		return lat + ',' + lng;
	}),

	save: function(task, location) {
		task.save.data['locations_short_address'] = location.name;
		task.save.data['locations_lat'] = location.latitude;
		task.save.data['locations_lng'] = location.longitude;
		task.save.data['locations_formatted_address'] = location.fulladdress;
		task.save.data['locations_data'] = JSON.stringify(location);

		task.resolve();
	},

	"{story} clear": function() {
		self.unset();
		self.hideSuggestions();
	}
}});

// Resolve module
module.resolve();

});

});
			EasySocial.module("site/story/mood", function($) {

var module = this;

EasySocial.require()
.done(function() {

	// Constants
	var KEYCODE = {
		BACKSPACE: 8,
		COMMA: 188,
		DELETE: 46,
		DOWN: 40,
		ENTER: 13,
		ESCAPE: 27,
		LEFT: 37,
		RIGHT: 39,
		SPACE: 32,
		TAB: 9,
		UP: 38
	};

	EasySocial.Controller("Story.Mood", {

		defaultOptions: {

			"{base}": "[data-story-mood]",

			"{presets}": "[data-story-mood-presets]",
			"{preset}": "[data-story-mood-preset]",

			"{verb}": "[data-story-mood-verb]",
			"{verbType}": "[data-story-mood-verb-type]",
			"{textField}": "[data-story-mood-textfield]",

			"{removeButton}": "[data-story-mood-remove-button]"
		}
	}, function(self, opts) { return {

		init: function() {

			var currentMood = self.options.currentMood;

			self.reset();

			// Add placeholder support for IE9
			self.textField().placeholder();

			if (currentMood) {
				self.textField()
				.val(currentMood.subjectText)
				.focus();
				
				self.setMood(currentMood);
			}
		},

		setLayout: function() {

			var base = self.base(),
				textField = self.textField();

			base.toggleClass("is-empty", textField.val()==="");
		},

		currentMood: {},

		resetMood: function() {

			self.currentMood = {
				icon: '',
				verb: '',
				subject: '',
				text: '',
				custom: false
			};

			self.preset().removeClass("is-disabled");

			self.story.setMeta("mood", "");
		},

		setMood: function(type, content) {

			var currentMood = self.currentMood;

			if ($.isPlainObject(type)) {
				$.extend(currentMood, type);
			} else {
				currentMood[type] = content;
			}

			// This toggles the preset selection
			self.base().toggleClass("using-preset", !currentMood.custom);

			self.updateMeta();

			self.setLayout();
		},

		getVerb: function() {
			return self.verbType(".active").data("storyMoodVerbType") || "feeling";
		},

		reset: function() {

			self.selecting = true;

			self.resetMood();

			self.preset()
				.removeClass("is-disabled");

			self.textField()
				.val("")
				.focus();

			self.setLayout();

			self.base()
				.removeClass("using-preset hide-preset");

			self.selecting = false;
		},

		updateMeta: function() {

			var currentMood = self.currentMood;
			var icon = currentMood.icon ? '<i class="es-emoji ' + currentMood.icon + '"></i> ' : '';

			self.verbType()
				.removeClass("active")
				.filterBy("storyMoodVerbType", currentMood.verb)
				.addClass("active");

			self.story.setMeta("mood", icon + currentMood.text);
		},

		"{preset} click": function(preset) {

			// Create mood object
			var mood = {
				icon       : preset.data("storyMoodIcon"),
				verb       : preset.data("storyMoodVerb"),
				subject    : preset.data("storyMoodSubject"),
				text       : preset.data("storyMoodText"),
				subjectText: preset.data("storyMoodSubjectText"),
				custom     : false,
			};

			self.selecting = true;

			// Update textfield and refocus
			self.textField()
				.val(mood.subjectText)
				.focus();

			// Update meta
			self.setMood(mood);

			self.selecting = false;
		},

		"{textField} keydown": function(textField, event) {

			self.update();
		},

		"{textField} keyup": function(textField, event) {

			self.update();
		},

		"{textField} input": function(textField, event) {

			// If user is selecting from preset,
			// don't do anything.
			if (self.selecting) return;

			// Get text
			var text = textField.val();

			if (!text) {
				self.reset();
				return;
			}

			// If user modifies a preset, set mood to custom.
			// This *might* cause the preset selection to show if there are matching keywords.
			var currentMood = self.currentMood;
			var presetModified = !currentMood.custom && (text !== currentMood.subjectText);

			if (presetModified) {
				self.setMood("custom", true);
			}

			// Highlight preset candidates
			var candidates =
				self.preset()
					.filter(function(){
						var preset = $(this),
							isDisabled = preset.data("storyMoodSubjectText").indexOf(text) !== 0;
						preset.toggleClass("is-disabled", isDisabled);
						return !isDisabled;
					});

			// Hide preset seleection if there is no candidate
			self.base().toggleClass("hide-preset", candidates.length < 1);


			// Create mood object
			var verb = self.getVerb();

			var mood = {
					verb: verb,
					subject: '',
					custom: true,
					text: self.story.options.moodText + " " + text,
			};

			// Set custom mood
			self.setMood(mood);
		},

		"{removeButton} click": function() {

			self.reset();
		},

		"{story} activateMeta": function(el, event, meta) {

			if (meta.name==="mood") {
				setTimeout(function(){
					self.textField().focus();
				}, 1);
			}
		},

		"{story} save": function(event, element, save) {

			var currentMood = self.currentMood;

			if (!currentMood.verb) return;

			save.data.mood_icon    = currentMood.icon;
			save.data.mood_verb    = currentMood.verb;
			save.data.mood_subject = currentMood.subject;
			save.data.mood_custom  = currentMood.custom;
			save.data.mood_text    = currentMood.text;
		},

		"{story} clear": function() {
			self.reset();
		}
	}});

	// Resolve module
	module.resolve();

});

});			EasySocial.module("site/story/osm", function($){

var module = this;

EasySocial.require()
.library("leaflet", "scrollTo", "image", "leaflet-providers")
.done(function() {

// Constants
var KEYCODE = {
	BACKSPACE: 8,
	COMMA: 188,
	DELETE: 46,
	DOWN: 40,
	ENTER: 13,
	ESCAPE: 27,
	LEFT: 37,
	RIGHT: 39,
	SPACE: 32,
	TAB: 9,
	UP: 38
};

EasySocial.Controller("Story.Osm", {
	defaultOptions: {

		map: {
			lat: 0,
			lng: 0
		},

		mapElementId: 'map',

		"{base}": "[data-story-location]",
		"{form}": "[data-story-location-form]",

		"{textField}": "[data-story-location-textField]",
		"{detectButton}": "[data-story-location-detect-button]",

		"{autocomplete}": "[data-story-location-autocomplete]",
		"{suggestions}": "[data-story-location-suggestions]",
		"{suggestion}": "[data-story-location-suggestion]",

		"{textbox}": "[data-story-location-textbox]",
		"{removeButton}": "[data-story-location-remove-button]",

		"{map}": "[data-story-location-map]",
		"{mapImage}": "[data-story-location-map-image]",

		"{meta}": "[data-story-meta-location]",
	}
}, function(self, opts) { return {

	init: function() {

		var currentLocation = self.options.currentLocation;

		if (self.options.mapElementId) {
			self.mapElementId = self.options.mapElementId;
		}

		// Only show auto-detect button if the browser supports geolocation
		if (navigator.geolocation && window.es.isHttps) {
			self.base().addClass("is-detectable");
			self.detectButton().show();
		}

		// Add placeholder support for IE9
		self.textField().placeholder();

		// Allow textfield input only when controller is implemented
		self.textField().removeAttr("disabled");

		if (currentLocation) {
			self.story.activateMeta('location');
			self.initMap();
			self.set(currentLocation);
		}
	},

	initMap: function() {

		self.osm = L.map(self.mapElementId, {
			zoom: 12
		});

		self.osm.fitWorld();

		// Esri.WorldImagery | HikeBike.HikeBike | CartoDB.Voyager | OpenStreetMap.Mapnik
		L.tileLayer.provider('Wikimedia').addTo(self.osm);

		// Add placeholder support for IE9
		self.textField().placeholder();

		// Allow textField input only when controller is implemented
		self.textField().removeAttr("disabled");

		function onMapClick(e) {
			var latlng = e.latlng;

			self.osm.removeLayer(self.marker);
			self.marker = L.marker(latlng).addTo(self.osm);
			self.osm.setView(latlng);
			self.lookupLatLng(latlng);
		}

		self.osm.on('click', onMapClick);
	},

	"{window} resize": $.debounce(function() {

		var currentLocation = self.currentLocation;

		if (!currentLocation) return;

		var mapImage = self.mapImage();

		if (mapImage.data("width") !== mapImage.width()) {
			self.navigate(currentLocation.latitude, currentLocation.longitude);
		}

	}, 250),

	updateField: function(result) {

		// Fill in the field with address
		self.textField().val(result[0].name);

		result = result[0];

		var location = {
			latitude: result.latitude,
			longitude: result.longitude,
			fulladdress: result.formatted_address,
			formatted_address: result.formatted_address,
			name: result.formatted_address,
			address: result.address
		}

		self.currentLocation = location;

		var process = $.Deferred();

		process.resolve(location);

		process.done(function(location) {

			// Get the caption
			EasySocial.ajax('site/views/location/getStoryCaption', {
				"address": result.name
			}).done(function(caption) {
				self.story.setMeta("location", caption);
			})

			self.lastQueryAddress = location.fulladdress;

			self.base()
				.removeClass('is-loading')
				.addClass("has-location");
		});
	},


	navigate: function(lat, lng) {
		self.detectButton().addClass("t-hidden");

		var latlng = {
					lat: parseFloat(lat),
					lng: parseFloat(lng)
				}

		if (self.marker !== undefined) {
			self.osm.removeLayer(self.marker);
		}

		self.osm.flyTo(latlng, 10, {
			"duration": 3
		});

		self.marker = L.marker(latlng).addTo(self.osm);
	},

	// Memoized locations
	locations: {},

	lastQueryAddress: null,

	"{textField} keydown": function(textField, event) {

		switch (event.keyCode)
		{
			case KEYCODE.UP:

				var prevSuggestion = $(
					self.suggestion(".active").prev(self.suggestion.selector)[0] ||
					self.suggestion(":last")[0]
				);

				// Remove all active class
				self.suggestion().removeClass("active");

				prevSuggestion
					.addClass("active")
					.trigger("activate");

				self.suggestions()
					.scrollTo(prevSuggestion, {
						offset: prevSuggestion.height() * -1
					});

				event.preventDefault();

				break;

			case KEYCODE.DOWN:

				var nextSuggestion = $(
					self.suggestion(".active").next(self.suggestion.selector)[0] ||
					self.suggestion(":first")[0]
				);

				// Remove all active class
				self.suggestion().removeClass("active");

				nextSuggestion
					.addClass("active")
					.trigger("activate");

				self.suggestions()
					.scrollTo(nextSuggestion, {
						offset: nextSuggestion.height() * -1
					});

				event.preventDefault();

				break;

			case KEYCODE.ENTER:

				var activeSuggestion = self.suggestion(".active"),
					location = activeSuggestion.data("location");

					if (location !== undefined) {
						self.set(location);
					}

				self.hideSuggestions();
				break;

			case KEYCODE.ESCAPE:
				self.hideSuggestions();
				break;
		}

	},

	"{textField} keyup": function(textField, event) {

		switch (event.keyCode) {

			case KEYCODE.UP:
			case KEYCODE.DOWN:
			case KEYCODE.LEFT:
			case KEYCODE.RIGHT:
			case KEYCODE.ENTER:
			case KEYCODE.ESCAPE:
				// Don't repopulate if these keys were pressed.
				break;

			default:
				var address = $.trim(textField.val());

				if (address === "") {
					self.base().removeClass("has-location");
					self.hideSuggestions();
				}

				var locations = self.locations[address];

				// If this location has been searched before
				if (locations) {

					// And set our last queried address to this address
					// so that it won't repopulate the suggestion again.
					self.lastQueryAddress = address;

					// Just use cached results
					self.suggest(locations);

				// Else ask google to find it out for us
				} else {
					self.lookup(address);
				}
				break;
		}
	},

	lookupLatLng: $.debounce(function(latlng) {

		self.base().addClass("is-loading");

		EasySocial.ajax('site/controllers/location/getLocations', {
			latitude: latlng.lat,
			longitude: latlng.lng
		})
		.done(function(result) {
			self.base().removeClass("is-loading");
			self.updateField(result);
		});

	}, 250),

	lookup: $.debounce(function(address) {

		// self.detectButton().addClass("is-loading");
		self.base().addClass("is-loading");

		EasySocial.ajax('site/controllers/location/getLocations', {
			query: address
		})
		.done(function(locations) {

			// Store a copy of the results
			self.locations[address] = locations;

			// Suggestion locations
			self.suggest(locations);

			self.lastQueryAddress = address;
		});

	}, 250),

	suggest: function(locations) {

		var suggestions = self.suggestions();

		// Clear location suggestions
		suggestions
			.empty();

		if (locations.length < 0) {
			return;
		}

		var items = [];

		$.each(locations, function(i, location) {
			items.push(location.formatted_address);
		});

		EasySocial.ajax('site/views/location/format', {
			"locations": items
		}).done(function(rows) {

			$.each(rows, function(i, row) {

				$(row)
					.data('location', locations[i])
					.appendTo(suggestions);
			});
		});

		self.showSuggestions();

		self.base().removeClass("is-loading");
	},

	showSuggestions: function() {

		self.focusSuggestion = true;

		self.element.find(".es-story-footer")
			.addClass("swap-zindex");

		self.story.clearMessage();

		setTimeout(function(){

			self.autocomplete().addClass("active");

			var doc = $(document),
				hideOnClick = "click.es.story.location";

			doc
				.off(hideOnClick)
				.on(hideOnClick, function(event){

					// Collect list of bubbled elements
					var targets = $(event.target).parents().andSelf();

					if (targets.filter(self.element).length > 0) return;

					doc.off(hideOnClick);

					self.hideSuggestions();
				});

		}, 500);
	},

	hideSuggestions: function() {

		self.focusSuggestion = false;

		self.autocomplete().removeClass("active");

		$(document).off("click.es.story.location");

		setTimeout(function(){

			if (self.focusSuggestion) return;

			self.element.find(".es-story-footer")
				.removeClass("swap-zindex");

		}, 500);
	},

	"{suggestion} activate": function(suggestion, event) {
		if (self.osm === undefined) {
			self.initMap();
		}

		var location = suggestion.data("location");

		var lat = location.latitude,
			lng = location.longitude;

		self.navigate(lat, lng);
	},

	"{suggestion} mouseover": function(suggestion) {

		// Remove all active class
		self.suggestion().removeClass("active");

		suggestion
			.addClass("active")
			.trigger("activate");
	},

	"{suggestion} click": function(suggestion, event) {
		if (self.osm === undefined) {
			self.initMap();
		}

		var location = suggestion.data("location");

		self.set(location);

		self.hideSuggestions();
	},

	set: function(location) {
		self.currentLocation = location;
		location.fulladdress = location.name;

		self.navigate(location.latitude, location.longitude);

		// Set the address on the field
		self.textField().val(location.fulladdress);

		self.lastQueryAddress = location.address;

		// Get the caption
		EasySocial.ajax('site/views/location/getStoryCaption', {
			"address": location.fulladdress
		}).done(function(caption) {
			self.story.setMeta("location", caption);
		})

		self.base()
			.removeClass('is-loading')
			.addClass("has-location");
	},

	unset: function() {

		if (self.marker !== undefined) {
			self.osm.removeLayer(self.marker);
		}

		self.currentLocation = null;

		self.textField().val('');

		self.story.removePanelCaption("locations");

		self.story.setMeta("location", "");

		self.base().removeClass("has-location");
	},

	activatePanel: function() {

		setTimeout(function(){
			self.textField().focus();
		}, 500);
	},

	deactivatePanel: function() {

		var location = self.currentLocation;

		if (location) {
			self.set(location);
		}
	},

	detectTimer: null,

	"{detectButton} click": function() {
		self.detectButton().addClass("is-loading");
		self.initMap();
		self.osm.locate();
		self.osm.on('locationfound', function(e) {
			self.detectButton().removeClass('is-loading');
			lat = e.latitude,
			lng = e.longitude;

			self.navigate(lat, lng);
			self.lookupLatLng(e.latlng);
		});
	},

	"{removeButton} click": function() {
		self.unset();
		self.hideSuggestions();
	},

	"{meta} click": function() {
		self.story.activateMeta("location");
	},

	"{story} activateMeta": function(el, event, meta) {

		if (meta.name==="location") {
			setTimeout(function(){
				self.textField().focus();
			}, 1);
		}
	},

	"{story} save": function(event, element, save) {

		var currentLocation = self.currentLocation;

		if (!currentLocation) return;

		var task = save.addTask('saveLocation');

		self.save(task, currentLocation);
	},

	save: function(task, location) {
		task.save.data['locations_short_address'] = location.name;
		task.save.data['locations_lat'] = location.latitude;
		task.save.data['locations_lng'] = location.longitude;
		task.save.data['locations_formatted_address'] = location.fulladdress;
		task.save.data['locations_data'] = JSON.stringify(location);

		task.resolve();
	},

	"{story} clear": function() {
		self.unset();
		self.hideSuggestions();

		if (self.osm !== undefined) {
			self.osm.remove();
			delete self.osm;
		}

		self.detectButton().removeClass("t-hidden");

	}
}});

// Resolve module
module.resolve();

});

});
			EasySocial.module("site/story/photos", function($){

var module = this;

EasySocial.require()
.script("site/albums/uploader")
.done(function() {

	EasySocial.Controller("Story.Photos", {
			defaultOptions: {

				"{albumView}"     : "[data-album-view]",
				"{albumContent}"  : "[data-album-content]",
				"{uploadButton}"  : "[data-album-upload-button]",

				"{photoItemGroup}": "[data-photo-item-group]",
				"{photoNewItem}"     : "[data-photo-item][data-photo-edit='0']",
				"{photoItem}"     : "[data-photo-item]",
				"{photoImage}"    : "[data-photo-image]",
				"{photoRemoveButton}": "[data-photo-remove-button]",
				"{uploadItem}"    : "[data-photo-upload-item]",

				"{uploadRemoveButton}": ".upload-remove-button",
			}
		}, function(self, opts) { return {

			init: function() {
				// I have access to:
				// self.story
				// self.attachmentButton()
				// self.attachmentItem()
				// self.attachmentContent()
				// self.attachmentToolbar()
				// self.attachmentDragHandle()
				// self.attachmentRemoveButton()

				opts.photosRemove = [];

				self.uploader =
					self.albumView()
						.addController(
							EasySocial.Controller.Albums.Uploader,
							$.extend({
								"{uploadButton}"   : self.uploadButton.selector,
								"{uploadItemGroup}": self.photoItemGroup.selector,
								"{uploadDropsite}" : self.albumContent.selector
							},
							{settings: self.options.uploader})
						);

				// Difference from album viewer
				self.photoItemGroup()
					.css("opacity", 1);

				self.addPlugin("uploader", self.uploader);

				self.setLayout();
			},

			hasItems: function() {

				var hasPhotoItem  = self.photoItem().length > 0,
					hasUploadItem = self.uploadItem().length > 0;

				return hasPhotoItem || hasUploadItem;
			},

			setLayout: function() {

				// Show upload hint when content is empty
				self.albumView()
					.toggleClass("has-photos", self.hasItems());
			},

			activateAttachment: function() {
			},

			removePhoto: function(id) {

				// Remove photo item
				var photo = self.photoItem()
					.filterBy('photoId', id);

				// When there is one photo left, need to notify users that this is a photo stream item
				// Remove is not allowed
				// For edit photo stream item only
				if (self.story.isEdit) {
					var photoItemCount = self.photoItem().length;

					if (photoItemCount == '1') {
						var message = opts.errors['noEmptyAllowed'];
						return self.story.setMessage(message, "error");
					}
				}

				if (photo.data('photoEdit') == '1') {
					// only if this is a existing photo.
					opts.photosRemove.push(id);
				}

				photo.remove();

				self.setLayout();
			},

			clearPhoto: function(){

				self.photoItem().remove();
				self.uploadItem().remove();

				self.setLayout();
			},

			"{uploader} FilesAdded": function() {

				self.setLayout();
				self.uploader.start();
			},

			"{uploader} FileUploaded": function(el, event, uploader, file, response) {

				var uploadItem = self.uploader.getItem(file);
				var photoItem = $($.parseHTML($.trim(response.html)));
				var photoData = response.data;

				// Initialize photo item
				photoItem
					.data("photo", photoData)
					.addClass("new-item")
					.insertAfter(uploadItem.element);

					self.uploader.removeItem(file.id);

					self.setLayout();

					setTimeout(function(){
						photoItem.removeClass("new-item");
					}, 1);

					self.save();
			},

			"{uploader} FileError": function(el, event, uploader, file, response) {

				self.story.setMessage(response.message, "error");

				var uploadingPhoto = self.uploadingPhoto;

				if (uploadingPhoto) {
					uploadingPhoto.reject();
					delete self.uploadingPhoto;
				}

				self.uploader.removeItem(file.id);

				self.setLayout();
			},

			"{uploader} Error": function(el, event, uploader, error) {

				var message = opts.errors[error.code] || error.message;
				self.story.setMessage(message, "error");

				var uploadingPhoto = self.uploadingPhoto;

				if (uploadingPhoto) {
					uploadingPhoto.reject();
					delete self.uploadingPhoto;
				}

				// Temporary workaround. Delegated event don't work
				// because the element has been removed.
				self.uploadRemoveButton()
					.click(function(){
						setTimeout(function(){
							self.setLayout();
						}, 1);
					});

				self.setLayout();
			},

			"{photoRemoveButton} click": function(photoRemoveButton) {

				var photoId =
					photoRemoveButton
						.parent(self.photoItem.selector)
						.data("photoId");

				self.removePhoto(photoId);
			},

			//
			// Saving
			//

			"{story} save": function(element, event, save) {

				if (!self.hasItems()) {
					return;
				}

				self.uploadingPhoto = save.addTask("uploadingPhoto");
				self.save();
			},

			save: function() {

				var uploadingPhoto = self.uploadingPhoto;

				if (!uploadingPhoto) return;

				var uploadItems = self.uploadItem();

				if (uploadItems.length < 1) {

					var photos = [],
						save = uploadingPhoto.save;

					self.photoNewItem().each(function(){
						photos.push($(this).data("photoId"));
					});


					if (opts.photosRemove.length > 0) {
						$.each(opts.photosRemove, function(idx, val){
							var remove = {'remove':val};
							photos.push(remove);
						});
					}

					save.addData(self, photos);

					uploadingPhoto.resolve();

					delete self.uploadingPhoto;
				}
			},

			"{story} clear": function() {

				self.clearPhoto();
			}
		}}
	);

	// Resolve module
	module.resolve();

});
});
			EasySocial.module('site/story/polls', function($) {

var module = this;

EasySocial.Controller('Story.Polls', {
	defaultOptions: {
		tmpForm: null,
		'{storyForm}': '[data-story-polls-form]',
		'{polls}': '[data-polls-form]'
	}
}, function(self, opts) { return {

	init: function() {

		// Clone initial form
		opts.tmpForm = self.storyForm().clone().html();
	},

	'{story} save': function(element, event, save) {

		if (save.currentPanel != 'polls') {
			return;
		}

		var pollController = self.polls().controller('EasySocial.Controller.Polls.Form');

		self.options.name = 'polls';

		var task = save.addTask('validatePollsForm');
		self.save(task, pollController);
	},

	save: function(task, pollController) {

		var valid = pollController.validateForm();

		if (!valid) {
			return task.reject(opts.error);
		}

		var data = pollController.toData();
		task.save.addData(self, data);

		task.resolve();
	},

	'{story} clear': function(element, event, clear) {
		self.storyForm().html(opts.tmpForm);

		var pollsForm = self.storyForm().find('[data-polls-form]');
		var controller = pollsForm.addController('EasySocial.Controller.Polls.Form');

		// Re-initialize the controller
		controller.init();
	}
}});

module.resolve();

});			EasySocial.module("site/story/story", function($){
var module = this;

// Non-essential dependencies
EasySocial.require()
.script(
	"site/story/gmaps",
	"site/story/friends",
	"site/story/mood",
	"site/story/osm"
);

EasySocial.require()
.library("mentions", "placeholder")
.done(function() {

EasySocial.Controller("Story", {
hostname: "story",
defaultOptions: {
	"plugin": {
		"text": {
			id: "text",
			name: "text",
			selector: "[data-story-plugin-name=photos]",
			type: "panel"
		}
	},

	sourceView: null,

	attachment: {
		limit: 1,
		lifo: true
	},

	flood: {
		enabled: false,
		interval: 90,
		submit: true,
	},

	enterToSubmit: false,
	hashtagEditable: false,
	singlePanel: false,
	emoticons: [],

	// Containers
	"{body}": "[data-body]",
	"{footer}": "[data-footer]",

	"{form}": "[data-story-form]",
	"{textbox}": "[data-story-textbox]",
	"{textField}": "[data-story-textField]",
	"{target}": "[data-story-target]",

	"{cluster}"      : "[data-story-cluster]",
	"{clusterType}"  : "[data-story-clustertype]",
	"{clusterPrivacy}" : "[data-story-clusterprivacy]",

	"{anywhereId}"  : "[data-story-anywhere]",

	"{submitButton}": "[data-story-submit]",
	"{privacyButton}": "[data-story-privacy]",
	"{postAsButton}": "[data-postas-toggle]",

	// Panels
	"{panelContents}": "[data-story-panel-contents]",
	"{panelContent}": "[data-story-panel-content]",
	"{panelButton}": "[data-story-panel-button]",

	"{friends}": "[data-story-friends]",
	"{location}": "[data-story-location]",
	"{mood}": "[data-story-mood]",
	"{autopost}": "[data-story-autopost]",

	// Custom Backgrounds
	"{background}": "[data-background-select]",
	"{currentBackground}": "[data-background-current]",
	"{resetBackground}": "[data-background-reset]",

	// Story params
	"{params}": "[data-story-params]",

	// Mentions
	"{mentionsOverlay}": "[data-mentions-overlay]",
	"{mentionsMetaOverlay}": "[data-mentions-meta-overlay]",

	// Giphy
	'{giphyBrowser}': '[data-giphy-browser]',
	"{giphyWrapper}": "[data-story-giphy]",
	'{giphyPlaceholder}': '[data-giphy-placeholder]',
	'{giphyPreview}': '[data-giphy-preview]',
	'{giphyRemove}': '[data-giphy-remove]',
	'{giphyForm}': '[data-giphy-browser]',
	'{insertGiphy}': '[data-giphy-item]',
	'{giphyLoader}': '[data-giphy-loader]',
	'{giphyLoaderWrapper}': '[data-giphy-wrapper]',
	'{giphyMetaContent}': '[data-story-meta-content=giphy]',

	// Meta
	"{meta}": "[data-story-meta]",
	"{metaContents}": "[data-story-meta-contents]",
	"{metaContent}" : "[data-story-meta-content]",
	"{metaButtons}" : "[data-story-meta-buttons]",
	"{metaButton}"  : "[data-story-meta-button]",

	// Hints
	"{tagHints}": "[data-hints-hashtags]",
	"{friendHints}": "[data-hints-friends]",
	"{emoticonHints}": "[data-hints-emoticons]",

	"{plusButton}": "[data-story-panel-add]",
	"{giphyButton}": "[data-story-giphy-meta-button]"
}

}, function(self, opts, base) { return {

	init: function() {
		// Find out what's my story id
		self.id = base.data("story");

		self.streamId = base.data('stream-id');
		self.isModule = base.data('story-module');

		self.isEdit = false;

		if (self.streamId) {
			self.isEdit = self.streamId;
		}

		if (self.isEdit) {
			self.initMention();
		} else {
			if (opts.flood.enabled && !opts.flood.submit) {
				self.lockSubmitButton(opts.flood.interval);
			}
		}

		var tmpPluginName = '';
		var totalPlugin = 0;

		// Create plugin repository
		$.each(self.options.plugin, function(pluginName, pluginOptions) {

			var plugin = self.plugins[pluginName] = pluginOptions;

			// Pre-count the number of available attachment type
			if (plugin.type=="attachment") {
				self.attachments.max++;
			}

			// Add selector property
			plugin.selector = self.getPluginSelector(pluginName);

			tmpPluginName = pluginName;

			if (self.options.singlePanel && pluginName != 'text') {
				totalPlugin++;
			}
		});

		if ((self.isEdit || totalPlugin == 1) && tmpPluginName != 'text') {
			// lets activite the panel
			self.activatePanel(tmpPluginName);
		}

		// Set mentions
		self.setMentionsLayout();

		// Implement friends plugin
		if (self.friends().length > 0) {
			var clusterId = self.cluster().val();
			var clusterType = self.clusterType().val();
			var privacyType = self.clusterPrivacy().val();
			var options = {};

			// Private cluster should only retrieve the member list
			if (privacyType == 2 || privacyType == 3) {
				namespace = 'site/controllers/friends/suggestClusterMembers';
				options = {
					namespace : namespace,
					clusterId : clusterId,
					clusterType : clusterType
				}
			}

			EasySocial.module("site/story/friends")
				.done(function(){
					self.addPlugin("friends", options);

					if (self.isEdit) {

						var friends = self.friends().find('[data-textboxlist-item]');

						var ids = [];

						friends.each(function(){
							var id = $(this).data("id");

							ids.push(id);
						});

						EasySocial.ajax('site/views/story/buildStoryMeta', {
							"ids": ids
						}).done(function(caption) {
							self.setMeta('friends', caption);
						});
					}

				});
		}

		if (self.location().length > 0) {

			var location = false;

			var currentLocation = self.options.currentLocation;
			var mapElementId = self.options.mapElementId;

			if (self.isEdit && currentLocation) {
				location = currentLocation
			}

			if (self.options.mapIntegration !== 'osm') {
				EasySocial.module("site/story/gmaps")
					.done(function(){
						self.addPlugin("gmaps", {
							currentLocation: location
						});
					});
			} else {
				EasySocial.module("site/story/osm")
				.done(function(){
					self.addPlugin("osm", {
						currentLocation: location,
						mapElementId: mapElementId
					});
				});
			}
		}

		// If there is giphy, should always show giphy first during edit stream item
		if (self.options.currentGiphy) {
			if (self.activateMeta('location')) {
				self.deactivateMeta('location');
			}

			self.activateMeta('giphy');
		}

		if (self.mood().length > 0) {

			var mood = false;

			var currentMood = self.options.currentMood;

			if (self.isEdit && currentMood) {
				mood = currentMood
			}

			EasySocial.module("site/story/mood")
				.done(function(){
					self.addPlugin("mood", {
						currentMood: mood
					});
				});
		}

		// Remember placeholder value (used by meta)
		self.placeholder = self.textField().attr("placeholder");

		// Duckpunch setMessage
		self._setMessage = self.setMessage;

		self.setMessage = function() {

			// Do not set any messages when story is collapsed or is resizing.
			if (base.hasClass("is-resizing")) {
				return;
			}

			// Remove any previous message group first to avoid stacking error messages.
			this.element
				.find('[data-message-group]')
				.remove();

			self._setMessage.apply(this, arguments);
		};

		// Show placeholder shim for ie9
		if (navigator.userAgent.match(/MSIE 9.0/i)) {
			base.addClass("is-ie");
		}

		// Resolve story instance
		$.module("story-" + self.id).resolve(self);
	},

	"{resetBackground} click": function(element, event) {
		var body = self.body().find('.es-story-text');
		var panel = self.body().find('> .es-story-panel-content');

		body.attr('class', 'es-story-text');
		panel.attr('class', 'es-story-panel-content');

		// Set the active background
		self.currentBackground()
			.attr('class', 'es-story-bg-menu-preview')
			.data('id', '');
	},

	"{background} click": function(element, event) {
		var id = element.data('id');
		var body = self.body().find('.es-story-text');
		var panel = self.body().find('> .es-story-panel-content');

		body.attr('class', 'es-story-text es-story--bg-' + id);
		panel.attr('class', 'es-story-panel-content es-story--bg-' + id);

		// Set the active background
		self.currentBackground()
			.attr('class', 'es-story-bg-menu-preview es-story--bg-' + id)
			.data('id', id);
	},

	giphyURL: null,

	"{insertGiphy} click": function(el) {
		var giphyUrl = el.data('original');

		self.insertGiphyUrl(giphyUrl);
	},

	insertGiphyUrl: function(url) {

		// Add preview
		self.giphyPreview().attr('src', url);

		self.giphyLoader().removeClass('t-hidden');

		self.giphyLoaderWrapper().addClass('is-loading');

		self.giphyPlaceholder().css('width', '100%');

		self.giphyPreview()
			.off('load')
				.on('load', function() {
					self.giphyLoaderWrapper().removeClass('is-loading');
					self.giphyLoaderWrapper().addClass('t-hidden');

					self.giphyPlaceholder().removeClass('t-hidden');

					self.giphyForm().addClass('t-hidden');

					var parent = $(this).parent();

					// Display the placeholder and set the width given the width of the image
					setTimeout(function() {
						var computedWidth = parent.css('width');

						self.giphyPlaceholder().css('width', computedWidth);
					}, 10);
				});

		self.giphyURL = url;
	},

	"{giphyRemove} click": function(el) {
		self.removeGiphy();
	},

	"{self} click": function(element, event) {

		if ($(event.target).parents().andSelf().length > 0) {
			return;
		}

		self.expand();
	},

	removeGiphy: function() {
		self.giphyURL = '';

		// Hide preview
		self.giphyPlaceholder().addClass('t-hidden');

		// Remove background
		self.giphyPreview().attr('src', '');

		self.giphyForm().removeClass('t-hidden');

		self.giphyLoaderWrapper().removeClass('t-hidden');

		// If this is from edit stream item and the giphy has been removed
		if (opts.currentGiphy) {
			self.giphyWrapper().removeClass('t-hidden');
		}

		opts.currentGiphy = null;
	},

	"{textField} touchstart": function() {
		self.expand();
	},

	"{textField} keydown": function(textField, event) {
		self.expand();
	},

	"{textField} click": function(textField, event) {
		self.expand();

		if (!opts.hashtagEditable) {
			self.preventHashtagEdit(textField, event);
		}
	},

	"{textField} dragstart": function(textField, event) {
		// Prevent drag in textarea
		event.preventDefault();
	},

	"{textField} mousedown": function(textField, event) {
		self.expand();
	},

	"{textField} keydown": function(textField, event) {

		// Bind cmd + enter key to submit
		// If pressing enter submits form
		// And enter key was pressed
		// Without any meta keys involved
		if (((event.metaKey || event.ctrlKey) && event.keyCode == 13) || (opts.enterToSubmit && event.keyCode==13 && !(event.shiftKey || event.altKey || event.ctrlKey || event.metaKey))) {
			self.save();
			event.preventDefault();
		}

		// Prevent the hashtag from being deleted.
		if (!opts.hashtagEditable) {
			self.preventHashtagEdit(textField, event);
		}
	},

	"{textField} paste": function(textField, event) {
		// Prevent the hashtag from being deleted.
		if (!opts.hashtagEditable) {
			self.preventHashtagEdit(textField, event);
		}
	},

	"{textField} focus": function(textField, event) {
		self.setTextboxCaret(textField);
	},

	setTextboxCaret: function(textField) {

		if (self.isEdit) {
			return;
		}

		var value = $(textField).data('default');
		var textvalue = textField.val();

		if (value.length == 0 || value.length != textvalue.length) {
			return;
		}

		var textbox = self.textbox();
		var mentions = textbox.controller("mentions");

		var markers = mentions.getMarkers();

		var lastMarker = null;

		$.each(markers, function() {
			var marker = this;

			if (marker.length >= 1 ) {
				lastMarker = marker;
			}
		});

		if (lastMarker != null) {
			var $textarea = $(lastMarker.textarea);
			var pos = lastMarker.start + lastMarker.length;

			var value = $(textField).data('default');
			var textvalue = textField.val();
			$textarea.caret(pos);
		}
	},

	expand: $.debounce(function() {

		if (base.hasClass("is-expanded") || base.hasClass("is-resizing")) {
			return;
		}
		var transitionEnd = $.support && $.support.transition && $.support.transition.end,
			transitionEvent = (transitionEnd || "transitionend") + ".es.story",
			finalize = $.debounce(function(){

				base.off(transitionEvent)
					.addClass("is-expanded")
					.removeClass("is-resizing")

				// Executes only once
				self.setMentionsLayout();
				self.submitButton().removeAttr("data-disabled");
				self.textField().focus();
			}, 1);

		if (transitionEnd) {
			base.on(transitionEvent, finalize);
		} else {
			setTimeout(finalize, 600);
		}

		// The CSS transition in this class expands the textarea
		base.removeClass("is-collapsed")
			.addClass("is-resizing");
	}, 1),

	preventHashtagEdit: function(textField, event) {
		var value = $(textField).data('default');
		var textbox = self.textbox();
		var mentions = textbox.controller("mentions");
		var markers = mentions.getMarkers();

		var lastMarker = null;

		$.each(markers, function() {
			var marker = this;

			if (marker.length >= 1 ) {
				lastMarker = marker;
			}
		});

		if (lastMarker != null) {
			var $textarea = $(lastMarker.textarea);
			var currentPos = $textarea.caret().start;

			// prevent backspace
			if (event.keyCode == 8 && currentPos == value.length) {
				event.preventDefault();
			}

			// Automatically move the cursor at the end of the tags.
			if (currentPos < value.length) {
				var pos = lastMarker.start + lastMarker.length;
				$textarea.caret(pos);

				textValue = textField.val();
				endPos = $textarea.caret().end;

				// user are trying to delete the entire content
				if (endPos == textValue.length) {
					mentions.reset();
				} else {
					event.preventDefault();
				}
			}
		}

		// Prevent new hashtag from being registered into the content
		if (event.keyCode == 51 && event.shiftKey) {
			event.preventDefault();
		}
	},

	collapse: function() {

		if (base.hasClass("is-collapsed") || base.hasClass("is-resizing")) {
			return;
		}

		base.addClass("is-resizing")
			.removeClass("is-expanded");

		// Reset the text
		self.clear();
		self.textField().blur();

		setTimeout(function(){
			base.addClass("is-collapsed")
				.removeClass("is-resizing");
		}, 1);
	},

	initMention: function() {

		var textbox = self.find('[data-story-textbox]');
		var mentions = textbox.controller("mentions");

		if (mentions) {
			mentions.cloneLayout();
			// return;
		} else {

			// Try to find for hints that may already be available on the page.
			var hashtagsHints = $('[data-hints-hashtags]');
			var friendsHints = $('[data-hints-friends]');
			var emoticonsHints = $('[data-hints-emoticons]');
			var autocompleteHints = $('[data-hints-autocomplete]');

			// override the autocomplete hint
			$.template("mentions/xsearchHint", autocompleteHints.find('[data-search]').html());
			$.template("mentions/xemptyHint", autocompleteHints.find('[data-empty]').html());

			textbox
				.mentions({
					triggers: {
						"@": {
							type: "entity",
							wrap: false,
							stop: "",
							allowSpace: true,
							finalize: true,
							query: {
								loadingHint: true,
								searchHint: friendsHints.find('[data-search]'),
								emptyHint: friendsHints.find('[data-empty]'),
								data: function(keyword) {

									var task = $.Deferred();
									var namespace = 'site/controllers/friends/suggest';
									var options = {search: keyword};
									var clusterId = self.cluster().val();

									// Cluster mention
									if (clusterId) {
										var privacyType = self.clusterPrivacy().val();

										// Private cluster should only retrieve the member list
										if (privacyType == 2 || privacyType == 3) {
											namespace = 'site/controllers/friends/suggestClusterMembers';
											options = {
												search: keyword,
												clusterId : clusterId,
												clusterType : self.clusterType().val()
											}
										}
									}

									EasySocial.ajax(namespace, options)
										.done(function(items){

											if (!$.isArray(items)) {
												task.reject();
											}

											var items = $.map(items, function(item){

												var html = $('<div/>').html(item);
												var title = html.find('[data-suggest-title]').val();
												var id = html.find('[data-suggest-id]').val();

												return {
													"id": id,
													"title": title,
													"type": "user",
													"menuHtml": item
												};
											});

											task.resolve(items);
										})
										.fail(task.reject);

									return task;
								},
								use: function(item) {
									return item.type + ":" + item.id;
								}
							}
						},
						"#": {
							type: "hashtag",
							wrap: true,
							stop: " #",
							allowSpace: false,
							query: {
								loadingHint: true,
								searchHint: hashtagsHints.find('[data-search]'),
								emptyHint: hashtagsHints.find('[data-empty]'),
								data: function(keyword) {

									var task = $.Deferred();

									EasySocial.ajax("site/controllers/hashtags/suggest", {search: keyword})
										.done(function(items){

											if (!$.isArray(items)) {
												task.reject();
											}

											var items = $.map(items, function(item) {

												return {
													"title": "#" + item,
													"type": "hashtag",
													"menuHtml": item
												};
											});

											task.resolve(items);
										})
										.fail(task.reject);

									return task;
								}
							}
						},
						":": {
							type: "emoticon",
							wrap: true,
							stop: "",
							allowSpace: false,
							query: {
								loadingHint: true,
								searchHint: emoticonsHints.find('[data-search]').html(),
								emptyHint: emoticonsHints.find('[data-empty]').html(),
								data: $.parseJSON(self.options.emoticons),
								renderAll: true
							}
						}
					},
					plugin: {
						autocomplete: {
							id: "es",
							component: "es",
							modifier: "es-story-mentions-autocomplete",
							sticky: true,
							shadow: true,
							position: {
								my: 'left top',
								at: 'left bottom',
								of: self.find('.es-story-text'),
								collision: 'none'
							},
							view: {
								searchHint: "mentions/xsearchHint",
								emptyHint: "mentions/xemptyHint",
							}
						}
					}
				});
		}
	},

	setMentionsLayout: function() {

		var textbox = self.textbox();
		var mentions = textbox.controller("mentions");

		if (mentions) {
			var mentionedItems = self.options.mentionedItems;

			if (self.isEdit && mentionedItems) {

				var markers = mentions.getMarkers();

				$.each(markers, function() {

					var marker = this;

					$.each(mentionedItems, function() {
						var mention = this;

						if (marker.start == mention.start && marker.length == mention.length) {

							var text = marker.val();

							var textValue = 'user' + ':' + mention.userId;
							var trigger = mentions.getTriggerFromType('entity');

							if (text.charAt(0) == '#') {
								var trigger = mentions.getTriggerFromType('hashtag');
								var textValue = text.substring(1);
							}

							if (text.charAt(0) == ':') {
								var trigger = mentions.getTriggerFromType('emoticon');
								var textValue = text.substring(1);
							}

							var data = $(marker.block).data("marker");
							data.trigger = trigger;

							// update marker's value
							marker.updateValue(textValue);
						}
					});
				});
			}

			mentions.cloneLayout();
			return;
		}


		var body = self.body();

		textbox.mentions({
			"triggers": {
				"@": {
					"type": "entity",
					"wrap": false,
					"stop": "",
					"allowSpace": true,
					"finalize": true,
					"query": {

							loadingHint: true,
							searchHint: self.friendHints().find('[data-search]').html(),
							emptyHint: self.friendHints().find('[data-empty]').html(),
							data: function(keyword) {

								var task = $.Deferred();
								var namespace = 'site/controllers/friends/suggest';
								var options = {search: keyword};
								var clusterId = self.cluster().val();

								// Cluster mention
								if (clusterId) {
									var privacyType = self.clusterPrivacy().val();

									// Private cluster should only retrieve the member list
									if (privacyType == 2 || privacyType == 3) {
										namespace = 'site/controllers/friends/suggestClusterMembers';
										options = {
											search: keyword,
											clusterId : clusterId,
											clusterType : self.clusterType().val()
										}
									}
								}

								EasySocial.ajax(namespace, options)
								.done(function(items) {

									if (!$.isArray(items)) {
										task.reject();
										return;
									}

									var items = $.map(items, function(item){

										var html = $('<div/>').html(item);
										var title = html.find('[data-suggest-title]').val();
										var id = html.find('[data-suggest-id]').val();

										return {
											"id": id,
											"title": title,
											"type": "user",
											"menuHtml": item
										};
									});

									task.resolve(items);

								}).fail(task.reject);

								return task;
							},
							use: function(item) {
								return item.type + ":" + item.id;
							}
						}
					},
					"#": {
						type: "hashtag",
						wrap: true,
						stop: " #",
						allowSpace: false,
						query: {
							loadingHint: true,
							searchHint: self.tagHints().find('[data-search]').html(),
							emptyHint: self.tagHints().find('[data-empty]').html(),
							data: function(keyword) {

								var task = $.Deferred();

								EasySocial.ajax("site/controllers/hashtags/suggest", {
									"search": keyword
								}).done(function(items){

									if (!$.isArray(items)) {
										task.reject();
										return;
									}

									var items = $.map(items, function(item) {

										return {
											"title": "#" + $.trim(item),
											"type": "hashtag",
											"menuHtml": item
										};
									});

									task.resolve(items);

								}).fail(task.reject);

								return task;
							}
						}
					},
					":": {
						type: "emoticon",
						wrap: true,
						stop: "",
						allowSpace: false,
						query: {
							loadingHint: true,
							searchHint: self.emoticonHints().find('[data-search]').html(),
							emptyHint: self.emoticonHints().find('[data-empty]').html(),
							data: $.parseJSON(self.options.emoticons),
							renderAll: true
						}
					}
				},
				plugin: {
					autocomplete: {
						id: "es",
						component: "",
						modifier: "es-story-mentions-autocomplete",
						sticky: true,
						shadow: true,
						position: {
							my: 'left top',
							at: 'left bottom',
							of: textbox.parent(),
							collision: 'none'
						},
						size: {
							width: function() {
								return body.width();
							}
						}
					}
				}
			});
	},

	//
	// PLUGINS
	//
	plugins: {},

	getPluginName: function(element) {
		return $(element).data("story-plugin-name");
	},

	getPluginSelector: function(pluginName) {
		return "[data-story-plugin-name=" + pluginName + "]";
	},

	hasPlugin: function(pluginName, pluginType) {

		var plugin = self.plugins[pluginName];

		if (!plugin) return false;

		// Also check for pluginType
		if (pluginType) return (plugin.type===pluginType);

		return true;
	},

	buildPluginSelectors: function(selectorNames, plugin, pluginControllerType) {

		var selectors = {};

		$.each(selectorNames, function(i, selectorName) {

			var selector = self[selectorName].selector + plugin.selector;

			if (pluginControllerType=="function") {
				selectors[selectorName] = function() {
					return self.find(selector);
				};
			} else {
				selectors["{"+selectorName+"}"] = selector;
			}
		});

		return selectors;
	},

	"{self} addPlugin": function(element, event, pluginName, pluginController, pluginOptions, pluginControllerType) {

		// Prevent unregistered plugin from extending onto story
		if (!self.hasPlugin(pluginName))
		{
			return;
		}

		var plugin = self.plugins[pluginName],
			extendedOptions = {};

		// See plugin type and build the necessary options for them
		switch (plugin.type)
		{
			case "panel":
				var panelSelectors = [
					"panelButton",
					"panelContent"
				];
				extendedOptions = self.buildPluginSelectors(panelSelectors, plugin, pluginControllerType);
				break;
		}

		$.extend(pluginOptions, extendedOptions);
	},

	"{self} registerPlugin": function(element, event, pluginName, pluginInstance) {

		// Prevent unregistered plugin from extending onto story
		if (!self.hasPlugin(pluginName)) return;

		var plugin = self.plugins[pluginName];

		plugin.instance = pluginInstance;
	},

	//
	// PANELS
	//

	panels: {},

	currentPanel: "text",

	getPanel: function(pluginName) {

		// If plugin is not a panel, stop.
		if (!self.hasPlugin(pluginName, 'panel')) return;

		var plugin = self.plugins[pluginName];

		// Return existing panel entry if it has been created,
		return self.panels[plugin.name] ||

				// or create panel entry and return it.
				(self.panels[plugin.name] = {
					plugin: plugin,
					button: self.panelButton(plugin.selector),
					content: self.panelContent(plugin.selector)
				});
	},

	activatePanel: function(pluginName) {

		// Get panel
		var panel = self.getPanel(pluginName);

		// If panel does not exist, stop.
		if (!panel) return;

		// Deactivate current panel
		self.deactivatePanel(self.currentPanel);

		// if (self.postAsButton().length > 0) {
		// 	// remove disabled class for the Post As dropdown
		// 	self.postAsButton().removeClass("disabled");

		// 	// Check if need to disable the dropdown
		// 	self.disablePostAsDropdown(pluginName);
		// }

		// Giphy is only available for 'Post Status'
		if (pluginName != 'text') {
			self.giphyButton().addClass('t-hidden');
			self.deactivateMeta('giphy');
			self.removeGiphy();
		} else {
			self.giphyButton().removeClass('t-hidden');
		}

		// Set plugin as current panel
		self.currentPanel = pluginName;

		var panelContents = self.panelContents();

		// Activate submit button (just in case it is disabled)
		self.submitButton().removeAttr("disabled");

		// Activate panel container
		panelContents.addClass("active");

		// Activate panel
		panel.button.addClass("active");
		panel.content
			.appendTo(panelContents)
			.addClass("active");

		base.addClass("plugin-" + pluginName);

		// Invoke plugin's activate method if exists
		self.invokePlugin(pluginName, "activatePanel", [panel]);

		// Trigger panel activate event
		self.trigger("activatePanel", [pluginName]);

		// Refocus story form
		self.textField().focus();
	},

	deactivatePanel: function(pluginName) {

		// Get panel
		var panel = self.getPanel(pluginName);

		// If panel does not exist, stop.
		if (!panel) return;

		// Deactivate panel
		panel.button.removeClass("active");
		panel.content.removeClass("active");

		base.removeClass("plugin-" + pluginName);

		// Deactivate panel container
		self.panelContents().removeClass("active");

		// Invoke plugin's deactivate method if exists
		self.invokePlugin(pluginName, "deactivatePanel", [panel]);

		// Trigger panel deactivate event
		self.trigger("deactivatePanel", [pluginName]);
	},

	// disablePostAsDropdown: function(pluginName) {

	// 	var plugins = ["event", "files", "blog"];

	// 	// This is to make sure post as page is selected by default
	// 	$('[data-postas-page]').click();

	// 	if ($.inArray(pluginName, plugins)  > -1){

	// 		// For blog post, we only allow post as user
	// 		if (pluginName == 'blog') {
	// 			$('[data-postas-user]').click();
	// 		}

	// 		self.postAsButton().addClass("disabled");
	// 	}
	// },

	addPanelCaption: function(pluginName, panelCaption) {

		// Get panel
		var panel = self.getPanel(pluginName);

		// If panel does not exist, stop.
		if (!panel) return;

		panel.button
			.addClass("has-data")
			.find(".with-data").html(panelCaption);
	},

	removePanelCaption: function(pluginName) {

		// Get panel
		var panel = self.getPanel(pluginName);

		// If panel does not exist, stop.
		if (!panel) return;

		panel.button
			.removeClass("has-data")
			.find(".with-data").empty();
	},

	// Triggered when the panel buttons beneath the story footer is clicked
	"{panelButton} click": function(panelButton, event) {
		var pluginName = self.getPluginName(panelButton);
		self.activatePanel(pluginName);
	},

	"{plusButton} click": function(plusButton, event) {
		// we need to set the current controller so that in wireframe/story/default.js the buttons can
		// retrieve the correct controller.
		window.currentStoryController = self;
	},

	//
	// SAVING
	//
	saving: false,
	locked: false,

	save: function(isEdit) {

		if (self.saving) {
			return;
		}

		if (self.locked) {
			EasySocial.dialog({
				"content": EasySocial.ajax('site/views/story/showFloodWarning')
			});
			return;
		}

		self.saving = true;

		// Create save object
		var save = $.Deferred();

		save.data = {};
		save.tasks = [];

		save.addData = function(plugin, props) {

			var pluginName = plugin.options.name;
			var pluginType = plugin.options.type;

			if (pluginName !== self.currentPanel) {
				return;
			}

			save.data.attachment = self.currentPanel;

			if ($.isPlainObject(props)) {
				$.each(props, function(key, val) {
					save.data[pluginName + "_" + key] = val;
				});
			} else {
				save.data[pluginName] = props;
			}
		};

		save.addTask = function(name) {

			var task = $.Deferred();
			task.name = name;
			task.save = save;
			save.tasks.push(task);
			return task;
		};

		save.process = function() {

			if (save.state() === "pending") {
				$.when.apply($, save.tasks)
					.done(function() {

						// If content & attachment & giphy are empty, reject.
						if (!$.trim(save.data.content) && !save.data.attachment && !save.data.giphy) {

							save.reject(opts.errors.empty, "warning");
							return;
						}

						save.resolve();
					})
					.fail(save.reject);
			}

			return save;
		};

		save.data.isEdit = isEdit;
		save.data.giphy = self.giphyURL ? self.giphyURL : self.options.currentGiphy;

		if (self.giphyURL) {
			// Reset the giphy in the form after assigning the value
			self.removeGiphy();
		}

		// Set the current panel so that the plugins know whether they should intercept
		save.currentPanel = self.currentPanel;

		// Trigger the save event
		self.trigger("save", [save]);

		self.element.addClass("is-loading");

		save.process()
			.done(function(){

				var mentions = self.textbox().mentions("controller").toArray();
				var hashtags = self.element.data("storyHashtags");
				var nohashtags = false;
				hashtags = (hashtags) ? hashtags.split(",") : [];

				if (hashtags.length > 0) {
					var tags =
						$.map(mentions, function(mention) {
							if (mention.type==="hashtag" && $.inArray(mention.value, hashtags) > -1) {
								return mention;
							}
						});

					nohashtags = tags.length < 1;
				}

				self.trigger("beforeSubmit", [save]);

				// Save the background id
				save.data.backgroundId = self.currentBackground().data('id');

				// Find any auto post input
				var autopost = self.autopost().find('input[type=checkbox]:checked');
				save.data.autopost = [];

				if (autopost.length > 0) {
					autopost.each(function(i, item) {
						var item = $(item);
						var name = item.attr('name');
						var checked = item.is(':checked');

						if (checked) {
							save.data[name] = 1;
						}

					});
				}

				// Get custom params
				var params = self.params();

				if (params.length > 0) {
					$.each(params, function(i, param) {
						var name = $(this).attr('name');
						var value = $(this).val();

						save.data[name] = value;
					});
				}

				// then the ajax call to save story.
				EasySocial.ajax("site/controllers/story/create", save.data)
					.done(function(html, id, message, preview, backgroundId, locationPreview, privacyHtml) {

						// If this isEdit
						if (isEdit) {
							self.trigger("update", [html, id, preview, backgroundId, locationPreview, privacyHtml]);

						} else {
							if (nohashtags) {
								html = self.setMessage(opts.errors.filter);
							}

							self.trigger("create", [html, id]);
							self.clear();

							if (opts.flood.enabled) {
								self.lockSubmitButton(opts.flood.interval);
							}
						}

						// Display success message for quickpost module
						if (self.isModule && message) {
							self.setMessage(message.message, message.type);
						}

						// Initialize reactions
						if (window.es.mobile || window.es.tablet) {
							window.es.initReactions();
						}

					})
					.fail(function(message){
						self.trigger("fail", arguments);

						var msg = message;
						var msgType = 'warning';

						if ($.type(message) !== 'string') {
							msg = message.message;
							msgType = message.type;
						}


						self.setMessage(msg, msgType);
					})
					.always(function(){

						self.trigger("afterSubmit", [save]);

						self.element.removeClass("is-loading");
						self.saving = false;
					});
			})
			.fail(function(message, messageType){

				if (!message) {
					message = opts.errors.standard;
					messageType = "error";
				}

				self.setMessage(message, messageType);
				self.element.removeClass("is-loading");
				self.saving = false;
			});
	},

	lockSubmitButton: function(interval) {

		// determine if we need to lock the submit button or not.
		if (opts.flood.enabled && interval > 0) {

			self.locked = true;

			var delay = interval * 1000;

			// need to start the counter.
			setTimeout(function() {
				self.locked = false;
			}, delay);
		}

	},


	clear: function() {

		// Clear textfield
		self.textField().val("");

		// Clear status messages
		self.clearMessage();

		// Reactivate text panel
		// Only reactivate the panel if this is not a single panel
		if (!self.options.singlePanel) {
			self.activatePanel("text");
		}

		// Deactivate meta
		self.deactivateMeta(self.currentMeta);

		// Trigger clear event
		self.trigger("clear");

		// Reset mentions
		var mentions = self.textbox().mentions("controller");
		mentions.reset();

		setTimeout(function(){
			mentions.cloneLayout();
		}, 500);

		// Focus textfield
		self.textField().focus();

		self.resetBackground().click();
	},

	getPostActor: function() {
		var postAsHidden = $('[data-postas-base] [data-postas-hidden]');

		return postAsHidden.val();
	},

	"{self} save": function(element, event, save) {

		var content = self.textField().val();
		var data = save.data;

		data.view = self.options.sourceView;
		data.content = content;
		data.target  = self.target().val();
		data.cluster = self.cluster().val();
		data.clusterType = self.clusterType().val();
		data.anywhereId = self.anywhereId().val();
		data.pageTitle = window.document.title;
		data.postActor = self.getPostActor();
		data.privacy = self.find("[data-privacy-hidden]").val();
		data.privacyCustom = self.find("[data-privacy-custom-hidden]").val();
		data.privacyField = '';


		var tmp = [];
		self.find("[data-privacy-field-inputs]").each(function(idx, ele) {
			var select = $(ele);
			var key = select.attr('name');
			var values = select.val();

			if (values) {
				key = key + '|' + values.join(',');
				tmp.push(key);
			}
		});

		if (tmp) {
			var value = tmp.join(';');
			data.privacyField = value;
		}


		var mentions = self.textbox().mentions("controller").toArray();

		data.mentions = $.map(mentions, function(mention){
			if ((mention.type==="hashtag" || mention.type==="emoticon") && $.isPlainObject(mention.value)) {
				mention.value = mention.value.title.slice(1);
			}
			return JSON.stringify(mention);
		});
	},

	"{submitButton} click": function(submitButton, event) {
		self.save(self.isEdit);
	},

	//
	// Privacy
	//
	"{privacyButton} click": function(el) {
		setTimeout(function(){
			var isActive = el.find("[data-es-privacy-container]").hasClass("active");
		}, 1);
	},

	//
	// Meta
	//
	metas: {
		friends: "",
		location: "",
		mood: ""
	},

	currentMeta: null,

	getMeta: function(metaName) {

		var meta = {
			name: metaName,
			button: self.metaButton().filterBy("storyMetaButton", metaName),
			content: self.metaContent().filterBy("storyMetaContent", metaName)
		};

		if (meta.button.length < 1 || meta.content.length < 1) return null;

		return meta;
	},


	activateMeta: function(metaName) {

		var meta = self.getMeta(metaName);

		if (!meta) return;

		// Deactivate current meta
		self.deactivateMeta(self.currentMeta);

		// Always hide the giphy meta content as it will cause empty spaces on other metas #3555
		self.giphyMetaContent().addClass('t-hidden');

		meta.button.addClass("active");

		// Always push meta content to the beginning
		meta.content
			.appendTo(self.metaContents())
			.addClass("active");

		self.currentMeta = metaName;

		self.trigger("activateMeta", [meta]);

		base.addClass("has-meta");

		// We only curl and render the giphy when the giphy form is rendered
		if (metaName == 'giphy') {
			self.giphyMetaContent().removeClass('t-hidden');

			// Show the giphy nicely if there is giphy item during stream edit
			if (opts.currentGiphy) {
				self.giphyLoaderWrapper().addClass('t-hidden');
			}

			// Ensure that form is alraedy loaded
			var formIsLoaded =  (self.giphyBrowser().length > 0);

			if (!formIsLoaded) {
				self.giphyLoader().addClass('is-active');

				EasySocial.ajax('site/views/giphy/getForm',{
					"from": "story"
				}).done(function(html) {
					self.giphyWrapper().html(html);
					self.giphyLoader().removeClass('is-active');
				});
			}
		}
	},

	deactivateMeta: function(metaName) {

		var meta = self.getMeta(metaName);

		if (!meta) return;

		meta.button.removeClass("active");

		meta.content.removeClass("active");

		self.currentMeta = null;

		self.trigger("deactivateMeta", [meta]);

		base.removeClass("has-meta");
	},

	toggleMeta: function(metaName) {

		if (self.currentMeta == metaName) {
			self.deactivateMeta(metaName);
		} else {
			self.activateMeta(metaName);
		}
	},

	getMetaText: function() {

		var metas = self.metas;
		var parts = [];

		$.each(["friends", "location", "mood"], function(i, type){
			var meta = metas[type];
			if (meta) {
				parts.push(meta);
			}
		});

		return parts.join(' ');
	},

	setMeta: function(metaName, content) {

		self.metas[metaName] = content;
		self.updateMeta();
	},

	updateMeta: $.debounce(function() {

		// This is debounced so we only have to update
		// the html once after multiple setMeta calls.
		var metaText = self.getMetaText(),
			meta = self.meta(),
			textField = self.textField();

		// Highlight meta button icon if meta has content
		$.each(self.metas, function(key, val){
			var meta = self.getMeta(key);
			meta && meta.button.toggleClass("has-content", !!val);
		});

		// If there is no meta string, don't show anything.
		if (!metaText) {
			meta.remove();
			textField.attr("placeholder", self.placeholder);
			return;
		}

		// Create meta element if it does not exist;
				var mentionsOverlay = self.mentionsMetaOverlay();

		if (meta.length < 1) {
			meta = $('<u class="es-story-meta" data-story-meta data-ignore></u>').appendTo(mentionsOverlay);
		}

		// Add rtl mark if necessary
		var rtlMark =  mentionsOverlay.css("direction")=="rtl" ? "&#8207;" : "";

		// Update meta string
		meta.html(rtlMark + " &mdash; " + metaText);

		// Don't show placeholder text if we have meta text
		textField.attr("placeholder", "");

		self.setMentionsLayout();

	}, 1),

	refreshMeta: function() {

		// Trigger refresh meta so plugins
		// can update the meta the database
		self.trigger("refreshMeta");

		self.updateMeta();
	},

	"{textbox} triggerClear": function() {

		self.refreshMeta();
	},

	"{meta} click": function(meta, event) {

		// Do not focus textfield if a link was clicked
		if ($(event.target).is("a")) return;

		self.textField().focus();
	},

	"{metaButton} click": function(metaButton) {

		var metaName = metaButton.attr("data-story-meta-button");
		self.toggleMeta(metaName);
	}
}});

module.resolve();
});

});
			EasySocial.module('site/story/tasks', function($) {

var module = this;

EasySocial.Controller('Story.Tasks', {
	defaultOptions: {
		"{form}": "[data-story-tasks-form]",
		"{input}": "[data-story-tasks-input]",
		"{remove}": "[data-story-tasks-remove]",
		"{list}": "[data-story-tasks-list]",
		"{milestone}": "[data-story-tasks-milestone]",
		"{due}": "[data-story-tasks-due]"
	}
}, function(self, opts) { return {

	"{story} save": function(element, event, save) {
		var values = new Array();

		$.each(self.input() , function( i , item ) {
			if ($( item ).val() != '') {
				values.push($(item).val() );	
			}
		});

		var data = {
						"items": values,
						"milestone": self.milestone().val(),
						"due": self.due().val()
					};

		save.addData(self, data);
	},

	"{story} clear": function() {
	}

}});
	
module.resolve();
});			EasySocial.module("site/story/videos", function($){

var module = this;

EasySocial.require()
.library('image', 'plupload')
.done(function($){

EasySocial.Controller("Story.Videos", {
	defaultOptions: {
		// This is the main wrapper for the form
		"{form}": "[data-video-form]",

		// This is video panel button
		"{panelButton}" : '[data-story-plugin-name="videos"]',

		// Video links
		"{insertVideo}": "[data-insert-video]",
		"{videoLink}": "[data-video-link]",
		"{videoCategory}": "[data-video-category]",

		// Video uploads
		"{uploaderForm}": "[data-video-uploader]",
		"{uploaderButton}": "[data-video-uploader-button]",
		"{uploaderDropsite}": "[data-video-uploader-dropsite]",
		"{uploaderProgressBar}": "[data-video-uploader-progress-bar]",
		"{uploaderProgressText}": "[data-video-uploader-progress-text]",

		"{uploaderUploadBar}": "[data-video-uploader-upload-bar]",
		"{uploaderUploadText}": "[data-video-uploader-upload-text]",

		// Video preview
		"{removeButton}": "[data-remove-video]",
		"{previewImageWrapper}": "[data-video-preview-image]",
		"{previewTitle}": "[data-video-preview-title]",
		"{title}": "[data-video-title]",
		"{previewDescription}": "[data-video-preview-description]",
		"{description}": "[data-video-description]"
	}
}, function(self, opts, base) { return {

	init: function() {

		// If video uploader form doesn't exist, perhaps the admin already disabled this
		if (self.uploaderForm().length == 0 && self.videoLink().length == 0) {
			return;
		}

		if (self.uploaderForm().length > 0) {
			self.uploader = self.uploaderForm().addController("plupload", $.extend({
					"{uploadButton}": self.uploaderButton.selector,
					"{uploadDropsite}": self.uploaderDropsite.selector
				}, opts.uploader)
			);

			self.plupload = self.uploader.plupload;
		}

		if (opts.isEdit) {
			self.video = {
				"type": opts.video.source,
				"title": opts.video.title,
				"description": self.description().val(),
				"link": opts.video.link,
				"id": opts.video.id,
				"isEncoding": opts.video.isEncoding
			};
		}
	},

	renderDefaultPlaceholderDescription: false,
	clickedRemoveButton: false,

	isProcessed: function() {
		self.form().switchClass('is-processed');

		self.processing = false;
	},

	isUploading: function() {
		self.form().switchClass('is-uploading');
	},

	isProcessing: function() {
		self.form().switchClass('is-processing');

		self.processing = true;
	},

	isEncoding: function() {
		self.form().switchClass('is-encoding');
	},

	isInitial: function() {
		self.form().switchClass('is-waiting');
	},

	currentCategory: null,
	processing: false,
	video: null,
	videoType: null,

	updatePreview: function(type, data, imageUrl) {

		self.video = {
			"type": type,
			"title": data.title,
			"description": data.description,
			"link": data.link,
			"id": data.id ? data.id : '',
			"isEncoding": false
		};

		// Retrieve the placeholder value
		title = self.title().attr("placeholder");
		description = self.description().attr("placeholder");

		if ($.trim(data.title) != '') {
			title = data.title;
			self.title().val(title);
		}

		if ($.trim(data.description) != '') {
			description = data.description;
			self.description().val(description);

            self.previewDescription().removeClass("no-description");
		}

		self.previewTitle().html(title);
		self.previewDescription().html(description);

		// Load the image
		$.Image.get(imageUrl).done(function(image){
			image.appendTo(self.previewImageWrapper());
		});

	},

	resetProgress: function() {

		// Reset the progress bar
		self.uploaderProgressBar().css('width', '0%');
		self.uploaderProgressText().html('0%');
	},

	clearForm: function(resetVideo) {

		if (resetVideo) {
			self.video = null;
		}

		// Set to initial position
		self.isInitial();

		// Reset all the form values
		self.videoLink().val('');

		self.previewImageWrapper().empty();

		self.previewTitle().empty();
		self.title().val('');

		self.previewDescription().empty();
		self.description().val('');
	},

	editTitleEvent: "click.es.story.video.editLinkTitle",
	editDescriptionEvent: "click.es.story.video.editLinkDescription",

	editTitle: function() {

		// Apply the class to the form wrapper
        self.form().addClass('editing-title');

		setTimeout(function(){

			self.title()
				.val(self.previewTitle().text())
				.focus()[0]
				.select();

			// Save the title when there is changes in the textbox. #3321
			$(self.title()).on('change keyup paste', function() {
				self.saveTitle("apply");
			});

			$(document).on(self.editTitleEvent, function(event) {

				if (event.target !== self.title()[0]) {
					self.saveTitle("save");
				}
			});

		}, 1);
	},

	saveTitle: function(operation) {

		if (!operation) {
			operation = 'save';
		}

		var value = self.title().val();

		// Changing the title from the textbox
		if (operation == 'apply') {
			self.video.title = value;
			return;
		}

		// Ensure that the title field has value.
		if (value.length > 0 && $.trim(value) != "") {
			if (operation == 'save') {
				self.previewTitle().html(value);
			}

			self.video.title = value;
		}

		// Remove the editing title class
        self.form().removeClass('editing-title');

		$(document).off(self.editTitleEvent);
	},

	checkVideoStatus: function(videoId, percentage) {
		EasySocial.ajax('site/controllers/videos/status', {
			"id": videoId,
			"uid": opts.video.uid,
			"type": opts.video.type,
			"createStream": 0,
			"percentage": percentage,
			"unpublished": 1
		}).done(function(permalink, percent, data, thumbnail) {

			if (percent === 'done') {

				self.processing = false;

				// Set the progress bar to 100%
				self.uploaderProgressBar().css('width', '100%');
				self.uploaderProgressText().html('100%');

				// Update the state
				self.isProcessed();

				// Update the preview
				self.updatePreview('upload', data, thumbnail);

				// Reset the progress bar
				self.resetProgress();

				return;
			}

			// There is a possibility that the progress is throwing errors on the line so we should skip this
			if (percent == 'ignore') {
				self.checkVideoStatus(videoId, percentage);
				return;
			}

			// Set the progress bar width
			var progress = percent + '%';
			self.uploaderProgressBar().css('width', progress);
			self.uploaderProgressText().html(progress);

			// This should run in a loop
			self.checkVideoStatus(videoId, percent);
		});
	},

	editDescription: function() {

        self.form().addClass('editing-description');

		setTimeout(function(){

			var descriptionClone = self.previewDescription().clone();

			var noDescription = descriptionClone.hasClass("no-description");

			descriptionClone.wrapInner(self.description());

			if (opts.isEdit && noDescription) {

				self.description()
					.val("")
					.focus()[0].select();

			} else if (noDescription) {

				self.description()
					.val("")
					.focus()[0].select();

			} else {

				// replace the linefeed to empty first
				var previewDescription = self.previewDescription().html().replace(/\n/g, "");

				// then only replace br tag to linefeed
				var previewDescription = previewDescription.replace(/<br\s*[\/]?>/gi, "\n");

				self.description()
					.val(previewDescription)
					.focus()[0].select();
			}

			// Save the description when there is changes in the textbox. #819
			$(self.description()).on('change keyup paste', function() {
				self.saveDescription("apply");
			});

			$(document).on(self.editDescriptionEvent, function(event) {

				if (event.target !== self.description()[0]) {
					self.saveDescription("save");
				}
			});
		}, 1);
	},

	saveDescription: function(operation) {

		// Do not proceed this if doesn't have data for this
		if (!self.video) {
			return;
		}

		if (!operation) {
			operation = 'save';
		}

		// var value = self.description().val().replace(/\n/g, "<br>");
		var value = self.description().val();

		// Always set this flag to false here so it will re-calculate again for different operation
		self.renderDefaultPlaceholderDescription = false;

		switch (operation) {

			case "save":

				// trim the space first before do validation
				// just in case those user only type space in description
				var noValue = ($.trim(value) === "");

				self.previewDescription()
					.toggleClass("no-description", noValue);

				if (noValue) {
					value = self.description().attr("placeholder");

					// Determine currently render the placeholder description now
					self.renderDefaultPlaceholderDescription = true;
				}

				// Only process this if there got the value for the description
				if (value) {
					self.previewDescription()
						.html(value.replace(/\n/g, "<br>"));
				}

				self.video.description = value;

				self.form().find(".textareaClone").remove();

                self.form().removeClass("editing-description");

				$(document).off(self.editDescriptionEvent);
				break;
			case "apply":

				// Determine currently whether got value for the description or not
				if (value === "") {
					self.renderDefaultPlaceholderDescription = true;
				}

				self.video.description = value;
			case "revert":
				break;
		}
	},

	"{window} easysocial.story.video.panel.insertvideolink" : function(el, ev, url) {

		if (self.video || self.processing || !url) {
			return;
		}

		// Switch to video panel
		self.panelButton().click();

		// Clear up any data inside the form
		self.clearForm(true);

		// Append the video link
		self.videoLink().val(url);

		// Process video link
		self.insertVideo().click();
	},

	"{uploaderForm} FilesAdded": function() {

		// Set the state to uploading
		self.isUploading();

		// Start the upload
		self.plupload.start();
	},

	"{uploaderForm} UploadProgress": function(el, event, uploader, file) {
		// Set the progress bar width
		var progress = file.percent + '%';

		self.uploaderUploadBar().css('width', progress);
		self.uploaderUploadText().html(progress);

	},

	"{uploaderForm} FileUploaded": function(uploaderForm, event, uploader, file, response) {

		// Server thrown an error
		if (response.error) {

			// Set the message
			self.clearMessage();
			self.setMessage(response.error);

			// Display the video upload form again
			self.clearForm(true);

			return false;
		}

		// If the server isn't encoding on the fly, we should display some message
		if (!response.isEncoding) {

			self.processing = false;

			// Set the progress bar to 100%
			self.uploaderProgressBar().css('width', '100%');
			self.uploaderProgressText().html('100%');

			// Update the state
			self.isProcessed();

			// Update the preview
			self.updatePreview('upload', response.data, response.thumbnail);

			self.video.isEncoding = true;

			// Reset the progress bar
			self.resetProgress();

			return;
		}

		// Set status to encoding
		self.isEncoding();

		self.processing = true;

		// Update the progress since the video needs to be converted.
		self.checkVideoStatus(response.data.id, 0);
	},

	"{uploaderForm} Error": function(el, event, uploader, error) {

		// Get the error message
		var message = opts.errors[error.code];

		self.story.setMessage(message, "error");
	},

	"{previewTitle} click": function() {

		var editing = self.form().hasClass('editing-title');

		self.form().toggleClass('editing-title', !editing);

		if (!editing) {
			self.editTitle();
		}
	},

	"{previewDescription} click": function() {
		var editing = self.form().hasClass('editing-description');

		self.form().toggleClass('editing-description', !editing);

		// Do not execute this if that is not editing and clicked remove button from the form
		if (!editing && !self.clickedRemoveButton) {
			self.editDescription();
		}
	},

	"{videoCategory} change": function(videoCategory) {
		self.currentCategory = videoCategory.val();
	},

	"{videoLink} paste": function() {
		setTimeout(function() {
			self.insertVideo().click();
		}, 100);
	},

	"{insertVideo} click": function() {

		var url = self.videoLink().val();

		if (!url || self.processing) {
			return;
		}

		// Hide the form
		self.isProcessing();

		EasySocial.ajax('ajax:/apps/user/videos/controllers/process/process', {
			"type": "link",
			"link": url
		}).done(function(data, image, embed) {
			self.isProcessed();

			data.link = url;

			self.updatePreview('link', data, image);
		}).fail(function(message){

			self.isProcessed();

			self.clearForm(true);

			self.story.setMessage(message, "error");
		});
	},

	"{removeButton} click": function(removeButton) {

		// set this flag to true because use to determine that no need to go through the saveDescription process
		self.clickedRemoveButton = true;

		self.clearForm(true);

		// set this flag to false back after clear the form
		self.clickedRemoveButton = false;
		self.renderDefaultPlaceholderDescription = false;
	},

	//
	// Saving
	//

	"{story} save": function(element, event, save) {

		if (save.currentPanel != 'videos') {
			return;
		}
		var url = self.videoLink().val();

		self.saveTitle();

		// If uploading a video link
		if (url && !self.video) {
			save.reject(opts.errors.messages.insert);
			return;
		}

		// If sharing a video without link and upload
		if (!url && !self.video) {
			save.reject(opts.errors.messages.empty);
			return;
		}

		// If sharing a video without title.
		if (!self.video.title || $.trim(self.video.title) == "") {
			save.reject(opts.errors.messages.title);
			return;
		}

		// Add the task for uploading video
		self.uploadingVideo = save.addTask("uploadingVideo");

		self.save(save);
	},

	"{story} afterSubmit": function() {

		var uploadingVideo = self.uploadingVideo;

		if (!uploadingVideo) {
			return;
		}

		// Reset the form upon submission
		self.clearForm(true);

		delete self.uploadingVideo;

		if (self.video && self.video.isEncoding) {

			EasySocial.dialog({
				content: EasySocial.ajax('site/views/videos/showEncodingMessage')
			});

			delete self.video;
			return;
		}

		delete self.video;
	},

	save: function(save) {

		var uploadingVideo = self.uploadingVideo;

		if (!uploadingVideo) {
			return;
		}

		if (self.processing) {
			save.reject(opts.errors.messages.processing);
			return;
		}

		// Attach the category to the video data
		self.video.category = self.videoCategory().val();

		if (!self.video.category || self.video.category == 0) {
			save.reject(opts.errors.messages.category);
			return;
		}

		if (self.title().val() == '') {
			save.reject(opts.errors.messages.title);
			return;
		}

		// Set the description to empty if detected currently render the default placeholder description before save
		if (self.renderDefaultPlaceholderDescription) {
			self.video.description = '';
		}

		save.addData(self, self.video);

		uploadingVideo.resolve();

		self.videoType = self.video.type;
	},

	"{story} clear": function() {
		self.clearForm(false);
		self.renderDefaultPlaceholderDescription = false;
	}
}});

// Resolve module
module.resolve();

});

});
			EasySocial.module('site/stream/ads', function(){

var module = this;

EasySocial.require()
.done(function($) {

EasySocial.Controller('Ads', {

	defaultOptions: {
		"{adsLink}": "[data-ads-link]"
	}
}, function(self, opts) { return {

	init : function() {
		self.on("scroll.stream", window, $._.debounce(function() {

			if (self.element.find('[data-contents]').visible()) {
				// Get previous stream id
				var prevStreamId = self.element.prev().data('id'),
				adStreamId = self.element.data('id');

				var sid = prevStreamId + '-' + adStreamId;

				if (window.adseen === undefined) {
					window.adseen = [];
				}

				if ($.inArray(sid, window.adseen) === -1) {
					EasySocial.ajax('site/controllers/ads/view', {
						"id" : self.element.data('id')
					}).done(function() {
						window.adseen.push(sid);
					});
				}
			}
		}, 250));
	},

	"{adsLink} click": function(el, event) {
		event.preventDefault();

		var href = self.element.data('link');

		EasySocial.ajax('site/controllers/ads/click', {
			"id" : self.element.data('id')
		});

		window.open(href);
	}

}});

module.resolve();
});

});
			EasySocial.module('site/stream/filter', function($){

var module = this;

EasySocial.require()
.script('site/vendors/puller')
.library('history')
.done(function($){

EasySocial.Controller('Stream.Filter', {
	"defaultOptions": {
		"title": null,
		"type": null,

		// If this is a cluster, it should be the cluster id
		"uid": null,
		"ajaxNamespace": "",
		"ajaxOptions": {},
		"isMobile": false,

		// Requirement to render the content as HTML with ajax
		"ajaxControllers": "",
		"ajaxMethod": "",

		// Wrapper and content
		"{wrapper}": "[data-wrapper]",
		"{contents}": "[data-contents]",

		// Filter dropdown
		"{activeFilterText}": "[data-active-filter-text]",
		'{activeFilterButton}': "[data-active-filter-button]",
		"{filter}": "[data-filter-item]",
		"{filterWrapper}": "[data-filter-wrapper]",

		// Post type filters
		"{postTypeFilterButton}": "[data-filter-post-type-button]",
		"{postTypeFilterWrapper}": "[data-filter-post-type-wrapper]",
		"{postTypeFilter}": "[data-filter-post-type]",
		"{postTypeFilterLabel}": "[data-filter-post-type-label]",

		// Hidden inputs to manipulate the states
		"{filterInput}": "[data-stream-filter]",

		// Custom filters
		"{createFilter}": "[data-filter-create]",
		"{editFilter}": "[data-edit-filter]",
		"{saveHashTag}": "[data-hashtag-filter-save]"
	}
}, function(self, opts) { return{

	clicked: false,
	initialLoad: true,

	init: function() {
		self.initFilters('filter');
	},

	initFilters: function(type) {
		var active = self.getActiveFilter();

		// There is a possibility that the active filter has been disabled altogether
		if (active.length > 0) {
			var title = self.getFilterHtml(active);

			self.activeFilterText().html(title);

			self.activeFilterButton().removeClass('is-loading');

			// Only process this on the user dashboard page
			if (opts.type == 'user') {
				// Disabled the news feed filter button first
				self.disabledNewsFeedFilterButton();

				// Disabled post type filter button first
				self.disabledPostTypeFilterButton();
			}
		}
	},

	loadPuller: function() {
		var targetElement = '[data-story-form]';

		// If story form not available, we use the first stream item
		if ($(targetElement).length == 0) {
			targetElement = '[data-stream-item]:first-child';
		}

		window.initPuller = function() {
			return window.es.puller.init({
									mainElement: targetElement,
									triggerElement: targetElement,
									onRefresh: function (done) {
										setTimeout(function () {
											var controller = $('body').controller(EasySocial.Controller.System.Notifier);

											controller.check(true, true);
											done();

										}, 150);
									}
								});
		};

		var puller = initPuller();
	},

	getActiveFilter: function(wrapper) {
		var active = self.filter('.active');

		return active;
	},

	getFilterHtml: function(filter) {
		return filter.find('[data-filter-text]').html();
	},

	setActiveFilter: function(filter) {
		// Find the wrapper
		var wrapper = filter.parents(self.filterWrapper.selector);
		var filters = wrapper.find(self.filter.selector);
		var type = filter.data('type');

		self.filterInput().val(type);

		filters.removeClass('active');
		filter.addClass('active');

		var title = filter.find('[data-filter-text]').html();
		var activeFilterText = wrapper.find(self.activeFilterText.selector);

		activeFilterText.html(title);
		wrapper.removeClass('open');
	},

	updateStream: function(filter, filterId, postTypes) {

		// Used only for custom filters
		var filterId = filterId != undefined ? filterId : '';

		// Used in combination with filter
		var postType = postType != undefined ? postType : '';

		// Notify the dashboard that it's starting to fetch the contents.
		self.updatingContents();

		// Remove empty state
		self.wrapper()
			.removeClass('is-empty');

		var options = $.extend({
			"type": filter,

			// Cluster uses filter. We probably need to standardize this
			"filter": filter,
			"postTypes": postTypes,
			"id": filterId,
			"controller": opts.ajaxController,
			"task": opts.ajaxTask,
		}, opts.ajaxOptions);

		options[EasySocial.token()] = 1;

		// Use jquery's ajax method as we need to use the standard html view. #2912
		$.Ajax({
			"url": EasySocial.ajaxUrl,
			"method": 'post',
			"data": options
		}).done(function(contents) {

			var data = JSON.parse(contents);

			var contents = $(data.contents);
			var count = data.count;

			if (count == 0) {
				self.wrapper().addClass('is-empty');
			}

			// Trigger change for the stream
			self.trigger('onStreamUpdate', [filter]);

			// Trigger sidebar toggle for responsive view.
			self.trigger('onEasySocialFilterClick');

			window.streamFilter = filter;

			// Update the contents of the dashboard area
			self.updateContents(contents);

			if (opts.isMobile) {
				self.loadPuller();
			}

			// 3PD FIX: Kunena [text] replacement
			try {
				MathJax && MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
			} catch(err) {};

		}).fail(function(message) {
			return message;
		}).always(function() {

			// Initialize reactions
			if (window.es.mobile || window.es.tablet) {
				window.es.initReactions();
			}

			// Give a tiny buffer to prevent call stack request from maxing out. #1733
			setTimeout(function() {
				self.clicked = false;

				// Only process this on the user dashboard page
				if (opts.type == 'user') {
					// Re-enabled news feed filter button
					self.enabledNewsFeedFilterButton();

					// Re-enabled post type filter button
					self.enabledPostTypeFilterButton();
				}

				// re-enable the post filter
				self.enabledPostTypeFilter();

			}, 500);

		});
	},

	updatingContents: function() {
		self.contents().empty();
		self.wrapper().addClass('is-loading');
	},

	updateContents: function(contents) {
		self.wrapper().removeClass("is-loading");

		$('body').trigger('beforeUpdatingContents');

		// Hide the content first.
		$.buildHTML(contents)
			.appendTo(self.contents());

		$('body').trigger('afterUpdatingContents');
	},

	disabledPostTypeFilter: function() {
		self.postTypeFilter().attr('disabled', 'disabled');
	},

	enabledPostTypeFilter: function() {
		self.postTypeFilter().removeAttr('disabled');
	},

	disabledNewsFeedFilterButton: function() {
		self.activeFilterButton().attr('disabled', 'disabled');
	},

	enabledNewsFeedFilterButton: function() {
		self.activeFilterButton().removeAttr('disabled');
	},

	disabledPostTypeFilterButton: function() {
		self.postTypeFilterButton().attr('disabled', 'disabled');
	},

	enabledPostTypeFilterButton: function() {
		self.postTypeFilterButton().removeAttr('disabled');
	},

	// Allows caller to remove all checked post types
	resetPostTypes: function() {
		self.postTypeFilter().removeAttr('checked');
	},

	getPostTypes: function() {
		// Whenever there is a change of post type filter, we just recompute the value
		var postTypes = [];

		self.postTypeFilter(':checked').map(function() {
			postTypes.push($(this).val());
		});

		return postTypes;
	},

	// Prevent closing of dropdown
	"{postTypeFilterWrapper} click": function(element, event) {
		event.preventDefault();
		event.stopPropagation();
	},

	// Since we have prevented the closing of dropdown, we need to manually stop propagation here
	"{postTypeFilterLabel} click": function(element, event) {
		event.stopPropagation();
	},

	// Since we have prevented the closing of dropdown, we need to manually stop propagation here
	"{postTypeFilter} click": function(element, event) {
		event.stopPropagation();

		self.changePostTypeFilter(element);
	},

	changePostTypeFilter: function(element)
	{
		// Disabled the filter checkbox first
		self.disabledPostTypeFilter();

		var active = self.getActiveFilter();
		var filter = active.data('type');
		var id = active.data('id');

		// Whenever there is a change of post type filter, we just recompute the value
		var postTypes = self.getPostTypes();

		$('body').trigger('onAfterSelectPostType', [element.val()]);

		// Get the current filter on the page
		self.updateStream(filter, id, postTypes);
	},

	"{filter} click": function(filter, event) {

		// Prevent clicking any items more than once
		if (self.clicked) {
			return false;
		}

		// Only process this on the user dashboard page
		if (opts.type == 'user') {
			// Disabled the news feed filter button during loading steam item
			self.disabledNewsFeedFilterButton();

			// Disabled post type filter button during loading steam item
			self.disabledPostTypeFilterButton();
		}

		self.resetPostTypes();
		self.clicked = true;

		// Prevent event from bubbling up
		event.preventDefault();
		event.stopPropagation();

		// Get the attributes of the item
		var type = filter.data('type');
		var id = filter.data('id');

		// Route the anchor links embedded
		var anchor = filter.find('> a');

		anchor.attr('title', opts.title);

		// Only modify the URL if this is not the first page load,
		// Otherwise, it will look like redirection.
		if (!self.initialLoad) {
			anchor.route();
		}

		self.initialLoad = false;

		// Set the active filter
		self.setActiveFilter(filter);

		self.updateStream(type, id);
	},

	"{editFilter} click": function(element, event) {

		// Get the filter attributes
		var id = element.data('id');
		var type = element.data('type');

		EasySocial.dialog({
			"content": EasySocial.ajax('site/views/stream/getFilterFormDialog', {
				"type": type,
				"id": id,
				"uid": opts.uid
			})
		});
	},

	"{createFilter} click": function(element, event) {
		EasySocial.dialog({
			"content": EasySocial.ajax('site/views/stream/getFilterFormDialog', {
				"type": opts.type,
				"uid": opts.uid
			})
		});
	},

	"{saveHashTag} click": function(el) {
		var hashtag = el.data('tag');

		EasySocial.dialog({
			"content": EasySocial.ajax('site/views/stream/getFilterFormDialog', {
				"type": opts.type,
				"hashtag": hashtag,
				"uid": opts.uid
			})
		});
	}
}});

module.resolve();

});

});
			EasySocial.module('site/stream/item', function() {

var module	= this;

EasySocial.require()
.library("mentions", "placeholder", "leaflet", "leaflet-providers", "gmaps", "toast")
.done(function($) {

EasySocial.Controller('Stream.Item', {
	defaultOptions: {
		// Properties
		id: "",
		context: "",

		// Actions
		"{delete}": "[data-stream-actions] > [data-delete]",

		// Bookmarks
		"{addBookmark}": "[data-bookmark-add]",
		"{removeBookmark}": "[data-bookmark-remove]",

		// Hide actions
		"{hiddenNotice}": "[data-hidden-notice]",
		"{hide}": "[data-hide]",
		"{unhide}": "[data-unhide]",

		// Translations
		"{translate}": "[data-translate]",

		// Sticky items
		"{addSticky}": "[data-sticky-add]",
		"{removeSticky}": "[data-sticky-remove]",

		// Stream content area
		"{contents}": "[data-contents]",
		"{preview}": "[data-preview]",
		"{wrapper}": "[data-wrapper]",

		// Editors
		"{edit}": "[data-edit]",
		"{update}": "[data-edit-update]",
		"{cancelEdit}": "[data-edit-cancel]",
		"{editor}": "[data-editor]",

		// Stream actions
		"{actions}": "[data-stream-actions]",
		"{comment}": "[data-stream-actions] [data-type=comments]",
		"{commentWrapper}": "[data-es-comments]",
		"{copyLink}": "[data-copylink]",

		// Polls
		"{editPoll}": "[data-polls-edit]",
		"{cancelEditPoll}"	: "[data-stream-polls-edit-cancel]",
		"{updatePoll}": "[data-stream-polls-edit-update]",

		// Others
		"{publishItem}": "[data-publish]",
		"{likes}": "[data-likes-action]",
		"{counterBar}": "[data-stream-counter]",
		"{likeContent}": "[data-likes-content]",
		"{repostContent}": "[data-repost-content]",

		"{share}": "[data-repost-action]",
		"{locationLink}": "[data-location-link]",
		"{locationPreview}": "[data-location-preview]",
		"{giphy}": "[data-giphy-item-preview-placeholder]",
		'{giphyPlaceholder}': '[data-giphy-placeholder]',
		'{giphyPreview}': '[data-giphy-preview]',
		'{giphyContainer}': '[data-giphy-container]',
		'{giphyRemove}': '[data-giphy-remove]'

	}
}, function(self, opts, base) { return {

	init: function() {
		// Set the stream's unique id.
		opts.id = base.data('id');
		opts.context = base.data('context');
		opts.hidden = base.data('hidden');
		opts.actor = base.data('actor');
		opts.appid = base.data('appid');
	},

	initMap: function() {

		var locationMap = base.find('[data-location-map]');
		var isEdit = locationMap.hasClass('is-edited');

		if (locationMap.length > 0) {
			var lat = locationMap.data('latitude');
			var lng = locationMap.data('longitude');

			if (lat && lng) {
				if (locationMap.data('location-provider') === 'osm') {
					self.initOsm(locationMap, lat, lng, isEdit);
				} else {
					self.initGmaps(locationMap, lat, lng, isEdit);
				}
			}

			locationMap.removeClass('is-edited');
		}
	},

	marker: {},
	gmap: false,

	initGmaps: function(divEle, lat, lng, isEdit) {
		if (self.gmap !== false && !isEdit) {
			return;
		}

		self.gmap = new $.GMaps({
				div: divEle.get(0),
				lat: lat,
				lng: lng,
				zoom: 15,
				mapTypeId: 'roadmap',
				zoomControl: true,
				clickableIcons: false,
				streetViewControl: false,
				mapTypeControl: false
			});

		// We will remove all markers first (if any)
		self.gmap.removeMarkers();

		// Add the new marker on the map
		var marker = self.gmap.addMarker({
			lat: lat,
			lng: lng
		});

		self.gmap.setCenter(lat, lng);

		var currentZoom = self.gmap.map.zoom;

		// If the current zoom too far,
		// we zoom in a bit
		if (currentZoom < 13) {
			self.gmap.fitZoom();
			self.gmap.zoomOut(9);
		}
	},

	initOsm: function(divEle, lat, lng, isEdit) {

		if (self.osm !== undefined && !isEdit) {
			return;
		}

		self.osm = L.map(divEle.get(0), {
			zoom: 12
		});

		self.osm.fitWorld();

		L.tileLayer.provider('Wikimedia').addTo(self.osm);

		var latlng = {
					lat: parseFloat(lat),
					lng: parseFloat(lng)
				}

		self.osm.removeLayer(self.marker);

		self.osm.flyTo(latlng, 10, {
			"duration": 3
		});

		self.marker = L.marker(latlng).addTo(self.osm);
	},

	getActiveFilter: function() {
		var filterItem = $('[data-filter-item].active');

		return filterItem;
	},

	plugins: {},

	"{locationLink} click": function() {
		self.locationPreview().toggleClass('t-hidden');
		self.initMap();
	},

	"{translate} click": function(link, event) {

		// Get the stream content
		var contents = self.contents().html();
		var translatedWrapper = link.siblings('[data-translations]');

		// Add a loading indicator on the translation link
		self.element.addClass('is-translating');

		EasySocial.ajax('site/controllers/stream/translate', {
			"contents": contents
		}).done(function(html) {

			// Add the translated contents
			translatedWrapper.html(html)

		}).always(function() {

			// Once translated, remove the translate link.
			link.remove();

			self.element
				.removeClass('is-translating')
				.addClass('is-translated');
		});
	},

	"{addBookmark} click": function(el, event) {

		// Add class to the element
		self.element.addClass('is-bookmarked');

		EasySocial.ajax('site/controllers/stream/bookmark', {
			"id" : opts.id
		}).done(function() {

		}).fail(function(message) {
			// If this is failed, we need to display the message object
			self.element.removeClass('is-bookmarked');

			self.setMessage(message);
		});
	},

	"{removeBookmark} click": function(link, event) {

		// Get the active filter type
		var filter = self.getActiveFilter();
		var type = filter.data('type');

		// Always remove the bookmark class
		self.element.removeClass('is-bookmarked');

		EasySocial.ajax('site/controllers/stream/removeBookmark', {
			"id": opts.id
		}).done(function() {
			if (type == 'bookmarks') {
				self.element.remove();
			}
		});
	},

	"{addSticky} click": function(el, event) {
		var recentDivider = $('[data-stream-recent-divider]');
		var stickyDivider = $('[data-stream-sticky-divider]');
		var stickyList = self.element.parent().siblings('[data-stream-sticky-list]');

		EasySocial.ajax('site/controllers/stream/addSticky', {
			"id" : opts.id
		})
		.done(function(){
			self.element.addClass('is-sticky');

			if (stickyDivider.hasClass('t-hidden')) {
				recentDivider.removeClass('t-hidden');
				stickyDivider.removeClass('t-hidden');
				stickyList.removeClass('t-hidden');
			}

			// append the new pinned item
			stickyList.prepend(self.element);
		});;
	},

	"{removeSticky} click": function(el, event) {
		var filter = self.getActiveFilter();
		var type = filter.data('type');

		var recentDivider = $('[data-stream-recent-divider]');
		var stickyDivider = $('[data-stream-sticky-divider]');
		var streamList = self.element.parent().siblings('[data-stream-list]');
		var stickyList = self.element.parent('[data-stream-sticky-list]');

		EasySocial.ajax('site/controllers/stream/removeSticky', {
			"id": self.options.id
		})
		.done(function(){

			self.element.removeClass('is-sticky');

			streamList.prepend(self.element);

			if (stickyList.children().length == 0) {
				recentDivider.addClass('t-hidden');
				stickyDivider.addClass('t-hidden');
				stickyList.addClass('t-hidden');
			}

		});
	},

	"{publishItem} click": function(el, event) {
		var id = opts.id;

		EasySocial.ajax('site/controllers/stream/publish', {
			"id": id
		}).done(function() {

			$pendingFilter = $('[data-filter-item="moderation"]');
			$pendingFilter.removeClass('has-notice');

			// When the stream is published, we want to hide the item
			base.switchClass('is-published');
		});
	},

	"{likes} onLiked": function(el, event, data) {
		self.counterBar().removeClass('hide');
	},

	"{likes} onUnliked": function(el, event, data) {

		var isLikeHide 		= self.likeContent().hasClass('hide');
		var isRepostHide 	= self.repostContent().hasClass('hide');

		if( isLikeHide && isRepostHide )
		{
			self.counterBar().addClass( 'hide' );
		}
	},

	"{share} create": function(el, event, itemHTML) {

		//need to make the data-stream-counter visible
		self.counterBar().removeClass('hide');

	},

	"{comment} click" : function() {
		// Trigger comments
		self.commentWrapper().trigger('show');
	},

	"{delete} click" : function() {

		var uid = opts.id;

		EasySocial.dialog({
			content: EasySocial.ajax('site/views/stream/confirmDelete'),
			bindings: {
				"{deleteButton} click" : function() {

					EasySocial.ajax('site/controllers/stream/delete', {
						"id": uid,
					}).done(function() {

						EasySocial.dialog.close();

						// Remove the element
						self.element
							.fadeOut(400, function() {
								self.element.remove();

								self.parent.trigger('onDeleteStream', [uid]);
							});

					});
				}
			}
		});

	},

	"{editPoll} click" : function(button, event) {
		var uid = self.options.id;
		var element = 'stream';

		EasySocial.ajax('site/views/polls/edit', {
			"uid": uid,
			"element": element,
			"source": 'stream'
		}).done(function(html) {

			// Add editing state
			self.element.addClass('is-editing');

			self.contents().hide();
			self.preview().hide();
			self.locationPreview().hide();
			self.editor().html(html);

		});
	},

	"{cancelEditPoll} click" : function() {
		self.element.removeClass('is-editing');

		self.editor().empty();
		self.contents().show();
		self.preview().show();
		self.locationPreview().show();
	},

	"{updatePoll} click": function() {
		var controller = self.element.find('[data-polls-form]').controller('EasySocial.Controller.Polls.Form');

		var valid = controller.validateForm();

		if (!valid) {
			return task.reject('Error validating polls inputs. Please make sure all the required fields are filled in.');
		}

		// Export the data
		var data = controller.toData();

		EasySocial.ajax('site/controllers/polls/update', data)
			.done(function(preview, id){
				self.preview().html(preview);
				self.cancelEditPoll().click();
			});
	},

	"{cancelEdit} click" : function() {
		self.element.removeClass('is-editing');

		// Remove the contents
		self.editor().empty();

		// Show the contents
		self.contents().removeClass('t-hidden');

		// Show the preview
		self.preview().removeClass('t-hidden');

		// Show the giphy
		self.giphy().removeClass('t-hidden');
	},


	"{edit} click" : function() {

		EasySocial.ajax('site/views/stream/edit', {
			"id": opts.id,
			"appid": opts.appid
		}).done(function(html) {

			// Add editing state
			self.element.addClass('is-editing');

			// Hide the stream contents
			self.contents().addClass('t-hidden');

			// Hide preview
			self.preview().addClass('t-hidden');
			self.locationPreview().addClass('t-hidden');

			// Hide the giphy
			self.giphy().addClass('t-hidden');

			// Append the editor
			self.editor().html(html);

			self.setGiphyImageWidth();
		});
	},

	setGiphyImageWidth: function() {
		self.giphyPlaceholder().css('width', '100%');
		self.giphyRemove().addClass('t-hidden');
		self.giphyContainer().addClass('is-loading');

		self.giphyPreview()
			.off('load')
				.on('load', function() {
					self.giphyContainer().removeClass('is-loading');

					var parent = $(this).parent();

						// Display the placeholder and set the width given the width of the image
						setTimeout(function() {
							var computedWidth = parent.css('width');

							self.giphyPlaceholder().css('width', computedWidth);
						}, 10);

					self.giphyRemove().removeClass('t-hidden');
				});
	},

	"{hide} click": function(link, event) {

		var type = link.data('type');
		var multiple = link.data('multiple');

		EasySocial.ajax('site/controllers/stream/hide', {
			"id": opts.id,
			"actor": opts.actor,
			"context": opts.context,
			"type": type
		}).done(function(html) {

			// Hide itself
			self.wrapper().hide();

			// Hide all feeds that belong to the type
			var items = $('[data-stream-item][data-' + type + '="' + opts[type] + '"]');
			items.addClass('t-hidden');

			// Append the message
			self.element.append(html);
			self.element.removeClass('t-hidden');
		});
	},

	"{copyLink} click": function(button) {
		var url = button.data('clipboard-link');
		var message = self.parent.options.copiedLinkMessage;

		self.linkToCopy(url, message);
	},

	linkToCopy: function(url, message) {

		// For ios device, require special handling to avoid issue in #3586
		if (navigator.userAgent.match(/iPhone|iPad|iPod/i)) {

			// Add new textarea
			textArea = document.createElement('textArea');
			textArea.value = url;

			// Set the properties to ensure that the textarea is not showing in the screen
			textArea.setAttribute('readonly', '');
			textArea.style.position = 'absolute';
			textArea.style.left = '-9999px';
			document.body.appendChild(textArea);

			// Set selection range manually
			range = document.createRange();
			range.selectNodeContents(textArea);
			selection = window.getSelection();
			selection.removeAllRanges();
			selection.addRange(range);
			textArea.setSelectionRange(0, 999999);

			// Copy the url
			document.execCommand('copy');
			document.body.removeChild(textArea);
		} else {
			var temp = $('<input>');

			$('body').append(temp);
			temp.val(url).select();

			document.execCommand('copy');
			temp.remove();
		}

		// Show the notification to the users to tell them that the link has been copied
		new $.toast({
			text: message,
			loader: false,
			textAlign: 'center',
			showHideTransition: 'fade',
			allowToastClose: true,
			hideAfter: 3000,
			position: 'bottom-center',
			loaderBg: '#000000',

			// false if there should be only one toast at a time or a number representing the maximum number of toasts to be shown at a time
			stack: false
		});
	},

	"{unhide} click": function(button, event) {
		var parent = button.parents(self.hiddenNotice.selector);
		var type = parent.data('type');

		EasySocial.ajax('site/controllers/stream/unhide', {
			"type": type,
			"actor": opts.actor,
			"context": opts.context,
			"id": opts.id
		}).done(function() {

			// Remove the hidden notice
			self.hiddenNotice('[data-type="' + type + '"]').remove();

			// Show the stream item
			self.wrapper().show();

			// Show all feeds that belong to this actor
			var items = $('[data-stream-item][data-' + type + '="' + opts[type] + '"]');

			if (items.length > 0) {
				items.removeClass('t-hidden');
			}
		});
	},

}});

module.resolve();
});
});
			EasySocial.module('site/stream/stream', function(){

var module = this;

EasySocial.require()
.script('site/stream/item')
.done(function($) {

EasySocial.Controller('Stream', {

	defaultOptions: {
		// Properties
		checknew: null,
		source: null,
		sourceId: null,
		clusterId: null,
		clusterType: null,
		autoload: true,

		// Elements
		"{story}": "[data-story]",
		"{repost}": "[data-repost-action]",

		// Notification bar to notify users of new stream items
		"{updatesBar}": "[data-updates-bar]",
		"{newUpdatesButton}": "[data-updates-button]",

		"{newNotiBar}": "[data-stream-notification-bar]",
		"{newNotiButton}": "[data-stream-notification-button]",

		// Stream lists
		"{list}": "[data-stream-list]",
		"{item}": "[data-stream-item]",

		// Pagination
		"{pagination}": "[data-pagination]"
	}
}, function(self, opts) { return {

	init : function() {

		// Implement stream item controller.
		self.item().addController(EasySocial.Controller.Stream.Item, {
			"{parent}": self
		});

		// Auto load streams when scroll
		if (opts.autoload == true) {

			self.on("scroll.stream", window, $._.debounce(function(){

				// If it is loading, do not run it again
				if (self.loading) {
					return;
				}

				if (!self.pagination().visible()) {
					return;
				}

				// Only run the load more when it's visible
				self.loadMore();

			}, 250));

			if (window.es.mobile) {

				// for mobile touch move
				self.on("touchmove", self.element, $._.debounce(function(){
					// If it is loading, do not run it again
					if (self.loading) {
						return;
					}

					// console.log(self.pagination(), document.body.scrollHeight);
					if (!self.pagination().visible()) {
						return;
					}

					// Only run the load more when bottom of the page
					self.loadMore();
				}, 250));
			}

		}

		self.setLayout();

		// listening to notifier.updates trigger
		$(window).on('notifier.updates', function(event, data) {

			if (data.stream == undefined) {
				return;
			}

			var total = data.stream.total;
			var streamData = data.stream.data;
			var nextupdate = streamData.startdate;
			var forceDisplay = data.forceDisplay;

			// update current date
			self.element.data('currentdate', nextupdate);

			if (total <= 0) {
				return;
			}

			var itemData = streamData.data;

			$.each(itemData, function(i, item) {

				if (item.cnt > 0) {

					// Try to find if there are any filter items that matches the criteria
					if (item.type == 'group' || item.type == 'event' || item.type == 'page') {
						item.type = 'feeds';
					}

					var filterItem = $('[data-filter-item][data-type="' + item.type + '"]');
					var counter = filterItem.find('[data-counter]');

					// Get the current count
					var currentCount = counter.text();

					// Get the correct counter to be displayed
					var totalCount = item.cnt;

					if (currentCount) {
						totalCount = parseInt(currentCount, 10) + parseInt(item.cnt, 10);
					}

					// Update the counter
					counter.html(totalCount);
					filterItem.addClass('has-notice');
				}
			});

			var newUpdatesButton = $.trim(streamData.contents);
			var currentContents = $.trim(self.updatesBar().text());

			// display the 'new feed bar' when there is new counter and this new feed bar is not display before.
			if (newUpdatesButton.length > 0 && currentContents.length == 0) {

				if (forceDisplay) {
					var type = $(newUpdatesButton).data('type');
					var uid = $(newUpdatesButton).data('uid');
					var currentdate = $(newUpdatesButton).data('since');

					self.getNewStreams(uid, type, currentdate);

					return;
				}


				self.updatesBar().html(newUpdatesButton);
			}
		});


		// listening to notifier.collection trigger
		$(window).on('notifier.collection', function(event, data) {

			if (!opts.checknew) {
				return;
			}

			// Find the active sidebar.
			var activeSidebar = $('[data-filter-item].active');
			var type = activeSidebar.data('type');
			var id = activeSidebar.data('id');
			var currentdate = self.element.data('currentdate');
			var excludeIds = self.element.data('excludeids');

			var contents = $.trim(self.updatesBar().html());

			if (type == undefined && id == undefined && opts.source == 'profile') {
				type = 'me';
				id = opts.sourceId;
			}

			//wrap up the data.
			var info = {
				"type": type,
				"id": id,
				"currentdate": currentdate,
				"exclude": excludeIds,
				"source": opts.source,
				"view": opts.source
			};

			data.stream = info;
		});

	},

	setLayout: function() {
		// Does nothing for now
	},


	getIdentifier: function() {
		return self.element.data('identifier');
	},

	getActiveFilter: function() {

		// lets try to get the filter item with identifier.
		var filterItem = $("[data-filter-item][data-stream-identifier='" + self.getIdentifier() + "'].active");

		// We know these view won't have filter, just skip this get filter element from page.
		if (opts.source == 'profile' || opts.source == 'profiles') {
			return filterItem;
		}

		if (filterItem == undefined || filterItem.length == 0) {
			var filterItem = $("[data-filter-item].active");
		}

		return filterItem;
	},

	loadMore: function() {

		var filter = self.getActiveFilter();

		var type = filter.data('type');
		var id = filter.data('id');
		var anyid = filter.data('anyid');
		var tag = filter.data('tag');
		var matchAllTags = filter.data('tagMatchAll');

		// Get the pagination attributes
		var startlimit = self.pagination().data('nextlimit');
		var customlimit = self.pagination().data('customlimit');
		var context = self.pagination().data('context');
		var excludeStreamIds = self.pagination().data('excludeStreamids');
		var startdatelimit = self.pagination().data('nextdatelimit');
		var source = opts.source;

		if (!startlimit) {
			return;
		}

		// User profile view
		if (type == undefined && id == undefined && opts.source == 'profile') {
			type = 'me';
			id = opts.sourceId;
		}

		// Profile type view eg: registered user
		if (type == undefined && id == undefined && opts.source == 'profiles') {
			type = 'profile';
			id = opts.sourceId;
		}

		// Set the current loading state
		self.loading = true;

		// Add loading indicator
		self.pagination().addClass('is-loading');

		// Determines if this stream listing is for a cluster
		var cluster = self.element.data('cluster');

		var options = {
				"id": id,
				"anyid": anyid,
				"type": type,
				"startlimit": startlimit,
				"startdatelimit": startdatelimit,
				"customlimit": customlimit,
				"source": source,
				"tag": tag,
				"matchAllTags": matchAllTags,
				"context": context,
				"iscluster": cluster,
				"clusterId": opts.clusterId,
				"clusterType": opts.clusterType,
				"excludeStreamIds": excludeStreamIds,
				"controller": "stream",
				"task": "loadmore",
		};

		options[EasySocial.token()] = 1;

		// Use jquery's ajax method as we need to use the standard html view
		$.Ajax({
			"url": EasySocial.ajaxUrl,
			"method": 'post',
			"data": options
		}).done(function(contents) {
			var data = JSON.parse(contents);

			var contents = $(data.contents);
			var nextlimit = data.nextlimit;
			var nextdatelimit = data.nextdatelimit;

			// Update start & end date
			self.pagination().data('nextlimit', nextlimit);
			self.pagination().data('nextdatelimit', nextdatelimit);

			var contents = $.buildHTML(contents);
			contents
				.appendTo(self.list())
				.filter(self.item.selector)
				.addController(EasySocial.Controller.Stream.Item, {
					"{parent}": self
				});

			self.setLayout();

			// add support to kunena [tex] replacement.
			try {
				MathJax && MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
			} catch(err) {};

			if (nextlimit == "") {
				self.pagination().remove();
			}
		})
		.always(function() {

			// Initialize reactions
			if (window.es.mobile || window.es.tablet) {
				window.es.initReactions();
			}

			self.pagination().removeClass('is-loading');

			self.loading = false;
		});
	},

	insertItem: function(html) {
		// Update the current date so that the next new stream notification will not include this item.
		self.updateCurrentDate();

		$.buildHTML(html)
			.prependTo(self.list())
			.addController(EasySocial.Controller.Stream.Item, {
				"{parent}": self
			});

		// Since something is added to the stream, it should never be empty
		self.element.removeClass('is-empty');
	},

	"{window} resize": $.debounce(function() {

		self.setLayout();

	}, 500),

	"{self} onDeleteStream": function(element, event, uid) {

		if (self.item().length <= 0) {
			self.element.addClass('is-empty');
		}
	},

	"{repost} create": function(element, event, itemHTML) {

		// Insert the item to the list
		self.insertItem(itemHTML);
	},

	"{story} create": function(element, event, html, id) {

		if (id) {
			// we need to increate the nextlimit
			var currentStartLimit = self.pagination().data('nextlimit');

			// if its already a negative, mean this page has no more stream to loadmore.
			if (currentStartLimit > 0) {
				currentStartLimit++;
				self.pagination().data('nextlimit', currentStartLimit);
			}
		}

	},

	updateCurrentDate: function() {

		EasySocial.ajax('site/views/stream/getCurrentDate', {
		}).done(function(currentdate) {
			// update next start date
			self.element.data('currentdate', currentdate);
		}).fail(function(messageObj) {

		});

	},

	updateExcludeIds: function(id) {
		var ids = self.element.data('excludeids');
		var newIds = '';

		if (ids != '' && ids != undefined) {
				newIds = ids + ',' + id;
		} else {
			newIds = id;
		}

		self.element.data('excludeids', newIds);
	},

	clearExcludeIds: function() {
		self.element.data('excludeids', '');
	},

	getNewStreams: function(uid, type, currentdate) {
		EasySocial.ajax('site/controllers/stream/getUpdates', {
			"type": type,
			"id": uid,
			"currentdate": currentdate,
			"source": opts.source,
			"view": opts.source
		}).done(function(contents, nextupdate, streamIds) {

			// Get the active filter item
			var filterItem = $('[data-filter-item].active');
			var counter = filterItem.find('[data-counter]');

			// Clear the counter value since we are now retrieving the new stuffs
			if (counter.length > 0) {
				filterItem.removeClass('has-notice');
				counter.html('0');
			}

			// Lets remove the stream items from the page if there is any
			$.each(streamIds, function(i, uid) {
				self.item().where('id', uid).remove();
			});

			var itemCount = streamIds.length;
			var	startlimit = self.pagination().data("nextlimit");
			startlimit = startlimit + itemCount;

			self.pagination().data('nextlimit', startlimit);

			// Clear the new feeds notification.
			self.updatesBar().empty();

			// append stream into list.
			var contents = $.buildHTML(contents);

			contents.prependTo(self.list())
				.addController(EasySocial.Controller.Stream.Item, {
					"{parent}": self
				});

			 // Clear the exclude ids
			 self.clearExcludeIds();

			 // Update the next update date
			 self.element.data('currentdate', nextupdate);
		});
	},

	"{newUpdatesButton} click": function(button, event) {
		var type = button.data('type');
		var uid = button.data('uid');
		var currentdate = button.data('since');

		self.getNewStreams(uid, type, currentdate);
	},


	loadMoreGuest: function() {
		var pagination = self.paginationGuest();
		var startlimit = pagination.data("nextlimit");

		var view = opts.source;

		if (!startlimit) {
			return;
		}

		self.loading = true;

		pagination.html(self.view.loadingContent({content: ""}));

		var options = {
				"controller": "stream",
				"task": "loadmoreGuest",
				"view": view,
				"startlimit": startlimit
		};

		options[EasySocial.token()] = 1;

		// Use jquery's ajax method as we need to use the standard html view
		$.Ajax({
			"url": EasySocial.ajaxUrl,
			"method": 'post',
			"data": options
		}).done(function(contents) {
			var data = JSON.parse(contents);

			var contents = $(data.contents);
			var nextlimit = data.nextlimit;

			// Update start & end date
			pagination.data({
				nextlimit: nextlimit
			});

			var contents = $.buildHTML(contents);

				contents
					.insertBefore(pagination)
					.filter(self.item.selector)
					.addController("EasySocial.Controller.Stream.Item", {
						"{parent}": self
					});

			// add support to kunena [tex] replacement.
			try { MathJax && MathJax.Hub.Queue(["Typeset",MathJax.Hub]); } catch(err) {};

			//if (opts.autoload || nextlimit=="") {
			if (nextlimit=="") {
				pagination.empty();
			} else {
				//append the anchor link.
				pagination.html(self.view.loadmoreContent());
			}
		})
		.always(function(){
			self.loading = false;
		});
	},

	"{pagination} click" : function() {
		self.loadMore();
	}
}});

module.resolve();
});

});
			EasySocial.module('site/system/broadcast', function($){

var module = this;

EasySocial.require()
.script('site/vendors/gritter')
.done(function($){

EasySocial.Controller('System.Broadcast', {
	defaultOptions: {
		interval: 30,
		sticky: false,
		period: 8
	}
}, function(self, opts, base) { return {

	init: function() {
		self.startMonitoring();
	},

	startMonitoring: function() {
		var interval = opts.interval * 1000;

		opts.state = setTimeout(self.check, interval);
	},

	stopMonitoring: function() {
		clearTimeout(opts.state);
	},

	check: function() {
		// Stop monitoring so that there wont be double calls at once.
		self.stopMonitoring();

		var interval = opts.interval * 1000;

		// Needs to run in a loop since we need to keep checking for new notification items.
		setTimeout(function(){

			EasySocial.ajax('site/controllers/notifications/getBroadcasts')
				.done(function(items){

					if (items) {

						$(items).each(function(i, item) {

							var data = {
								title: item.title,
								raw_title: item.raw_title,
								text: item.content,
								image: item.authorAvatar,
								sticky: self.options.sticky,
								time: self.options.period * 1000,
								class_name: 'es-broadcast'
							};

							$.gritter.add(data);

							$('body').trigger('update.notifications', ['broadcast', {"title": data.raw_title, "contents": data.text, "link": data.link, "image": data.image}]);
						});
					}

					// Continue monitoring.
					self.startMonitoring();
				});

		}, interval);

	}
}});

module.resolve();
});

});
			EasySocial.module('site/system/keepalive', function($){

var module = this;

EasySocial.Controller('System.KeepAlive', {
	defaultOptions: {
		"isHidden" : false,
		"hidden":null,
		"visibilityChange":null,
	}
}, function(self, opts) { return {

	init: function() {
		self.execute();
	},

	execute: function() {

		if (typeof document.hidden !== "undefined") { // Opera 12.10 and Firefox 18 and later support 
			self.hidden = "hidden";
			self.visibilityChange = "visibilitychange";
		} else if (typeof document.msHidden !== "undefined") {
			self.hidden = "msHidden";
			self.visibilityChange = "msvisibilitychange";
		} else if (typeof document.webkitHidden !== "undefined") {
			self.hidden = "webkitHidden";
			self.visibilityChange = "webkitvisibilitychange";
		}

		document.addEventListener(self.visibilityChange, function(e) {

			var hidden = self.hidden;

			if (document[hidden]) {
				self.isHidden = true;
			}

			if (self.isHidden && !document[hidden]) {

				var keepaliveOptions = Joomla.getOptions('system.keepalive'),
					keepaliveUri = keepaliveOptions && keepaliveOptions.uri ? keepaliveOptions.uri.replace(/&amp;/g, '&') : '',
					systemPaths = Joomla.getOptions('system.paths');

				// Fallback in case no keepalive uri was found.
				if (keepaliveUri === '') {
					keepaliveUri = (systemPaths ? systemPaths.root + '/index.php' : window.location.pathname) + '?option=com_ajax&format=json';
				}

				Joomla.request({
					url: keepaliveUri,
					onSuccess: function(response, xhr) {
						var renewUri = (systemPaths ? systemPaths.root + '/index.php' : window.location.pathname) + '/index.php?option=com_easysocial&renewToken=true';

						Joomla.request({
							url: renewUri,
							onSuccess: function(response, xhr) {
								// #3257
								// we do not overwrite the window.es.token so that we stil keep track the
								// old token for later comparison in plupload.
								// see file 'media/com_easysocial/scripts/vendors/plupload.js' at line line 1152 on BeforeUpload bind.

								// update component.js session token value
								EasySocial.token.value = response;
							},
							onError: function(xhr) {
								// Do nothing
							}
						});
					},
					onError: function(xhr) {
						// Do nothing
					}
				});
			}

		}, false);
	}

}});

module.resolve();
});
			EasySocial.module('site/system/notifications', function($){

var module = this;

EasySocial.Controller('System.Notifications', {
	defaultOptions: {
		"interval": 2,
		userId: null
	}
}, function(self, opts) { return {
	init: function(){
		self.start();
	},

	getInterval: function() {
		return opts.interval * 1000;
	},

	start: function() {
		opts.state = setTimeout(self.check, self.getInterval());
	},

	stop: function() {
		clearTimeout(opts.state);
	},

	check: function() {
		// When checking, ensure that all previous queues are stopped
		self.stop();

		// Needs to run in a loop since we need to keep checking for new notification items.
		setTimeout(function(){

			$.ajax({
				"url": window.es.rootUrl + '/components/com_easysocial/polling.php',
				"method": "post",
				"data": {
					"method": "notifier",
					"userId": opts.userId
				}
			}).done(function(data) {
				self.element.trigger('notification.updates', data);
				self.start();
			});

		}, self.getInterval());
	}

}});

module.resolve();
});
			EasySocial.module('site/system/notifier', function($){

var module = this;

EasySocial.Controller('System.Notifier', {
	defaultOptions: {
		"interval": 30
	}
}, function(self, opts) { return {

	init: function() {

		if (!opts.guest) {
			self.start();
		}
	},

	getInterval: function() {
		return opts.interval * 1000;
	},

	start: function() {
		opts.state = setTimeout(self.check, self.getInterval());
	},

	stop: function() {
		clearTimeout(opts.state);
	},

	execute: function(forceDisplay) {
		// before we send request to server, lets gather data from
		// other plugins.
		var collection = {};
		self.element.trigger('notifier.collection', collection);

		EasySocial.ajax('site/controllers/notifier/check', {
			"data": collection,
		}).done(function(data) {

			data.forceDisplay = forceDisplay;

			self.element.trigger('notifier.updates', data);
			self.start();
		});
	},

	check: function(executeNow, forceDisplay) {

		forceDisplay = forceDisplay == undefined ? false : forceDisplay;
		executeNow = executeNow == undefined ? false : executeNow;
		
		// When checking, ensure that all previous queues are stopped
		self.stop();

		// Needs to run in a loop since we need to keep checking for new notification items.
		if (executeNow) {
			self.execute(forceDisplay);
			return;
		}

		setTimeout(function(){
			self.execute(forceDisplay);
		}, self.getInterval());
	}

}});

module.resolve();
});
			EasySocial.module('site/toolbar/friends', function($) {

var module = this;

EasySocial.Controller('Notifications.Friends.Popbox', {
	
	defaultOptions: {
		// This should be added by the implementer
		'messages' : {
			'rejected': ''
		},

		'{actions}': '[data-actions]',
		'{item}': '[data-item]',
		"{reject}": "[data-action=reject]",
		"{accept}": "[data-action=accept]",

		actions : []
	}
}, function(self, opts) { return {
	
	getToolbarController: function() {
		var element = $('[data-notifications][data-type="friends"]');

		return element;
	},

	getRequesterId: function(element) {
		var item = element.closest(self.item.selector);
		var id = item.data('id');

		return id;
	},

	updateCounter: function() {
		var controller = self.getToolbarController();
		var counter = controller.find('[data-counter]').first().text();
		counter = parseInt(counter) - 1;

		if (counter <= 0) {
			controller.removeClass('has-new');
		}

		// Update the count
		controller.find('[data-counter]').html(counter.toString());
	},

	insertMessage: function(button, message) {
		// Get the actions wrapper
		var wrapper = button.parents(self.actions.selector);

		wrapper.html(message)
			.addClass('t-text--muted');
	},

	'{reject} click': function(button, event) {
		// Stop other events from propagating
		event.preventDefault();
		event.stopPropagation();

		if (opts.actions['reject']) {
			return;
		}

		button.addClass('is-loading');

		opts.actions['reject'] = true;

		var id = self.getRequesterId(button);
		
		// Update the message
		self.insertMessage(button, opts.messages.rejected);

		// Update the toolbar's counter
		self.updateCounter();

		EasySocial.ajax('site/controllers/friends/reject', {
			"id": id
		}).always(function() {
			opts.actions['reject'] = false;
			button.removeClass('is-loading');
		});
	},

	'{accept} click': function(button, event) {

		// Stop other events from propagating
		event.preventDefault();
		event.stopPropagation();

		if (opts.actions['accept']) {
			return;
		}

		button.addClass('is-loading');

		opts.actions['accept'] = true;

		var id = self.getRequesterId(button);

		// Update the counter
		self.updateCounter();

		// Approve the friend request
		EasySocial.ajax('site/controllers/friends/approve', {
			"id": id
		}).done(function(newButton, message) {
			self.insertMessage(button, message);
		}).always(function() {
			opts.actions['accept'] = false;
			button.removeClass('is-loading');
		});
	}
}});


module.resolve();

});
			EasySocial.module('site/toolbar/notifications' , function($){

var module = this;

EasySocial.Controller('Notifications', {
	defaultOptions: {
		"interval": 45,
		"{friends}": "[data-notifications][data-type=friends]",
		"{conversations}": "[data-notifications][data-type=conversations]",
		"{system}": "[data-notifications][data-type=system]",
		"{item}": "[data-toolbar-item]"
	}
}, function(self, opts){ return {

	init: function() {

		// Initialize responsive layout for the notification bar.
		self.setLayout();

		$(window).on('notification.updates', function(event, data) {

			if (data) {
				if (data.conversation != undefined && data.conversation.total > 0) {
					var total = data.conversation.total > 99 ? '99+' : data.conversation.total;
					var counter = self.conversations().find("[data-counter]");
					var previous = counter.text();

					//update counter
					counter.text(total);
					self.conversations().addClass('has-new');

					// Trigger for 3rd party to intercept
					if (previous != total && total > 0) {
						$('body').trigger('update.notifications', ['conversation', data.conversation.data]);
					}
				} else {
					self.conversations().removeClass('has-new');
				}

				if (data.friend != undefined && data.friend.total > 0) {
					var total = data.friend.total > 99 ? '99+' : data.friend.total;

					self.friends().find("[data-counter]").text(total);
					self.friends().addClass('has-new');
				} else {
					self.friends().removeClass('has-new');

				}

				if (data.system != undefined && data.system.total > 0) {
					var total = data.system.total > 99 ? '99+' : data.system.total;
					self.system().find("[data-counter]").text(total);
					self.system().addClass('has-new');
				} else {
					self.system().removeClass('has-new');
				}
			}

		});


	},

	"{window} resize": $.debounce(function(){
		self.setLayout();
	}, 250),

	setLayout: function() {

		var elem = self.element;
		var toolbarWidth = elem.outerWidth(true) - 80;
		var allItemWidth = 0;

		// Calculate how much width toolbar items are taking
		self.item().each(function(){
			allItemWidth += $(this).outerWidth(true);
		});

		var exceeded = (allItemWidth > toolbarWidth);

		elem.toggleClass("narrow", exceeded).toggleClass("wide", !exceeded);
	},

	getInterval: function() {
		var interval = opts.interval * 1000;
		return interval;
	},

	'{window} easysocial.clearSystemNotification': function() {
		// clear system notification.
		self.system().removeClass('has-new');
		self.system().find("[data-counter]").text(0);
	},

}});

module.resolve();

});
			EasySocial.module( 'site/toolbar/system' , function($){

var module = this;

EasySocial.Controller('Notifications.System.Popbox', {
	defaultOptions: {
		"{readAll}": "[data-readall]",
		"{items}": "[data-items]",
		"{empty}": "[data-empty]"
	}
}, function(self) { return {

	getToolbarController: function() {
		var element = $('[data-notifications][data-type="system"]');

		return element.controller();
	},

	updateCounter: function() {
		var controller = self.getToolbarController();

		// Update the counter and states
		controller.element.removeClass('has-new');
		controller.counter().html(0);
	},

	"{readAll} click": function(link, event) {

		EasySocial.ajax( 'site/controllers/notifications/setAllRead', {
			"state": "read"
		}).done(function() {

			// Remove the items
			self.items().remove();
			self.empty().parent().addClass('is-empty');
			self.empty().removeClass('t-hidden');

			$(window).trigger('easysocial.clearSystemNotification');
		});
	}
}});

module.resolve();

});
			EasySocial.module('site/users/default', function($){

var module = this;

EasySocial.Controller('Users', {
	defaultOptions: {

		sort: '',

		// Sorting
		"{sort}": "[data-sort]",

		// Contents and result
		"{contents}": "[data-contents]",
		"{wrapper}": "[data-wrapper]",
		"{result}": "[data-es-users-result]",
		"{header}": "[data-header]",

		// Sidebar filters
		"{filterItem}": "[data-filter-item]"
	}
}, function(self, opts) { return {

	init : function() {
		opts.sort = self.sort('.active').data('type');
	},

	setActiveFilter: function(filter) {
		// Remove all filter item's active class
		self.filterItem().removeClass('active');

		// Add active state to itself
		filter.addClass('active');
	},

	updateContents: function(contents) {
		self.result().removeClass('is-loading');

		self.result().html(contents);
	},

	getActiveFilter: function() {
		return self.filterItem('.active');
	},

	filter: function(sortRequest) {

		// Determines the filter type
		var filter = self.getActiveFilter();

		// Retrieve filter type from the sidebar e.g. users, profiles, search
		var type = filter.data('type');

		// Retrieve filter type data id e.g. all, online, withphotos, and other id (int)
		var id = filter.data('id');

		// If there unable to retrieve the valid type and id, mean the sidebar module already disabled on the site.
		// This part handling for the desktop view
		if (!type && !id) {

			// data filter attribute name return 'all' mean under 'users' type
			if (opts.filter == 'all'
				|| opts.filter == 'friends'
				|| opts.filter == 'followers'
				|| opts.filter == 'photos'
				|| opts.filter == 'online'
				|| opts.filter == 'verified'
				|| opts.filter == 'blocked') {

				var type = 'users';
				var id = opts.filter;
			}

			// Currently only these 2 filter type contain the ids
			if (opts.filter == 'profiletype') {
				var type = 'profiles';
				var id = opts.filterid;
			}

			if (opts.filter == 'search') {
				var type = opts.filter;
				var id = opts.filterid;
			}
		}

		// Add loading indicator
		self.contents().addClass('is-loading');

		if (sortRequest) {
			self.result().empty();
		} else {
			self.wrapper().empty();
		}

		EasySocial.ajax('site/controllers/users/filter', {
			"type": type,
			"id": id,
			"filter": id,
			"sorting": opts.sort,
			"pagination": 1,
			"sortRequest": sortRequest ? 1 : 0
		}).done(function(output) {

			self.contents().removeClass('is-loading');

			if (sortRequest) {
				self.result().html(output);
			} else {
				self.wrapper().html(output);
			}

			$('body').trigger('afterUpdatingContents');

		}).always(function() {
			// Remove loading state
			filter.removeClass('is-loading');
		});
	},

	"{filterItem} click": function(filter, event) {
		// Prevent default
		event.stopPropagation();
		event.preventDefault();

		// Set active filter
		self.setActiveFilter(filter);

		// Route the url
		var anchor = filter.find('> a');
		anchor.route();

		// Add loading state to the filter link
		filter.addClass('is-loading');


		if (filter.data('type') != 'users') {
			opts.sort = '';
		}

		self.filter(false);

        // trigger sidebar toggle for responsive view.
        self.trigger('onEasySocialFilterClick');
	},

	"{sort} click" : function(link, event) {

		// event.preventDefault();
		// event.stopPropagation();

		// Set active class
		self.sort().removeClass('active');
		link.addClass('active');

		// Route the link
		link.route();

		// Retrieve current sorting type from the dropdown
		var sort = link.data('type');

		// Assign to this sort option for this sorting type
		opts.sort = link.data('type');

		// Retrieve current filter data attribute name from the sorting dropdown
		opts.filter = link.data('filter');

		// Retrieve the filter type data id e.g. search and profiles
		opts.filterid = link.data('filterid');

		self.filter(true);
	}
}});

module.resolve();
});
			EasySocial.module("site/users/popbox", function($) {

var module = this;

EasySocial.require()
.library("popbox")
.done(function(){

	EasySocial.module("users/popbox", function($) {

		this.resolve(function(popbox) {

			var ids = popbox.button.data("ids");
			var position = popbox.button.attr("data-popbox-position") || "top-left";

			return {
				content: EasySocial.ajax("site/views/users/popbox", {ids: ids}),
				id: "es",
				component: "",
				type: "users",
				position: position
			};
		});
	});

});

module.resolve();

});
			EasySocial.module('site/utilities/sharing', function($) {

var module = this;

EasySocial.require()
.library('textboxlist')
.done(function() {

$.template('sharing/recipientContent', '[%= title %]<input type="hidden" name="items" value="[%= title %]" />');

EasySocial.Controller('Sharing', {
	defaultOptions: {
		'{vendors}': '[data-sharing-vendor]',
		'{emailForm}': '[data-sharing-email]'
	}
}, function(self, opts, base) { return {
	init: function() {
		self.initLinks();

		self.initEmail();
	},

	initLinks: function() {
		$.each(self.vendors(), function(i, vendor) {

			vendor = $(vendor);

			if(!vendor.data('loaded')) {

				// Extract the href
				var link = vendor.attr('href');

				// Assign it to a data
				vendor.data('href', link);

				// Assign a void to the href
				vendor.attr('href', 'javascript:void(0);');

				// Assign loaded state
				vendor.attr('loaded', true);
			}
		});
	},

	initEmail: function() {
		$.each(self.emailForm(), function(i, form) {

			form = $(form);

			if (!form.data('loaded')) {

				// Implement email form controller
				self.addPlugin('email');

				// Assign loaded state
				form.attr('loaded', true);
			}
		});
	},

	'{vendors} click': function(el, ev) {
		var optionString = el.data('options') || '';

		window.open(el.data('href'), '', optionString);
	}
}});

EasySocial.Controller('Sharing.Email', {
	defaultOptions: {
		token			: '',

		'{container}'	: '[data-sharing-email]',
		'{frames}'		: '[data-sharing-email-frame]',
		'{recipients}'	: '[data-sharing-email-recipients]',
		'{input}'		: '[data-sharing-email-input]',
		'{content}'		: '[data-sharing-email-content]',

		// Frames
		'{frames}'		: '[data-sharing-email-frame]',
		'{frameForm}'	: '[data-sharing-email-form]',
		'{frameSending}': '[data-sharing-email-sending]',
		'{frameDone}'	: '[data-sharing-email-done]',
		'{frameFail}'	: '[data-sharing-email-fail]',
		'{failMsg}'		: '[data-sharing-email-fail-msg]'
	}
}, function(self, opts, base) { return {
		init: function() {
			// Initiate textboxlist plugin
			self.recipients().textboxlist({
				"component": 'es',
				"view": { itemContent: 'sharing/recipientContent'}
			});

			opts.token = self.container().data('token');
			self.originalPosition = self.container().css('position');
		},

		getRecipients: function() {
			var items = self.recipients().controller('textboxlist').getAddedItems();

			var recipients = [];

			$.each(items, function(i, item) {
				recipients.push(item.title);
			});

			var input = self.input().val();

			if(recipients.length < 1 && !$.isEmpty(input)) {
				recipients.push(input);
			}

			return recipients;
		},

		getContent: function() {
			return self.content().val();
		},

		sending: false,
		send: function() {

			if (self.sending) {
				return;
			}

			self.sending = true;

			// Control frames
			self.frames().hide();
			self.frameSending().show();

			// Get the data
			var token = self.options.token;
			var recipients = self.getRecipients();
			var content = self.getContent();

			/// Make the ajax call
			self.submitForm(token, recipients, content)
				.done(function() {
					// Control frames
					self.frames().hide();
					self.frameDone().show();

					// Show the form after 1 second
					setTimeout(function() {
						// Clear recipients
						self.recipients().controller('textboxlist').clearItems();

						// Clear content
						self.content().val('');

						// Control frames
						self.frameDone().hide();
						self.frameForm().show();
					}, 1000);
				}).fail(function(msg) {

					// Control frames
					self.frames().hide();
					self.frameFail().show();
					self.frameForm().show();

					if (msg !== undefined) {
						self.failMsg().html(msg);
					}
				})
				.always(function() {
					self.sending = false;
				});
		},

		// Add email address in if comma is pressed
		'{input} keypress': function(el, ev) {
			if(ev.which === 44) {
				self.recipients().controller('textboxlist').addItem(el.val());
				el.val('');
				return false;
			}
		},

		submitForm: function(token, recipients, content) {
			return EasySocial.ajax('site/controllers/sharing/send', {
				token: token,
				recipients: recipients,
				content: content
			});
		}
	}
});

module.resolve();

});
});
			EasySocial.module('site/utilities/webcam', function($){

var module 	= this;


/**
 * @license jQuery webcam plugin v1.0.0 09/12/2010
 * http://www.xarg.org/project/jquery-webcam-plugin/
 *
 * Copyright (c) 2010, Robert Eisele (robert@xarg.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/

(function ($) {

    var webcam = {

	"extern": null, // external select token to support jQuery dialogs
	"append": true, // append object instead of overwriting

	"width": 320,
	"height": 240,

	"mode": "callback", // callback | save | stream

	"swffile": $.rootPath + '/media/com_easysocial/scripts/site/utilities/jscam.swf',
	"quality": 85,

	"debug":	function () {},
	"onCapture":	function () {},
	"onTick":	function () {},
	"onSave":	function () {},
	"onLoad":	function () {}
    };

    window["webcam"] = webcam;

    $["fn"]["webcam"] = function(options) {

	if (typeof options === "object") {
	    for (var ndx in webcam) {
		if (options[ndx] !== undefined) {
		    webcam[ndx] = options[ndx];
		}
	    }
	}

	var source = '<object id="XwebcamXobjectX" type="application/x-shockwave-flash" data="'+webcam["swffile"]+'" width="'+webcam["width"]+'" height="'+webcam["height"]+'"><param name="movie" value="'+webcam["swffile"]+'" /><param name="FlashVars" value="mode='+webcam["mode"]+'&amp;quality='+webcam["quality"]+'" /><param name="allowScriptAccess" value="always" /></object>';

	if (null !== webcam["extern"]) {
	    $(webcam["extern"])[webcam["append"] ? "append" : "html"](source);
	} else {
	    this[webcam["append"] ? "append" : "html"](source);
	}

	var run = 3;
	(_register = function() {
	    var cam = document.getElementById('XwebcamXobjectX');

	    if (cam && cam["capture"] !== undefined) {

		/* Simple callback methods are not allowed :-/ */
		webcam["capture"] = function(x) {
		    try {
			return cam["capture"](x);
		    } catch(e) {}
		}
		webcam["save"] = function(x) {
		    try {
			return cam["save"](x);
		    } catch(e) {}
		}
		webcam["setCamera"] = function(x) {
		    try {
			return cam["setCamera"](x);
		    } catch(e) {}
		}
		webcam["getCameraList"] = function() {
		    try {
			return cam["getCameraList"]();
		    } catch(e) {}
		}
		webcam["pauseCamera"] = function() {
		    try {
			return cam["pauseCamera"]();
		    } catch(e) {}
		}
		webcam["resumeCamera"] = function() {
		    try {
			return cam["resumeCamera"]();
		    } catch(e) {}
		}
		webcam["onLoad"]();
	    } else if (0 == run) {
		webcam["debug"]("error", "Flash movie not yet registered!");
	    } else {
		/* Flash interface not ready yet */
		run--;
		window.setTimeout(_register, 1000 * (4 - run));
	    }
	})();
    }

})($);


module.resolve();

}); 
			EasySocial.module('site/vendors/gritter', function($) {

var module = this;

/*
 * Gritter for jQuery
 * http://www.boedesign.com/
 *
 * Copyright (c) 2012 Jordan Boesch
 * Dual licensed under the MIT and GPL licenses.
 *
 * Date: February 24, 2012
 * Version: 1.7.4
 */

(function($){
 	
	/**
	* Set it up as an object under the jQuery namespace
	*/
	$.gritter = {};
	
	/**
	* Set up global options that the user can over-ride
	*/
	$.gritter.options = {
		position: '',
		class_name: '', // could be set to 'gritter-light' to use white notifications
		fade_in_speed: 'medium', // how fast notifications fade in
		fade_out_speed: 1000, // how fast the notices fade out
		time: 6000 // hang on the screen for...
	}
	
	/**
	* Add a gritter notification to the screen
	* @see Gritter#add();
	*/
	$.gritter.add = function(params){

		try {
			return Gritter.add(params || {});
		} catch(e) {
		
			var err = 'Gritter Error: ' + e;
			(typeof(console) != 'undefined' && console.error) ? 
				console.error(err, params) : 
				alert(err);
				
		}
		
	}
	
	/**
	* Remove a gritter notification from the screen
	* @see Gritter#removeSpecific();
	*/
	$.gritter.remove = function(id, params){
		Gritter.removeSpecific(id, params || {});
	}
	
	/**
	* Remove all notifications
	* @see Gritter#stop();
	*/
	$.gritter.removeAll = function(params){
		Gritter.stop(params || {});
	}
	
	/**
	* Big fat Gritter object
	* @constructor (not really since its object literal)
	*/
	var Gritter = {
		
		// Public - options to over-ride with $.gritter.options in "add"
		position: '',
		fade_in_speed: '',
		fade_out_speed: '',
		time: '',
		
		// Private - no touchy the private parts
		_custom_timer: 0,
		_item_count: 0,
		_is_setup: 0,
		_tpl_close: '<a class="gritter-close" href="#" tabindex="1">Close Notification</a>',
		_tpl_title: '<span class="gritter-title">[[title]]</span>',
		_tpl_item: '<div id="gritter-item-[[number]]" class="gritter-item-wrapper [[item_class]]" style="display:none" role="alert"><div class="gritter-top"></div><div class="gritter-item">[[close]][[image]]<div class="[[class_name]]">[[title]]<p>[[text]]</p></div><div style="clear:both"></div></div><div class="gritter-bottom"></div></div>',
		_tpl_wrap: '<div id="gritter-notice-wrapper"></div>',
		
		/**
		* Add a gritter notification to the screen
		* @param {Object} params The object that contains all the options for drawing the notification
		* @return {Integer} The specific numeric id to that gritter notification
		*/
		add: function(params){
			// Handle straight text
			if(typeof(params) == 'string'){
				params = {text:params};
			}

			// We might have some issues if we don't have a title or text!
			if(params.text === null){
				throw 'You must supply "text" parameter.'; 
			}
			
			// Check the options and set them once
			if(!this._is_setup){
				this._runSetup();
			}
			
			// Basics
			var title = params.title, 
				text = params.text,
				image = params.image || '',
				sticky = params.sticky || false,
				item_class = params.class_name || $.gritter.options.class_name,
				position = $.gritter.options.position,
				time_alive = params.time || '';

			this._verifyWrapper();
			
			this._item_count++;
			var number = this._item_count, 
				tmp = this._tpl_item;
			
			// Assign callbacks
			$(['before_open', 'after_open', 'before_close', 'after_close']).each(function(i, val){
				Gritter['_' + val + '_' + number] = ($.isFunction(params[val])) ? params[val] : function(){}
			});

			// Reset
			this._custom_timer = 0;
			
			// A custom fade time set
			if(time_alive){
				this._custom_timer = time_alive;
			}
			
			var image_str = (image != '') ? '<img src="' + image + '" class="gritter-image" />' : '',
				class_name = (image != '') ? 'gritter-with-image' : 'gritter-without-image';
			
			// String replacements on the template
			if(title){
				title = this._str_replace('[[title]]',title,this._tpl_title);
			}else{
				title = '';
			}
			
			tmp = this._str_replace(
				['[[title]]', '[[text]]', '[[close]]', '[[image]]', '[[number]]', '[[class_name]]', '[[item_class]]'],
				[title, text, this._tpl_close, image_str, this._item_count, class_name, item_class], tmp
			);

			// If it's false, don't show another gritter message
			if(this['_before_open_' + number]() === false){
				return false;
			}

			$('#gritter-notice-wrapper').addClass(position).append(tmp);
			
			var item = $('#gritter-item-' + this._item_count);
			
			item.fadeIn(this.fade_in_speed, function(){
				Gritter['_after_open_' + number]($(this));
			});
			
			if(!sticky){
				this._setFadeTimer(item, number);
			}
			
			// Bind the hover/unhover states
			$(item).bind('mouseenter mouseleave', function(event){
				if(event.type == 'mouseenter'){
					if(!sticky){ 
						Gritter._restoreItemIfFading($(this), number);
					}
				}
				else {
					if(!sticky){
						Gritter._setFadeTimer($(this), number);
					}
				}
				Gritter._hoverState($(this), event.type);
			});
			
			// Clicking (X) makes the perdy thing close
			$(item).find('.gritter-close').click(function(){
				Gritter.removeSpecific(number, {}, null, true);
				return false;
			});
			
			return number;
		
		},
		
		/**
		* If we don't have any more gritter notifications, get rid of the wrapper using this check
		* @private
		* @param {Integer} unique_id The ID of the element that was just deleted, use it for a callback
		* @param {Object} e The jQuery element that we're going to perform the remove() action on
		* @param {Boolean} manual_close Did we close the gritter dialog with the (X) button
		*/
		_countRemoveWrapper: function(unique_id, e, manual_close){
			
			// Remove it then run the callback function
			e.remove();
			this['_after_close_' + unique_id](e, manual_close);
			
			// Check if the wrapper is empty, if it is.. remove the wrapper
			if($('.gritter-item-wrapper').length == 0){
				$('#gritter-notice-wrapper').remove();
			}
		
		},
		
		/**
		* Fade out an element after it's been on the screen for x amount of time
		* @private
		* @param {Object} e The jQuery element to get rid of
		* @param {Integer} unique_id The id of the element to remove
		* @param {Object} params An optional list of params to set fade speeds etc.
		* @param {Boolean} unbind_events Unbind the mouseenter/mouseleave events if they click (X)
		*/
		_fade: function(e, unique_id, params, unbind_events){

			var params = params || {},
				fade = (typeof(params.fade) != 'undefined') ? params.fade : true,
				fade_out_speed = params.speed || this.fade_out_speed,
				manual_close = unbind_events;

			this['_before_close_' + unique_id](e, manual_close);
			
			// If this is true, then we are coming from clicking the (X)
			if(unbind_events){
				e.unbind('mouseenter mouseleave');
			}
			
			// Fade it out or remove it
			if(fade){
			
				e.animate({
					opacity: 0
				}, fade_out_speed, function(){
					e.animate({ height: 0 }, 300, function(){
						Gritter._countRemoveWrapper(unique_id, e, manual_close);
					})
				})
				
			}
			else {
				
				this._countRemoveWrapper(unique_id, e);
				
			}
						
		},
		
		/**
		* Perform actions based on the type of bind (mouseenter, mouseleave) 
		* @private
		* @param {Object} e The jQuery element
		* @param {String} type The type of action we're performing: mouseenter or mouseleave
		*/
		_hoverState: function(e, type){
			
			// Change the border styles and add the (X) close button when you hover
			if(type == 'mouseenter'){
				
				e.addClass('hover');
				
				// Show close button
				e.find('.gritter-close').show();
						
			}
			// Remove the border styles and hide (X) close button when you mouse out
			else {
				
				e.removeClass('hover');
				
				// Hide close button
				e.find('.gritter-close').hide();
				
			}
			
		},
		
		/**
		* Remove a specific notification based on an ID
		* @param {Integer} unique_id The ID used to delete a specific notification
		* @param {Object} params A set of options passed in to determine how to get rid of it
		* @param {Object} e The jQuery element that we're "fading" then removing
		* @param {Boolean} unbind_events If we clicked on the (X) we set this to true to unbind mouseenter/mouseleave
		*/
		removeSpecific: function(unique_id, params, e, unbind_events){
			
			if(!e){
				var e = $('#gritter-item-' + unique_id);
			}

			// We set the fourth param to let the _fade function know to 
			// unbind the "mouseleave" event.  Once you click (X) there's no going back!
			this._fade(e, unique_id, params || {}, unbind_events);
			
		},
		
		/**
		* If the item is fading out and we hover over it, restore it!
		* @private
		* @param {Object} e The HTML element to remove
		* @param {Integer} unique_id The ID of the element
		*/
		_restoreItemIfFading: function(e, unique_id){
			
			clearTimeout(this['_int_id_' + unique_id]);
			e.stop().css({ opacity: '', height: '' });
			
		},
		
		/**
		* Setup the global options - only once
		* @private
		*/
		_runSetup: function(){
		
			for(opt in $.gritter.options){
				this[opt] = $.gritter.options[opt];
			}
			this._is_setup = 1;
			
		},
		
		/**
		* Set the notification to fade out after a certain amount of time
		* @private
		* @param {Object} item The HTML element we're dealing with
		* @param {Integer} unique_id The ID of the element
		*/
		_setFadeTimer: function(e, unique_id){
			
			var timer_str = (this._custom_timer) ? this._custom_timer : this.time;
			this['_int_id_' + unique_id] = setTimeout(function(){ 
				Gritter._fade(e, unique_id);
			}, timer_str);
		
		},
		
		/**
		* Bring everything to a halt
		* @param {Object} params A list of callback functions to pass when all notifications are removed
		*/  
		stop: function(params){
			
			// callbacks (if passed)
			var before_close = ($.isFunction(params.before_close)) ? params.before_close : function(){};
			var after_close = ($.isFunction(params.after_close)) ? params.after_close : function(){};
			
			var wrap = $('#gritter-notice-wrapper');
			before_close(wrap);
			wrap.fadeOut(function(){
				$(this).remove();
				after_close();
			});
		
		},
		
		/**
		* An extremely handy PHP function ported to JS, works well for templating
		* @private
		* @param {String/Array} search A list of things to search for
		* @param {String/Array} replace A list of things to replace the searches with
		* @return {String} sa The output
		*/  
		_str_replace: function(search, replace, subject, count){
		
			var i = 0, j = 0, temp = '', repl = '', sl = 0, fl = 0,
				f = [].concat(search),
				r = [].concat(replace),
				s = subject,
				ra = r instanceof Array, sa = s instanceof Array;
			s = [].concat(s);
			
			if(count){
				this.window[count] = 0;
			}
		
			for(i = 0, sl = s.length; i < sl; i++){
				
				if(s[i] === ''){
					continue;
				}
				
				for (j = 0, fl = f.length; j < fl; j++){
					
					temp = s[i] + '';
					repl = ra ? (r[j] !== undefined ? r[j] : '') : r[0];
					s[i] = (temp).split(f[j]).join(repl);
					
					if(count && s[i] !== temp){
						this.window[count] += (temp.length-s[i].length) / f[j].length;
					}
					
				}
			}
			
			return sa ? s : s[0];
			
		},
		
		/**
		* A check to make sure we have something to wrap our notices with
		* @private
		*/  
		_verifyWrapper: function(){


			if ($("body > [id=es].gritter").length < 1) {

				// Create container for #fd.gritter
				$(document.createElement("div"))
					.attr("id", "es")
					.addClass("gritter")
					.css({
						position: "absolute",
						top: 0,
						left: 0,
						overflow: "visible",
						width: 0,
						height: 0,
						zIndex: 10022
					})
					.appendTo("body");
			}
		  
			if($('#gritter-notice-wrapper').length == 0){
				$("[id=es].gritter").append(this._tpl_wrap);
			}
		}
		
	}
	
})($);

module.resolve();

}); 			EasySocial.module('site/vendors/idle', function($) {

var module = this;

/**
 *  File: jquery.idle.js
 *  Title:  JQuery Idle.
 *  A dead simple jQuery plugin that executes a callback function if the user is idle.
 *  About: Author
 *  Henrique Boaventura (hboaventura@gmail.com).
 *  About: Version
 *  1.2.7
 *  About: License
 *  Copyright (C) 2013, Henrique Boaventura (hboaventura@gmail.com).
 *  MIT License:
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *  - The above copyright notice and this permission notice shall be included in all
 *    copies or substantial portions of the Software.
 *  - THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 **/
/*jslint browser: true */
/*global jQuery: false */


(function ($) {
	'use strict';

	$.fn.idle = function (options) {
	var defaults = {
			idle: 60000, //idle time in ms
			events: 'mousemove keydown mousedown touchstart', //events that will trigger the idle resetter
			onIdle: function () {}, //callback function to be executed after idle time
			onActive: function () {}, //callback function to be executed after back from idleness
			onHide: function () {}, //callback function to be executed when window is hidden
			onShow: function () {}, //callback function to be executed when window is visible
			keepTracking: true, //set it to false if you want to track only the first time
			startAtIdle: false,
			recurIdleCall: false
		},
		idle = options.startAtIdle || false,
		visible = !options.startAtIdle || true,
		settings = $.extend({}, defaults, options),
		lastId = null,
		resetTimeout,
	 	timeout;

	//event to clear all idle events
	$(this).on( "idle:stop", {}, function( event) {
		$(this).off(settings.events);
		settings.keepTracking = false;
		resetTimeout(lastId, settings);
	});

	resetTimeout = function (id, settings) {
		if (idle) {
			idle = false;
			settings.onActive.call();
		}
		clearTimeout(id);
		if(settings.keepTracking) {
			return timeout(settings);
		}
	};

	timeout = function (settings) {
		var timer = (settings.recurIdleCall ? setInterval : setTimeout), id;
		id = timer(function () {
			idle = true;
			settings.onIdle.call();
		}, settings.idle);
		return id;
	};

	return this.each(function () {
		lastId = timeout(settings);
		$(this).on(settings.events, function (e) {
			lastId = resetTimeout(lastId, settings);
		});

		if (settings.onShow || settings.onHide) {
			$(document).on("visibilitychange webkitvisibilitychange mozvisibilitychange msvisibilitychange", function () {
				if (document.hidden || document.webkitHidden || document.mozHidden || document.msHidden) {
					if (visible) {
						visible = false;
						settings.onHide.call();
					}
				} else {
					if (!visible) {
						visible = true;
						settings.onShow.call();
					}
				}
			});
		}
	});

	};
}($));


module.resolve();

});
			EasySocial.module('site/vendors/jquery.raty', function($) {

var module = this;


/*!
 * jQuery Raty FA - A Star Rating Plugin with Font Awesome
 *
 * Licensed under The MIT License
 *
 * @author  : Jacob Overgaard
 * @doc     : http://jacob87.github.io/raty-fa/
 * @version : 0.1.1
 *
 */

;(function($) {

	var methods = {
		init: function(settings) {
			return this.each(function() {
				methods.destroy.call(this);

				this.opt = $.extend(true, {}, $.fn.raty.defaults, settings);

				var that  = $(this),
						inits = ['number', 'readOnly', 'score', 'scoreName'];

				methods._callback.call(this, inits);

				if (this.opt.precision) {
					methods._adjustPrecision.call(this);
				}

				this.opt.number = methods._between(this.opt.number, 0, this.opt.numberMax);

				this.stars = methods._createStars.call(this);
				this.score = methods._createScore.call(this);

				methods._apply.call(this, this.opt.score);

				if (this.opt.cancel) {
					this.cancel = methods._createCancel.call(this);
				}

				if (this.opt.width) {
					that.css('width', this.opt.width);
				}

				if (this.opt.readOnly) {
					methods._lock.call(this);
				} else {
					that.css('cursor', 'pointer');
					methods._binds.call(this);
				}

				methods._target.call(this, this.opt.score);

				that.data({ 'settings': this.opt, 'raty': true });
			});
		}, _adjustPrecision: function() {
			this.opt.targetType = 'score';
			this.opt.half       = true;
		}, _apply: function(score) {
			if (score && score > 0) {
				score = methods._between(score, 0, this.opt.number);
				this.score.val(score);
			}

			methods._fill.call(this, score);

			if (score) {
				methods._roundStars.call(this, score);
			}
		}, _between: function(value, min, max) {
			return Math.min(Math.max(parseFloat(value), min), max);
		}, _binds: function() {
			if (this.cancel) {
				methods._bindCancel.call(this);
			}

			methods._bindClick.call(this);
			methods._bindOut.call(this);
			methods._bindOver.call(this);
		}, _bindCancel: function() {
			methods._bindClickCancel.call(this);
			methods._bindOutCancel.call(this);
			methods._bindOverCancel.call(this);
		}, _bindClick: function() {
			var self = this,
					that = $(self);

			self.stars.on('click.raty', function(evt) {
				self.score.val((self.opt.half || self.opt.precision) ? that.data('score') : $(this).data('score'));

				if (self.opt.click) {
					self.opt.click.call(self, parseFloat(self.score.val()), evt);
				}
			});
		}, _bindClickCancel: function() {
			var self = this;

			self.cancel.on('click.raty', function(evt) {
				self.score.removeAttr('value');

				if (self.opt.click) {
					self.opt.click.call(self, null, evt);
				}
			});
		}, _bindOut: function() {
			var self = this;

			$(this).on('mouseleave.raty', function(evt) {
				var score = parseFloat(self.score.val()) || undefined;

				methods._apply.call(self, score);
				methods._target.call(self, score, evt);

				if (self.opt.mouseout) {
					self.opt.mouseout.call(self, score, evt);
				}
			});
		}, _bindOutCancel: function() {
			var self = this;

			self.cancel.on('mouseleave.raty', function(evt) {
				$(this).attr('class', self.opt.cancelOff);

				if (self.opt.mouseout) {
					self.opt.mouseout.call(self, self.score.val() || null, evt);
				}
			});
		}, _bindOverCancel: function() {
			var self = this;

			self.cancel.on('mouseover.raty', function(evt) {
				$(this).attr('class', self.opt.cancelOn);

				self.stars.attr('class', self.opt.starOff);

				methods._target.call(self, null, evt);

				if (self.opt.mouseover) {
					self.opt.mouseover.call(self, null);
				}
			});
		}, _bindOver: function() {
			var self   = this,
					that   = $(self),
					action = self.opt.half ? 'mousemove.raty' : 'mouseover.raty';

			self.stars.on(action, function(evt) {
				var score = parseInt($(this).data('score'), 10);

				if (self.opt.half) {
					var position = parseFloat((evt.pageX - $(this).offset().left) / (self.opt.size ? self.opt.size : parseInt(that.css('font-size')))),
							plus     = (position > .5) ? 1 : .5;

					score = score - 1 + plus;

					methods._fill.call(self, score);

					if (self.opt.precision) {
						score = score - plus + position;
					}

					methods._roundStars.call(self, score);

					that.data('score', score);
				} else {
					methods._fill.call(self, score);
				}

				methods._target.call(self, score, evt);

				if (self.opt.mouseover) {
					self.opt.mouseover.call(self, score, evt);
				}
			});
		}, _callback: function(options) {
			for (var i in options) {
				if (typeof this.opt[options[i]] === 'function') {
					this.opt[options[i]] = this.opt[options[i]].call(this);
				}
			}
		}, _createCancel: function() {
			var that   = $(this),
					icon   = this.opt.cancelOff,
					cancel = $('<i />', { class: icon, title: this.opt.cancelHint });

			if (this.opt.cancelPlace == 'left') {
				that.prepend('&#160;').prepend(cancel);
			} else {
				that.append('&#160;').append(cancel);
			}

			return cancel;
		}, _createScore: function() {
			return $('<input />', { type: 'hidden', name: this.opt.scoreName }).appendTo(this);
		}, _createStars: function() {
			var that = $(this);

			for (var i = 1; i <= this.opt.number; i++) {
				var title = methods._getHint.call(this, i),
						icon  = (this.opt.score && this.opt.score >= i) ? 'starOn' : 'starOff';

				icon = this.opt[icon];

				$('<i />', { class : icon, title: title, 'data-score': i }).appendTo(this);

				if (this.opt.space) {
					that.append((i < this.opt.number) ? '&#160;' : '');
				}
			}

			return that.children('i');
		}, _error: function(message) {
			$(this).html(message);

			$.error(message);
		}, _fill: function(score) {
			var self  = this,
					hash  = 0;

			for (var i = 1; i <= self.stars.length; i++) {
				var star   = self.stars.eq(i - 1),
						select = self.opt.single ? (i == score) : (i <= score);

				if (self.opt.iconRange && self.opt.iconRange.length > hash) {
					var irange = self.opt.iconRange[hash],
							on     = irange.on  || self.opt.starOn,
							off    = irange.off || self.opt.starOff,
							icon   = select ? on : off;

					if (i <= irange.range) {
						star.attr('class', icon);
					}

					if (i == irange.range) {
						hash++;
					}
				} else {
					var icon = select ? 'starOn' : 'starOff';

					star.attr('class', this.opt[icon]);
				}
			}
		}, _getHint: function(score) {
			var hint = this.opt.hints[score - 1];
			return (hint === '') ? '' : (hint || score);
		}, _lock: function() {
			var score = parseInt(this.score.val(), 10), // TODO: 3.1 >> [['1'], ['2'], ['3', '.1', '.2']]
					hint  = score ? methods._getHint.call(this, score) : this.opt.noRatedMsg;

			$(this).data('readonly', true).css('cursor', '').attr('title', hint);

			this.score.attr('readonly', 'readonly');
			this.stars.attr('title', hint);

			if (this.cancel) {
				this.cancel.hide();
			}
		}, _roundStars: function(score) {
			var rest = (score - Math.floor(score)).toFixed(2);

			if (rest > this.opt.round.down) {
				var icon = 'starOn';                                 // Up:   [x.76 .. x.99]

				if (this.opt.halfShow && rest < this.opt.round.up) { // Half: [x.26 .. x.75]
					icon = 'starHalf';
				} else if (rest < this.opt.round.full) {             // Down: [x.00 .. x.5]
					icon = 'starOff';
				}

				this.stars.eq(Math.ceil(score) - 1).attr('class', this.opt[icon]);
			}                              // Full down: [x.00 .. x.25]
		}, _target: function(score, evt) {
			if (this.opt.target) {
				var target = $(this.opt.target);

				if (target.length === 0) {
					methods._error.call(this, 'Target selector invalid or missing!');
				}

				if (this.opt.targetFormat.indexOf('{score}') < 0) {
					methods._error.call(this, 'Template "{score}" missing!');
				}

				var mouseover = evt && evt.type == 'mouseover';

				if (score === undefined) {
					score = this.opt.targetText;
				} else if (score === null) {
					score = mouseover ? this.opt.cancelHint : this.opt.targetText;
				} else {
					if (this.opt.targetType == 'hint') {
						score = methods._getHint.call(this, Math.ceil(score));
					} else if (this.opt.precision) {
						score = parseFloat(score).toFixed(1);
					}

					if (!mouseover && !this.opt.targetKeep) {
						score = this.opt.targetText;
					}
				}

				if (score) {
					score = this.opt.targetFormat.toString().replace('{score}', score);
				}

				if (target.is(':input')) {
					target.val(score);
				} else {
					target.html(score);
				}
			}
		}, _unlock: function() {
			$(this).data('readonly', false).css('cursor', 'pointer').removeAttr('title');

			this.score.removeAttr('readonly', 'readonly');

			for (var i = 0; i < this.opt.number; i++) {
				this.stars.eq(i).attr('title', methods._getHint.call(this, i + 1));
			}

			if (this.cancel) {
				this.cancel.css('display', '');
			}
		}, cancel: function(click) {
			return this.each(function() {
				if ($(this).data('readonly') !== true) {
					methods[click ? 'click' : 'score'].call(this, null);
					this.score.removeAttr('value');
				}
			});
		}, click: function(score) {
			return $(this).each(function() {
				if ($(this).data('readonly') !== true) {
					methods._apply.call(this, score);

					if (!this.opt.click) {
						methods._error.call(this, 'You must add the "click: function(score, evt) { }" callback.');
					}


					this.opt.click.call(this, score, $.Event('click'));

					methods._target.call(this, score);
				}
			});
		}, destroy: function() {
			return $(this).each(function() {
				var that = $(this),
						raw  = that.data('raw');

				if (raw) {
					that.off('.raty').empty().css({ cursor: raw.style.cursor, width: raw.style.width }).removeData('readonly');
				} else {
					that.data('raw', that.clone()[0]);
				}
			});
		}, getScore: function() {
			var score = [],
					value ;

			$(this).each(function() {
				value = this.score.val();

				score.push(value ? parseFloat(value) : undefined);
			});

			return (score.length > 1) ? score : score[0];
		}, readOnly: function(readonly) {
			return this.each(function() {
				var that = $(this);

				if (that.data('readonly') !== readonly) {
					if (readonly) {
						that.off('.raty').children('i').off('.raty');

						methods._lock.call(this);
					} else {
						methods._binds.call(this);
						methods._unlock.call(this);
					}

					that.data('readonly', readonly);
				}
			});
		}, reload: function() {
			return methods.set.call(this, {});
		}, score: function() {
			return arguments.length ? methods.setScore.apply(this, arguments) : methods.getScore.call(this);
		}, set: function(settings) {
			return this.each(function() {
				var that   = $(this),
						actual = that.data('settings'),
						news   = $.extend({}, actual, settings);

				that.raty(news);
			});
		}, setScore: function(score) {
			return $(this).each(function() {
				if ($(this).data('readonly') !== true) {
					methods._apply.call(this, score);
					methods._target.call(this, score);
				}
			});
		}
	};

	$.fn.raty = function(method) {
		if (methods[method]) {
			return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));
		} else if (typeof method === 'object' || !method) {
			return methods.init.apply(this, arguments);
		} else {
			$.error('Method ' + method + ' does not exist!');
		}
	};

	$.fn.raty.defaults = {
		cancel        : false,
		cancelHint    : 'Cancel this rating!',
		cancelOff     : 'fa fa-fw fa-minus-square',
		cancelOn      : 'fa fa-fw fa-check-square',
		cancelPlace   : 'left',
		click         : undefined,
		half          : false,
		halfShow      : true,
		hints         : ['bad', 'poor', 'regular', 'good', 'gorgeous'],
		iconRange     : undefined,
		mouseout      : undefined,
		mouseover     : undefined,
		noRatedMsg    : 'Not rated yet!',
		number        : 5,
		numberMax     : 20,
		precision     : false,
		readOnly      : false,
		round         : { down: .25, full: .6, up: .76 },
		score         : undefined,
		scoreName     : 'score',
		single        : false,
		size          : null,
		space         : true,
		starHalf      : 'far fa-fw fa-star',
		starOff       : 'far fa-fw fa-star',
		starOn        : 'fa fa-fw fa-star',
		target        : undefined,
		targetFormat  : '{score}',
		targetKeep    : false,
		targetText    : '',
		targetType    : 'hint',
		width         : false
	};

})($);

module.resolve();

}); 			var rootDoc = this;

EasySocial.module('site/vendors/lightbox', function($) {

	var module = this;
	var jQuery = $;

		/*!
		* Lightbox v2.8.1
		* by Lokesh Dhakar
		*
		* More info:
		* http://lokeshdhakar.com/projects/lightbox2/
		*
		* Copyright 2007, 2015 Lokesh Dhakar
		* Released under the MIT license
		* https://github.com/lokesh/lightbox2/blob/master/LICENSE
		*/

		// Uses Node, AMD or browser globals to create a module.
		(function (root, factory) {
			rootDoc.lightbox = factory(jQuery);
				// if (typeof define === 'function' && define.amd) {
				//     // AMD. Register as an anonymous module.
				//     define(['jquery'], factory);
				// } else {
				//     // Browser globals
				//     factory(jQuery);
				// }
			// if (typeof define === 'function' && define.amd) {
			//     // AMD. Register as an anonymous module.
			//     define(['jquery'], factory);
			// } else if (typeof exports === 'object') {
			//     // Node. Does not work with strict CommonJS, but
			//     // only CommonJS-like environments that support module.exports,
			//     // like Node.
			//     module.exports = factory(require('jquery'));
			// } else {
			//     // Browser globals (root is window)
			//     root.lightbox = factory(root.jQuery);
			// }
		}(this, function ($) {

				function Lightbox(options) {
					this.album = [];
					this.currentImageIndex = void 0;
					this.init();

					// options
					this.options = $.extend({}, this.constructor.defaults);
					this.option(options);
				}

				// Descriptions of all options available on the demo site:
				// http://lokeshdhakar.com/projects/lightbox2/index.html#options
				Lightbox.defaults = {
					albumLabel: 'Image %1 of %2',
					alwaysShowNavOnTouchDevices: false,
					fadeDuration: 500,
					fitImagesInViewport: true,
					// maxWidth: 800,
					// maxHeight: 600,
					positionFromTop: 50,
					resizeDuration: 700,
					showImageNumberLabel: true,
					wrapAround: false
				};

				Lightbox.prototype.option = function(options) {
					$.extend(this.options, options);
				};

				Lightbox.prototype.imageCountLabel = function(currentImageNum, totalImages) {
					return this.options.albumLabel.replace(/%1/g, currentImageNum).replace(/%2/g, totalImages);
				};

				Lightbox.prototype.init = function() {
					this.enable();
					this.build();
				};

				// Loop through anchors and areamaps looking for either data-lightbox attributes or rel attributes
				// that contain 'lightbox'. When these are clicked, start lightbox.
				Lightbox.prototype.enable = function() {
					var self = this;
					$('body').on('click', 'a[rel^=lightbox], area[rel^=lightbox], a[data-lightbox], area[data-lightbox]', function(event) {
						self.start($(event.currentTarget));
						return false;
					});
				};

				// Build html for the lightbox and the overlay.
				// Attach event handlers to the new DOM elements. click click click
				Lightbox.prototype.build = function() {
					var self = this;
					$('<div id="es-lightboxOverlay" class="es-lightboxOverlay"></div><div id="es-lightbox" class="es-lightbox"><div class="lb-outerContainer"><div class="lb-container"><img class="lb-image" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" /><div class="lb-nav"><a class="lb-prev" href="" ></a><a class="lb-next" href="" ></a></div><div class="lb-loader"><a class="lb-cancel"></a></div></div></div><div class="lb-dataContainer"><div class="lb-data"><div class="lb-details"><span class="lb-caption"></span><span class="lb-number"></span></div><div class="lb-closeContainer"><a class="lb-close"></a></div></div></div></div>').appendTo($('body'));

					// Cache jQuery objects
					this.$lightbox       = $('#es-lightbox');
					this.$overlay        = $('#es-lightboxOverlay');
					this.$outerContainer = this.$lightbox.find('.lb-outerContainer');
					this.$container      = this.$lightbox.find('.lb-container');

					// Store css values for future lookup
					this.containerTopPadding = parseInt(this.$container.css('padding-top'), 10);
					this.containerRightPadding = parseInt(this.$container.css('padding-right'), 10);
					this.containerBottomPadding = parseInt(this.$container.css('padding-bottom'), 10);
					this.containerLeftPadding = parseInt(this.$container.css('padding-left'), 10);

					// Attach event handlers to the newly minted DOM elements
					this.$overlay.hide().on('click', function() {
						self.end();
						return false;
					});

					this.$lightbox.hide().on('click', function(event) {
						if ($(event.target).attr('id') === 'es-lightbox') {
							self.end();
						}
						return false;
					});

					this.$outerContainer.on('click', function(event) {
						if ($(event.target).attr('id') === 'es-lightbox') {
							self.end();
						}
						return false;
					});

					this.$lightbox.find('.lb-prev').on('click', function() {
						if (self.currentImageIndex === 0) {
							self.changeImage(self.album.length - 1);
						} else {
							self.changeImage(self.currentImageIndex - 1);
						}
						return false;
					});

					this.$lightbox.find('.lb-next').on('click', function() {
						if (self.currentImageIndex === self.album.length - 1) {
							self.changeImage(0);
						} else {
							self.changeImage(self.currentImageIndex + 1);
						}
						return false;
					});

					this.$lightbox.find('.lb-loader, .lb-close').on('click', function() {
						self.end();
						return false;
					});
				};

				// Show overlay and lightbox. If the image is part of a set, add siblings to album array.
				Lightbox.prototype.start = function($link) {
					var self    = this;
					var $window = $(window);

					$window.on('resize', $.proxy(this.sizeOverlay, this));

					$('select, object, embed').css({
						visibility: 'hidden'
					});

					this.sizeOverlay();

					this.album = [];
					var imageNumber = 0;

					function addToAlbum($link) {
						self.album.push({
							link: $link.attr('href'),
							title: $link.attr('data-title') || $link.attr('title')
						});
					}

					// Support both data-lightbox attribute and rel attribute implementations
					var dataLightboxValue = $link.attr('data-lightbox');
					var $links;

					if (dataLightboxValue) {
						$links = $($link.prop('tagName') + '[data-lightbox="' + dataLightboxValue + '"]');
						for (var i = 0; i < $links.length; i = ++i) {
							addToAlbum($($links[i]));
							if ($links[i] === $link[0]) {
								imageNumber = i;
							}
						}
					} else {
						if ($link.attr('rel') === 'lightbox') {
							// If image is not part of a set
							addToAlbum($link);
						} else {
							// If image is part of a set
							$links = $($link.prop('tagName') + '[rel="' + $link.attr('rel') + '"]');
							for (var j = 0; j < $links.length; j = ++j) {
								addToAlbum($($links[j]));
								if ($links[j] === $link[0]) {
									imageNumber = j;
								}
							}
						}
					}

					// Position Lightbox
					var top  = $window.scrollTop() + this.options.positionFromTop;
					var left = $window.scrollLeft();
					this.$lightbox.css({
						top: top + 'px',
						left: left + 'px'
					}).fadeIn(this.options.fadeDuration);

					this.changeImage(imageNumber);
				};

				// Hide most UI elements in preparation for the animated resizing of the lightbox.
				Lightbox.prototype.changeImage = function(imageNumber) {
					var self = this;

					this.disableKeyboardNav();
					var $image = this.$lightbox.find('.lb-image');

					this.$overlay.fadeIn(this.options.fadeDuration);

					$('.lb-loader').fadeIn('slow');
					this.$lightbox.find('.lb-image, .lb-nav, .lb-prev, .lb-next, .lb-dataContainer, .lb-numbers, .lb-caption').hide();

					this.$outerContainer.addClass('animating');

					// When image to show is preloaded, we send the width and height to sizeContainer()
					var preloader = new Image();
					preloader.onload = function() {
						var $preloader;
						var imageHeight;
						var imageWidth;
						var maxImageHeight;
						var maxImageWidth;
						var windowHeight;
						var windowWidth;

						$image.attr('src', self.album[imageNumber].link);

						$preloader = $(preloader);

						$image.width(preloader.width);
						$image.height(preloader.height);

						if (self.options.fitImagesInViewport) {
							// Fit image inside the viewport.
							// Take into account the border around the image and an additional 10px gutter on each side.

							windowWidth    = $(window).width();
							windowHeight   = $(window).height();
							maxImageWidth  = windowWidth - self.containerLeftPadding - self.containerRightPadding - 20;
							maxImageHeight = windowHeight - self.containerTopPadding - self.containerBottomPadding - 120;

							// Check if image size is larger then maxWidth|maxHeight in settings
							if (self.options.maxWidth && self.options.maxWidth < maxImageWidth) {
								maxImageWidth = self.options.maxWidth;
							}
							if (self.options.maxHeight && self.options.maxHeight < maxImageWidth) {
								maxImageHeight = self.options.maxHeight;
							}

							// Is there a fitting issue?
							if ((preloader.width > maxImageWidth) || (preloader.height > maxImageHeight)) {
								if ((preloader.width / maxImageWidth) > (preloader.height / maxImageHeight)) {
									imageWidth  = maxImageWidth;
									imageHeight = parseInt(preloader.height / (preloader.width / imageWidth), 10);
									$image.width(imageWidth);
									$image.height(imageHeight);
								} else {
									imageHeight = maxImageHeight;
									imageWidth = parseInt(preloader.width / (preloader.height / imageHeight), 10);
									$image.width(imageWidth);
									$image.height(imageHeight);
								}
							}
						}
						self.sizeContainer($image.width(), $image.height());
					};

					preloader.src          = this.album[imageNumber].link;
					this.currentImageIndex = imageNumber;
				};

				// Stretch overlay to fit the viewport
				Lightbox.prototype.sizeOverlay = function() {
					this.$overlay
						.width($(window).width())
						.height($(document).height());
				};

				// Animate the size of the lightbox to fit the image we are showing
				Lightbox.prototype.sizeContainer = function(imageWidth, imageHeight) {
					var self = this;

					var oldWidth  = this.$outerContainer.outerWidth();
					var oldHeight = this.$outerContainer.outerHeight();
					var newWidth  = imageWidth + this.containerLeftPadding + this.containerRightPadding;
					var newHeight = imageHeight + this.containerTopPadding + this.containerBottomPadding;

					function postResize() {
						self.$lightbox.find('.lb-dataContainer').width(newWidth);
						self.$lightbox.find('.lb-prevLink').height(newHeight);
						self.$lightbox.find('.lb-nextLink').height(newHeight);
						self.showImage();
					}

					if (oldWidth !== newWidth || oldHeight !== newHeight) {
						this.$outerContainer.animate({
							width: newWidth,
							height: newHeight
						}, this.options.resizeDuration, 'swing', function() {
							postResize();
						});
					} else {
						postResize();
					}
				};

				// Display the image and its details and begin preload neighboring images.
				Lightbox.prototype.showImage = function() {
					this.$lightbox.find('.lb-loader').stop(true).hide();
					this.$lightbox.find('.lb-image').fadeIn('slow');

					this.updateNav();
					this.updateDetails();
					this.preloadNeighboringImages();
					this.enableKeyboardNav();
				};

				// Display previous and next navigation if appropriate.
				Lightbox.prototype.updateNav = function() {
					// Check to see if the browser supports touch events. If so, we take the conservative approach
					// and assume that mouse hover events are not supported and always show prev/next navigation
					// arrows in image sets.
					var alwaysShowNav = false;
					try {
						document.createEvent('TouchEvent');
						alwaysShowNav = (this.options.alwaysShowNavOnTouchDevices) ? true : false;
					} catch (e) {}

					this.$lightbox.find('.lb-nav').show();

					if (this.album.length > 1) {
						if (this.options.wrapAround) {
							if (alwaysShowNav) {
								this.$lightbox.find('.lb-prev, .lb-next').css('opacity', '1');
							}
							this.$lightbox.find('.lb-prev, .lb-next').show();
						} else {
							if (this.currentImageIndex > 0) {
								this.$lightbox.find('.lb-prev').show();
								if (alwaysShowNav) {
									this.$lightbox.find('.lb-prev').css('opacity', '1');
								}
							}
							if (this.currentImageIndex < this.album.length - 1) {
								this.$lightbox.find('.lb-next').show();
								if (alwaysShowNav) {
									this.$lightbox.find('.lb-next').css('opacity', '1');
								}
							}
						}
					}
				};

				// Display caption, image number, and closing button.
				Lightbox.prototype.updateDetails = function() {
					var self = this;

					// Enable anchor clicks in the injected caption html.
					// Thanks Nate Wright for the fix. @https://github.com/NateWr
					if (typeof this.album[this.currentImageIndex].title !== 'undefined' &&
						this.album[this.currentImageIndex].title !== '') {
						this.$lightbox.find('.lb-caption')
							.html(this.album[this.currentImageIndex].title)
							.fadeIn('fast')
							.find('a').on('click', function(event) {
								if ($(this).attr('target') !== undefined) {
									window.open($(this).attr('href'), $(this).attr('target'));
								} else {
									location.href = $(this).attr('href');
								}
							});
					}

					if (this.album.length > 1 && this.options.showImageNumberLabel) {
						var labelText = this.imageCountLabel(this.currentImageIndex + 1, this.album.length);
						this.$lightbox.find('.lb-number').text(labelText).fadeIn('fast');
					} else {
						this.$lightbox.find('.lb-number').hide();
					}

					this.$outerContainer.removeClass('animating');

					this.$lightbox.find('.lb-dataContainer').fadeIn(this.options.resizeDuration, function() {
						return self.sizeOverlay();
					});
				};

				// Preload previous and next images in set.
				Lightbox.prototype.preloadNeighboringImages = function() {
					if (this.album.length > this.currentImageIndex + 1) {
						var preloadNext = new Image();
						preloadNext.src = this.album[this.currentImageIndex + 1].link;
					}
					if (this.currentImageIndex > 0) {
						var preloadPrev = new Image();
						preloadPrev.src = this.album[this.currentImageIndex - 1].link;
					}
				};

				Lightbox.prototype.enableKeyboardNav = function() {
					$(document).on('keyup.keyboard', $.proxy(this.keyboardAction, this));
				};

				Lightbox.prototype.disableKeyboardNav = function() {
					$(document).off('.keyboard');
				};

				Lightbox.prototype.keyboardAction = function(event) {
					var KEYCODE_ESC        = 27;
					var KEYCODE_LEFTARROW  = 37;
					var KEYCODE_RIGHTARROW = 39;

					var keycode = event.keyCode;
					var key     = String.fromCharCode(keycode).toLowerCase();
					if (keycode === KEYCODE_ESC || key.match(/x|o|c/)) {
						this.end();
					} else if (key === 'p' || keycode === KEYCODE_LEFTARROW) {
						if (this.currentImageIndex !== 0) {
							this.changeImage(this.currentImageIndex - 1);
						} else if (this.options.wrapAround && this.album.length > 1) {
							this.changeImage(this.album.length - 1);
						}
					} else if (key === 'n' || keycode === KEYCODE_RIGHTARROW) {
						if (this.currentImageIndex !== this.album.length - 1) {
							this.changeImage(this.currentImageIndex + 1);
						} else if (this.options.wrapAround && this.album.length > 1) {
							this.changeImage(0);
						}
					}
				};

				// Closing time. :-(
				Lightbox.prototype.end = function() {
					this.disableKeyboardNav();
					$(window).off('resize', this.sizeOverlay);
					this.$lightbox.fadeOut(this.options.fadeDuration);
					this.$overlay.fadeOut(this.options.fadeDuration);
					$('select, object, embed').css({
						visibility: 'visible'
					});
				};

				return new Lightbox();
		}));

		module.resolve();

});
			EasySocial.module('site/vendors/puller', function($){

var module = this;

var PullToRefresh = (function () {
var _ptrMarkup = function () { return "<div class=\"__PREFIX__box\"><div class=\"__PREFIX__content\"><div class=\"__PREFIX__icon\"></div><div class=\"__PREFIX__text\"></div></div></div>"; };

var _ptrStyles = function () { return ".__PREFIX__ptr {\n  box-shadow: inset 0 -3px 5px rgba(0, 0, 0, 0.12);\n  pointer-events: none;\n  font-size: 0.85em;\n  font-weight: bold;\n  top: 0;\n  height: 0;\n  transition: height 0.3s, min-height 0.3s;\n  text-align: center;\n  width: 100%;\n  overflow: hidden;\n  display: flex;\n  align-items: flex-end;\n  align-content: stretch;\n}\n.__PREFIX__box {\n  padding: 10px;\n  flex-basis: 100%;\n}\n.__PREFIX__pull {\n  transition: none;\n}\n.__PREFIX__text {\n  margin-top: .33em;\n  color: rgba(0, 0, 0, 0.3);\n}\n.__PREFIX__icon {\n  color: rgba(0, 0, 0, 0.3);\n  transition: transform .3s;\n}\n.__PREFIX__top {\n  touch-action: pan-x pan-down pinch-zoom;\n}\n.__PREFIX__release .__PREFIX__icon {\n  transform: rotate(180deg);\n}\n"; };

/* eslint-disable import/no-unresolved */

var _SETTINGS = {};

var _defaults = {
	distThreshold: 60,
	distMax: 80,
	distReload: 50,
	bodyOffset: 20,
	mainElement: 'body',
	triggerElement: 'body',
	ptrElement: '.ptr',
	classPrefix: 'ptr--',
	cssProp: 'min-height',
	iconArrow: '<i class="fa fa-long-arrow-alt-down"></i>',
	iconRefreshing: '<div class="o-loader o-loader--sm o-loader--inline is-active"></div>',
	instructionsPullToRefresh: 'Pull down to refresh',
	instructionsReleaseToRefresh: 'Release to refresh',
	instructionsRefreshing: 'Refreshing',
	refreshTimeout: 500,
	getMarkup: _ptrMarkup,
	getStyles: _ptrStyles,
	onInit: function () {},
	onRefresh: function () { return location.reload(); },
	resistanceFunction: function (t) { return Math.min(1, t / 2.5); },
	shouldPullToRefresh: function () { return !window.scrollY; },
};

var pullStartY = null;
var pullMoveY = null;
var dist = 0;
var distResisted = 0;

var _state = 'pending';
var _setup = false;
var _enable = false;
var _timeout;

var supportsPassive = false;

try {
	window.addEventListener('test', null, {
		get passive() {
			supportsPassive = true;
		},
	});
} catch (e) {
	// do nothing
}

function _update() {
	var classPrefix = _SETTINGS.classPrefix;
	var ptrElement = _SETTINGS.ptrElement;
	var iconArrow = _SETTINGS.iconArrow;
	var iconRefreshing = _SETTINGS.iconRefreshing;
	var instructionsRefreshing = _SETTINGS.instructionsRefreshing;
	var instructionsPullToRefresh = _SETTINGS.instructionsPullToRefresh;
	var instructionsReleaseToRefresh = _SETTINGS.instructionsReleaseToRefresh;

	var iconEl = ptrElement.querySelector(("." + classPrefix + "icon"));
	var textEl = ptrElement.querySelector(("." + classPrefix + "text"));

	if (_state === 'refreshing') {
		iconEl.innerHTML = iconRefreshing;
	} else {
		iconEl.innerHTML = iconArrow;
	}

	if (_state === 'releasing') {
		// textEl.innerHTML = instructionsReleaseToRefresh;
	}

	if (_state === 'pulling' || _state === 'pending') {
		// textEl.innerHTML = instructionsPullToRefresh;
	}

	// if (_state === 'refreshing') {
	// 	textEl.innerHTML = instructionsRefreshing;
	// }
}

function _setupEvents() {
	function onReset() {
		var cssProp = _SETTINGS.cssProp;
		var ptrElement = _SETTINGS.ptrElement;
		var classPrefix = _SETTINGS.classPrefix;

		ptrElement.classList.remove((classPrefix + "refresh"));
		ptrElement.style[cssProp] = '0px';

		_state = 'pending';
	}

	function _onTouchStart(e) {
		var shouldPullToRefresh = _SETTINGS.shouldPullToRefresh;
		var triggerElement = _SETTINGS.triggerElement;

		if (shouldPullToRefresh()) {
			pullStartY = e.touches[0].screenY;
		}

		if (_state !== 'pending') {
			return;
		}

		clearTimeout(_timeout);

		_enable = triggerElement.contains(e.target);
		_state = 'pending';
		_update();
	}

	function _onTouchMove(e) {
		var cssProp = _SETTINGS.cssProp;
		var classPrefix = _SETTINGS.classPrefix;
		var distMax = _SETTINGS.distMax;
		var distThreshold = _SETTINGS.distThreshold;
		var ptrElement = _SETTINGS.ptrElement;
		var resistanceFunction = _SETTINGS.resistanceFunction;
		var shouldPullToRefresh = _SETTINGS.shouldPullToRefresh;

		if (!pullStartY) {
			if (shouldPullToRefresh()) {
				pullStartY = e.touches[0].screenY;
			}
		} else {
			pullMoveY = e.touches[0].screenY;
		}

		if (!_enable || _state === 'refreshing') {
			if (shouldPullToRefresh() && pullStartY < pullMoveY) {
				e.preventDefault();
			}

			return;
		}

		if (_state === 'pending') {
			ptrElement.classList.add((classPrefix + "pull"));
			_state = 'pulling';
			_update();
		}

		if (pullStartY && pullMoveY) {
			dist = pullMoveY - pullStartY;
		}

		if (dist > 0) {
			e.preventDefault();

			ptrElement.style[cssProp] = distResisted + "px";

			distResisted = resistanceFunction(dist / distThreshold)
				* Math.min(distMax, dist);

			if (_state === 'pulling' && distResisted > distThreshold) {
				ptrElement.classList.add((classPrefix + "release"));
				_state = 'releasing';
				_update();
			}

			if (_state === 'releasing' && distResisted < distThreshold) {
				ptrElement.classList.remove((classPrefix + "release"));
				_state = 'pulling';
				_update();
			}
		}
	}

	function _onTouchEnd() {
		var ptrElement = _SETTINGS.ptrElement;
		var onRefresh = _SETTINGS.onRefresh;
		var refreshTimeout = _SETTINGS.refreshTimeout;
		var distThreshold = _SETTINGS.distThreshold;
		var distReload = _SETTINGS.distReload;
		var cssProp = _SETTINGS.cssProp;
		var classPrefix = _SETTINGS.classPrefix;

		if (_state === 'releasing' && distResisted > distThreshold) {
			_state = 'refreshing';

			ptrElement.style[cssProp] = distReload + "px";
			ptrElement.classList.add((classPrefix + "refresh"));

			_timeout = setTimeout(function () {
				var retval = onRefresh(onReset);

				if (retval && typeof retval.then === 'function') {
					retval.then(function () { return onReset(); });
				}

				if (!retval && !onRefresh.length) {
					onReset();
				}
			}, refreshTimeout);
		} else {
			if (_state === 'refreshing') {
				return;
			}

			ptrElement.style[cssProp] = '0px';

			_state = 'pending';
		}

		_update();

		ptrElement.classList.remove((classPrefix + "release"));
		ptrElement.classList.remove((classPrefix + "pull"));

		pullStartY = pullMoveY = null;
		dist = distResisted = 0;
	}

	function _onScroll() {
		var mainElement = _SETTINGS.mainElement;
		var classPrefix = _SETTINGS.classPrefix;
		var shouldPullToRefresh = _SETTINGS.shouldPullToRefresh;

		mainElement.classList.toggle((classPrefix + "top"), shouldPullToRefresh());
	}

	_SETTINGS['mainElement'].addEventListener('touchend', _onTouchEnd);
	_SETTINGS['mainElement'].addEventListener('touchstart', _onTouchStart);
	_SETTINGS['mainElement'].addEventListener('touchmove', _onTouchMove, supportsPassive
		? { passive: _SETTINGS.passive || false }
		: undefined);

	_SETTINGS['mainElement'].addEventListener('scroll', _onScroll);
	// window.addEventListener('touchend', _onTouchEnd);
	// window.addEventListener('touchstart', _onTouchStart);
	// window.addEventListener('touchmove', _onTouchMove, supportsPassive
	// 	? { passive: _SETTINGS.passive || false }
	// 	: undefined);

	// window.addEventListener('scroll', _onScroll);

	// Store event handlers to use for teardown later
	return {
		onTouchStart: _onTouchStart,
		onTouchMove: _onTouchMove,
		onTouchEnd: _onTouchEnd,
		onScroll: _onScroll,
	};
}

function _run() {
	var mainElement = _SETTINGS.mainElement;
	var getMarkup = _SETTINGS.getMarkup;
	var getStyles = _SETTINGS.getStyles;
	var classPrefix = _SETTINGS.classPrefix;
	var onInit = _SETTINGS.onInit;

	if (!document.querySelector(("." + classPrefix + "ptr"))) {
		var ptr = document.createElement('div');

		if (mainElement !== document.body) {
			mainElement.parentNode.insertBefore(ptr, mainElement);
		} else {
			document.body.insertBefore(ptr, document.body.firstChild);
		}

		ptr.classList.add((classPrefix + "ptr"));
		ptr.innerHTML = getMarkup()
			.replace(/__PREFIX__/g, classPrefix);

		_SETTINGS.ptrElement = ptr;
	}

	// Add the css styles to the style node, and then
	// insert it into the dom
	// ========================================================
	var styleEl;
	if (!document.querySelector('#pull-to-refresh-js-style')) {
		styleEl = document.createElement('style');
		styleEl.setAttribute('id', 'pull-to-refresh-js-style');

		document.head.appendChild(styleEl);
	} else {
		styleEl = document.querySelector('#pull-to-refresh-js-style');
	}

	styleEl.textContent = getStyles()
		.replace(/__PREFIX__/g, classPrefix)
		.replace(/\s+/g, ' ');

	if (typeof onInit === 'function') {
		onInit(_SETTINGS);
	}

	return {
		styleNode: styleEl,
		ptrElement: _SETTINGS.ptrElement,
	};
}

var pulltorefresh = {

	init: function init(options) {
		if (options === void 0) {
			options = {};
		}

		var handlers;

		Object.keys(_defaults).forEach(function (key) {
			_SETTINGS[key] = options[key] || _defaults[key];
		});

		var methods = ['mainElement', 'ptrElement', 'triggerElement'];

		methods.forEach(function (method) {
			if (typeof _SETTINGS[method] === 'string') {
				_SETTINGS[method] = document.querySelector(_SETTINGS[method]);
			}
		});

		if (!_setup) {
			handlers = _setupEvents();
			_setup = true;
		}

		var ref = _run();
		var styleNode = ref.styleNode;
		var ptrElement = ref.ptrElement;

		return {
			destroy: function destroy() {

				// Teardown event listeners
				_SETTINGS['mainElement'].removeEventListener('touchstart', handlers.onTouchStart);
				_SETTINGS['mainElement'].removeEventListener('touchend', handlers.onTouchEnd);
				_SETTINGS['mainElement'].removeEventListener('touchmove', handlers.onTouchMove, supportsPassive
					? { passive: _SETTINGS.passive || false }
					: undefined);
				_SETTINGS['mainElement'].removeEventListener('scroll', handlers.onScroll);
				// // Teardown event listeners
				// window.removeEventListener('touchstart', handlers.onTouchStart);
				// window.removeEventListener('touchend', handlers.onTouchEnd);
				// window.removeEventListener('touchmove', handlers.onTouchMove, supportsPassive
				// 	? { passive: _SETTINGS.passive || false }
				// 	: undefined);
				// window.removeEventListener('scroll', handlers.onScroll);

				// Remove ptr element and style tag
				styleNode.parentNode.removeChild(styleNode);
				ptrElement.parentNode.removeChild(ptrElement);

				// Enable setupEvents to run again
				_setup = false;

				// null object references
				handlers = null;
				styleNode = null;
				ptrElement = null;
				_SETTINGS = {};
			},
		};
	},
};

return pulltorefresh;

}());


window.es.puller = PullToRefresh;

module.resolve();

});
			EasySocial.module('site/videos/browser', function($) {

var module = this;

EasySocial.Controller('Videos.Browser', {
	defaultOptions: {

		"{wrapper}": "[data-wrapper]",
		"{sorting}": "input[name='sorting']",
		"{sortItem}": "[data-sorting]",

		// Videos result
		"{result}": "[data-videos-result]",
		"{list}": "[data-result-list]",

		// Video actions
		"{item}": "[data-video-item]",
		"{deleteButton}": "[data-video-delete]",
		"{featureButton}": "[data-video-feature]",
		"{unfeatureButton}": "[data-video-unfeature]",
		"{createFilter}": "[data-video-create-filter]"
	}
}, function(self, opts, base) { return {

	currentFilter: "",
	currentSorting: "",
	categoryId: null,
	isSort: false,
	clicked: false,

	getVideos: function(callback) {

		if (!self.currentSorting) {
			// Set the current sorting
			self.currentSorting = self.sorting().val();
		}

		if (!self.currentFilter) {
			// Set the current sorting
			self.currentFilter = self.activeFilter.data('type');
		}

		// if still empty the filter, just set to all.
		if (!self.currentFilter) {
			self.currentFilter = "all";
		}

		var isSortReq = self.isSort ? "1" : "0";

		EasySocial.ajax('site/controllers/videos/getVideos',{
			"filter": self.currentFilter,
			"categoryId": self.categoryId,
			"sort": self.currentSorting,
			"uid": opts.uid,
			"type": opts.type,
			"hashtags": opts.hashtag,
			"hashtagFilterId": self.hashtagId,
			"isSort": isSortReq
		}).done(function(output) {

			if ($.isFunction(callback)) {
				callback.call(this, output);
			}

			self.activeFilter.parent().removeClass('is-loading');

			if (self.isSort) {
				self.result().removeClass('is-loading');
				self.list().html(output);
			} else {
				self.wrapper().removeClass('is-loading');
				self.result().html(output);
			}

			$('body').trigger('afterUpdatingContents', [output]);
		});
	},

	"{sortItem} click" : function(sortItem, event) {

		// Get the sort type
		var type = sortItem.data('type');
		self.currentSorting = type;

		self.isSort = true;

		if (!self.hashtagId) {
			self.hashtagId = sortItem.data('tag-id');
		}

		var sortFilter = sortItem.data('filter');

		if (sortFilter == 'category') {
			self.categoryId = sortItem.data('id');
		}

		// Route the item so that we can update the url
		sortItem.route();

		self.result().addClass('is-loading');
		self.list().empty();

		self.getVideos();
	},

	"{deleteButton} click": function(deleteButton, event) {

		var item = deleteButton.parents(self.item.selector);
		var id = item.data('id');
		var returnUrl = deleteButton.data('return');

		var options = {
			"id": id
		};

		if (returnUrl.length > 0) {
			options["return"] = returnUrl;
		}

		EasySocial.dialog({
			content: EasySocial.ajax('site/views/videos/confirmDelete', options)
		});
	},

	"{unfeatureButton} click": function(unfeatureButton, event) {
		var item = unfeatureButton.parents(self.item.selector);
		var id = item.data('id');
		var returnUrl = unfeatureButton.data('return');

		var options = {
			"id": id
		};

		if (returnUrl.length > 0) {
			options["return"] = returnUrl;
		}

		EasySocial.dialog({
			content: EasySocial.ajax('site/views/videos/confirmUnfeature', options)
		});
	},

	"{featureButton} click": function(featureButton, event) {
		var item = featureButton.parents(self.item.selector);
		var id = item.data('id');
		var returnUrl = featureButton.data('return');

		var options = {
			"id": id
		};

		if (returnUrl) {
			options["return"] = returnUrl;
		}

		EasySocial.dialog({
			content: EasySocial.ajax('site/views/videos/confirmFeature', options)
		});
	}
}});

module.resolve();


});
			EasySocial.module('site/videos/filter', function($) {

var module = this;

EasySocial.require()
.script('site/videos/browser')
.done(function($) {


EasySocial.Controller('Videos.Filter', {

defaultOptions: {
	"{filter}": "[data-es-video-filters] [data-filter-item]",
	"{createFilter}": "[data-video-create-filter]",
	"{browserController}": "[data-videos-listing]"
}

}, function(self, opts, base) { return {

	controller: null,
	clicked: false,

	init: function() {
		self.controller = self.getController();

		if (self.controller) {
			self.controller.activeFilter = self.filter('[data-type=' + opts.active + ']');
		}
	},

	getController: function() {
		var controller = self.browserController().controller();

		return controller;
	},

	setActiveFilter: function(filter) {

		self.filter().removeClass('active');

		filter.addClass('active');

		// Set loading on the correct filter
		filter.addClass('is-loading');
	},

	"{filter} click": function(filter, event) {

		// Since controller doesn't exist, we should just redirect to the view
		if (!self.controller) {
			return;
		}

		event.preventDefault();
		event.stopPropagation();

		var type = filter.data('type');

		// Route the inner filter links
		if (filter.is('a')) {
			filter.route();
		} else {
			filter.find('a').route();
		}

		// Add an active state to the parent
		self.setActiveFilter(filter);

		// Filter by category
		var categoryId = null;

		if (type == 'category') {
			type = 'all';
			categoryId = filter.data('id');
		}

		var hashtagId = null;

		if (type == 'hashtag') {
			hashtagId = filter.data('tagId');
		}

		// Set the current filter
		self.controller.currentFilter = type;
		self.controller.categoryId = categoryId;
		self.controller.hashtagId = hashtagId;
		self.controller.isSort = false;

		self.controller.result().empty();
		self.controller.wrapper().addClass('is-loading');

		self.controller.getVideos(function() {
			filter.removeClass('is-loading');
		});

		// trigger sidebar toggle for responsive view.
		self.controller.trigger('onEasySocialFilterClick');
	},

	"{createFilter} click": function(filter, event) {

		// Prevent default
		event.preventDefault();
		event.stopPropagation();

		EasySocial.dialog({
			"content": EasySocial.ajax('site/views/videos/getFilterFormDialog', {
				"id": filter.data('id'),
				"cid": filter.data('uid'),
				"clusterType": filter.data('clusterType')
			})
		});
	}
}});

module.resolve();

});

});
			EasySocial.module('site/videos/form', function($) {

var module = this;

EasySocial.require()
.script('site/friends/suggest')
.library('mentions')
.done(function($) {

EasySocial.Controller('Videos.Form', {
	defaultOptions: {
		"{videoSource}": "[data-video-source]",

		// Forms for video source
		"{forms}": "[data-form-source]",
		"{linkForm}": "[data-form-link]",
		"{uploadForm}": "[data-form-upload]",
		"{linkSource}": "[data-video-link]",

		// Mentions
		"{mentions}": "[data-mentions]",
		'{hashtags}': '[data-hashtags]',
		"{header}": "[data-hashtags-header]",
		"{file}": "[data-video-file]",
		"{browseButton}": "[data-browse-button]",
		"{videoId}": "[data-video-id]",
		"{fileUploaded}": "[data-file-uploaded]",
		"{videoTitle}": "[data-video-title]",
		"{videoDescription}": "[data-video-desc]",
		"{saveButton}": "[data-save-button]"
	}
}, function(self, opts, base) { return {

	init: function() {
		self.initMentions();

		// Get available hints for friend suggestions and hashtags
		opts.hints = {
				"friends": self.element.find('[data-hints-friends]'),
				"hashtags": self.element.find('[data-hints-hashtags]')
		};

		// Apply the mentions on the comment form
		self.setMentionsLayout();
	},

	initMentions: function() {

		var options = {
				"showNonFriend": false,
				"includeSelf": true,
				"name": "tags[]",
				"exclusion": opts.tagsExclusion
			}

		if (opts.isPrivateCluster) {
			var options = $.extend(options, {
				clusterId: opts.uid,
				clusterType: opts.type
			});
		}

		self.mentions()
			.addController("EasySocial.Controller.Friends.Suggest", options);
	},

	'{file} change' : function(el , event) {

		if($.isEmpty(el.val())) {
			return;
		}

		var label = el.val().replace(/\\/g, '/').replace(/.*\//, '');

		el.parents('.o-input-group').find(':text').val(opts.uploadingText + '...');

		self.clearError(self.uploadForm());
		self.browseButton().addClass('is-loading');
		self.saveButton().attr('disabled', true);

		var isEditing = false;

		if (self.videoId().val()) {
			isEditing = self.videoId().val();
		}

		EasySocial.ajax('site/controllers/videos/uploadFile' , {
			files: el,
			type: opts.type,
			uid: opts.uid,
			isEditing: isEditing
		}, {
			type: 'iframe'
		}).done(function(result){

			self.saveButton().attr('disabled', false);

			self.videoId().val(result.id);
			self.fileUploaded().val(true);

			if (!self.videoTitle().val()) {
				self.videoTitle().val(result.title);
			}

			el.parents('.o-input-group').find(':text').val(label);

			self.browseButton().removeClass('is-loading');

			// Reset the file input to avoid the form sending the data
			el.val('');

		}).fail(function(msg) {

			self.showError(self.uploadForm(), msg);
			el.parents('.o-input-group').find(':text').val(label);

			self.browseButton().removeClass('is-loading');
		});
	},

	showError: function (field, message) {
		field.addClass('has-error');
		field.find('[data-link-notice]').html(message);
	},

	clearError: function (field) {
		field.removeClass('has-error');
		field.find('[data-link-notice]').html('');
	},

	"{videoSource} change": function(videoSource, event) {

		var source = $(videoSource).val();
		var form = self[source + "Form"]();

		// Hide all source forms
		self.forms().addClass('t-hidden');

		// Remove hidden class for the active form
		form.removeClass('t-hidden');
	},

	setMentionsLayout: function() {
		var hashtags = self.hashtags();
		var mentions = hashtags.controller("mentions");

		if (mentions) {
			mentions.cloneLayout();
			return;
		}

		var header = self.header();

		hashtags.mentions({

			triggers: {
				"#": {
					"type": "hashtag",
					"wrap": true,
					"stop": " #",
					"allowSpace": false,
					"query": {
						"loadingHint": false,
						"searchHint": opts.hints.hashtags.find('[data-search]'),
						"emptyHint": opts.hints.hashtags.find('[data-empty]'),
						data: function(keyword) {

							var task = $.Deferred();

							EasySocial.ajax("site/controllers/hashtags/suggest", {search: keyword, type: "video"})
								.done(function(items) {

									if (!$.isArray(items)) {
										task.reject();
									}

									var items = $.map(items, function(item) {

										return {
											"title": "#" + $.trim(item),
											"type": "hashtag",
											"menuHtml": item
										};
									});

									task.resolve(items);
								})
								.fail(task.reject);

							return task;
						}
					}
				}
			},
			"plugin": {
					"autocomplete": {
						"id": "es",
						"component": "",
						"position": {
							my: 'left top',
							at: 'left bottom',
							of: header.parent(),
							collision: 'none'
						},
						"size": {
							width: function() {
								return header.parent().outerWidth();
							}
						}
					}
				}

		});
	},

	"{linkSource} focusout": function(el){
		var defaultEditor = $('[data-video-desc-field]').data('video-editor-type');

        // If they choose editors, do not proceed.
        if (defaultEditor != 'noeditor') {
            return;
        }

		var url = el.val();

		if (url.length < 1) {
			return;
		}

		self.linkForm().addClass('is-loading');

		self.clearError(self.linkForm());

		EasySocial.ajax('site/controllers/videos/processLink', {
			"link" : url
		}).done(function(data){
			if (data['title']) {
				self.videoTitle().val(data['title']);
			}

			if (data['description']) {
				self.videoDescription().val(data['description']);
			}

			self.linkForm().removeClass('is-loading');
		}).fail(function(message){
			self.linkForm().removeClass('is-loading');
			self.showError(self.linkForm(), message);
		});
	},

	"{saveButton} click": function(ele, event) {

		var title = self.videoTitle().val();
		var wrapper = self.videoTitle().closest('div.o-control-input');
		title = title.trim();

		// clear the error 1st
		wrapper.removeClass('has-error');

		if (title == '') {
			wrapper.addClass('has-error');
			self.videoTitle().focus();
			return false;
		}

		return true;
	}
}});

module.resolve();

});
});
			EasySocial.module('site/videos/item', function($) {

var module = this;

EasySocial.Controller('Videos.Item', {
	defaultOptions: {

		tagAdding	: null,

		"{tagPeople}": "[data-video-tag]",
		"{tagsWrapper}": "[data-video-tag-wrapper]",
		"{deleteButton}": "[data-video-delete]",

		"{removeTag}": "[data-remove-tag]",
		"{tagItem}": "[data-tags-item]",

		"{featureButton}": "[data-video-feature]",
		"{unfeatureButton}": "[data-video-unfeature]",

		"{embed}": "[data-video-embed]"
	}
}, function(self, opts, base) { return {

	init: function() {
		opts.id = self.element.data('id');
	},

	"{embed} click": function(button, event) {
		EasySocial.dialog({
			content: EasySocial.ajax("site/views/videos/embed", {
				"id": opts.id
			})
		});
	},

	"{unfeatureButton} click": function(unfeatureButton, event) {
		EasySocial.dialog({
			content: EasySocial.ajax("site/views/videos/confirmUnfeature", {
				"id": opts.id,
				"return": opts.callbackUrl
			})
		});
	},

	"{featureButton} click": function(featureButton, event) {

		EasySocial.dialog({
			content: EasySocial.ajax("site/views/videos/confirmFeature", {
				"id": opts.id,
				"return": opts.callbackUrl
			})
		});
	},

	"{deleteButton} click": function(deleteButton, event) {
		EasySocial.dialog({
			content: EasySocial.ajax("site/views/videos/confirmDelete", {
				"id": opts.id
			}),
			bindings: {

			}
		})
	},

	"{removeTag} click": function(removeTag, event) {

		var parent = removeTag.parents(self.tagItem.selector);
		var id = parent.data('id');

		var userId = parent.find('[data-user-id]').data('user-id');
		var userId = userId.toString();

		parent.remove();

		// If the length is only 1, we know that it's empty
		if (self.tagsWrapper().children().length == 0) {
			self.tagsWrapper().parent().addClass('is-empty');
		}

		EasySocial.ajax('site/controllers/videos/removeTag', {
			"id": id
		}).done(function() {
			opts.tagsExclusion.splice($.inArray(userId, opts.tagsExclusion), 1);
		});
	},

	"{tagPeople} click": function(tagPeople, event) {

		self.tagAdding = false;

		EasySocial.dialog({
			content: EasySocial.ajax('site/views/videos/tagPeople', {
							"id": opts.id,
							"exclusion": opts.tagsExclusion,
							"clusterId": opts.clusterId,
							"clusterType": opts.clusterType
						}),
			bindings: {
				"{submit} click": function(submitButton, event) {

					if (self.tagAdding) {
						return;
					}

					// now we set the state
					self.tagAdding = true;

					var suggest = this.suggest().textboxlist("controller");
					var items = suggest.getAddedItems();

					if (items.length <= 0) {
						return;
					}

					var ids = $.pluck(items, "id");

					// Make an ajax call to the server to tag people in this video
					EasySocial.ajax('site/controllers/videos/tag', {
						"ids": ids,
						"id": opts.id
					}).done(function(tags) {

						if (! opts.tagsExclusion) {
							opts.tagsExclusion = [];
						}

						$.each(ids, function(i, id) {
							opts.tagsExclusion.push(id);
						});

						// Just try to remove the is-empty on the wrapper.
						self.tagsWrapper().parent().removeClass('is-empty');

						self.tagsWrapper().removeClass('t-hidden');


						// Append the tags to the wrapper
						self.tagsWrapper().append(tags);

						//clear items in dialog to avoid user click insert multiple time
						suggest.clearItems();

						// Hide the dialog
						EasySocial.dialog().close();

						// unset the state
						self.tagAdding = false;
					});
				}
			}
		})
	}
}});

module.resolve();


});
			EasySocial.module('site/videos/preview', function($) {

var module = this;

EasySocial.Controller('Videos.Preview', {
	defaultOptions: {
		id : null,

		"{playerWrapper}": "[data-embed-player-wrapper]",
		"{playButton}": "[data-embed-play-button]",

		"{videoPreview}": "[data-es-embed-preview]",
		"{videoPreviewResult}": "[data-es-embed-preview-result]"
	}
}, function(self, opts, base) { return {

	init: function() {
		opts.id = self.element.data('id');
	},

	insertEmbed: function() {
		self.playButton().addClass('t-hidden');
		self.playerWrapper().addClass('vjs-waiting');

		// Retrieve the embed codes
		EasySocial.ajax('site/views/videos/getEmbedCodes', {
			'id' : opts.id
		}).done(function(output) {
			self.videoPreviewResult().html(output);

			// Check for iframe load
			var iframe = self.videoPreviewResult().find('iframe');

			if (iframe.length > 0) {
				iframe.on('load', function() {
					self.videoPreviewResult().removeClass('t-hidden');
					self.videoPreview().addClass('t-hidden');

					// Once play button pressed, we adjust the video contaner ratio accodingly
					container = self.element.parents('[data-video-container]');
					ratio = container.data('video-ratio');
					container.addClass(ratio);
				});
			} else {
				// Display error message?
			}
		});
	},

	click: false,

	"{playerWrapper} click": function() {

		// Prevent double click
		if (self.click) {
			return;
		}

		self.click = true;
		self.insertEmbed();
	}
}});

module.resolve();

});
			EasySocial.module('site/videos/process', function($) {

var module = this;

EasySocial.Controller('Videos.Process', {
	defaultOptions: {
		"{progressBar}": "[data-video-progress-bar]",
		"{progressResult}": "[data-video-progress-result]"
	}
}, function(self, opts, base) { return {
	
	init: function() {

		// Set the global options
		opts.id = base.data('id');

		self.processVideo();
	},

	processVideo: function() {

		// Initialize the video processing here
		EasySocial.ajax('site/controllers/videos/process', {
			"id": opts.id
		}).done(function() {

			// Run check status
			self.status(opts.id);
		});
	},

	status: function(videoId) {
		// Initialize the video processing here
		EasySocial.ajax('site/controllers/videos/status', {
			"id": videoId
		}).done(function(permalink, progress) {
			
			if (progress == 'done') {
				self.progressBar().css('width', '100%');
				self.progressResult().html('100%');

				// Redirect the user upon completion
				window.location = permalink;
				
				return;
			}

			var percentage = progress + '%';

			// Reiterate the same method again until it's completed.
			self.progressBar().css('width', percentage);
			self.progressResult().html(percentage);

			self.status(videoId);

			return;
		});
	}

}});

module.resolve();
});
	});
